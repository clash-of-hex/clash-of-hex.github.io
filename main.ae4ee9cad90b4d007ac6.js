/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./config.json":
/*!*********************!*\
  !*** ./config.json ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"testnet":{"router":"0:c769f598769b44349277be2508a035b743f3d9963010aa9250b2a4c69f84d1ed","gameroot":"0:2d68ccad6049d94bf7eda1d26dc79dc5c22a78dfd887c9e71510a00db4bfbc9a","codeHash":"fa7bb90da63c9ccf2032b8c12ca73db9b909c7630df89571d10c597de66cf78b","endpoint":"https://devnet.evercloud.dev/4b0e77393fba46759305e30cea4aaa95/graphql"},"localnet":{"router":"0:95bb6f16b9c00359365d252ab326ea53d8e8f2a264bc2919b9bd5cd0301f2b03","gameroot":"0:948f614578db3d32756872efe9888e95647f7080782d8749dc75d161becb1c7f","codeHash":"116b7a815dc63e8d3bd07e93d529ca978c87baf8738f90ab666b28437c3505c1","endpoint":"http://localhost/graphql"}}');

/***/ }),

/***/ "./contracts/build/Cell.abi.json":
/*!***************************************!*\
  !*** ./contracts/build/Cell.abi.json ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"ABI version":2,"version":"2.2","header":["pubkey","time","expire"],"functions":[{"name":"constructor","inputs":[{"name":"router","type":"address"},{"name":"owner","type":"address"},{"name":"endTime","type":"uint128"},{"name":"speed","type":"uint64"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"color","type":"tuple"},{"name":"energy","type":"uint64"}],"outputs":[]},{"name":"getRouter","inputs":[],"outputs":[{"name":"router","type":"address"}]},{"name":"getDetails","inputs":[],"outputs":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"color","type":"tuple"},{"name":"level","type":"uint64"},{"name":"speed","type":"uint64"},{"name":"endTime","type":"uint128"},{"name":"energy","type":"uint64"},{"name":"energySec","type":"uint64"},{"name":"energyMax","type":"uint64"},{"name":"lastCalcTime","type":"uint128"},{"name":"owner","type":"address"}]},{"name":"calculateEnergy","inputs":[],"outputs":[{"name":"energy","type":"uint64"}]},{"name":"markCell","inputs":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"targetCoord","type":"tuple"},{"name":"energy","type":"uint64"}],"outputs":[]},{"name":"helpCell","inputs":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"targetCoord","type":"tuple"},{"name":"energy","type":"uint64"}],"outputs":[]},{"name":"_helpCell","inputs":[{"name":"owner","type":"address"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"color","type":"tuple"},{"name":"energy","type":"uint64"}],"outputs":[]},{"name":"attkCell","inputs":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"targetCoord","type":"tuple"},{"name":"energy","type":"uint64"}],"outputs":[]},{"name":"_attkCell","inputs":[{"name":"owner","type":"address"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"color","type":"tuple"},{"name":"energy","type":"uint64"}],"outputs":[]},{"name":"upgradeCell","inputs":[],"outputs":[]},{"name":"_resolveCell","inputs":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"}],"outputs":[{"name":"cellAddress","type":"address"}]},{"name":"destruct","inputs":[{"name":"dest_addr","type":"address"}],"outputs":[]}],"data":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"key":1,"name":"_coord","type":"tuple"}],"events":[],"fields":[{"name":"_pubkey","type":"uint256"},{"name":"_timestamp","type":"uint64"},{"name":"_constructorFlag","type":"bool"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"_coord","type":"tuple"},{"name":"_costPerLevel","type":"uint64[]"},{"name":"_energyPerLevel","type":"uint64[]"},{"name":"_energyPerLevelMax","type":"uint64[]"},{"name":"_router","type":"address"},{"name":"_owner","type":"address"},{"name":"_speed","type":"uint64"},{"name":"_level","type":"uint64"},{"name":"_energy","type":"uint64"},{"name":"_lastCalcTime","type":"uint128"},{"name":"_endTime","type":"uint128"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"_color","type":"tuple"}]}');

/***/ }),

/***/ "./contracts/build/GameRoot.abi.json":
/*!*******************************************!*\
  !*** ./contracts/build/GameRoot.abi.json ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"ABI version":2,"version":"2.2","header":["pubkey","time","expire"],"functions":[{"name":"constructor","inputs":[{"name":"ownerPubkey","type":"uint256"},{"name":"codeRouter","type":"cell"},{"name":"codeCell","type":"cell"}],"outputs":[]},{"name":"getDetails","inputs":[],"outputs":[{"name":"nonce","type":"uint16"},{"name":"owner","type":"uint256"}]},{"name":"newRouter","inputs":[{"name":"roundTime","type":"uint64"},{"name":"radius","type":"uint64"},{"name":"speed","type":"uint64"},{"name":"name","type":"string"},{"name":"nonce","type":"uint16"}],"outputs":[]},{"name":"getOwner","inputs":[],"outputs":[{"name":"pubkey","type":"uint256"}]},{"name":"owner","inputs":[{"name":"answerId","type":"uint32"}],"outputs":[{"name":"pubkey","type":"uint256"}]},{"name":"transferOwnership","inputs":[{"name":"newOwner","type":"uint256"}],"outputs":[]}],"data":[{"key":1,"name":"_nonce","type":"uint16"}],"events":[{"name":"RouterCreated","inputs":[{"name":"nonce","type":"uint16"},{"name":"routerAddress","type":"address"}],"outputs":[]},{"name":"OwnershipTransferred","inputs":[{"name":"oldOwner","type":"uint256"},{"name":"newOwner","type":"uint256"}],"outputs":[]}],"fields":[{"name":"_pubkey","type":"uint256"},{"name":"_timestamp","type":"uint64"},{"name":"_constructorFlag","type":"bool"},{"name":"_owner","type":"uint256"},{"name":"_nonce","type":"uint16"},{"name":"_codeRouter","type":"cell"},{"name":"_codeCell","type":"cell"}]}');

/***/ }),

/***/ "./contracts/build/Router.abi.json":
/*!*****************************************!*\
  !*** ./contracts/build/Router.abi.json ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"ABI version":2,"version":"2.2","header":["pubkey","time","expire"],"functions":[{"name":"constructor","inputs":[{"name":"codeCell","type":"cell"},{"name":"roundTime","type":"uint64"},{"name":"radius","type":"uint64"},{"name":"speed","type":"uint64"},{"name":"name","type":"string"}],"outputs":[]},{"name":"getDetails","inputs":[],"outputs":[{"name":"nonce","type":"uint32"},{"name":"endTime","type":"uint128"},{"name":"radius","type":"uint64"},{"name":"speed","type":"uint64"},{"name":"name","type":"string"},{"name":"root","type":"address"}]},{"name":"getUsers","inputs":[],"outputs":[{"name":"users","type":"map(address,uint128)"}]},{"name":"getAddressCells","inputs":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coords","type":"tuple[]"}],"outputs":[{"name":"addreses","type":"address[]"}]},{"name":"newGame","inputs":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"baseCoord","type":"tuple"}],"outputs":[]},{"name":"_newCell","inputs":[{"name":"owner","type":"address"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"baseCoord","type":"tuple"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"targetCoord","type":"tuple"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"color","type":"tuple"},{"name":"energy","type":"uint64"}],"outputs":[]},{"name":"onCellOwnerChanged","inputs":[{"name":"oldOwner","type":"address"},{"name":"newOwner","type":"address"}],"outputs":[]},{"name":"_resolveCell","inputs":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"}],"outputs":[{"name":"cellAddress","type":"address"}]},{"name":"_users","inputs":[],"outputs":[{"name":"_users","type":"map(address,uint128)"}]}],"data":[{"key":1,"name":"_nonce","type":"uint32"}],"events":[{"name":"CellCreated","inputs":[{"name":"owner","type":"uint256"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"}],"outputs":[]}],"fields":[{"name":"_pubkey","type":"uint256"},{"name":"_timestamp","type":"uint64"},{"name":"_constructorFlag","type":"bool"},{"name":"_nonce","type":"uint32"},{"name":"_root","type":"address"},{"name":"_users","type":"map(address,uint128)"},{"name":"_codeCell","type":"cell"},{"name":"_radius","type":"uint64"},{"name":"_speed","type":"uint64"},{"name":"_name","type":"string"},{"name":"_endTime","type":"uint128"}]}');

/***/ }),

/***/ "./node_modules/@broxus/await-semaphore/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@broxus/await-semaphore/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Mutex = exports.Semaphore = void 0;\nfunction ensureCallable(fn) {\n    if (typeof fn !== 'function')\n        throw new TypeError(fn + \" is not a function\");\n    return fn;\n}\nfunction byObserver(Observer) {\n    const node = document.createTextNode('');\n    let queue, currentQueue, bit = 0, i = 0;\n    new Observer(function () {\n        let callback;\n        if (!queue) {\n            if (!currentQueue)\n                return;\n            queue = currentQueue;\n        }\n        else if (currentQueue) {\n            queue = currentQueue.slice(i).concat(queue);\n        }\n        currentQueue = queue;\n        queue = null;\n        i = 0;\n        if (typeof currentQueue === 'function') {\n            callback = currentQueue;\n            currentQueue = null;\n            callback();\n            return;\n        }\n        node.data = (bit = ++bit % 2); // Invoke other batch, to handle leftover callbacks in case of crash\n        while (i < currentQueue.length) {\n            callback = currentQueue[i];\n            i++;\n            if (i === currentQueue.length)\n                currentQueue = null;\n            callback();\n        }\n    }).observe(node, { characterData: true });\n    return function (fn) {\n        ensureCallable(fn);\n        if (queue) {\n            if (typeof queue === 'function')\n                queue = [queue, fn];\n            else\n                queue.push(fn);\n            return;\n        }\n        queue = fn;\n        node.data = (bit = ++bit % 2);\n    };\n}\nconst nextTick = (function () {\n    // queueMicrotask\n    if (typeof queueMicrotask === \"function\") {\n        return function (cb) {\n            queueMicrotask(ensureCallable(cb));\n        };\n    }\n    // MutationObserver\n    if ((typeof document === 'object') && document) {\n        if (typeof MutationObserver === 'function')\n            return byObserver(MutationObserver);\n        if (typeof window.WebKitMutationObserver === 'function')\n            return byObserver(window.WebKitMutationObserver);\n    }\n    // W3C Draft\n    // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html\n    if (typeof setImmediate === 'function') {\n        return function (cb) {\n            setImmediate(ensureCallable(cb));\n        };\n    }\n    // Wide available standard\n    if ((typeof setTimeout === 'function') || (typeof setTimeout === 'object')) {\n        return function (cb) {\n            setTimeout(ensureCallable(cb), 0);\n        };\n    }\n    throw new Error('No `nextTick` implementation found');\n}());\nclass Semaphore {\n    constructor(count) {\n        this.tasks = [];\n        this.count = count;\n    }\n    sched() {\n        if (this.count > 0 && this.tasks.length > 0) {\n            this.count--;\n            let next = this.tasks.shift();\n            if (next === undefined) {\n                throw \"Unexpected undefined value in tasks list\";\n            }\n            next();\n        }\n    }\n    acquire() {\n        return new Promise((res, _rej) => {\n            const task = () => {\n                let released = false;\n                res(() => {\n                    if (!released) {\n                        released = true;\n                        this.count++;\n                        this.sched();\n                    }\n                });\n            };\n            this.tasks.push(task);\n            nextTick(this.sched.bind(this));\n        });\n    }\n    use(f) {\n        return this.acquire()\n            .then(release => {\n            return f()\n                .then((res) => {\n                release();\n                return res;\n            })\n                .catch((err) => {\n                release();\n                throw err;\n            });\n        });\n    }\n}\nexports.Semaphore = Semaphore;\nclass Mutex extends Semaphore {\n    constructor() {\n        super(1);\n    }\n}\nexports.Mutex = Mutex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJyb3h1cy9hd2FpdC1zZW1hcGhvcmUvZGlzdC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9AYnJveHVzL2F3YWl0LXNlbWFwaG9yZS9kaXN0L2luZGV4LmpzPzdhY2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk11dGV4ID0gZXhwb3J0cy5TZW1hcGhvcmUgPSB2b2lkIDA7XG5mdW5jdGlvbiBlbnN1cmVDYWxsYWJsZShmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICByZXR1cm4gZm47XG59XG5mdW5jdGlvbiBieU9ic2VydmVyKE9ic2VydmVyKSB7XG4gICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBsZXQgcXVldWUsIGN1cnJlbnRRdWV1ZSwgYml0ID0gMCwgaSA9IDA7XG4gICAgbmV3IE9ic2VydmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IGNhbGxiYWNrO1xuICAgICAgICBpZiAoIXF1ZXVlKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRRdWV1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLnNsaWNlKGkpLmNvbmNhdChxdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gbnVsbDtcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIGlmICh0eXBlb2YgY3VycmVudFF1ZXVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGN1cnJlbnRRdWV1ZTtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuZGF0YSA9IChiaXQgPSArK2JpdCAlIDIpOyAvLyBJbnZva2Ugb3RoZXIgYmF0Y2gsIHRvIGhhbmRsZSBsZWZ0b3ZlciBjYWxsYmFja3MgaW4gY2FzZSBvZiBjcmFzaFxuICAgICAgICB3aGlsZSAoaSA8IGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY3VycmVudFF1ZXVlW2ldO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaWYgKGkgPT09IGN1cnJlbnRRdWV1ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9KS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGVuc3VyZUNhbGxhYmxlKGZuKTtcbiAgICAgICAgaWYgKHF1ZXVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXVlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHF1ZXVlID0gW3F1ZXVlLCBmbl07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcXVldWUgPSBmbjtcbiAgICAgICAgbm9kZS5kYXRhID0gKGJpdCA9ICsrYml0ICUgMik7XG4gICAgfTtcbn1cbmNvbnN0IG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBxdWV1ZU1pY3JvdGFza1xuICAgIGlmICh0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhlbnN1cmVDYWxsYWJsZShjYikpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBNdXRhdGlvbk9ic2VydmVyXG4gICAgaWYgKCh0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnKSAmJiBkb2N1bWVudCkge1xuICAgICAgICBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm4gYnlPYnNlcnZlcihNdXRhdGlvbk9ic2VydmVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiBieU9ic2VydmVyKHdpbmRvdy5XZWJLaXRNdXRhdGlvbk9ic2VydmVyKTtcbiAgICB9XG4gICAgLy8gVzNDIERyYWZ0XG4gICAgLy8gaHR0cDovL2R2Y3MudzMub3JnL2hnL3dlYnBlcmYvcmF3LWZpbGUvdGlwL3NwZWNzL3NldEltbWVkaWF0ZS9PdmVydmlldy5odG1sXG4gICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGVuc3VyZUNhbGxhYmxlKGNiKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFdpZGUgYXZhaWxhYmxlIHN0YW5kYXJkXG4gICAgaWYgKCh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykgfHwgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgc2V0VGltZW91dChlbnN1cmVDYWxsYWJsZShjYiksIDApO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGBuZXh0VGlja2AgaW1wbGVtZW50YXRpb24gZm91bmQnKTtcbn0oKSk7XG5jbGFzcyBTZW1hcGhvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNvdW50KSB7XG4gICAgICAgIHRoaXMudGFza3MgPSBbXTtcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgIH1cbiAgICBzY2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPiAwICYmIHRoaXMudGFza3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnRhc2tzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIHVuZGVmaW5lZCB2YWx1ZSBpbiB0YXNrcyBsaXN0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWNxdWlyZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIF9yZWopID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlbGVhc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVzKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWxlYXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy50YXNrcy5wdXNoKHRhc2spO1xuICAgICAgICAgICAgbmV4dFRpY2sodGhpcy5zY2hlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVzZShmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjcXVpcmUoKVxuICAgICAgICAgICAgLnRoZW4ocmVsZWFzZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZigpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TZW1hcGhvcmUgPSBTZW1hcGhvcmU7XG5jbGFzcyBNdXRleCBleHRlbmRzIFNlbWFwaG9yZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDEpO1xuICAgIH1cbn1cbmV4cG9ydHMuTXV0ZXggPSBNdXRleDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@broxus/await-semaphore/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@eversdk/appkit/dist/account.js":
/*!******************************************************!*\
  !*** ./node_modules/@eversdk/appkit/dist/account.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DefaultGiverContract = exports.Account = exports.AccountType = exports.AccountError = void 0;\nconst core_1 = __webpack_require__(/*! @eversdk/core */ \"./node_modules/@eversdk/core/dist/index.js\");\nvar ERR_CODES;\n(function (ERR_CODES) {\n    ERR_CODES[ERR_CODES[\"MISSING_TVC\"] = 0] = \"MISSING_TVC\";\n    ERR_CODES[ERR_CODES[\"ACC_NOT_EXISTS\"] = 1] = \"ACC_NOT_EXISTS\";\n})(ERR_CODES || (ERR_CODES = {}));\nclass AccountError extends Error {\n    constructor(opt) {\n        super(opt.message);\n        this.code = opt.code;\n    }\n    static missingTVC() {\n        return new AccountError({\n            code: ERR_CODES.MISSING_TVC,\n            message: \"Can't calculate deploy params: missing required TVC.\",\n        });\n    }\n    static missingBOC() {\n        return new AccountError({\n            code: ERR_CODES.ACC_NOT_EXISTS,\n            message: 'Account has an empty BOC. Possible reason is: account was deleted (has account type \"NonExist\")',\n        });\n    }\n}\nexports.AccountError = AccountError;\n/**\n * Current type of the account.\n */\nvar AccountType;\n(function (AccountType) {\n    /**\n     * Account exists in the blockchain but without smart contract.\n     */\n    AccountType[AccountType[\"uninit\"] = 0] = \"uninit\";\n    /**\n     * Account exists in the blockchain with smart contract.\n     */\n    AccountType[AccountType[\"active\"] = 1] = \"active\";\n    /**\n     * Account exists in the blockchain but it had frozen.\n     */\n    AccountType[AccountType[\"frozen\"] = 2] = \"frozen\";\n    /**\n     * Account is missing in the blockchain.\n     */\n    AccountType[AccountType[\"nonExist\"] = 3] = \"nonExist\";\n})(AccountType = exports.AccountType || (exports.AccountType = {}));\n/**\n * Object to deal with specified account using specified signer (owner).\n *\n * Account instance can be bound to account address\n * or account deploy parameters that uniquely identifies\n * account address.\n */\nclass Account {\n    /**\n     * Constructs account instance.\n     *\n     * @param contract Contract package containing abi and optional tvc data.\n     * @param options Account instance options.\n     */\n    constructor(contract, options) {\n        var _a, _b, _c, _d, _e;\n        this.syncLastTransLt = null;\n        this.cachedBoc = null;\n        this.subscriptions = null;\n        this.contract = contract;\n        this.client = (_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : core_1.TonClient.default;\n        this.abi = (0, core_1.abiContract)(contract.abi);\n        this.signer = (_b = options === null || options === void 0 ? void 0 : options.signer) !== null && _b !== void 0 ? _b : (0, core_1.signerNone)();\n        this.address = (_c = options === null || options === void 0 ? void 0 : options.address) !== null && _c !== void 0 ? _c : null;\n        this.initData = (_d = options === null || options === void 0 ? void 0 : options.initData) !== null && _d !== void 0 ? _d : null;\n        this.useCachedState = (_e = options === null || options === void 0 ? void 0 : options.useCachedState) !== null && _e !== void 0 ? _e : false;\n    }\n    /**\n     * Returns the giver instance assigned for specified client instance.\n     * Or `null` if no giver is associated with this client yet.\n     *\n     * @param client Client instance looking for.\n     */\n    static findGiverForClient(client) {\n        var _a;\n        return (_a = this.giversByClient.find(x => x.client === client)) === null || _a === void 0 ? void 0 : _a.giver;\n    }\n    /**\n     * Assigns specified giver as a default for specified client instance.\n     * If client already has default giver it will be reassigned.\n     *\n     * @param client Client instance.\n     * @param giver New giver instance or `null` if the default giver for\n     * this client must be removed.\n     */\n    static setGiverForClient(client, giver) {\n        const i = this.giversByClient.findIndex(x => x.client === client);\n        if (i >= 0) {\n            if (giver) {\n                this.giversByClient[i].giver = giver;\n            }\n            else {\n                this.giversByClient.splice(i, 1);\n            }\n        }\n        else if (giver) {\n            this.giversByClient.push({\n                client,\n                giver,\n            });\n        }\n    }\n    static createGiver(client) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const giverKeys = yield getDefaultGiverKeys(client);\n            const giverAddress = yield getDefaultGiverAddress(client, giverKeys);\n            const giver = new Account(exports.DefaultGiverContract, {\n                client,\n                address: giverAddress,\n                signer: (0, core_1.signerKeys)(giverKeys),\n            });\n            return {\n                address: giverAddress,\n                sendTo: (address, value) => __awaiter(this, void 0, void 0, function* () {\n                    yield giver.run(\"sendTransaction\", {\n                        dest: address,\n                        value,\n                        bounce: false,\n                    });\n                }),\n            };\n        });\n    }\n    /**\n     * Returns the default giver for specified client instance.\n     * If no giver assigned yet then new one will be created,\n     * assigned and returned.\n     *\n     * @param client Client instance.\n     */\n    static getGiverForClient(client) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const existing = this.findGiverForClient(client);\n            if (existing) {\n                return existing;\n            }\n            const giver = yield this.createGiver(client);\n            this.giversByClient.push({\n                client,\n                giver,\n            });\n            return giver;\n        });\n    }\n    /**\n     * Returns address of the account.\n     *\n     * Uses address specified in constructor options\n     * or calculates it from deploy data provided in constructor.\n     */\n    getAddress() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let address = this.address;\n            if (address === null) {\n                const deployParams = this.getParamsOfDeployMessage({\n                    initFunctionName: null,\n                });\n                address = (yield this.client.abi.encode_message(deployParams)).address;\n                this.address = address;\n            }\n            return address;\n        });\n    }\n    /**\n     * Returns params for encoding deploy message.\n     * @param options Message encoding options.\n     */\n    getParamsOfDeployMessage(options) {\n        var _a;\n        if (!this.contract.tvc) {\n            throw AccountError.missingTVC();\n        }\n        const params = {\n            abi: this.abi,\n            signer: this.signer,\n            deploy_set: {\n                tvc: this.contract.tvc,\n            },\n        };\n        if (this.initData) {\n            params.deploy_set.initial_data = this.initData;\n        }\n        if ((options === null || options === void 0 ? void 0 : options.initFunctionName) !== null) {\n            params.call_set = {\n                function_name: (_a = options === null || options === void 0 ? void 0 : options.initFunctionName) !== null && _a !== void 0 ? _a : \"constructor\",\n            };\n            if ((options === null || options === void 0 ? void 0 : options.initInput) !== undefined) {\n                params.call_set.input = options.initInput;\n            }\n        }\n        return params;\n    }\n    /**\n     * Calculates detailed deploy fees.\n     */\n    calcDeployFees(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const deployParams = yield this.getParamsOfDeployMessage(options);\n            const message = yield this.client.abi.encode_message(deployParams);\n            const result = yield this.client.tvm.run_executor({\n                account: (0, core_1.accountForExecutorUninit)(),\n                abi: this.abi,\n                message: message.message,\n            });\n            return result.fees;\n        });\n    }\n    /**\n     * Deploys account into network\n     * @param options\n     */\n    deploy(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const deployParams = this.getParamsOfDeployMessage(options);\n            const useGiver = options === null || options === void 0 ? void 0 : options.useGiver;\n            const giver = useGiver === true ? (yield Account.getGiverForClient(this.client)) : useGiver;\n            this.address = (yield this.client.abi.encode_message(deployParams)).address;\n            if (giver) {\n                yield giver.sendTo(this.address, 10000000000);\n            }\n            const result = yield this.client.processing.process_message({\n                message_encode_params: deployParams,\n                send_events: false,\n            });\n            this.needSyncWithTransaction(result.transaction);\n            return result;\n        });\n    }\n    /**\n     * Emulate deploy\n     * @param options\n     */\n    deployLocal(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const deployParams = this.getParamsOfDeployMessage(options);\n            const { address, message, } = yield this.client.abi.encode_message(deployParams);\n            const result = yield this.client.tvm.run_executor({\n                account: (0, core_1.accountForExecutorUninit)(),\n                abi: this.abi,\n                message,\n                return_updated_account: true,\n            });\n            this.address = address;\n            this.cachedBoc = result.account;\n            return result;\n        });\n    }\n    /**\n     * Calculates detailed fees for specified run parameters.\n     *\n     * @param functionName Name of the function according to the ABI.\n     * @param input Object with function parameters (function parameters).\n     */\n    calcRunFees(functionName, input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const message = yield this.client.abi.encode_message({\n                address: yield this.getAddress(),\n                abi: this.abi,\n                signer: this.signer,\n                call_set: {\n                    function_name: functionName,\n                    input,\n                },\n            });\n            let result;\n            result = yield this.client.tvm.run_executor({\n                account: (0, core_1.accountForExecutorAccount)(yield this.boc()),\n                abi: this.abi,\n                message: message.message,\n            });\n            return result.fees;\n        });\n    }\n    /**\n     * Process message on network and returns detailed information\n     * about results including produced transaction and messages.\n     *\n     * @param functionName Name of the function according to the ABI.\n     * @param input Object with function parameters (function parameters).\n     * @param options Run options.\n     */\n    run(functionName, input, options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = (yield this.client.processing.process_message({\n                message_encode_params: {\n                    address: yield this.getAddress(),\n                    abi: this.abi,\n                    signer: (_a = options === null || options === void 0 ? void 0 : options.signer) !== null && _a !== void 0 ? _a : this.signer,\n                    call_set: {\n                        function_name: functionName,\n                        input,\n                    },\n                },\n                send_events: false,\n            }));\n            this.needSyncWithTransaction(result.transaction);\n            return result;\n        });\n    }\n    /**\n     * Evaluates message on local TVM and returns decoded output.\n     *\n     * @param functionName Name of the function according to the ABI.\n     * @param input Object with function parameters (function input).\n     * @param options Run options.\n     */\n    runLocal(functionName, input, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const message = yield this.client.abi.encode_message({\n                address: yield this.getAddress(),\n                abi: this.abi,\n                signer: this.signer,\n                call_set: {\n                    function_name: functionName,\n                    input,\n                },\n            });\n            let result;\n            if (options === null || options === void 0 ? void 0 : options.performAllChecks) {\n                result = yield this.client.tvm.run_executor({\n                    account: (0, core_1.accountForExecutorAccount)(yield this.boc()),\n                    abi: this.abi,\n                    message: message.message,\n                    return_updated_account: true,\n                });\n            }\n            else {\n                result = (yield this.client.tvm.run_tvm({\n                    account: yield this.boc(),\n                    abi: this.abi,\n                    message: message.message,\n                    return_updated_account: true,\n                }));\n            }\n            if (result.account) {\n                this.cachedBoc = result.account;\n            }\n            return result;\n        });\n    }\n    needSyncWithTransaction(transaction) {\n        if (!transaction.aborted && transaction.lt) {\n            this.syncLastTransLt = transaction.lt;\n            this.cachedBoc = null;\n        }\n    }\n    /**\n     * Returns raw data of the account in form of BOC.\n     * Fetches boc data from network and caches it in private field.\n     * `runLocal` updates cached boc.\n     * `run` drops cached boc.\n     * This function syncs fetching boc with last `run` or `deploy`\n     * so fetched boc\n     */\n    boc() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.cachedBoc && this.useCachedState) {\n                return this.cachedBoc;\n            }\n            const address = yield this.getAddress();\n            const net = this.client.net;\n            if (this.syncLastTransLt) {\n                const accounts = yield net.query_collection({\n                    collection: \"accounts\",\n                    filter: {\n                        id: { eq: address },\n                        last_trans_lt: { ge: this.syncLastTransLt },\n                    },\n                    result: \"boc\",\n                });\n                if (accounts.result.length > 0) {\n                    const boc = accounts.result[0].boc;\n                    this.syncLastTransLt = null;\n                    if (boc) {\n                        this.cachedBoc = boc;\n                        return boc;\n                    }\n                    throw AccountError.missingBOC();\n                }\n            }\n            try {\n                const boc = (\n                // Returns BOC or null if account was found in DB, but has \"NotExists\" status\n                // Throws if:\n                //  - account NOT found in DB (err.code 603) \n                //  - some network error occured\n                yield net.wait_for_collection({\n                    collection: \"accounts\",\n                    filter: { id: { eq: this.address } },\n                    result: \"boc\",\n                    timeout: 1000,\n                })).result.boc;\n                if (boc) {\n                    this.cachedBoc = boc;\n                    return boc;\n                }\n                throw AccountError.missingBOC();\n            }\n            catch (error) {\n                if (error.code === 603) {\n                    throw AccountError.missingBOC();\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Drops all cached and local data.\n     */\n    refresh() {\n        this.cachedBoc = null;\n    }\n    /**\n     * Returns parsed data of the account.\n     */\n    getAccount() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const boc = yield this.boc();\n                return (yield this.client.boc.parse_account({ boc })).parsed;\n            }\n            catch (err) {\n                if (err.code === ERR_CODES.ACC_NOT_EXISTS) {\n                    return {\n                        acc_type: AccountType.nonExist,\n                    };\n                }\n            }\n        });\n    }\n    subscribeAccount(fields, listener) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.subscribe(\"accounts\", { id: { eq: yield this.getAddress() } }, fields, listener);\n        });\n    }\n    subscribeTransactions(fields, listener) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const address = yield this.getAddress();\n            yield this.subscribe(\"transactions\", {\n                account_addr: { eq: address },\n                status: { eq: 5 },\n            }, fields, listener);\n        });\n    }\n    subscribeMessages(fields, listener) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const address = yield this.getAddress();\n            yield this.subscribe(\"messages\", {\n                status: { eq: 5 },\n                src: { eq: address },\n                OR: {\n                    status: { eq: 5 },\n                    dst: { eq: address },\n                },\n            }, fields, listener);\n        });\n    }\n    decodeMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield core_1.TonClient.default.abi.decode_message({\n                abi: this.abi,\n                message,\n            });\n        });\n    }\n    decodeMessageBody(body, isInternal) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield core_1.TonClient.default.abi.decode_message_body({\n                abi: this.abi,\n                body,\n                is_internal: isInternal,\n            });\n        });\n    }\n    getBalance() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return (yield this.getAccount()).balance;\n        });\n    }\n    subscribe(collection, filter, fields, listener) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const prevSubscription = this.subscriptions && this.subscriptions.get(collection);\n            if (prevSubscription) {\n                (_a = this.subscriptions) === null || _a === void 0 ? void 0 : _a.delete(collection);\n                yield this.client.net.unsubscribe(prevSubscription);\n            }\n            else if (!this.subscriptions) {\n                this.subscriptions = new Map();\n            }\n            const subscription = yield this.client.net.subscribe_collection({\n                collection,\n                filter,\n                result: fields,\n            }, ((params, responseType) => {\n                if (responseType === 100) {\n                    listener(params.result);\n                }\n            }));\n            (_b = this.subscriptions) === null || _b === void 0 ? void 0 : _b.set(collection, subscription);\n        });\n    }\n    /**\n     * Free all internal resources related to this instance\n     * and allocated inside core.\n     *\n     * It is a good practice to call this method when you have finished\n     * with this Account object.\n     *\n     * Note that this instance still fully operable.\n     * So you can continue to work with this instance.\n     */\n    free() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.subscriptions) {\n                const subscriptions = this.subscriptions.values();\n                this.subscriptions = null;\n                for (const subscription of subscriptions) {\n                    yield this.client.net.unsubscribe(subscription);\n                }\n            }\n        });\n    }\n}\nexports.Account = Account;\nAccount.giversByClient = [];\nfunction getEnv(name) {\n    const globalEval = eval;\n    try {\n        return globalEval(`process.env.${name}`);\n    }\n    catch (_a) {\n        return undefined;\n    }\n}\nfunction getDefaultGiverKeys(client) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const definedSecret = getEnv(\"TON_GIVER_SECRET\");\n        if (definedSecret) {\n            const definedKeys = yield client.crypto.nacl_sign_keypair_from_secret_key({\n                secret: definedSecret,\n            });\n            definedKeys.secret = definedKeys.secret.substr(0, 64);\n            return definedKeys;\n        }\n        // noinspection SpellCheckingInspection\n        return {\n            \"public\": \"2ada2e65ab8eeab09490e3521415f45b6e42df9c760a639bcf53957550b25a16\",\n            \"secret\": \"172af540e43a524763dd53b26a066d472a97c4de37d5498170564510608250c3\",\n        };\n    });\n}\nfunction getDefaultGiverAddress(client, keys) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        const definedAddress = getEnv(\"TON_GIVER_ADDRESS\");\n        if (definedAddress) {\n            return definedAddress;\n        }\n        return (yield client.abi.encode_message({\n            abi: (0, core_1.abiContract)(exports.DefaultGiverContract.abi),\n            deploy_set: {\n                tvc: (_a = exports.DefaultGiverContract.tvc) !== null && _a !== void 0 ? _a : \"\",\n            },\n            signer: (0, core_1.signerKeys)(keys),\n        })).address;\n    });\n}\n// noinspection SpellCheckingInspection\nexports.DefaultGiverContract = {\n    abi: {\n        \"ABI version\": 2,\n        header: [\"time\", \"expire\"],\n        functions: [\n            {\n                name: \"sendTransaction\",\n                inputs: [\n                    {\n                        \"name\": \"dest\",\n                        \"type\": \"address\",\n                    },\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"uint128\",\n                    },\n                    {\n                        \"name\": \"bounce\",\n                        \"type\": \"bool\",\n                    },\n                ],\n                outputs: [],\n            },\n            {\n                name: \"getMessages\",\n                inputs: [],\n                outputs: [\n                    {\n                        components: [\n                            {\n                                name: \"hash\",\n                                type: \"uint256\",\n                            },\n                            {\n                                name: \"expireAt\",\n                                type: \"uint64\",\n                            },\n                        ],\n                        name: \"messages\",\n                        type: \"tuple[]\",\n                    },\n                ],\n            },\n            {\n                name: \"upgrade\",\n                inputs: [\n                    {\n                        name: \"newcode\",\n                        type: \"cell\",\n                    },\n                ],\n                outputs: [],\n            },\n            {\n                name: \"constructor\",\n                inputs: [],\n                outputs: [],\n            },\n        ],\n        data: [],\n        events: [],\n    },\n    tvc: \"te6ccgECGgEAA9sAAgE0BgEBAcACAgPPIAUDAQHeBAAD0CAAQdgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAIm/wD0pCAiwAGS9KDhiu1TWDD0oQkHAQr0pCD0oQgAAAIBIAwKAfz/fyHtRNAg10nCAZ/T/9MA9AX4an/4Yfhm+GKOG/QFbfhqcAGAQPQO8r3XC//4YnD4Y3D4Zn/4YeLTAAGOEoECANcYIPkBWPhCIPhl+RDyqN4j+EL4RSBukjBw3rry4GUh0z/THzQx+CMhAb7yuSH5ACD4SoEBAPQOIJEx3rMLAE7y4Gb4ACH4SiIBVQHIyz9ZgQEA9EP4aiMEXwTTHwHwAfhHbpLyPN4CASASDQIBWBEOAQm46Jj8UA8B/vhBbo4S7UTQ0//TAPQF+Gp/+GH4Zvhi3tFwbW8C+EqBAQD0hpUB1ws/f5NwcHDikSCONyMjI28CbyLIIs8L/yHPCz8xMQFvIiGkA1mAIPRDbwI0IvhKgQEA9HyVAdcLP3+TcHBw4gI1MzHoXwPIghB3RMfighCAAAAAsc8LHyEQAKJvIgLLH/QAyIJYYAAAAAAAAAAAAAAAAM8LZoEDmCLPMQG5lnHPQCHPF5Vxz0EhzeIgyXH7AFswwP+OEvhCyMv/+EbPCwD4SgH0AMntVN5/+GcAxbkWq+f/CC3Rxt2omgQa6ThAM/p/+mAegL8NT/8MPwzfDFHDfoCtvw1OADAIHoHeV7rhf/8MTh8Mbh8Mz/8MPFvfCNJeRnJuPwzcXwAaPwhZGX//CNnhYB8JQD6AGT2qj/8M8AIBIBUTAde7Fe+TX4QW6OEu1E0NP/0wD0Bfhqf/hh+Gb4Yt76QNcNf5XU0dDTf9/XDACV1NHQ0gDf0SIiInPIcc8LASLPCgBzz0AkzxYj+gKAac9Acs9AIMki+wBfBfhKgQEA9IaVAdcLP3+TcHBw4pEggUAJKOLfgjIgG7n/hKIwEhAYEBAPRbMDH4at4i+EqBAQD0fJUB1ws/f5NwcHDiAjUzMehfA18D+ELIy//4Rs8LAPhKAfQAye1Uf/hnAgEgFxYAx7jkYYdfCC3Rwl2omhp/+mAegL8NT/8MPwzfDFvamj8IXwikDdJGDhvXXlwMvwAfCFkZf/8I2eFgHwlAPoAZPaqfAeQfYIQaHaPdqn4ARh8IWRl//wjZ4WAfCUA+gBk9qo//DPACAtoZGAAtr4QsjL//hGzwsA+EoB9ADJ7VT4D/IAgAdacCHHAJ0i0HPXIdcLAMABkJDi4CHXDR+S8jzhUxHAAJDgwQMighD////9vLGS8jzgAfAB+EdukvI83o\",\n};\n//# sourceMappingURL=account.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGV2ZXJzZGsvYXBwa2l0L2Rpc3QvYWNjb3VudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9AZXZlcnNkay9hcHBraXQvZGlzdC9hY2NvdW50LmpzPzMxMmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVmYXVsdEdpdmVyQ29udHJhY3QgPSBleHBvcnRzLkFjY291bnQgPSBleHBvcnRzLkFjY291bnRUeXBlID0gZXhwb3J0cy5BY2NvdW50RXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiQGV2ZXJzZGsvY29yZVwiKTtcbnZhciBFUlJfQ09ERVM7XG4oZnVuY3Rpb24gKEVSUl9DT0RFUykge1xuICAgIEVSUl9DT0RFU1tFUlJfQ09ERVNbXCJNSVNTSU5HX1RWQ1wiXSA9IDBdID0gXCJNSVNTSU5HX1RWQ1wiO1xuICAgIEVSUl9DT0RFU1tFUlJfQ09ERVNbXCJBQ0NfTk9UX0VYSVNUU1wiXSA9IDFdID0gXCJBQ0NfTk9UX0VYSVNUU1wiO1xufSkoRVJSX0NPREVTIHx8IChFUlJfQ09ERVMgPSB7fSkpO1xuY2xhc3MgQWNjb3VudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdCkge1xuICAgICAgICBzdXBlcihvcHQubWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IG9wdC5jb2RlO1xuICAgIH1cbiAgICBzdGF0aWMgbWlzc2luZ1RWQygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBY2NvdW50RXJyb3Ioe1xuICAgICAgICAgICAgY29kZTogRVJSX0NPREVTLk1JU1NJTkdfVFZDLFxuICAgICAgICAgICAgbWVzc2FnZTogXCJDYW4ndCBjYWxjdWxhdGUgZGVwbG95IHBhcmFtczogbWlzc2luZyByZXF1aXJlZCBUVkMuXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgbWlzc2luZ0JPQygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBY2NvdW50RXJyb3Ioe1xuICAgICAgICAgICAgY29kZTogRVJSX0NPREVTLkFDQ19OT1RfRVhJU1RTLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0FjY291bnQgaGFzIGFuIGVtcHR5IEJPQy4gUG9zc2libGUgcmVhc29uIGlzOiBhY2NvdW50IHdhcyBkZWxldGVkIChoYXMgYWNjb3VudCB0eXBlIFwiTm9uRXhpc3RcIiknLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkFjY291bnRFcnJvciA9IEFjY291bnRFcnJvcjtcbi8qKlxuICogQ3VycmVudCB0eXBlIG9mIHRoZSBhY2NvdW50LlxuICovXG52YXIgQWNjb3VudFR5cGU7XG4oZnVuY3Rpb24gKEFjY291bnRUeXBlKSB7XG4gICAgLyoqXG4gICAgICogQWNjb3VudCBleGlzdHMgaW4gdGhlIGJsb2NrY2hhaW4gYnV0IHdpdGhvdXQgc21hcnQgY29udHJhY3QuXG4gICAgICovXG4gICAgQWNjb3VudFR5cGVbQWNjb3VudFR5cGVbXCJ1bmluaXRcIl0gPSAwXSA9IFwidW5pbml0XCI7XG4gICAgLyoqXG4gICAgICogQWNjb3VudCBleGlzdHMgaW4gdGhlIGJsb2NrY2hhaW4gd2l0aCBzbWFydCBjb250cmFjdC5cbiAgICAgKi9cbiAgICBBY2NvdW50VHlwZVtBY2NvdW50VHlwZVtcImFjdGl2ZVwiXSA9IDFdID0gXCJhY3RpdmVcIjtcbiAgICAvKipcbiAgICAgKiBBY2NvdW50IGV4aXN0cyBpbiB0aGUgYmxvY2tjaGFpbiBidXQgaXQgaGFkIGZyb3plbi5cbiAgICAgKi9cbiAgICBBY2NvdW50VHlwZVtBY2NvdW50VHlwZVtcImZyb3plblwiXSA9IDJdID0gXCJmcm96ZW5cIjtcbiAgICAvKipcbiAgICAgKiBBY2NvdW50IGlzIG1pc3NpbmcgaW4gdGhlIGJsb2NrY2hhaW4uXG4gICAgICovXG4gICAgQWNjb3VudFR5cGVbQWNjb3VudFR5cGVbXCJub25FeGlzdFwiXSA9IDNdID0gXCJub25FeGlzdFwiO1xufSkoQWNjb3VudFR5cGUgPSBleHBvcnRzLkFjY291bnRUeXBlIHx8IChleHBvcnRzLkFjY291bnRUeXBlID0ge30pKTtcbi8qKlxuICogT2JqZWN0IHRvIGRlYWwgd2l0aCBzcGVjaWZpZWQgYWNjb3VudCB1c2luZyBzcGVjaWZpZWQgc2lnbmVyIChvd25lcikuXG4gKlxuICogQWNjb3VudCBpbnN0YW5jZSBjYW4gYmUgYm91bmQgdG8gYWNjb3VudCBhZGRyZXNzXG4gKiBvciBhY2NvdW50IGRlcGxveSBwYXJhbWV0ZXJzIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllc1xuICogYWNjb3VudCBhZGRyZXNzLlxuICovXG5jbGFzcyBBY2NvdW50IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFjY291bnQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJhY3QgQ29udHJhY3QgcGFja2FnZSBjb250YWluaW5nIGFiaSBhbmQgb3B0aW9uYWwgdHZjIGRhdGEuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWNjb3VudCBpbnN0YW5jZSBvcHRpb25zLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIHRoaXMuc3luY0xhc3RUcmFuc0x0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYWNoZWRCb2MgPSBudWxsO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRyYWN0ID0gY29udHJhY3Q7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29yZV8xLlRvbkNsaWVudC5kZWZhdWx0O1xuICAgICAgICB0aGlzLmFiaSA9ICgwLCBjb3JlXzEuYWJpQ29udHJhY3QpKGNvbnRyYWN0LmFiaSk7XG4gICAgICAgIHRoaXMuc2lnbmVyID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25lcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKDAsIGNvcmVfMS5zaWduZXJOb25lKSgpO1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYWRkcmVzcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbnVsbDtcbiAgICAgICAgdGhpcy5pbml0RGF0YSA9IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pbml0RGF0YSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbnVsbDtcbiAgICAgICAgdGhpcy51c2VDYWNoZWRTdGF0ZSA9IChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51c2VDYWNoZWRTdGF0ZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGdpdmVyIGluc3RhbmNlIGFzc2lnbmVkIGZvciBzcGVjaWZpZWQgY2xpZW50IGluc3RhbmNlLlxuICAgICAqIE9yIGBudWxsYCBpZiBubyBnaXZlciBpcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjbGllbnQgeWV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNsaWVudCBDbGllbnQgaW5zdGFuY2UgbG9va2luZyBmb3IuXG4gICAgICovXG4gICAgc3RhdGljIGZpbmRHaXZlckZvckNsaWVudChjbGllbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5naXZlcnNCeUNsaWVudC5maW5kKHggPT4geC5jbGllbnQgPT09IGNsaWVudCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5naXZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzaWducyBzcGVjaWZpZWQgZ2l2ZXIgYXMgYSBkZWZhdWx0IGZvciBzcGVjaWZpZWQgY2xpZW50IGluc3RhbmNlLlxuICAgICAqIElmIGNsaWVudCBhbHJlYWR5IGhhcyBkZWZhdWx0IGdpdmVyIGl0IHdpbGwgYmUgcmVhc3NpZ25lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbGllbnQgQ2xpZW50IGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSBnaXZlciBOZXcgZ2l2ZXIgaW5zdGFuY2Ugb3IgYG51bGxgIGlmIHRoZSBkZWZhdWx0IGdpdmVyIGZvclxuICAgICAqIHRoaXMgY2xpZW50IG11c3QgYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0R2l2ZXJGb3JDbGllbnQoY2xpZW50LCBnaXZlcikge1xuICAgICAgICBjb25zdCBpID0gdGhpcy5naXZlcnNCeUNsaWVudC5maW5kSW5kZXgoeCA9PiB4LmNsaWVudCA9PT0gY2xpZW50KTtcbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgaWYgKGdpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5naXZlcnNCeUNsaWVudFtpXS5naXZlciA9IGdpdmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5naXZlcnNCeUNsaWVudC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2l2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZ2l2ZXJzQnlDbGllbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgY2xpZW50LFxuICAgICAgICAgICAgICAgIGdpdmVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUdpdmVyKGNsaWVudCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZ2l2ZXJLZXlzID0geWllbGQgZ2V0RGVmYXVsdEdpdmVyS2V5cyhjbGllbnQpO1xuICAgICAgICAgICAgY29uc3QgZ2l2ZXJBZGRyZXNzID0geWllbGQgZ2V0RGVmYXVsdEdpdmVyQWRkcmVzcyhjbGllbnQsIGdpdmVyS2V5cyk7XG4gICAgICAgICAgICBjb25zdCBnaXZlciA9IG5ldyBBY2NvdW50KGV4cG9ydHMuRGVmYXVsdEdpdmVyQ29udHJhY3QsIHtcbiAgICAgICAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgICAgICAgYWRkcmVzczogZ2l2ZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgIHNpZ25lcjogKDAsIGNvcmVfMS5zaWduZXJLZXlzKShnaXZlcktleXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGdpdmVyQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzZW5kVG86IChhZGRyZXNzLCB2YWx1ZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBnaXZlci5ydW4oXCJzZW5kVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdDogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGVmYXVsdCBnaXZlciBmb3Igc3BlY2lmaWVkIGNsaWVudCBpbnN0YW5jZS5cbiAgICAgKiBJZiBubyBnaXZlciBhc3NpZ25lZCB5ZXQgdGhlbiBuZXcgb25lIHdpbGwgYmUgY3JlYXRlZCxcbiAgICAgKiBhc3NpZ25lZCBhbmQgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xpZW50IENsaWVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0R2l2ZXJGb3JDbGllbnQoY2xpZW50KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuZmluZEdpdmVyRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBnaXZlciA9IHlpZWxkIHRoaXMuY3JlYXRlR2l2ZXIoY2xpZW50KTtcbiAgICAgICAgICAgIHRoaXMuZ2l2ZXJzQnlDbGllbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgY2xpZW50LFxuICAgICAgICAgICAgICAgIGdpdmVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZ2l2ZXI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQuXG4gICAgICpcbiAgICAgKiBVc2VzIGFkZHJlc3Mgc3BlY2lmaWVkIGluIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICAgKiBvciBjYWxjdWxhdGVzIGl0IGZyb20gZGVwbG95IGRhdGEgcHJvdmlkZWQgaW4gY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgZ2V0QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXBsb3lQYXJhbXMgPSB0aGlzLmdldFBhcmFtc09mRGVwbG95TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGluaXRGdW5jdGlvbk5hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9ICh5aWVsZCB0aGlzLmNsaWVudC5hYmkuZW5jb2RlX21lc3NhZ2UoZGVwbG95UGFyYW1zKSkuYWRkcmVzcztcbiAgICAgICAgICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHBhcmFtcyBmb3IgZW5jb2RpbmcgZGVwbG95IG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgTWVzc2FnZSBlbmNvZGluZyBvcHRpb25zLlxuICAgICAqL1xuICAgIGdldFBhcmFtc09mRGVwbG95TWVzc2FnZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRyYWN0LnR2Yykge1xuICAgICAgICAgICAgdGhyb3cgQWNjb3VudEVycm9yLm1pc3NpbmdUVkMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgc2lnbmVyOiB0aGlzLnNpZ25lcixcbiAgICAgICAgICAgIGRlcGxveV9zZXQ6IHtcbiAgICAgICAgICAgICAgICB0dmM6IHRoaXMuY29udHJhY3QudHZjLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuaW5pdERhdGEpIHtcbiAgICAgICAgICAgIHBhcmFtcy5kZXBsb3lfc2V0LmluaXRpYWxfZGF0YSA9IHRoaXMuaW5pdERhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaW5pdEZ1bmN0aW9uTmFtZSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmFtcy5jYWxsX3NldCA9IHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbl9uYW1lOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaW5pdEZ1bmN0aW9uTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmluaXRJbnB1dCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5jYWxsX3NldC5pbnB1dCA9IG9wdGlvbnMuaW5pdElucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgZGV0YWlsZWQgZGVwbG95IGZlZXMuXG4gICAgICovXG4gICAgY2FsY0RlcGxveUZlZXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGVwbG95UGFyYW1zID0geWllbGQgdGhpcy5nZXRQYXJhbXNPZkRlcGxveU1lc3NhZ2Uob3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0geWllbGQgdGhpcy5jbGllbnQuYWJpLmVuY29kZV9tZXNzYWdlKGRlcGxveVBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLmNsaWVudC50dm0ucnVuX2V4ZWN1dG9yKHtcbiAgICAgICAgICAgICAgICBhY2NvdW50OiAoMCwgY29yZV8xLmFjY291bnRGb3JFeGVjdXRvclVuaW5pdCkoKSxcbiAgICAgICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UubWVzc2FnZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5mZWVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwbG95cyBhY2NvdW50IGludG8gbmV0d29ya1xuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgZGVwbG95KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlcGxveVBhcmFtcyA9IHRoaXMuZ2V0UGFyYW1zT2ZEZXBsb3lNZXNzYWdlKG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgdXNlR2l2ZXIgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudXNlR2l2ZXI7XG4gICAgICAgICAgICBjb25zdCBnaXZlciA9IHVzZUdpdmVyID09PSB0cnVlID8gKHlpZWxkIEFjY291bnQuZ2V0R2l2ZXJGb3JDbGllbnQodGhpcy5jbGllbnQpKSA6IHVzZUdpdmVyO1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzID0gKHlpZWxkIHRoaXMuY2xpZW50LmFiaS5lbmNvZGVfbWVzc2FnZShkZXBsb3lQYXJhbXMpKS5hZGRyZXNzO1xuICAgICAgICAgICAgaWYgKGdpdmVyKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgZ2l2ZXIuc2VuZFRvKHRoaXMuYWRkcmVzcywgMTAwMDAwMDAwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5jbGllbnQucHJvY2Vzc2luZy5wcm9jZXNzX21lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VfZW5jb2RlX3BhcmFtczogZGVwbG95UGFyYW1zLFxuICAgICAgICAgICAgICAgIHNlbmRfZXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5uZWVkU3luY1dpdGhUcmFuc2FjdGlvbihyZXN1bHQudHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtdWxhdGUgZGVwbG95XG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBkZXBsb3lMb2NhbChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBkZXBsb3lQYXJhbXMgPSB0aGlzLmdldFBhcmFtc09mRGVwbG95TWVzc2FnZShvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYWRkcmVzcywgbWVzc2FnZSwgfSA9IHlpZWxkIHRoaXMuY2xpZW50LmFiaS5lbmNvZGVfbWVzc2FnZShkZXBsb3lQYXJhbXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5jbGllbnQudHZtLnJ1bl9leGVjdXRvcih7XG4gICAgICAgICAgICAgICAgYWNjb3VudDogKDAsIGNvcmVfMS5hY2NvdW50Rm9yRXhlY3V0b3JVbmluaXQpKCksXG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHJldHVybl91cGRhdGVkX2FjY291bnQ6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZEJvYyA9IHJlc3VsdC5hY2NvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgZGV0YWlsZWQgZmVlcyBmb3Igc3BlY2lmaWVkIHJ1biBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZ1bmN0aW9uTmFtZSBOYW1lIG9mIHRoZSBmdW5jdGlvbiBhY2NvcmRpbmcgdG8gdGhlIEFCSS5cbiAgICAgKiBAcGFyYW0gaW5wdXQgT2JqZWN0IHdpdGggZnVuY3Rpb24gcGFyYW1ldGVycyAoZnVuY3Rpb24gcGFyYW1ldGVycykuXG4gICAgICovXG4gICAgY2FsY1J1bkZlZXMoZnVuY3Rpb25OYW1lLCBpbnB1dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHlpZWxkIHRoaXMuY2xpZW50LmFiaS5lbmNvZGVfbWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogeWllbGQgdGhpcy5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBzaWduZXI6IHRoaXMuc2lnbmVyLFxuICAgICAgICAgICAgICAgIGNhbGxfc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX25hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuY2xpZW50LnR2bS5ydW5fZXhlY3V0b3Ioe1xuICAgICAgICAgICAgICAgIGFjY291bnQ6ICgwLCBjb3JlXzEuYWNjb3VudEZvckV4ZWN1dG9yQWNjb3VudCkoeWllbGQgdGhpcy5ib2MoKSksXG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLm1lc3NhZ2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZmVlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgbWVzc2FnZSBvbiBuZXR3b3JrIGFuZCByZXR1cm5zIGRldGFpbGVkIGluZm9ybWF0aW9uXG4gICAgICogYWJvdXQgcmVzdWx0cyBpbmNsdWRpbmcgcHJvZHVjZWQgdHJhbnNhY3Rpb24gYW5kIG1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZ1bmN0aW9uTmFtZSBOYW1lIG9mIHRoZSBmdW5jdGlvbiBhY2NvcmRpbmcgdG8gdGhlIEFCSS5cbiAgICAgKiBAcGFyYW0gaW5wdXQgT2JqZWN0IHdpdGggZnVuY3Rpb24gcGFyYW1ldGVycyAoZnVuY3Rpb24gcGFyYW1ldGVycykuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgUnVuIG9wdGlvbnMuXG4gICAgICovXG4gICAgcnVuKGZ1bmN0aW9uTmFtZSwgaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKHlpZWxkIHRoaXMuY2xpZW50LnByb2Nlc3NpbmcucHJvY2Vzc19tZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlX2VuY29kZV9wYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogeWllbGQgdGhpcy5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICAgICAgICAgIGFiaTogdGhpcy5hYmksXG4gICAgICAgICAgICAgICAgICAgIHNpZ25lcjogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25lcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5zaWduZXIsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxfc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9uYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlbmRfZXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMubmVlZFN5bmNXaXRoVHJhbnNhY3Rpb24ocmVzdWx0LnRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgbWVzc2FnZSBvbiBsb2NhbCBUVk0gYW5kIHJldHVybnMgZGVjb2RlZCBvdXRwdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnVuY3Rpb25OYW1lIE5hbWUgb2YgdGhlIGZ1bmN0aW9uIGFjY29yZGluZyB0byB0aGUgQUJJLlxuICAgICAqIEBwYXJhbSBpbnB1dCBPYmplY3Qgd2l0aCBmdW5jdGlvbiBwYXJhbWV0ZXJzIChmdW5jdGlvbiBpbnB1dCkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgUnVuIG9wdGlvbnMuXG4gICAgICovXG4gICAgcnVuTG9jYWwoZnVuY3Rpb25OYW1lLCBpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHlpZWxkIHRoaXMuY2xpZW50LmFiaS5lbmNvZGVfbWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogeWllbGQgdGhpcy5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBzaWduZXI6IHRoaXMuc2lnbmVyLFxuICAgICAgICAgICAgICAgIGNhbGxfc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX25hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGVyZm9ybUFsbENoZWNrcykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuY2xpZW50LnR2bS5ydW5fZXhlY3V0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50OiAoMCwgY29yZV8xLmFjY291bnRGb3JFeGVjdXRvckFjY291bnQpKHlpZWxkIHRoaXMuYm9jKCkpLFxuICAgICAgICAgICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybl91cGRhdGVkX2FjY291bnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAoeWllbGQgdGhpcy5jbGllbnQudHZtLnJ1bl90dm0oe1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50OiB5aWVsZCB0aGlzLmJvYygpLFxuICAgICAgICAgICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybl91cGRhdGVkX2FjY291bnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5hY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRCb2MgPSByZXN1bHQuYWNjb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWVkU3luY1dpdGhUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLmFib3J0ZWQgJiYgdHJhbnNhY3Rpb24ubHQpIHtcbiAgICAgICAgICAgIHRoaXMuc3luY0xhc3RUcmFuc0x0ID0gdHJhbnNhY3Rpb24ubHQ7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZEJvYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByYXcgZGF0YSBvZiB0aGUgYWNjb3VudCBpbiBmb3JtIG9mIEJPQy5cbiAgICAgKiBGZXRjaGVzIGJvYyBkYXRhIGZyb20gbmV0d29yayBhbmQgY2FjaGVzIGl0IGluIHByaXZhdGUgZmllbGQuXG4gICAgICogYHJ1bkxvY2FsYCB1cGRhdGVzIGNhY2hlZCBib2MuXG4gICAgICogYHJ1bmAgZHJvcHMgY2FjaGVkIGJvYy5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHN5bmNzIGZldGNoaW5nIGJvYyB3aXRoIGxhc3QgYHJ1bmAgb3IgYGRlcGxveWBcbiAgICAgKiBzbyBmZXRjaGVkIGJvY1xuICAgICAqL1xuICAgIGJvYygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhY2hlZEJvYyAmJiB0aGlzLnVzZUNhY2hlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkQm9jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgY29uc3QgbmV0ID0gdGhpcy5jbGllbnQubmV0O1xuICAgICAgICAgICAgaWYgKHRoaXMuc3luY0xhc3RUcmFuc0x0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSB5aWVsZCBuZXQucXVlcnlfY29sbGVjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IFwiYWNjb3VudHNcIixcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogeyBlcTogYWRkcmVzcyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF90cmFuc19sdDogeyBnZTogdGhpcy5zeW5jTGFzdFRyYW5zTHQgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBcImJvY1wiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChhY2NvdW50cy5yZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib2MgPSBhY2NvdW50cy5yZXN1bHRbMF0uYm9jO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bmNMYXN0VHJhbnNMdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChib2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkQm9jID0gYm9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBBY2NvdW50RXJyb3IubWlzc2luZ0JPQygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9jID0gKFxuICAgICAgICAgICAgICAgIC8vIFJldHVybnMgQk9DIG9yIG51bGwgaWYgYWNjb3VudCB3YXMgZm91bmQgaW4gREIsIGJ1dCBoYXMgXCJOb3RFeGlzdHNcIiBzdGF0dXNcbiAgICAgICAgICAgICAgICAvLyBUaHJvd3MgaWY6XG4gICAgICAgICAgICAgICAgLy8gIC0gYWNjb3VudCBOT1QgZm91bmQgaW4gREIgKGVyci5jb2RlIDYwMykgXG4gICAgICAgICAgICAgICAgLy8gIC0gc29tZSBuZXR3b3JrIGVycm9yIG9jY3VyZWRcbiAgICAgICAgICAgICAgICB5aWVsZCBuZXQud2FpdF9mb3JfY29sbGVjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IFwiYWNjb3VudHNcIixcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiB7IGlkOiB7IGVxOiB0aGlzLmFkZHJlc3MgfSB9LFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IFwiYm9jXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDEwMDAsXG4gICAgICAgICAgICAgICAgfSkpLnJlc3VsdC5ib2M7XG4gICAgICAgICAgICAgICAgaWYgKGJvYykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZEJvYyA9IGJvYztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgQWNjb3VudEVycm9yLm1pc3NpbmdCT0MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSA2MDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgQWNjb3VudEVycm9yLm1pc3NpbmdCT0MoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcm9wcyBhbGwgY2FjaGVkIGFuZCBsb2NhbCBkYXRhLlxuICAgICAqL1xuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuY2FjaGVkQm9jID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwYXJzZWQgZGF0YSBvZiB0aGUgYWNjb3VudC5cbiAgICAgKi9cbiAgICBnZXRBY2NvdW50KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBib2MgPSB5aWVsZCB0aGlzLmJvYygpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoeWllbGQgdGhpcy5jbGllbnQuYm9jLnBhcnNlX2FjY291bnQoeyBib2MgfSkpLnBhcnNlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IEVSUl9DT0RFUy5BQ0NfTk9UX0VYSVNUUykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjX3R5cGU6IEFjY291bnRUeXBlLm5vbkV4aXN0LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN1YnNjcmliZUFjY291bnQoZmllbGRzLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zdWJzY3JpYmUoXCJhY2NvdW50c1wiLCB7IGlkOiB7IGVxOiB5aWVsZCB0aGlzLmdldEFkZHJlc3MoKSB9IH0sIGZpZWxkcywgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3Vic2NyaWJlVHJhbnNhY3Rpb25zKGZpZWxkcywgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc3Vic2NyaWJlKFwidHJhbnNhY3Rpb25zXCIsIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50X2FkZHI6IHsgZXE6IGFkZHJlc3MgfSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHsgZXE6IDUgfSxcbiAgICAgICAgICAgIH0sIGZpZWxkcywgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3Vic2NyaWJlTWVzc2FnZXMoZmllbGRzLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zdWJzY3JpYmUoXCJtZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiB7IGVxOiA1IH0sXG4gICAgICAgICAgICAgICAgc3JjOiB7IGVxOiBhZGRyZXNzIH0sXG4gICAgICAgICAgICAgICAgT1I6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7IGVxOiA1IH0sXG4gICAgICAgICAgICAgICAgICAgIGRzdDogeyBlcTogYWRkcmVzcyB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LCBmaWVsZHMsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlY29kZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNvcmVfMS5Ub25DbGllbnQuZGVmYXVsdC5hYmkuZGVjb2RlX21lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGFiaTogdGhpcy5hYmksXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVjb2RlTWVzc2FnZUJvZHkoYm9keSwgaXNJbnRlcm5hbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNvcmVfMS5Ub25DbGllbnQuZGVmYXVsdC5hYmkuZGVjb2RlX21lc3NhZ2VfYm9keSh7XG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIGlzX2ludGVybmFsOiBpc0ludGVybmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRCYWxhbmNlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuICh5aWVsZCB0aGlzLmdldEFjY291bnQoKSkuYmFsYW5jZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN1YnNjcmliZShjb2xsZWN0aW9uLCBmaWx0ZXIsIGZpZWxkcywgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZTdWJzY3JpcHRpb24gPSB0aGlzLnN1YnNjcmlwdGlvbnMgJiYgdGhpcy5zdWJzY3JpcHRpb25zLmdldChjb2xsZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChwcmV2U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5zdWJzY3JpcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVsZXRlKGNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY2xpZW50Lm5ldC51bnN1YnNjcmliZShwcmV2U3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB5aWVsZCB0aGlzLmNsaWVudC5uZXQuc3Vic2NyaWJlX2NvbGxlY3Rpb24oe1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogZmllbGRzLFxuICAgICAgICAgICAgfSwgKChwYXJhbXMsIHJlc3BvbnNlVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVR5cGUgPT09IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcihwYXJhbXMucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLnN1YnNjcmlwdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXQoY29sbGVjdGlvbiwgc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZyZWUgYWxsIGludGVybmFsIHJlc291cmNlcyByZWxhdGVkIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAgKiBhbmQgYWxsb2NhdGVkIGluc2lkZSBjb3JlLlxuICAgICAqXG4gICAgICogSXQgaXMgYSBnb29kIHByYWN0aWNlIHRvIGNhbGwgdGhpcyBtZXRob2Qgd2hlbiB5b3UgaGF2ZSBmaW5pc2hlZFxuICAgICAqIHdpdGggdGhpcyBBY2NvdW50IG9iamVjdC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIGluc3RhbmNlIHN0aWxsIGZ1bGx5IG9wZXJhYmxlLlxuICAgICAqIFNvIHlvdSBjYW4gY29udGludWUgdG8gd29yayB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnJlZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zLnZhbHVlcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdWJzY3JpcHRpb24gb2Ygc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNsaWVudC5uZXQudW5zdWJzY3JpYmUoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQWNjb3VudCA9IEFjY291bnQ7XG5BY2NvdW50LmdpdmVyc0J5Q2xpZW50ID0gW107XG5mdW5jdGlvbiBnZXRFbnYobmFtZSkge1xuICAgIGNvbnN0IGdsb2JhbEV2YWwgPSBldmFsO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxFdmFsKGBwcm9jZXNzLmVudi4ke25hbWV9YCk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRHaXZlcktleXMoY2xpZW50KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgZGVmaW5lZFNlY3JldCA9IGdldEVudihcIlRPTl9HSVZFUl9TRUNSRVRcIik7XG4gICAgICAgIGlmIChkZWZpbmVkU2VjcmV0KSB7XG4gICAgICAgICAgICBjb25zdCBkZWZpbmVkS2V5cyA9IHlpZWxkIGNsaWVudC5jcnlwdG8ubmFjbF9zaWduX2tleXBhaXJfZnJvbV9zZWNyZXRfa2V5KHtcbiAgICAgICAgICAgICAgICBzZWNyZXQ6IGRlZmluZWRTZWNyZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlZmluZWRLZXlzLnNlY3JldCA9IGRlZmluZWRLZXlzLnNlY3JldC5zdWJzdHIoMCwgNjQpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmluZWRLZXlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBTcGVsbENoZWNraW5nSW5zcGVjdGlvblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJwdWJsaWNcIjogXCIyYWRhMmU2NWFiOGVlYWIwOTQ5MGUzNTIxNDE1ZjQ1YjZlNDJkZjljNzYwYTYzOWJjZjUzOTU3NTUwYjI1YTE2XCIsXG4gICAgICAgICAgICBcInNlY3JldFwiOiBcIjE3MmFmNTQwZTQzYTUyNDc2M2RkNTNiMjZhMDY2ZDQ3MmE5N2M0ZGUzN2Q1NDk4MTcwNTY0NTEwNjA4MjUwYzNcIixcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRHaXZlckFkZHJlc3MoY2xpZW50LCBrZXlzKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGRlZmluZWRBZGRyZXNzID0gZ2V0RW52KFwiVE9OX0dJVkVSX0FERFJFU1NcIik7XG4gICAgICAgIGlmIChkZWZpbmVkQWRkcmVzcykge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmluZWRBZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoeWllbGQgY2xpZW50LmFiaS5lbmNvZGVfbWVzc2FnZSh7XG4gICAgICAgICAgICBhYmk6ICgwLCBjb3JlXzEuYWJpQ29udHJhY3QpKGV4cG9ydHMuRGVmYXVsdEdpdmVyQ29udHJhY3QuYWJpKSxcbiAgICAgICAgICAgIGRlcGxveV9zZXQ6IHtcbiAgICAgICAgICAgICAgICB0dmM6IChfYSA9IGV4cG9ydHMuRGVmYXVsdEdpdmVyQ29udHJhY3QudHZjKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpZ25lcjogKDAsIGNvcmVfMS5zaWduZXJLZXlzKShrZXlzKSxcbiAgICAgICAgfSkpLmFkZHJlc3M7XG4gICAgfSk7XG59XG4vLyBub2luc3BlY3Rpb24gU3BlbGxDaGVja2luZ0luc3BlY3Rpb25cbmV4cG9ydHMuRGVmYXVsdEdpdmVyQ29udHJhY3QgPSB7XG4gICAgYWJpOiB7XG4gICAgICAgIFwiQUJJIHZlcnNpb25cIjogMixcbiAgICAgICAgaGVhZGVyOiBbXCJ0aW1lXCIsIFwiZXhwaXJlXCJdLFxuICAgICAgICBmdW5jdGlvbnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInNlbmRUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJkZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1aW50MTI4XCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImJvdW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiZ2V0TWVzc2FnZXNcIixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJoYXNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImV4cGlyZUF0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDY0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm1lc3NhZ2VzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlW11cIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInVwZ3JhZGVcIixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJuZXdjb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBldmVudHM6IFtdLFxuICAgIH0sXG4gICAgdHZjOiBcInRlNmNjZ0VDR2dFQUE5c0FBZ0UwQmdFQkFjQUNBZ1BQSUFVREFRSGVCQUFEMENBQVFkZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFJbS93RDBwQ0Fpd0FHUzlLRGhpdTFUV0REMG9Ra0hBUXIwcENEMG9RZ0FBQUlCSUF3S0Fmei9meUh0Uk5BZzEwbkNBWi9ULzlNQTlBWDRhbi80WWZobStHS09HL1FGYmZocWNBR0FRUFFPOHIzWEMvLzRZbkQ0WTNENFpuLzRZZUxUQUFHT0VvRUNBTmNZSVBrQldQaENJUGhsK1JEeXFONGorRUw0UlNCdWtqQnczcnJ5NEdVaDB6L1RIelF4K0NNaEFiN3l1U0g1QUNENFNvRUJBUFFPSUpFeDNyTUxBRTd5NEdiNEFDSDRTaUlCVlFISXl6OVpnUUVBOUVQNGFpTUVYd1RUSHdId0FmaEhicEx5UE40Q0FTQVNEUUlCV0JFT0FRbTQ2Smo4VUE4Qi92aEJibzRTN1VUUTAvL1RBUFFGK0dwLytHSDRadmhpM3RGd2JXOEMrRXFCQVFEMGhwVUIxd3MvZjVOd2NIRGlrU0NPTnlNakkyOENieUxJSXM4TC95SFBDejh4TVFGdklpR2tBMW1BSVBSRGJ3STBJdmhLZ1FFQTlIeVZBZGNMUDMrVGNIQnc0Z0kxTXpIb1h3UElnaEIzUk1maWdoQ0FBQUFBc2M4TEh5RVFBS0p2SWdMTEgvUUF5SUpZWUFBQUFBQUFBQUFBQUFBQUFNOExab0VEbUNMUE1RRzVsbkhQUUNIUEY1Vnh6MEVoemVJZ3lYSDdBRnN3d1ArT0V2aEN5TXYvK0ViUEN3RDRTZ0gwQU1udFZONS8rR2NBeGJrV3ErZi9DQzNSeHQyb21nUWE2VGhBTS9wLyttQWVnTDhOVC84TVB3emZERkhEZm9DdHZ3MU9BREFJSG9IZVY3cmhmLzhNVGg4TWJoOE16LzhNUEZ2ZkNOSmVSbkp1UHd6Y1h3QWFQd2haR1gvL0NObmhZQjhKUUQ2QUdUMnFqLzhNOEFJQklCVVRBZGU3RmUrVFg0UVc2T0V1MUUwTlAvMHdEMEJmaHFmL2hoK0diNFl0NzZRTmNOZjVYVTBkRFRmOS9YREFDVjFOSFEwZ0RmMFNJaUluUEljYzhMQVNMUENnQnp6MEFrenhZaitnS0FhYzlBY3M5QUlNa2krd0JmQmZoS2dRRUE5SWFWQWRjTFAzK1RjSEJ3NHBFZ2dVQUpLT0xmZ2pJZ0c3bi9oS0l3RWhBWUVCQVBSYk1ESDRhdDRpK0VxQkFRRDBmSlVCMXdzL2Y1TndjSERpQWpVek1laGZBMThEK0VMSXkvLzRSczhMQVBoS0FmUUF5ZTFVZi9obkFnRWdGeFlBeDdqa1lZZGZDQzNSd2wyb21ocC8rbUFlZ0w4TlQvOE1Qd3pmREZ2YW1qOElYd2lrRGRKR0RodlhYbHdNdndBZkNGa1pmLzhJMmVGZ0h3bEFQb0FaUGFxZkFlUWZZSVFhSGFQZHFuNEFSaDhJV1JsLy93alo0V0FmQ1VBK2dCazlxby8vRFBBQ0F0b1pHQUF0cjRRc2pMLy9oR3p3c0ErRW9COUFESjdWVDREL0lBZ0FkYWNDSEhBSjBpMEhQWElkY0xBTUFCa0pEaTRDSFhEUitTOGp6aFV4SEFBSkRnd1FNaWdoRC8vLy85dkxHUzhqemdBZkFCK0VkdWt2STgzb1wiLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY291bnQuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@eversdk/appkit/dist/account.js\n");

/***/ }),

/***/ "./node_modules/@eversdk/appkit/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@eversdk/appkit/dist/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./account */ \"./node_modules/@eversdk/appkit/dist/account.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGV2ZXJzZGsvYXBwa2l0L2Rpc3QvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9ub2RlX21vZHVsZXMvQGV2ZXJzZGsvYXBwa2l0L2Rpc3QvaW5kZXguanM/ZDU3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FjY291bnRcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@eversdk/appkit/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@eversdk/core/dist/bin.js":
/*!************************************************!*\
  !*** ./node_modules/@eversdk/core/dist/bin.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CommonBinaryBridge = exports.useLibrary = exports.getBridge = exports.ResponseType = void 0;\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/@eversdk/core/dist/errors.js\");\nvar ResponseType;\n(function (ResponseType) {\n    ResponseType[ResponseType[\"Success\"] = 0] = \"Success\";\n    ResponseType[ResponseType[\"Error\"] = 1] = \"Error\";\n    ResponseType[ResponseType[\"Nop\"] = 2] = \"Nop\";\n    ResponseType[ResponseType[\"AppRequest\"] = 3] = \"AppRequest\";\n    ResponseType[ResponseType[\"AppNotify\"] = 4] = \"AppNotify\";\n    ResponseType[ResponseType[\"Custom\"] = 100] = \"Custom\";\n})(ResponseType = exports.ResponseType || (exports.ResponseType = {}));\nlet bridge = undefined;\nfunction getBridge() {\n    if (!bridge) {\n        throw new errors_1.TonClientError(1, \"TON Client binary bridge isn't set.\");\n    }\n    return bridge;\n}\nexports.getBridge = getBridge;\nfunction useLibrary(loader) {\n    if (\"createContext\" in loader) {\n        bridge = loader;\n    }\n    else {\n        bridge = new CommonBinaryBridge(loader);\n    }\n}\nexports.useLibrary = useLibrary;\nclass BinaryLibraryAdapter {\n    constructor(library) {\n        this.library = library;\n    }\n    setResponseParamsHandler(handler) {\n        if (handler === undefined) {\n            this.library.setResponseHandler(undefined);\n        }\n        else {\n            this.library.setResponseHandler((requestId, paramsJson, responseType, finished) => handler(requestId, paramsJson !== \"\" ? JSON.parse(paramsJson) : undefined, responseType, finished));\n        }\n    }\n    sendRequestParams(context, requestId, functionName, functionParams) {\n        const paramsJson = (functionParams === undefined) || (functionParams === null)\n            ? \"\"\n            : JSON.stringify(functionParams, (_, value) => typeof value === \"bigint\"\n                ? (value < Number.MAX_SAFE_INTEGER && value > Number.MIN_SAFE_INTEGER\n                    ? Number(value)\n                    : value.toString())\n                : value);\n        this.library.sendRequest(context, requestId, functionName, paramsJson);\n    }\n    createContext(configJson) {\n        return this.library.createContext(configJson);\n    }\n    destroyContext(context) {\n        this.library.destroyContext(context);\n    }\n}\nclass CommonBinaryBridge {\n    constructor(loader) {\n        this.loading = undefined;\n        this.loadError = undefined;\n        this.library = undefined;\n        this.requests = new Map();\n        this.nextRequestId = 1;\n        this.contextCount = 0;\n        this.responseHandlerAssigned = false;\n        this.loading = [];\n        loader().then((library) => {\n            const saveLoading = this.loading;\n            this.loading = undefined;\n            let libraryWithParams = \"setResponseParamsHandler\" in library\n                ? library\n                : new BinaryLibraryAdapter(library);\n            this.library = libraryWithParams;\n            saveLoading === null || saveLoading === void 0 ? void 0 : saveLoading.forEach(x => x.resolve(libraryWithParams));\n        }, (reason) => {\n            const saveLoading = this.loading;\n            this.loading = undefined;\n            this.loadError = reason !== null && reason !== void 0 ? reason : undefined;\n            saveLoading === null || saveLoading === void 0 ? void 0 : saveLoading.forEach(x => x.reject(reason));\n        });\n    }\n    checkResponseHandler() {\n        var _a, _b;\n        const mustBeAssigned = (this.contextCount > 0) || (this.requests.size > 0);\n        if (this.responseHandlerAssigned !== mustBeAssigned) {\n            if (mustBeAssigned) {\n                (_a = this.library) === null || _a === void 0 ? void 0 : _a.setResponseParamsHandler((requestId, params, responseType, finished) => this.handleLibraryResponse(requestId, params, responseType, finished));\n            }\n            else {\n                (_b = this.library) === null || _b === void 0 ? void 0 : _b.setResponseParamsHandler();\n            }\n            this.responseHandlerAssigned = mustBeAssigned;\n        }\n    }\n    createContext(config) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const lib = this.library || (yield this.loadRequired());\n            this.contextCount += 1;\n            return CommonBinaryBridge.parseResult(yield lib.createContext(JSON.stringify(config)));\n        });\n    }\n    destroyContext(context) {\n        var _a;\n        this.contextCount = Math.max(this.contextCount - 1, 0);\n        this.checkResponseHandler();\n        (_a = this.library) === null || _a === void 0 ? void 0 : _a.destroyContext(context);\n    }\n    request(context, functionName, functionParams, responseHandler) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const lib = (_a = this.library) !== null && _a !== void 0 ? _a : yield this.loadRequired();\n            return new Promise((resolve, reject) => {\n                const request = {\n                    resolve,\n                    reject,\n                    responseHandler,\n                };\n                const requestId = this.generateRequestId();\n                this.requests.set(requestId, request);\n                this.checkResponseHandler();\n                lib.sendRequestParams(context, requestId, functionName, functionParams);\n            });\n        });\n    }\n    loadRequired() {\n        if (this.library !== undefined) {\n            return Promise.resolve(this.library);\n        }\n        if (this.loadError !== undefined) {\n            return Promise.reject(this.loadError);\n        }\n        if (this.loading === undefined) {\n            return Promise.reject(new errors_1.TonClientError(1, \"TON Client binary library isn't set.\"));\n        }\n        return new Promise((resolve, reject) => {\n            var _a;\n            (_a = this.loading) === null || _a === void 0 ? void 0 : _a.push({\n                resolve,\n                reject,\n            });\n        });\n    }\n    generateRequestId() {\n        const id = this.nextRequestId;\n        do {\n            this.nextRequestId += 1;\n            if (this.nextRequestId >= Number.MAX_SAFE_INTEGER) {\n                this.nextRequestId = 1;\n            }\n        } while (this.requests.has(this.nextRequestId));\n        return id;\n    }\n    handleLibraryResponse(requestId, params, responseType, finished) {\n        const request = this.requests.get(requestId);\n        if (!request) {\n            return;\n        }\n        if (finished) {\n            this.requests.delete(requestId);\n            this.checkResponseHandler();\n        }\n        switch (responseType) {\n            case ResponseType.Success:\n                request.resolve(params);\n                break;\n            case ResponseType.Error:\n                request.reject(params);\n                break;\n            default:\n                const isAppObjectOrCustom = responseType === ResponseType.AppNotify\n                    || responseType === ResponseType.AppRequest\n                    || responseType >= ResponseType.Custom;\n                if (isAppObjectOrCustom && request.responseHandler) {\n                    request.responseHandler(params, responseType);\n                }\n        }\n    }\n    static parseResult(resultJson) {\n        const result = JSON.parse(resultJson);\n        if (\"error\" in result) {\n            throw new errors_1.TonClientError(result.error.code, result.error.message, result.error.data);\n        }\n        return result.result;\n    }\n}\nexports.CommonBinaryBridge = CommonBinaryBridge;\n//# sourceMappingURL=bin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGV2ZXJzZGsvY29yZS9kaXN0L2Jpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9AZXZlcnNkay9jb3JlL2Rpc3QvYmluLmpzPzBkODgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbW9uQmluYXJ5QnJpZGdlID0gZXhwb3J0cy51c2VMaWJyYXJ5ID0gZXhwb3J0cy5nZXRCcmlkZ2UgPSBleHBvcnRzLlJlc3BvbnNlVHlwZSA9IHZvaWQgMDtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIFJlc3BvbnNlVHlwZTtcbihmdW5jdGlvbiAoUmVzcG9uc2VUeXBlKSB7XG4gICAgUmVzcG9uc2VUeXBlW1Jlc3BvbnNlVHlwZVtcIlN1Y2Nlc3NcIl0gPSAwXSA9IFwiU3VjY2Vzc1wiO1xuICAgIFJlc3BvbnNlVHlwZVtSZXNwb25zZVR5cGVbXCJFcnJvclwiXSA9IDFdID0gXCJFcnJvclwiO1xuICAgIFJlc3BvbnNlVHlwZVtSZXNwb25zZVR5cGVbXCJOb3BcIl0gPSAyXSA9IFwiTm9wXCI7XG4gICAgUmVzcG9uc2VUeXBlW1Jlc3BvbnNlVHlwZVtcIkFwcFJlcXVlc3RcIl0gPSAzXSA9IFwiQXBwUmVxdWVzdFwiO1xuICAgIFJlc3BvbnNlVHlwZVtSZXNwb25zZVR5cGVbXCJBcHBOb3RpZnlcIl0gPSA0XSA9IFwiQXBwTm90aWZ5XCI7XG4gICAgUmVzcG9uc2VUeXBlW1Jlc3BvbnNlVHlwZVtcIkN1c3RvbVwiXSA9IDEwMF0gPSBcIkN1c3RvbVwiO1xufSkoUmVzcG9uc2VUeXBlID0gZXhwb3J0cy5SZXNwb25zZVR5cGUgfHwgKGV4cG9ydHMuUmVzcG9uc2VUeXBlID0ge30pKTtcbmxldCBicmlkZ2UgPSB1bmRlZmluZWQ7XG5mdW5jdGlvbiBnZXRCcmlkZ2UoKSB7XG4gICAgaWYgKCFicmlkZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlRvbkNsaWVudEVycm9yKDEsIFwiVE9OIENsaWVudCBiaW5hcnkgYnJpZGdlIGlzbid0IHNldC5cIik7XG4gICAgfVxuICAgIHJldHVybiBicmlkZ2U7XG59XG5leHBvcnRzLmdldEJyaWRnZSA9IGdldEJyaWRnZTtcbmZ1bmN0aW9uIHVzZUxpYnJhcnkobG9hZGVyKSB7XG4gICAgaWYgKFwiY3JlYXRlQ29udGV4dFwiIGluIGxvYWRlcikge1xuICAgICAgICBicmlkZ2UgPSBsb2FkZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBicmlkZ2UgPSBuZXcgQ29tbW9uQmluYXJ5QnJpZGdlKGxvYWRlcik7XG4gICAgfVxufVxuZXhwb3J0cy51c2VMaWJyYXJ5ID0gdXNlTGlicmFyeTtcbmNsYXNzIEJpbmFyeUxpYnJhcnlBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihsaWJyYXJ5KSB7XG4gICAgICAgIHRoaXMubGlicmFyeSA9IGxpYnJhcnk7XG4gICAgfVxuICAgIHNldFJlc3BvbnNlUGFyYW1zSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubGlicmFyeS5zZXRSZXNwb25zZUhhbmRsZXIodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGlicmFyeS5zZXRSZXNwb25zZUhhbmRsZXIoKHJlcXVlc3RJZCwgcGFyYW1zSnNvbiwgcmVzcG9uc2VUeXBlLCBmaW5pc2hlZCkgPT4gaGFuZGxlcihyZXF1ZXN0SWQsIHBhcmFtc0pzb24gIT09IFwiXCIgPyBKU09OLnBhcnNlKHBhcmFtc0pzb24pIDogdW5kZWZpbmVkLCByZXNwb25zZVR5cGUsIGZpbmlzaGVkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZFJlcXVlc3RQYXJhbXMoY29udGV4dCwgcmVxdWVzdElkLCBmdW5jdGlvbk5hbWUsIGZ1bmN0aW9uUGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtc0pzb24gPSAoZnVuY3Rpb25QYXJhbXMgPT09IHVuZGVmaW5lZCkgfHwgKGZ1bmN0aW9uUGFyYW1zID09PSBudWxsKVxuICAgICAgICAgICAgPyBcIlwiXG4gICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KGZ1bmN0aW9uUGFyYW1zLCAoXywgdmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIlxuICAgICAgICAgICAgICAgID8gKHZhbHVlIDwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgJiYgdmFsdWUgPiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxuICAgICAgICAgICAgICAgICAgICA/IE51bWJlcih2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZS50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgIDogdmFsdWUpO1xuICAgICAgICB0aGlzLmxpYnJhcnkuc2VuZFJlcXVlc3QoY29udGV4dCwgcmVxdWVzdElkLCBmdW5jdGlvbk5hbWUsIHBhcmFtc0pzb24pO1xuICAgIH1cbiAgICBjcmVhdGVDb250ZXh0KGNvbmZpZ0pzb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlicmFyeS5jcmVhdGVDb250ZXh0KGNvbmZpZ0pzb24pO1xuICAgIH1cbiAgICBkZXN0cm95Q29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMubGlicmFyeS5kZXN0cm95Q29udGV4dChjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBDb21tb25CaW5hcnlCcmlkZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvYWRlcikge1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubG9hZEVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxpYnJhcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVxdWVzdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubmV4dFJlcXVlc3RJZCA9IDE7XG4gICAgICAgIHRoaXMuY29udGV4dENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5yZXNwb25zZUhhbmRsZXJBc3NpZ25lZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBbXTtcbiAgICAgICAgbG9hZGVyKCkudGhlbigobGlicmFyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2F2ZUxvYWRpbmcgPSB0aGlzLmxvYWRpbmc7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgbGlicmFyeVdpdGhQYXJhbXMgPSBcInNldFJlc3BvbnNlUGFyYW1zSGFuZGxlclwiIGluIGxpYnJhcnlcbiAgICAgICAgICAgICAgICA/IGxpYnJhcnlcbiAgICAgICAgICAgICAgICA6IG5ldyBCaW5hcnlMaWJyYXJ5QWRhcHRlcihsaWJyYXJ5KTtcbiAgICAgICAgICAgIHRoaXMubGlicmFyeSA9IGxpYnJhcnlXaXRoUGFyYW1zO1xuICAgICAgICAgICAgc2F2ZUxvYWRpbmcgPT09IG51bGwgfHwgc2F2ZUxvYWRpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNhdmVMb2FkaW5nLmZvckVhY2goeCA9PiB4LnJlc29sdmUobGlicmFyeVdpdGhQYXJhbXMpKTtcbiAgICAgICAgfSwgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2F2ZUxvYWRpbmcgPSB0aGlzLmxvYWRpbmc7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmxvYWRFcnJvciA9IHJlYXNvbiAhPT0gbnVsbCAmJiByZWFzb24gIT09IHZvaWQgMCA/IHJlYXNvbiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHNhdmVMb2FkaW5nID09PSBudWxsIHx8IHNhdmVMb2FkaW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzYXZlTG9hZGluZy5mb3JFYWNoKHggPT4geC5yZWplY3QocmVhc29uKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjaGVja1Jlc3BvbnNlSGFuZGxlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbXVzdEJlQXNzaWduZWQgPSAodGhpcy5jb250ZXh0Q291bnQgPiAwKSB8fCAodGhpcy5yZXF1ZXN0cy5zaXplID4gMCk7XG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNlSGFuZGxlckFzc2lnbmVkICE9PSBtdXN0QmVBc3NpZ25lZCkge1xuICAgICAgICAgICAgaWYgKG11c3RCZUFzc2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5saWJyYXJ5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0UmVzcG9uc2VQYXJhbXNIYW5kbGVyKChyZXF1ZXN0SWQsIHBhcmFtcywgcmVzcG9uc2VUeXBlLCBmaW5pc2hlZCkgPT4gdGhpcy5oYW5kbGVMaWJyYXJ5UmVzcG9uc2UocmVxdWVzdElkLCBwYXJhbXMsIHJlc3BvbnNlVHlwZSwgZmluaXNoZWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMubGlicmFyeSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNldFJlc3BvbnNlUGFyYW1zSGFuZGxlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZUhhbmRsZXJBc3NpZ25lZCA9IG11c3RCZUFzc2lnbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUNvbnRleHQoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBsaWIgPSB0aGlzLmxpYnJhcnkgfHwgKHlpZWxkIHRoaXMubG9hZFJlcXVpcmVkKCkpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0Q291bnQgKz0gMTtcbiAgICAgICAgICAgIHJldHVybiBDb21tb25CaW5hcnlCcmlkZ2UucGFyc2VSZXN1bHQoeWllbGQgbGliLmNyZWF0ZUNvbnRleHQoSlNPTi5zdHJpbmdpZnkoY29uZmlnKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzdHJveUNvbnRleHQoY29udGV4dCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuY29udGV4dENvdW50ID0gTWF0aC5tYXgodGhpcy5jb250ZXh0Q291bnQgLSAxLCAwKTtcbiAgICAgICAgdGhpcy5jaGVja1Jlc3BvbnNlSGFuZGxlcigpO1xuICAgICAgICAoX2EgPSB0aGlzLmxpYnJhcnkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95Q29udGV4dChjb250ZXh0KTtcbiAgICB9XG4gICAgcmVxdWVzdChjb250ZXh0LCBmdW5jdGlvbk5hbWUsIGZ1bmN0aW9uUGFyYW1zLCByZXNwb25zZUhhbmRsZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbGliID0gKF9hID0gdGhpcy5saWJyYXJ5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB5aWVsZCB0aGlzLmxvYWRSZXF1aXJlZCgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICByZWplY3QsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGFuZGxlcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHRoaXMuZ2VuZXJhdGVSZXF1ZXN0SWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RzLnNldChyZXF1ZXN0SWQsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tSZXNwb25zZUhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICBsaWIuc2VuZFJlcXVlc3RQYXJhbXMoY29udGV4dCwgcmVxdWVzdElkLCBmdW5jdGlvbk5hbWUsIGZ1bmN0aW9uUGFyYW1zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbG9hZFJlcXVpcmVkKCkge1xuICAgICAgICBpZiAodGhpcy5saWJyYXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5saWJyYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2FkRXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMubG9hZEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2FkaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgZXJyb3JzXzEuVG9uQ2xpZW50RXJyb3IoMSwgXCJUT04gQ2xpZW50IGJpbmFyeSBsaWJyYXJ5IGlzbid0IHNldC5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmxvYWRpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wdXNoKHtcbiAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2VuZXJhdGVSZXF1ZXN0SWQoKSB7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5uZXh0UmVxdWVzdElkO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB0aGlzLm5leHRSZXF1ZXN0SWQgKz0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRSZXF1ZXN0SWQgPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRSZXF1ZXN0SWQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICh0aGlzLnJlcXVlc3RzLmhhcyh0aGlzLm5leHRSZXF1ZXN0SWQpKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICBoYW5kbGVMaWJyYXJ5UmVzcG9uc2UocmVxdWVzdElkLCBwYXJhbXMsIHJlc3BvbnNlVHlwZSwgZmluaXNoZWQpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMucmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXNwb25zZUhhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBSZXNwb25zZVR5cGUuU3VjY2VzczpcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc29sdmUocGFyYW1zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUmVzcG9uc2VUeXBlLkVycm9yOlxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVqZWN0KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXBwT2JqZWN0T3JDdXN0b20gPSByZXNwb25zZVR5cGUgPT09IFJlc3BvbnNlVHlwZS5BcHBOb3RpZnlcbiAgICAgICAgICAgICAgICAgICAgfHwgcmVzcG9uc2VUeXBlID09PSBSZXNwb25zZVR5cGUuQXBwUmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICB8fCByZXNwb25zZVR5cGUgPj0gUmVzcG9uc2VUeXBlLkN1c3RvbTtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcHBPYmplY3RPckN1c3RvbSAmJiByZXF1ZXN0LnJlc3BvbnNlSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlSGFuZGxlcihwYXJhbXMsIHJlc3BvbnNlVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZVJlc3VsdChyZXN1bHRKc29uKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UocmVzdWx0SnNvbik7XG4gICAgICAgIGlmIChcImVycm9yXCIgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVG9uQ2xpZW50RXJyb3IocmVzdWx0LmVycm9yLmNvZGUsIHJlc3VsdC5lcnJvci5tZXNzYWdlLCByZXN1bHQuZXJyb3IuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5Db21tb25CaW5hcnlCcmlkZ2UgPSBDb21tb25CaW5hcnlCcmlkZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW4uanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@eversdk/core/dist/bin.js\n");

/***/ }),

/***/ "./node_modules/@eversdk/core/dist/client.js":
/*!***************************************************!*\
  !*** ./node_modules/@eversdk/core/dist/client.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright 2018-2020 TON Labs LTD.\n *\n * Licensed under the SOFTWARE EVALUATION License (the \"License\"); you may not use\n * this file except in compliance with the License.\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific TON DEV software governing permissions and\n * limitations under the License.\n *\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TonClient = void 0;\nconst modules_1 = __webpack_require__(/*! ./modules */ \"./node_modules/@eversdk/core/dist/modules.js\");\nconst bin_1 = __webpack_require__(/*! ./bin */ \"./node_modules/@eversdk/core/dist/bin.js\");\nclass TonClient {\n    constructor(config) {\n        this.context = undefined;\n        this.contextCreation = undefined;\n        this.contextError = undefined;\n        this.config = config !== null && config !== void 0 ? config : {};\n        this.client = new modules_1.ClientModule(this);\n        this.crypto = new modules_1.CryptoModule(this);\n        this.abi = new modules_1.AbiModule(this);\n        this.boc = new modules_1.BocModule(this);\n        this.processing = new modules_1.ProcessingModule(this);\n        this.utils = new modules_1.UtilsModule(this);\n        this.net = new modules_1.NetModule(this);\n        this.tvm = new modules_1.TvmModule(this);\n        this.proofs = new modules_1.ProofsModule(this);\n    }\n    static set default(client) {\n        this._default = client;\n    }\n    static get default() {\n        if (this._default === null) {\n            this._default = new TonClient(this._defaultConfig);\n        }\n        return this._default;\n    }\n    static set defaultConfig(config) {\n        this._defaultConfig = config;\n    }\n    static get defaultConfig() {\n        return this._defaultConfig;\n    }\n    static useBinaryLibrary(loader) {\n        (0, bin_1.useLibrary)(loader);\n    }\n    static toKey(d) {\n        return toHex(d, 256);\n    }\n    static toHash64(d) {\n        return toHex(d, 64);\n    }\n    static toHash128(d) {\n        return toHex(d, 128);\n    }\n    static toHash256(d) {\n        return toHex(d, 256);\n    }\n    static toHash512(d) {\n        return toHex(d, 512);\n    }\n    static toHex(dec, bits = 0) {\n        return toHex(dec, bits);\n    }\n    close() {\n        const context = this.context;\n        if (context !== undefined) {\n            this.context = undefined;\n            (0, bin_1.getBridge)().destroyContext(context);\n        }\n    }\n    resolveError(functionName, params, err) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (err.code !== 23 || !((_a = err.data) === null || _a === void 0 ? void 0 : _a.suggest_use_helper_for)) {\n                return err;\n            }\n            try {\n                const [modName, funcName] = functionName.split(\".\");\n                const api = (yield this.client.get_api_reference()).api;\n                const allTypesArray = api.modules.reduce((accumulator, element) => accumulator.concat(element.types), []);\n                const allTypesDict = {};\n                allTypesArray.forEach((element) => allTypesDict[element.name] = element);\n                const module = api.modules.find((x) => x.name === modName);\n                const func = module.functions.find((x) => x.name === funcName);\n                const param = func.params[1];\n                // If there is only context param (or AppObject second param), there is nothing to analyze\n                if (!param || param.generic_name == \"AppObject\") {\n                    return err;\n                }\n                const paramTypeInfo = allTypesDict[param.ref_name];\n                walkParameters(paramTypeInfo, params, \"\");\n                function walkParameters(valueTypeInfo, value, path) {\n                    switch (valueTypeInfo.type) {\n                        case \"Array\":\n                            if (Array.isArray(value)) {\n                                value.forEach(v => walkParameters(valueTypeInfo.array_item, v, `${path}[i]`));\n                            }\n                            break;\n                        case \"Struct\":\n                            valueTypeInfo.struct_fields.forEach((sf) => walkParameters(sf, value[sf.name], path ? `${path}.${sf.name}` : sf.name));\n                            break;\n                        case \"Optional\":\n                            if (value) {\n                                walkParameters(valueTypeInfo.optional_inner, value, path);\n                            }\n                            break;\n                        case \"Ref\":\n                            if (valueTypeInfo.ref_name != \"Value\" &&\n                                valueTypeInfo.ref_name != \"API\" &&\n                                valueTypeInfo.ref_name != \"AbiParam\") {\n                                walkParameters(allTypesDict[valueTypeInfo.ref_name], value, path);\n                            }\n                            break;\n                        case \"EnumOfTypes\":\n                            if (valueTypeInfo.enum_types.some((et) => et.name == value.type)) {\n                                return;\n                            }\n                            let parameterName = valueTypeInfo.name.toLowerCase();\n                            let helperFunctions = [];\n                            valueTypeInfo.enum_types.forEach((et) => helperFunctions.push(parameterName + et.name));\n                            err.message = `Consider using one of the helper methods (${helperFunctions.join(\", \")}) for the \\\"${path}\\\" parameter\\n` + err.message;\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n            catch (e) {\n                err.message = (_b = e.message) !== null && _b !== void 0 ? _b : `${e}`;\n            }\n            return err;\n        });\n    }\n    contextRequired() {\n        if (this.context !== undefined) {\n            return Promise.resolve(this.context);\n        }\n        if (this.contextError !== undefined) {\n            return Promise.reject(this.contextError);\n        }\n        if (this.contextCreation === undefined) {\n            this.contextCreation = [];\n            (0, bin_1.getBridge)().createContext(this.config).then((context) => {\n                const creation = this.contextCreation;\n                this.contextCreation = undefined;\n                this.context = context;\n                creation === null || creation === void 0 ? void 0 : creation.forEach(x => x.resolve(context));\n            }, (reason) => {\n                const creation = this.contextCreation;\n                this.contextCreation = undefined;\n                this.contextError = reason !== null && reason !== void 0 ? reason : undefined;\n                creation === null || creation === void 0 ? void 0 : creation.forEach(x => x.reject(reason));\n            });\n        }\n        return new Promise((resolve, reject) => {\n            var _a;\n            (_a = this.contextCreation) === null || _a === void 0 ? void 0 : _a.push({\n                resolve,\n                reject,\n            });\n        });\n    }\n    request(functionName, functionParams, responseHandler) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const context = (_a = this.context) !== null && _a !== void 0 ? _a : yield this.contextRequired();\n            return (0, bin_1.getBridge)()\n                .request(context, functionName, functionParams, responseHandler !== null && responseHandler !== void 0 ? responseHandler : (() => {\n            }))\n                .catch((reason) => __awaiter(this, void 0, void 0, function* () {\n                throw yield this.resolveError(functionName, functionParams, reason);\n            }));\n        });\n    }\n    resolve_app_request(app_request_id, result) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (app_request_id) {\n                yield this.client.resolve_app_request({\n                    app_request_id,\n                    result: {\n                        type: \"Ok\",\n                        result,\n                    },\n                });\n            }\n        });\n    }\n    reject_app_request(app_request_id, error) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (app_request_id) {\n                yield this.client.resolve_app_request({\n                    app_request_id,\n                    result: {\n                        type: \"Error\",\n                        text: error.message,\n                    },\n                });\n            }\n        });\n    }\n}\nexports.TonClient = TonClient;\nTonClient._defaultConfig = {};\nTonClient._default = null;\n// Converts value to hex\nfunction toHex(value, bits) {\n    let hex;\n    if (typeof value === \"number\" || typeof value === \"bigint\") {\n        hex = value.toString(16);\n    }\n    else if (typeof value === \"string\") {\n        if (value.startsWith(\"0x\")) {\n            hex = value.substring(2);\n        }\n        else {\n            hex = decToHex(value);\n        }\n    }\n    else {\n        hex = value.toString();\n    }\n    let len = bits / 4;\n    while (hex.length > len && hex.startsWith(\"0\")) {\n        hex = hex.substring(1);\n    }\n    return hex.padStart(len, \"0\");\n}\nfunction decToHex(dec) {\n    var _a;\n    let bigNum = [];\n    for (let i = 0; i < dec.length; i += 1) {\n        const d = ((_a = dec.codePointAt(i)) !== null && _a !== void 0 ? _a : 0) - 48;\n        const mul8 = shl(bigNum, 3);\n        const mul2 = shl(bigNum, 1);\n        const mul10 = add(mul8, mul2);\n        bigNum = add(mul10, [d]);\n    }\n    let hex = \"\";\n    for (let i = bigNum.length - 1; i >= 0; i -= 1) {\n        hex += bigNum[i].toString(16).padStart(4, \"0\");\n    }\n    return hex;\n}\nfunction shl(bigNum, bits) {\n    let rest = 0;\n    const result = [];\n    for (let i = 0; i < bigNum.length; i += 1) {\n        let v = (bigNum[i] << bits) + rest;\n        result.push(v & 0xFFFF);\n        rest = (v >> 16) & 0xFFFF;\n    }\n    if (rest > 0) {\n        result.push(rest);\n    }\n    return result;\n}\nfunction add(a, b) {\n    let rest = 0;\n    const result = [];\n    const len = Math.max(a.length, b.length);\n    for (let i = 0; i < len; i += 1) {\n        let v = (i < a.length ? a[i] : 0) + (i < b.length ? b[i] : 0) + rest;\n        result.push(v & 0xFFFF);\n        rest = (v >> 16) & 0xFFFF;\n    }\n    if (rest > 0) {\n        result.push(rest);\n    }\n    return result;\n}\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGV2ZXJzZGsvY29yZS9kaXN0L2NsaWVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9AZXZlcnNkay9jb3JlL2Rpc3QvY2xpZW50LmpzP2JmODYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTgtMjAyMCBUT04gTGFicyBMVEQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIFNPRlRXQVJFIEVWQUxVQVRJT04gTGljZW5zZSAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXG4gKiB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIFRPTiBERVYgc29mdHdhcmUgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVG9uQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgbW9kdWxlc18xID0gcmVxdWlyZShcIi4vbW9kdWxlc1wiKTtcbmNvbnN0IGJpbl8xID0gcmVxdWlyZShcIi4vYmluXCIpO1xuY2xhc3MgVG9uQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbnRleHRDcmVhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jb250ZXh0RXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnICE9PSBudWxsICYmIGNvbmZpZyAhPT0gdm9pZCAwID8gY29uZmlnIDoge307XG4gICAgICAgIHRoaXMuY2xpZW50ID0gbmV3IG1vZHVsZXNfMS5DbGllbnRNb2R1bGUodGhpcyk7XG4gICAgICAgIHRoaXMuY3J5cHRvID0gbmV3IG1vZHVsZXNfMS5DcnlwdG9Nb2R1bGUodGhpcyk7XG4gICAgICAgIHRoaXMuYWJpID0gbmV3IG1vZHVsZXNfMS5BYmlNb2R1bGUodGhpcyk7XG4gICAgICAgIHRoaXMuYm9jID0gbmV3IG1vZHVsZXNfMS5Cb2NNb2R1bGUodGhpcyk7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZyA9IG5ldyBtb2R1bGVzXzEuUHJvY2Vzc2luZ01vZHVsZSh0aGlzKTtcbiAgICAgICAgdGhpcy51dGlscyA9IG5ldyBtb2R1bGVzXzEuVXRpbHNNb2R1bGUodGhpcyk7XG4gICAgICAgIHRoaXMubmV0ID0gbmV3IG1vZHVsZXNfMS5OZXRNb2R1bGUodGhpcyk7XG4gICAgICAgIHRoaXMudHZtID0gbmV3IG1vZHVsZXNfMS5Udm1Nb2R1bGUodGhpcyk7XG4gICAgICAgIHRoaXMucHJvb2ZzID0gbmV3IG1vZHVsZXNfMS5Qcm9vZnNNb2R1bGUodGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBzZXQgZGVmYXVsdChjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdCA9IGNsaWVudDtcbiAgICB9XG4gICAgc3RhdGljIGdldCBkZWZhdWx0KCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmYXVsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdCA9IG5ldyBUb25DbGllbnQodGhpcy5fZGVmYXVsdENvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBzZXQgZGVmYXVsdENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdENvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgc3RhdGljIGdldCBkZWZhdWx0Q29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdENvbmZpZztcbiAgICB9XG4gICAgc3RhdGljIHVzZUJpbmFyeUxpYnJhcnkobG9hZGVyKSB7XG4gICAgICAgICgwLCBiaW5fMS51c2VMaWJyYXJ5KShsb2FkZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9LZXkoZCkge1xuICAgICAgICByZXR1cm4gdG9IZXgoZCwgMjU2KTtcbiAgICB9XG4gICAgc3RhdGljIHRvSGFzaDY0KGQpIHtcbiAgICAgICAgcmV0dXJuIHRvSGV4KGQsIDY0KTtcbiAgICB9XG4gICAgc3RhdGljIHRvSGFzaDEyOChkKSB7XG4gICAgICAgIHJldHVybiB0b0hleChkLCAxMjgpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9IYXNoMjU2KGQpIHtcbiAgICAgICAgcmV0dXJuIHRvSGV4KGQsIDI1Nik7XG4gICAgfVxuICAgIHN0YXRpYyB0b0hhc2g1MTIoZCkge1xuICAgICAgICByZXR1cm4gdG9IZXgoZCwgNTEyKTtcbiAgICB9XG4gICAgc3RhdGljIHRvSGV4KGRlYywgYml0cyA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRvSGV4KGRlYywgYml0cyk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAoMCwgYmluXzEuZ2V0QnJpZGdlKSgpLmRlc3Ryb3lDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc29sdmVFcnJvcihmdW5jdGlvbk5hbWUsIHBhcmFtcywgZXJyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09IDIzIHx8ICEoKF9hID0gZXJyLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWdnZXN0X3VzZV9oZWxwZXJfZm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFttb2ROYW1lLCBmdW5jTmFtZV0gPSBmdW5jdGlvbk5hbWUuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwaSA9ICh5aWVsZCB0aGlzLmNsaWVudC5nZXRfYXBpX3JlZmVyZW5jZSgpKS5hcGk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsVHlwZXNBcnJheSA9IGFwaS5tb2R1bGVzLnJlZHVjZSgoYWNjdW11bGF0b3IsIGVsZW1lbnQpID0+IGFjY3VtdWxhdG9yLmNvbmNhdChlbGVtZW50LnR5cGVzKSwgW10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbFR5cGVzRGljdCA9IHt9O1xuICAgICAgICAgICAgICAgIGFsbFR5cGVzQXJyYXkuZm9yRWFjaCgoZWxlbWVudCkgPT4gYWxsVHlwZXNEaWN0W2VsZW1lbnQubmFtZV0gPSBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2R1bGUgPSBhcGkubW9kdWxlcy5maW5kKCh4KSA9PiB4Lm5hbWUgPT09IG1vZE5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmMgPSBtb2R1bGUuZnVuY3Rpb25zLmZpbmQoKHgpID0+IHgubmFtZSA9PT0gZnVuY05hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gZnVuYy5wYXJhbXNbMV07XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgb25seSBjb250ZXh0IHBhcmFtIChvciBBcHBPYmplY3Qgc2Vjb25kIHBhcmFtKSwgdGhlcmUgaXMgbm90aGluZyB0byBhbmFseXplXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbSB8fCBwYXJhbS5nZW5lcmljX25hbWUgPT0gXCJBcHBPYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbVR5cGVJbmZvID0gYWxsVHlwZXNEaWN0W3BhcmFtLnJlZl9uYW1lXTtcbiAgICAgICAgICAgICAgICB3YWxrUGFyYW1ldGVycyhwYXJhbVR5cGVJbmZvLCBwYXJhbXMsIFwiXCIpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdhbGtQYXJhbWV0ZXJzKHZhbHVlVHlwZUluZm8sIHZhbHVlLCBwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWVUeXBlSW5mby50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCh2ID0+IHdhbGtQYXJhbWV0ZXJzKHZhbHVlVHlwZUluZm8uYXJyYXlfaXRlbSwgdiwgYCR7cGF0aH1baV1gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlN0cnVjdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlVHlwZUluZm8uc3RydWN0X2ZpZWxkcy5mb3JFYWNoKChzZikgPT4gd2Fsa1BhcmFtZXRlcnMoc2YsIHZhbHVlW3NmLm5hbWVdLCBwYXRoID8gYCR7cGF0aH0uJHtzZi5uYW1lfWAgOiBzZi5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiT3B0aW9uYWxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Fsa1BhcmFtZXRlcnModmFsdWVUeXBlSW5mby5vcHRpb25hbF9pbm5lciwgdmFsdWUsIHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJSZWZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVUeXBlSW5mby5yZWZfbmFtZSAhPSBcIlZhbHVlXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVUeXBlSW5mby5yZWZfbmFtZSAhPSBcIkFQSVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlVHlwZUluZm8ucmVmX25hbWUgIT0gXCJBYmlQYXJhbVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGtQYXJhbWV0ZXJzKGFsbFR5cGVzRGljdFt2YWx1ZVR5cGVJbmZvLnJlZl9uYW1lXSwgdmFsdWUsIHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJFbnVtT2ZUeXBlc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVR5cGVJbmZvLmVudW1fdHlwZXMuc29tZSgoZXQpID0+IGV0Lm5hbWUgPT0gdmFsdWUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFyYW1ldGVyTmFtZSA9IHZhbHVlVHlwZUluZm8ubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBoZWxwZXJGdW5jdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVR5cGVJbmZvLmVudW1fdHlwZXMuZm9yRWFjaCgoZXQpID0+IGhlbHBlckZ1bmN0aW9ucy5wdXNoKHBhcmFtZXRlck5hbWUgKyBldC5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgQ29uc2lkZXIgdXNpbmcgb25lIG9mIHRoZSBoZWxwZXIgbWV0aG9kcyAoJHtoZWxwZXJGdW5jdGlvbnMuam9pbihcIiwgXCIpfSkgZm9yIHRoZSBcXFwiJHtwYXRofVxcXCIgcGFyYW1ldGVyXFxuYCArIGVyci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSAoX2IgPSBlLm1lc3NhZ2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGAke2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb250ZXh0UmVxdWlyZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRFcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5jb250ZXh0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRDcmVhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRDcmVhdGlvbiA9IFtdO1xuICAgICAgICAgICAgKDAsIGJpbl8xLmdldEJyaWRnZSkoKS5jcmVhdGVDb250ZXh0KHRoaXMuY29uZmlnKS50aGVuKChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3JlYXRpb24gPSB0aGlzLmNvbnRleHRDcmVhdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRDcmVhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIGNyZWF0aW9uID09PSBudWxsIHx8IGNyZWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjcmVhdGlvbi5mb3JFYWNoKHggPT4geC5yZXNvbHZlKGNvbnRleHQpKTtcbiAgICAgICAgICAgIH0sIChyZWFzb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcmVhdGlvbiA9IHRoaXMuY29udGV4dENyZWF0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dENyZWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dEVycm9yID0gcmVhc29uICE9PSBudWxsICYmIHJlYXNvbiAhPT0gdm9pZCAwID8gcmVhc29uIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNyZWF0aW9uID09PSBudWxsIHx8IGNyZWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjcmVhdGlvbi5mb3JFYWNoKHggPT4geC5yZWplY3QocmVhc29uKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5jb250ZXh0Q3JlYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wdXNoKHtcbiAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWVzdChmdW5jdGlvbk5hbWUsIGZ1bmN0aW9uUGFyYW1zLCByZXNwb25zZUhhbmRsZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IChfYSA9IHRoaXMuY29udGV4dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogeWllbGQgdGhpcy5jb250ZXh0UmVxdWlyZWQoKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgYmluXzEuZ2V0QnJpZGdlKSgpXG4gICAgICAgICAgICAgICAgLnJlcXVlc3QoY29udGV4dCwgZnVuY3Rpb25OYW1lLCBmdW5jdGlvblBhcmFtcywgcmVzcG9uc2VIYW5kbGVyICE9PSBudWxsICYmIHJlc3BvbnNlSGFuZGxlciAhPT0gdm9pZCAwID8gcmVzcG9uc2VIYW5kbGVyIDogKCgpID0+IHtcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgocmVhc29uKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgeWllbGQgdGhpcy5yZXNvbHZlRXJyb3IoZnVuY3Rpb25OYW1lLCBmdW5jdGlvblBhcmFtcywgcmVhc29uKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc29sdmVfYXBwX3JlcXVlc3QoYXBwX3JlcXVlc3RfaWQsIHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGFwcF9yZXF1ZXN0X2lkKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jbGllbnQucmVzb2x2ZV9hcHBfcmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIGFwcF9yZXF1ZXN0X2lkLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiT2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlamVjdF9hcHBfcmVxdWVzdChhcHBfcmVxdWVzdF9pZCwgZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChhcHBfcmVxdWVzdF9pZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY2xpZW50LnJlc29sdmVfYXBwX3JlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICBhcHBfcmVxdWVzdF9pZCxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlRvbkNsaWVudCA9IFRvbkNsaWVudDtcblRvbkNsaWVudC5fZGVmYXVsdENvbmZpZyA9IHt9O1xuVG9uQ2xpZW50Ll9kZWZhdWx0ID0gbnVsbDtcbi8vIENvbnZlcnRzIHZhbHVlIHRvIGhleFxuZnVuY3Rpb24gdG9IZXgodmFsdWUsIGJpdHMpIHtcbiAgICBsZXQgaGV4O1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgIGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgICAgIGhleCA9IHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhleCA9IGRlY1RvSGV4KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGV4ID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgbGV0IGxlbiA9IGJpdHMgLyA0O1xuICAgIHdoaWxlIChoZXgubGVuZ3RoID4gbGVuICYmIGhleC5zdGFydHNXaXRoKFwiMFwiKSkge1xuICAgICAgICBoZXggPSBoZXguc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4LnBhZFN0YXJ0KGxlbiwgXCIwXCIpO1xufVxuZnVuY3Rpb24gZGVjVG9IZXgoZGVjKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBiaWdOdW0gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlYy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBkID0gKChfYSA9IGRlYy5jb2RlUG9pbnRBdChpKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgLSA0ODtcbiAgICAgICAgY29uc3QgbXVsOCA9IHNobChiaWdOdW0sIDMpO1xuICAgICAgICBjb25zdCBtdWwyID0gc2hsKGJpZ051bSwgMSk7XG4gICAgICAgIGNvbnN0IG11bDEwID0gYWRkKG11bDgsIG11bDIpO1xuICAgICAgICBiaWdOdW0gPSBhZGQobXVsMTAsIFtkXSk7XG4gICAgfVxuICAgIGxldCBoZXggPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSBiaWdOdW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgaGV4ICs9IGJpZ051bVtpXS50b1N0cmluZygxNikucGFkU3RhcnQoNCwgXCIwXCIpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZnVuY3Rpb24gc2hsKGJpZ051bSwgYml0cykge1xuICAgIGxldCByZXN0ID0gMDtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpZ051bS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgdiA9IChiaWdOdW1baV0gPDwgYml0cykgKyByZXN0O1xuICAgICAgICByZXN1bHQucHVzaCh2ICYgMHhGRkZGKTtcbiAgICAgICAgcmVzdCA9ICh2ID4+IDE2KSAmIDB4RkZGRjtcbiAgICB9XG4gICAgaWYgKHJlc3QgPiAwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHJlc3QpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgICBsZXQgcmVzdCA9IDA7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgbGVuID0gTWF0aC5tYXgoYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGxldCB2ID0gKGkgPCBhLmxlbmd0aCA/IGFbaV0gOiAwKSArIChpIDwgYi5sZW5ndGggPyBiW2ldIDogMCkgKyByZXN0O1xuICAgICAgICByZXN1bHQucHVzaCh2ICYgMHhGRkZGKTtcbiAgICAgICAgcmVzdCA9ICh2ID4+IDE2KSAmIDB4RkZGRjtcbiAgICB9XG4gICAgaWYgKHJlc3QgPiAwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHJlc3QpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@eversdk/core/dist/client.js\n");

/***/ }),

/***/ "./node_modules/@eversdk/core/dist/errors.js":
/*!***************************************************!*\
  !*** ./node_modules/@eversdk/core/dist/errors.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TonClientError = void 0;\nclass TonClientError extends Error {\n    constructor(code, message, data) {\n        super(message);\n        this.code = code;\n        this.data = data;\n    }\n}\nexports.TonClientError = TonClientError;\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGV2ZXJzZGsvY29yZS9kaXN0L2Vycm9ycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9AZXZlcnNkay9jb3JlL2Rpc3QvZXJyb3JzLmpzPzExODQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRvbkNsaWVudEVycm9yID0gdm9pZCAwO1xuY2xhc3MgVG9uQ2xpZW50RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG5leHBvcnRzLlRvbkNsaWVudEVycm9yID0gVG9uQ2xpZW50RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@eversdk/core/dist/errors.js\n");

/***/ }),

/***/ "./node_modules/@eversdk/core/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@eversdk/core/dist/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./modules */ \"./node_modules/@eversdk/core/dist/modules.js\"), exports);\n__exportStar(__webpack_require__(/*! ./client */ \"./node_modules/@eversdk/core/dist/client.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGV2ZXJzZGsvY29yZS9kaXN0L2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL0BldmVyc2RrL2NvcmUvZGlzdC9pbmRleC5qcz8xYTM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kdWxlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2xpZW50XCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@eversdk/core/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@eversdk/core/dist/modules.js":
/*!****************************************************!*\
  !*** ./node_modules/@eversdk/core/dist/modules.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.builderOpInteger = exports.BocErrorCode = exports.bocCacheTypeUnpinned = exports.bocCacheTypePinned = exports.AbiModule = exports.messageSourceEncodingParams = exports.messageSourceEncoded = exports.stateInitSourceTvc = exports.stateInitSourceStateInit = exports.stateInitSourceMessage = exports.MessageBodyType = exports.signerSigningBox = exports.signerKeys = exports.signerExternal = exports.signerNone = exports.abiSerialized = exports.abiHandle = exports.abiJson = exports.abiContract = exports.AbiErrorCode = exports.CryptoModule = exports.resultOfAppEncryptionBoxDecrypt = exports.resultOfAppEncryptionBoxEncrypt = exports.resultOfAppEncryptionBoxGetInfo = exports.paramsOfAppEncryptionBoxDecrypt = exports.paramsOfAppEncryptionBoxEncrypt = exports.paramsOfAppEncryptionBoxGetInfo = exports.resultOfAppSigningBoxSign = exports.resultOfAppSigningBoxGetPublicKey = exports.paramsOfAppSigningBoxSign = exports.paramsOfAppSigningBoxGetPublicKey = exports.resultOfAppPasswordProviderGetPassword = exports.paramsOfAppPasswordProviderGetPassword = exports.boxEncryptionAlgorithmNaclSecretBox = exports.boxEncryptionAlgorithmNaclBox = exports.boxEncryptionAlgorithmChaCha20 = exports.cryptoBoxSecretEncryptedSecret = exports.cryptoBoxSecretPredefinedSeedPhrase = exports.cryptoBoxSecretRandomSeedPhrase = exports.CipherMode = exports.encryptionAlgorithmNaclSecretBox = exports.encryptionAlgorithmNaclBox = exports.encryptionAlgorithmChaCha20 = exports.encryptionAlgorithmAES = exports.CryptoErrorCode = exports.ClientModule = exports.appRequestResultOk = exports.appRequestResultError = exports.NetworkQueriesProtocol = exports.ClientErrorCode = void 0;\nexports.resultOfAppDebotBrowserInput = exports.paramsOfAppDebotBrowserApprove = exports.paramsOfAppDebotBrowserSend = exports.paramsOfAppDebotBrowserInvokeDebot = exports.paramsOfAppDebotBrowserGetSigningBox = exports.paramsOfAppDebotBrowserInput = exports.paramsOfAppDebotBrowserShowAction = exports.paramsOfAppDebotBrowserSwitchCompleted = exports.paramsOfAppDebotBrowserSwitch = exports.paramsOfAppDebotBrowserLog = exports.debotActivityTransaction = exports.DebotErrorCode = exports.NetModule = exports.AggregationFn = exports.paramsOfQueryOperationQueryCounterparties = exports.paramsOfQueryOperationAggregateCollection = exports.paramsOfQueryOperationWaitForCollection = exports.paramsOfQueryOperationQueryCollection = exports.SortDirection = exports.NetErrorCode = exports.TvmModule = exports.accountForExecutorAccount = exports.accountForExecutorUninit = exports.accountForExecutorNone = exports.TvmErrorCode = exports.UtilsModule = exports.AccountAddressType = exports.addressStringFormatBase64 = exports.addressStringFormatHex = exports.addressStringFormatAccountId = exports.ProcessingModule = exports.processingEventRempError = exports.processingEventRempOther = exports.processingEventRempIncludedIntoAcceptedBlock = exports.processingEventRempIncludedIntoBlock = exports.processingEventRempSentToValidators = exports.processingEventMessageExpired = exports.processingEventFetchNextBlockFailed = exports.processingEventWillFetchNextBlock = exports.processingEventSendFailed = exports.processingEventDidSend = exports.processingEventWillSend = exports.processingEventFetchFirstBlockFailed = exports.processingEventWillFetchFirstBlock = exports.ProcessingErrorCode = exports.BocModule = exports.builderOpAddress = exports.builderOpCellBoc = exports.builderOpCell = exports.builderOpBitString = void 0;\nexports.ProofsModule = exports.ProofsErrorCode = exports.DebotModule = exports.resultOfAppDebotBrowserApprove = exports.resultOfAppDebotBrowserInvokeDebot = exports.resultOfAppDebotBrowserGetSigningBox = void 0;\n// client module\nvar ClientErrorCode;\n(function (ClientErrorCode) {\n    ClientErrorCode[ClientErrorCode[\"NotImplemented\"] = 1] = \"NotImplemented\";\n    ClientErrorCode[ClientErrorCode[\"InvalidHex\"] = 2] = \"InvalidHex\";\n    ClientErrorCode[ClientErrorCode[\"InvalidBase64\"] = 3] = \"InvalidBase64\";\n    ClientErrorCode[ClientErrorCode[\"InvalidAddress\"] = 4] = \"InvalidAddress\";\n    ClientErrorCode[ClientErrorCode[\"CallbackParamsCantBeConvertedToJson\"] = 5] = \"CallbackParamsCantBeConvertedToJson\";\n    ClientErrorCode[ClientErrorCode[\"WebsocketConnectError\"] = 6] = \"WebsocketConnectError\";\n    ClientErrorCode[ClientErrorCode[\"WebsocketReceiveError\"] = 7] = \"WebsocketReceiveError\";\n    ClientErrorCode[ClientErrorCode[\"WebsocketSendError\"] = 8] = \"WebsocketSendError\";\n    ClientErrorCode[ClientErrorCode[\"HttpClientCreateError\"] = 9] = \"HttpClientCreateError\";\n    ClientErrorCode[ClientErrorCode[\"HttpRequestCreateError\"] = 10] = \"HttpRequestCreateError\";\n    ClientErrorCode[ClientErrorCode[\"HttpRequestSendError\"] = 11] = \"HttpRequestSendError\";\n    ClientErrorCode[ClientErrorCode[\"HttpRequestParseError\"] = 12] = \"HttpRequestParseError\";\n    ClientErrorCode[ClientErrorCode[\"CallbackNotRegistered\"] = 13] = \"CallbackNotRegistered\";\n    ClientErrorCode[ClientErrorCode[\"NetModuleNotInit\"] = 14] = \"NetModuleNotInit\";\n    ClientErrorCode[ClientErrorCode[\"InvalidConfig\"] = 15] = \"InvalidConfig\";\n    ClientErrorCode[ClientErrorCode[\"CannotCreateRuntime\"] = 16] = \"CannotCreateRuntime\";\n    ClientErrorCode[ClientErrorCode[\"InvalidContextHandle\"] = 17] = \"InvalidContextHandle\";\n    ClientErrorCode[ClientErrorCode[\"CannotSerializeResult\"] = 18] = \"CannotSerializeResult\";\n    ClientErrorCode[ClientErrorCode[\"CannotSerializeError\"] = 19] = \"CannotSerializeError\";\n    ClientErrorCode[ClientErrorCode[\"CannotConvertJsValueToJson\"] = 20] = \"CannotConvertJsValueToJson\";\n    ClientErrorCode[ClientErrorCode[\"CannotReceiveSpawnedResult\"] = 21] = \"CannotReceiveSpawnedResult\";\n    ClientErrorCode[ClientErrorCode[\"SetTimerError\"] = 22] = \"SetTimerError\";\n    ClientErrorCode[ClientErrorCode[\"InvalidParams\"] = 23] = \"InvalidParams\";\n    ClientErrorCode[ClientErrorCode[\"ContractsAddressConversionFailed\"] = 24] = \"ContractsAddressConversionFailed\";\n    ClientErrorCode[ClientErrorCode[\"UnknownFunction\"] = 25] = \"UnknownFunction\";\n    ClientErrorCode[ClientErrorCode[\"AppRequestError\"] = 26] = \"AppRequestError\";\n    ClientErrorCode[ClientErrorCode[\"NoSuchRequest\"] = 27] = \"NoSuchRequest\";\n    ClientErrorCode[ClientErrorCode[\"CanNotSendRequestResult\"] = 28] = \"CanNotSendRequestResult\";\n    ClientErrorCode[ClientErrorCode[\"CanNotReceiveRequestResult\"] = 29] = \"CanNotReceiveRequestResult\";\n    ClientErrorCode[ClientErrorCode[\"CanNotParseRequestResult\"] = 30] = \"CanNotParseRequestResult\";\n    ClientErrorCode[ClientErrorCode[\"UnexpectedCallbackResponse\"] = 31] = \"UnexpectedCallbackResponse\";\n    ClientErrorCode[ClientErrorCode[\"CanNotParseNumber\"] = 32] = \"CanNotParseNumber\";\n    ClientErrorCode[ClientErrorCode[\"InternalError\"] = 33] = \"InternalError\";\n    ClientErrorCode[ClientErrorCode[\"InvalidHandle\"] = 34] = \"InvalidHandle\";\n    ClientErrorCode[ClientErrorCode[\"LocalStorageError\"] = 35] = \"LocalStorageError\";\n})(ClientErrorCode = exports.ClientErrorCode || (exports.ClientErrorCode = {}));\n/**\n * Network protocol used to perform GraphQL queries.\n */\nvar NetworkQueriesProtocol;\n(function (NetworkQueriesProtocol) {\n    NetworkQueriesProtocol[\"HTTP\"] = \"HTTP\";\n    NetworkQueriesProtocol[\"WS\"] = \"WS\";\n})(NetworkQueriesProtocol = exports.NetworkQueriesProtocol || (exports.NetworkQueriesProtocol = {}));\nfunction appRequestResultError(text) {\n    return {\n        type: 'Error',\n        text,\n    };\n}\nexports.appRequestResultError = appRequestResultError;\nfunction appRequestResultOk(result) {\n    return {\n        type: 'Ok',\n        result,\n    };\n}\nexports.appRequestResultOk = appRequestResultOk;\n/**\n * Provides information about library.\n */\nclass ClientModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Returns Core Library API reference\n     * @returns ResultOfGetApiReference\n     */\n    get_api_reference() {\n        return this.client.request('client.get_api_reference');\n    }\n    /**\n     * Returns Core Library version\n     * @returns ResultOfVersion\n     */\n    version() {\n        return this.client.request('client.version');\n    }\n    /**\n     * Returns Core Library API reference\n     * @returns ClientConfig\n     */\n    config() {\n        return this.client.request('client.config');\n    }\n    /**\n     * Returns detailed information about this build.\n     * @returns ResultOfBuildInfo\n     */\n    build_info() {\n        return this.client.request('client.build_info');\n    }\n    /**\n     * Resolves application request processing result\n     *\n     * @param {ParamsOfResolveAppRequest} params\n     * @returns\n     */\n    resolve_app_request(params) {\n        return this.client.request('client.resolve_app_request', params);\n    }\n}\nexports.ClientModule = ClientModule;\n// crypto module\nvar CryptoErrorCode;\n(function (CryptoErrorCode) {\n    CryptoErrorCode[CryptoErrorCode[\"InvalidPublicKey\"] = 100] = \"InvalidPublicKey\";\n    CryptoErrorCode[CryptoErrorCode[\"InvalidSecretKey\"] = 101] = \"InvalidSecretKey\";\n    CryptoErrorCode[CryptoErrorCode[\"InvalidKey\"] = 102] = \"InvalidKey\";\n    CryptoErrorCode[CryptoErrorCode[\"InvalidFactorizeChallenge\"] = 106] = \"InvalidFactorizeChallenge\";\n    CryptoErrorCode[CryptoErrorCode[\"InvalidBigInt\"] = 107] = \"InvalidBigInt\";\n    CryptoErrorCode[CryptoErrorCode[\"ScryptFailed\"] = 108] = \"ScryptFailed\";\n    CryptoErrorCode[CryptoErrorCode[\"InvalidKeySize\"] = 109] = \"InvalidKeySize\";\n    CryptoErrorCode[CryptoErrorCode[\"NaclSecretBoxFailed\"] = 110] = \"NaclSecretBoxFailed\";\n    CryptoErrorCode[CryptoErrorCode[\"NaclBoxFailed\"] = 111] = \"NaclBoxFailed\";\n    CryptoErrorCode[CryptoErrorCode[\"NaclSignFailed\"] = 112] = \"NaclSignFailed\";\n    CryptoErrorCode[CryptoErrorCode[\"Bip39InvalidEntropy\"] = 113] = \"Bip39InvalidEntropy\";\n    CryptoErrorCode[CryptoErrorCode[\"Bip39InvalidPhrase\"] = 114] = \"Bip39InvalidPhrase\";\n    CryptoErrorCode[CryptoErrorCode[\"Bip32InvalidKey\"] = 115] = \"Bip32InvalidKey\";\n    CryptoErrorCode[CryptoErrorCode[\"Bip32InvalidDerivePath\"] = 116] = \"Bip32InvalidDerivePath\";\n    CryptoErrorCode[CryptoErrorCode[\"Bip39InvalidDictionary\"] = 117] = \"Bip39InvalidDictionary\";\n    CryptoErrorCode[CryptoErrorCode[\"Bip39InvalidWordCount\"] = 118] = \"Bip39InvalidWordCount\";\n    CryptoErrorCode[CryptoErrorCode[\"MnemonicGenerationFailed\"] = 119] = \"MnemonicGenerationFailed\";\n    CryptoErrorCode[CryptoErrorCode[\"MnemonicFromEntropyFailed\"] = 120] = \"MnemonicFromEntropyFailed\";\n    CryptoErrorCode[CryptoErrorCode[\"SigningBoxNotRegistered\"] = 121] = \"SigningBoxNotRegistered\";\n    CryptoErrorCode[CryptoErrorCode[\"InvalidSignature\"] = 122] = \"InvalidSignature\";\n    CryptoErrorCode[CryptoErrorCode[\"EncryptionBoxNotRegistered\"] = 123] = \"EncryptionBoxNotRegistered\";\n    CryptoErrorCode[CryptoErrorCode[\"InvalidIvSize\"] = 124] = \"InvalidIvSize\";\n    CryptoErrorCode[CryptoErrorCode[\"UnsupportedCipherMode\"] = 125] = \"UnsupportedCipherMode\";\n    CryptoErrorCode[CryptoErrorCode[\"CannotCreateCipher\"] = 126] = \"CannotCreateCipher\";\n    CryptoErrorCode[CryptoErrorCode[\"EncryptDataError\"] = 127] = \"EncryptDataError\";\n    CryptoErrorCode[CryptoErrorCode[\"DecryptDataError\"] = 128] = \"DecryptDataError\";\n    CryptoErrorCode[CryptoErrorCode[\"IvRequired\"] = 129] = \"IvRequired\";\n    CryptoErrorCode[CryptoErrorCode[\"CryptoBoxNotRegistered\"] = 130] = \"CryptoBoxNotRegistered\";\n    CryptoErrorCode[CryptoErrorCode[\"InvalidCryptoBoxType\"] = 131] = \"InvalidCryptoBoxType\";\n    CryptoErrorCode[CryptoErrorCode[\"CryptoBoxSecretSerializationError\"] = 132] = \"CryptoBoxSecretSerializationError\";\n    CryptoErrorCode[CryptoErrorCode[\"CryptoBoxSecretDeserializationError\"] = 133] = \"CryptoBoxSecretDeserializationError\";\n    CryptoErrorCode[CryptoErrorCode[\"InvalidNonceSize\"] = 134] = \"InvalidNonceSize\";\n})(CryptoErrorCode = exports.CryptoErrorCode || (exports.CryptoErrorCode = {}));\nfunction encryptionAlgorithmAES(value) {\n    return {\n        type: 'AES',\n        value,\n    };\n}\nexports.encryptionAlgorithmAES = encryptionAlgorithmAES;\nfunction encryptionAlgorithmChaCha20(value) {\n    return {\n        type: 'ChaCha20',\n        value,\n    };\n}\nexports.encryptionAlgorithmChaCha20 = encryptionAlgorithmChaCha20;\nfunction encryptionAlgorithmNaclBox(value) {\n    return {\n        type: 'NaclBox',\n        value,\n    };\n}\nexports.encryptionAlgorithmNaclBox = encryptionAlgorithmNaclBox;\nfunction encryptionAlgorithmNaclSecretBox(value) {\n    return {\n        type: 'NaclSecretBox',\n        value,\n    };\n}\nexports.encryptionAlgorithmNaclSecretBox = encryptionAlgorithmNaclSecretBox;\nvar CipherMode;\n(function (CipherMode) {\n    CipherMode[\"CBC\"] = \"CBC\";\n    CipherMode[\"CFB\"] = \"CFB\";\n    CipherMode[\"CTR\"] = \"CTR\";\n    CipherMode[\"ECB\"] = \"ECB\";\n    CipherMode[\"OFB\"] = \"OFB\";\n})(CipherMode = exports.CipherMode || (exports.CipherMode = {}));\nfunction cryptoBoxSecretRandomSeedPhrase(dictionary, wordcount) {\n    return {\n        type: 'RandomSeedPhrase',\n        dictionary,\n        wordcount,\n    };\n}\nexports.cryptoBoxSecretRandomSeedPhrase = cryptoBoxSecretRandomSeedPhrase;\nfunction cryptoBoxSecretPredefinedSeedPhrase(phrase, dictionary, wordcount) {\n    return {\n        type: 'PredefinedSeedPhrase',\n        phrase,\n        dictionary,\n        wordcount,\n    };\n}\nexports.cryptoBoxSecretPredefinedSeedPhrase = cryptoBoxSecretPredefinedSeedPhrase;\nfunction cryptoBoxSecretEncryptedSecret(encrypted_secret) {\n    return {\n        type: 'EncryptedSecret',\n        encrypted_secret,\n    };\n}\nexports.cryptoBoxSecretEncryptedSecret = cryptoBoxSecretEncryptedSecret;\nfunction boxEncryptionAlgorithmChaCha20(value) {\n    return {\n        type: 'ChaCha20',\n        value,\n    };\n}\nexports.boxEncryptionAlgorithmChaCha20 = boxEncryptionAlgorithmChaCha20;\nfunction boxEncryptionAlgorithmNaclBox(value) {\n    return {\n        type: 'NaclBox',\n        value,\n    };\n}\nexports.boxEncryptionAlgorithmNaclBox = boxEncryptionAlgorithmNaclBox;\nfunction boxEncryptionAlgorithmNaclSecretBox(value) {\n    return {\n        type: 'NaclSecretBox',\n        value,\n    };\n}\nexports.boxEncryptionAlgorithmNaclSecretBox = boxEncryptionAlgorithmNaclSecretBox;\nfunction paramsOfAppPasswordProviderGetPassword(encryption_public_key) {\n    return {\n        type: 'GetPassword',\n        encryption_public_key,\n    };\n}\nexports.paramsOfAppPasswordProviderGetPassword = paramsOfAppPasswordProviderGetPassword;\nfunction resultOfAppPasswordProviderGetPassword(encrypted_password, app_encryption_pubkey) {\n    return {\n        type: 'GetPassword',\n        encrypted_password,\n        app_encryption_pubkey,\n    };\n}\nexports.resultOfAppPasswordProviderGetPassword = resultOfAppPasswordProviderGetPassword;\nfunction paramsOfAppSigningBoxGetPublicKey() {\n    return {\n        type: 'GetPublicKey',\n    };\n}\nexports.paramsOfAppSigningBoxGetPublicKey = paramsOfAppSigningBoxGetPublicKey;\nfunction paramsOfAppSigningBoxSign(unsigned) {\n    return {\n        type: 'Sign',\n        unsigned,\n    };\n}\nexports.paramsOfAppSigningBoxSign = paramsOfAppSigningBoxSign;\nfunction resultOfAppSigningBoxGetPublicKey(public_key) {\n    return {\n        type: 'GetPublicKey',\n        public_key,\n    };\n}\nexports.resultOfAppSigningBoxGetPublicKey = resultOfAppSigningBoxGetPublicKey;\nfunction resultOfAppSigningBoxSign(signature) {\n    return {\n        type: 'Sign',\n        signature,\n    };\n}\nexports.resultOfAppSigningBoxSign = resultOfAppSigningBoxSign;\nfunction paramsOfAppEncryptionBoxGetInfo() {\n    return {\n        type: 'GetInfo',\n    };\n}\nexports.paramsOfAppEncryptionBoxGetInfo = paramsOfAppEncryptionBoxGetInfo;\nfunction paramsOfAppEncryptionBoxEncrypt(data) {\n    return {\n        type: 'Encrypt',\n        data,\n    };\n}\nexports.paramsOfAppEncryptionBoxEncrypt = paramsOfAppEncryptionBoxEncrypt;\nfunction paramsOfAppEncryptionBoxDecrypt(data) {\n    return {\n        type: 'Decrypt',\n        data,\n    };\n}\nexports.paramsOfAppEncryptionBoxDecrypt = paramsOfAppEncryptionBoxDecrypt;\nfunction resultOfAppEncryptionBoxGetInfo(info) {\n    return {\n        type: 'GetInfo',\n        info,\n    };\n}\nexports.resultOfAppEncryptionBoxGetInfo = resultOfAppEncryptionBoxGetInfo;\nfunction resultOfAppEncryptionBoxEncrypt(data) {\n    return {\n        type: 'Encrypt',\n        data,\n    };\n}\nexports.resultOfAppEncryptionBoxEncrypt = resultOfAppEncryptionBoxEncrypt;\nfunction resultOfAppEncryptionBoxDecrypt(data) {\n    return {\n        type: 'Decrypt',\n        data,\n    };\n}\nexports.resultOfAppEncryptionBoxDecrypt = resultOfAppEncryptionBoxDecrypt;\nfunction dispatchAppPasswordProvider(obj, params, app_request_id, client) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let result = {};\n            switch (params.type) {\n                case 'GetPassword':\n                    result = yield obj.get_password(params);\n                    break;\n            }\n            client.resolve_app_request(app_request_id, Object.assign({ type: params.type }, result));\n        }\n        catch (error) {\n            client.reject_app_request(app_request_id, error);\n        }\n    });\n}\nfunction dispatchAppSigningBox(obj, params, app_request_id, client) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let result = {};\n            switch (params.type) {\n                case 'GetPublicKey':\n                    result = yield obj.get_public_key();\n                    break;\n                case 'Sign':\n                    result = yield obj.sign(params);\n                    break;\n            }\n            client.resolve_app_request(app_request_id, Object.assign({ type: params.type }, result));\n        }\n        catch (error) {\n            client.reject_app_request(app_request_id, error);\n        }\n    });\n}\nfunction dispatchAppEncryptionBox(obj, params, app_request_id, client) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let result = {};\n            switch (params.type) {\n                case 'GetInfo':\n                    result = yield obj.get_info();\n                    break;\n                case 'Encrypt':\n                    result = yield obj.encrypt(params);\n                    break;\n                case 'Decrypt':\n                    result = yield obj.decrypt(params);\n                    break;\n            }\n            client.resolve_app_request(app_request_id, Object.assign({ type: params.type }, result));\n        }\n        catch (error) {\n            client.reject_app_request(app_request_id, error);\n        }\n    });\n}\n/**\n * Crypto functions.\n */\nclass CryptoModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Integer factorization\n     *\n     * @remarks\n     * Performs prime factorization  decomposition of a composite number\n     * into a product of smaller prime integers (factors).\n     * See [https://en.wikipedia.org/wiki/Integer_factorization]\n     *\n     * @param {ParamsOfFactorize} params\n     * @returns ResultOfFactorize\n     */\n    factorize(params) {\n        return this.client.request('crypto.factorize', params);\n    }\n    /**\n     * Modular exponentiation\n     *\n     * @remarks\n     * Performs modular exponentiation for big integers (`base`^`exponent` mod `modulus`).\n     * See [https://en.wikipedia.org/wiki/Modular_exponentiation]\n     *\n     * @param {ParamsOfModularPower} params\n     * @returns ResultOfModularPower\n     */\n    modular_power(params) {\n        return this.client.request('crypto.modular_power', params);\n    }\n    /**\n     * Calculates CRC16 using TON algorithm.\n     *\n     * @param {ParamsOfTonCrc16} params\n     * @returns ResultOfTonCrc16\n     */\n    ton_crc16(params) {\n        return this.client.request('crypto.ton_crc16', params);\n    }\n    /**\n     * Generates random byte array of the specified length and returns it in `base64` format\n     *\n     * @param {ParamsOfGenerateRandomBytes} params\n     * @returns ResultOfGenerateRandomBytes\n     */\n    generate_random_bytes(params) {\n        return this.client.request('crypto.generate_random_bytes', params);\n    }\n    /**\n     * Converts public key to ton safe_format\n     *\n     * @param {ParamsOfConvertPublicKeyToTonSafeFormat} params\n     * @returns ResultOfConvertPublicKeyToTonSafeFormat\n     */\n    convert_public_key_to_ton_safe_format(params) {\n        return this.client.request('crypto.convert_public_key_to_ton_safe_format', params);\n    }\n    /**\n     * Generates random ed25519 key pair.\n     * @returns KeyPair\n     */\n    generate_random_sign_keys() {\n        return this.client.request('crypto.generate_random_sign_keys');\n    }\n    /**\n     * Signs a data using the provided keys.\n     *\n     * @param {ParamsOfSign} params\n     * @returns ResultOfSign\n     */\n    sign(params) {\n        return this.client.request('crypto.sign', params);\n    }\n    /**\n     * Verifies signed data using the provided public key. Raises error if verification is failed.\n     *\n     * @param {ParamsOfVerifySignature} params\n     * @returns ResultOfVerifySignature\n     */\n    verify_signature(params) {\n        return this.client.request('crypto.verify_signature', params);\n    }\n    /**\n     * Calculates SHA256 hash of the specified data.\n     *\n     * @param {ParamsOfHash} params\n     * @returns ResultOfHash\n     */\n    sha256(params) {\n        return this.client.request('crypto.sha256', params);\n    }\n    /**\n     * Calculates SHA512 hash of the specified data.\n     *\n     * @param {ParamsOfHash} params\n     * @returns ResultOfHash\n     */\n    sha512(params) {\n        return this.client.request('crypto.sha512', params);\n    }\n    /**\n     * Perform `scrypt` encryption\n     *\n     * @remarks\n     * Derives key from `password` and `key` using `scrypt` algorithm.\n     * See [https://en.wikipedia.org/wiki/Scrypt].\n     *\n     * # Arguments\n     * - `log_n` - The log2 of the Scrypt parameter `N`\n     * - `r` - The Scrypt parameter `r`\n     * - `p` - The Scrypt parameter `p`\n     * # Conditions\n     * - `log_n` must be less than `64`\n     * - `r` must be greater than `0` and less than or equal to `4294967295`\n     * - `p` must be greater than `0` and less than `4294967295`\n     * # Recommended values sufficient for most use-cases\n     * - `log_n = 15` (`n = 32768`)\n     * - `r = 8`\n     * - `p = 1`\n     *\n     * @param {ParamsOfScrypt} params\n     * @returns ResultOfScrypt\n     */\n    scrypt(params) {\n        return this.client.request('crypto.scrypt', params);\n    }\n    /**\n     * Generates a key pair for signing from the secret key\n     *\n     * @remarks\n     * **NOTE:** In the result the secret key is actually the concatenation\n     * of secret and public keys (128 symbols hex string) by design of [NaCL](http://nacl.cr.yp.to/sign.html).\n     * See also [the stackexchange question](https://crypto.stackexchange.com/questions/54353/).\n     *\n     * @param {ParamsOfNaclSignKeyPairFromSecret} params\n     * @returns KeyPair\n     */\n    nacl_sign_keypair_from_secret_key(params) {\n        return this.client.request('crypto.nacl_sign_keypair_from_secret_key', params);\n    }\n    /**\n     * Signs data using the signer's secret key.\n     *\n     * @param {ParamsOfNaclSign} params\n     * @returns ResultOfNaclSign\n     */\n    nacl_sign(params) {\n        return this.client.request('crypto.nacl_sign', params);\n    }\n    /**\n     * Verifies the signature and returns the unsigned message\n     *\n     * @remarks\n     * Verifies the signature in `signed` using the signer's public key `public`\n     * and returns the message `unsigned`.\n     *\n     * If the signature fails verification, crypto_sign_open raises an exception.\n     *\n     * @param {ParamsOfNaclSignOpen} params\n     * @returns ResultOfNaclSignOpen\n     */\n    nacl_sign_open(params) {\n        return this.client.request('crypto.nacl_sign_open', params);\n    }\n    /**\n     * Signs the message using the secret key and returns a signature.\n     *\n     * @remarks\n     * Signs the message `unsigned` using the secret key `secret`\n     * and returns a signature `signature`.\n     *\n     * @param {ParamsOfNaclSign} params\n     * @returns ResultOfNaclSignDetached\n     */\n    nacl_sign_detached(params) {\n        return this.client.request('crypto.nacl_sign_detached', params);\n    }\n    /**\n     * Verifies the signature with public key and `unsigned` data.\n     *\n     * @param {ParamsOfNaclSignDetachedVerify} params\n     * @returns ResultOfNaclSignDetachedVerify\n     */\n    nacl_sign_detached_verify(params) {\n        return this.client.request('crypto.nacl_sign_detached_verify', params);\n    }\n    /**\n     * Generates a random NaCl key pair\n     * @returns KeyPair\n     */\n    nacl_box_keypair() {\n        return this.client.request('crypto.nacl_box_keypair');\n    }\n    /**\n     * Generates key pair from a secret key\n     *\n     * @param {ParamsOfNaclBoxKeyPairFromSecret} params\n     * @returns KeyPair\n     */\n    nacl_box_keypair_from_secret_key(params) {\n        return this.client.request('crypto.nacl_box_keypair_from_secret_key', params);\n    }\n    /**\n     * Public key authenticated encryption\n     *\n     * @remarks\n     * Encrypt and authenticate a message using the senders secret key, the receivers public\n     * key, and a nonce.\n     *\n     * @param {ParamsOfNaclBox} params\n     * @returns ResultOfNaclBox\n     */\n    nacl_box(params) {\n        return this.client.request('crypto.nacl_box', params);\n    }\n    /**\n     * Decrypt and verify the cipher text using the receivers secret key, the senders public key, and the nonce.\n     *\n     * @param {ParamsOfNaclBoxOpen} params\n     * @returns ResultOfNaclBoxOpen\n     */\n    nacl_box_open(params) {\n        return this.client.request('crypto.nacl_box_open', params);\n    }\n    /**\n     * Encrypt and authenticate message using nonce and secret key.\n     *\n     * @param {ParamsOfNaclSecretBox} params\n     * @returns ResultOfNaclBox\n     */\n    nacl_secret_box(params) {\n        return this.client.request('crypto.nacl_secret_box', params);\n    }\n    /**\n     * Decrypts and verifies cipher text using `nonce` and secret `key`.\n     *\n     * @param {ParamsOfNaclSecretBoxOpen} params\n     * @returns ResultOfNaclBoxOpen\n     */\n    nacl_secret_box_open(params) {\n        return this.client.request('crypto.nacl_secret_box_open', params);\n    }\n    /**\n     * Prints the list of words from the specified dictionary\n     *\n     * @param {ParamsOfMnemonicWords} params\n     * @returns ResultOfMnemonicWords\n     */\n    mnemonic_words(params) {\n        return this.client.request('crypto.mnemonic_words', params);\n    }\n    /**\n     * Generates a random mnemonic\n     *\n     * @remarks\n     * Generates a random mnemonic from the specified dictionary and word count\n     *\n     * @param {ParamsOfMnemonicFromRandom} params\n     * @returns ResultOfMnemonicFromRandom\n     */\n    mnemonic_from_random(params) {\n        return this.client.request('crypto.mnemonic_from_random', params);\n    }\n    /**\n     * Generates mnemonic from pre-generated entropy\n     *\n     * @param {ParamsOfMnemonicFromEntropy} params\n     * @returns ResultOfMnemonicFromEntropy\n     */\n    mnemonic_from_entropy(params) {\n        return this.client.request('crypto.mnemonic_from_entropy', params);\n    }\n    /**\n     * Validates a mnemonic phrase\n     *\n     * @remarks\n     * The phrase supplied will be checked for word length and validated according to the checksum\n     * specified in BIP0039.\n     *\n     * @param {ParamsOfMnemonicVerify} params\n     * @returns ResultOfMnemonicVerify\n     */\n    mnemonic_verify(params) {\n        return this.client.request('crypto.mnemonic_verify', params);\n    }\n    /**\n     * Derives a key pair for signing from the seed phrase\n     *\n     * @remarks\n     * Validates the seed phrase, generates master key and then derives\n     * the key pair from the master key and the specified path\n     *\n     * @param {ParamsOfMnemonicDeriveSignKeys} params\n     * @returns KeyPair\n     */\n    mnemonic_derive_sign_keys(params) {\n        return this.client.request('crypto.mnemonic_derive_sign_keys', params);\n    }\n    /**\n     * Generates an extended master private key that will be the root for all the derived keys\n     *\n     * @param {ParamsOfHDKeyXPrvFromMnemonic} params\n     * @returns ResultOfHDKeyXPrvFromMnemonic\n     */\n    hdkey_xprv_from_mnemonic(params) {\n        return this.client.request('crypto.hdkey_xprv_from_mnemonic', params);\n    }\n    /**\n     * Returns extended private key derived from the specified extended private key and child index\n     *\n     * @param {ParamsOfHDKeyDeriveFromXPrv} params\n     * @returns ResultOfHDKeyDeriveFromXPrv\n     */\n    hdkey_derive_from_xprv(params) {\n        return this.client.request('crypto.hdkey_derive_from_xprv', params);\n    }\n    /**\n     * Derives the extended private key from the specified key and path\n     *\n     * @param {ParamsOfHDKeyDeriveFromXPrvPath} params\n     * @returns ResultOfHDKeyDeriveFromXPrvPath\n     */\n    hdkey_derive_from_xprv_path(params) {\n        return this.client.request('crypto.hdkey_derive_from_xprv_path', params);\n    }\n    /**\n     * Extracts the private key from the serialized extended private key\n     *\n     * @param {ParamsOfHDKeySecretFromXPrv} params\n     * @returns ResultOfHDKeySecretFromXPrv\n     */\n    hdkey_secret_from_xprv(params) {\n        return this.client.request('crypto.hdkey_secret_from_xprv', params);\n    }\n    /**\n     * Extracts the public key from the serialized extended private key\n     *\n     * @param {ParamsOfHDKeyPublicFromXPrv} params\n     * @returns ResultOfHDKeyPublicFromXPrv\n     */\n    hdkey_public_from_xprv(params) {\n        return this.client.request('crypto.hdkey_public_from_xprv', params);\n    }\n    /**\n     * Performs symmetric `chacha20` encryption.\n     *\n     * @param {ParamsOfChaCha20} params\n     * @returns ResultOfChaCha20\n     */\n    chacha20(params) {\n        return this.client.request('crypto.chacha20', params);\n    }\n    /**\n     * Creates a Crypto Box instance.\n     *\n     * @remarks\n     * Crypto Box is a root crypto object, that encapsulates some secret (seed phrase usually)\n     * in encrypted form and acts as a factory for all crypto primitives used in SDK:\n     * keys for signing and encryption, derived from this secret.\n     *\n     * Crypto Box encrypts original Seed Phrase with salt and password that is retrieved\n     * from `password_provider` callback, implemented on Application side.\n     *\n     * When used, decrypted secret shows up in core library's memory for a very short period\n     * of time and then is immediately overwritten with zeroes.\n     *\n     * @param {ParamsOfCreateCryptoBox} params\n     * @returns RegisteredCryptoBox\n     */\n    create_crypto_box(params, obj) {\n        return this.client.request('crypto.create_crypto_box', params, (params, responseType) => {\n            if (responseType === 3) {\n                dispatchAppPasswordProvider(obj, params.request_data, params.app_request_id, this.client);\n            }\n            else if (responseType === 4) {\n                dispatchAppPasswordProvider(obj, params, null, this.client);\n            }\n        });\n    }\n    /**\n     * Removes Crypto Box. Clears all secret data.\n     *\n     * @param {RegisteredCryptoBox} params\n     * @returns\n     */\n    remove_crypto_box(params) {\n        return this.client.request('crypto.remove_crypto_box', params);\n    }\n    /**\n     * Get Crypto Box Info. Used to get `encrypted_secret` that should be used for all the cryptobox initializations except the first one.\n     *\n     * @param {RegisteredCryptoBox} params\n     * @returns ResultOfGetCryptoBoxInfo\n     */\n    get_crypto_box_info(params) {\n        return this.client.request('crypto.get_crypto_box_info', params);\n    }\n    /**\n     * Get Crypto Box Seed Phrase.\n     *\n     * @remarks\n     * Attention! Store this data in your application for a very short period of time and overwrite it with zeroes ASAP.\n     *\n     * @param {RegisteredCryptoBox} params\n     * @returns ResultOfGetCryptoBoxSeedPhrase\n     */\n    get_crypto_box_seed_phrase(params) {\n        return this.client.request('crypto.get_crypto_box_seed_phrase', params);\n    }\n    /**\n     * Get handle of Signing Box derived from Crypto Box.\n     *\n     * @param {ParamsOfGetSigningBoxFromCryptoBox} params\n     * @returns RegisteredSigningBox\n     */\n    get_signing_box_from_crypto_box(params) {\n        return this.client.request('crypto.get_signing_box_from_crypto_box', params);\n    }\n    /**\n     * Gets Encryption Box from Crypto Box.\n     *\n     * @remarks\n     * Derives encryption keypair from cryptobox secret and hdpath and\n     * stores it in cache for `secret_lifetime`\n     * or until explicitly cleared by `clear_crypto_box_secret_cache` method.\n     * If `secret_lifetime` is not specified - overwrites encryption secret with zeroes immediately after\n     * encryption operation.\n     *\n     * @param {ParamsOfGetEncryptionBoxFromCryptoBox} params\n     * @returns RegisteredEncryptionBox\n     */\n    get_encryption_box_from_crypto_box(params) {\n        return this.client.request('crypto.get_encryption_box_from_crypto_box', params);\n    }\n    /**\n     * Removes cached secrets (overwrites with zeroes) from all signing and encryption boxes, derived from crypto box.\n     *\n     * @param {RegisteredCryptoBox} params\n     * @returns\n     */\n    clear_crypto_box_secret_cache(params) {\n        return this.client.request('crypto.clear_crypto_box_secret_cache', params);\n    }\n    /**\n     * Register an application implemented signing box.\n     * @returns RegisteredSigningBox\n     */\n    register_signing_box(obj) {\n        return this.client.request('crypto.register_signing_box', undefined, (params, responseType) => {\n            if (responseType === 3) {\n                dispatchAppSigningBox(obj, params.request_data, params.app_request_id, this.client);\n            }\n            else if (responseType === 4) {\n                dispatchAppSigningBox(obj, params, null, this.client);\n            }\n        });\n    }\n    /**\n     * Creates a default signing box implementation.\n     *\n     * @param {KeyPair} params\n     * @returns RegisteredSigningBox\n     */\n    get_signing_box(params) {\n        return this.client.request('crypto.get_signing_box', params);\n    }\n    /**\n     * Returns public key of signing key pair.\n     *\n     * @param {RegisteredSigningBox} params\n     * @returns ResultOfSigningBoxGetPublicKey\n     */\n    signing_box_get_public_key(params) {\n        return this.client.request('crypto.signing_box_get_public_key', params);\n    }\n    /**\n     * Returns signed user data.\n     *\n     * @param {ParamsOfSigningBoxSign} params\n     * @returns ResultOfSigningBoxSign\n     */\n    signing_box_sign(params) {\n        return this.client.request('crypto.signing_box_sign', params);\n    }\n    /**\n     * Removes signing box from SDK.\n     *\n     * @param {RegisteredSigningBox} params\n     * @returns\n     */\n    remove_signing_box(params) {\n        return this.client.request('crypto.remove_signing_box', params);\n    }\n    /**\n     * Register an application implemented encryption box.\n     * @returns RegisteredEncryptionBox\n     */\n    register_encryption_box(obj) {\n        return this.client.request('crypto.register_encryption_box', undefined, (params, responseType) => {\n            if (responseType === 3) {\n                dispatchAppEncryptionBox(obj, params.request_data, params.app_request_id, this.client);\n            }\n            else if (responseType === 4) {\n                dispatchAppEncryptionBox(obj, params, null, this.client);\n            }\n        });\n    }\n    /**\n     * Removes encryption box from SDK\n     *\n     * @param {RegisteredEncryptionBox} params\n     * @returns\n     */\n    remove_encryption_box(params) {\n        return this.client.request('crypto.remove_encryption_box', params);\n    }\n    /**\n     * Queries info from the given encryption box\n     *\n     * @param {ParamsOfEncryptionBoxGetInfo} params\n     * @returns ResultOfEncryptionBoxGetInfo\n     */\n    encryption_box_get_info(params) {\n        return this.client.request('crypto.encryption_box_get_info', params);\n    }\n    /**\n     * Encrypts data using given encryption box Note.\n     *\n     * @remarks\n     * Block cipher algorithms pad data to cipher block size so encrypted data can be longer then original data. Client should store the original data size after encryption and use it after\n     * decryption to retrieve the original data from decrypted data.\n     *\n     * @param {ParamsOfEncryptionBoxEncrypt} params\n     * @returns ResultOfEncryptionBoxEncrypt\n     */\n    encryption_box_encrypt(params) {\n        return this.client.request('crypto.encryption_box_encrypt', params);\n    }\n    /**\n     * Decrypts data using given encryption box Note.\n     *\n     * @remarks\n     * Block cipher algorithms pad data to cipher block size so encrypted data can be longer then original data. Client should store the original data size after encryption and use it after\n     * decryption to retrieve the original data from decrypted data.\n     *\n     * @param {ParamsOfEncryptionBoxDecrypt} params\n     * @returns ResultOfEncryptionBoxDecrypt\n     */\n    encryption_box_decrypt(params) {\n        return this.client.request('crypto.encryption_box_decrypt', params);\n    }\n    /**\n     * Creates encryption box with specified algorithm\n     *\n     * @param {ParamsOfCreateEncryptionBox} params\n     * @returns RegisteredEncryptionBox\n     */\n    create_encryption_box(params) {\n        return this.client.request('crypto.create_encryption_box', params);\n    }\n}\nexports.CryptoModule = CryptoModule;\n// abi module\nvar AbiErrorCode;\n(function (AbiErrorCode) {\n    AbiErrorCode[AbiErrorCode[\"RequiredAddressMissingForEncodeMessage\"] = 301] = \"RequiredAddressMissingForEncodeMessage\";\n    AbiErrorCode[AbiErrorCode[\"RequiredCallSetMissingForEncodeMessage\"] = 302] = \"RequiredCallSetMissingForEncodeMessage\";\n    AbiErrorCode[AbiErrorCode[\"InvalidJson\"] = 303] = \"InvalidJson\";\n    AbiErrorCode[AbiErrorCode[\"InvalidMessage\"] = 304] = \"InvalidMessage\";\n    AbiErrorCode[AbiErrorCode[\"EncodeDeployMessageFailed\"] = 305] = \"EncodeDeployMessageFailed\";\n    AbiErrorCode[AbiErrorCode[\"EncodeRunMessageFailed\"] = 306] = \"EncodeRunMessageFailed\";\n    AbiErrorCode[AbiErrorCode[\"AttachSignatureFailed\"] = 307] = \"AttachSignatureFailed\";\n    AbiErrorCode[AbiErrorCode[\"InvalidTvcImage\"] = 308] = \"InvalidTvcImage\";\n    AbiErrorCode[AbiErrorCode[\"RequiredPublicKeyMissingForFunctionHeader\"] = 309] = \"RequiredPublicKeyMissingForFunctionHeader\";\n    AbiErrorCode[AbiErrorCode[\"InvalidSigner\"] = 310] = \"InvalidSigner\";\n    AbiErrorCode[AbiErrorCode[\"InvalidAbi\"] = 311] = \"InvalidAbi\";\n    AbiErrorCode[AbiErrorCode[\"InvalidFunctionId\"] = 312] = \"InvalidFunctionId\";\n    AbiErrorCode[AbiErrorCode[\"InvalidData\"] = 313] = \"InvalidData\";\n    AbiErrorCode[AbiErrorCode[\"EncodeInitialDataFailed\"] = 314] = \"EncodeInitialDataFailed\";\n    AbiErrorCode[AbiErrorCode[\"InvalidFunctionName\"] = 315] = \"InvalidFunctionName\";\n})(AbiErrorCode = exports.AbiErrorCode || (exports.AbiErrorCode = {}));\nfunction abiContract(value) {\n    return {\n        type: 'Contract',\n        value,\n    };\n}\nexports.abiContract = abiContract;\nfunction abiJson(value) {\n    return {\n        type: 'Json',\n        value,\n    };\n}\nexports.abiJson = abiJson;\nfunction abiHandle(value) {\n    return {\n        type: 'Handle',\n        value,\n    };\n}\nexports.abiHandle = abiHandle;\nfunction abiSerialized(value) {\n    return {\n        type: 'Serialized',\n        value,\n    };\n}\nexports.abiSerialized = abiSerialized;\nfunction signerNone() {\n    return {\n        type: 'None',\n    };\n}\nexports.signerNone = signerNone;\nfunction signerExternal(public_key) {\n    return {\n        type: 'External',\n        public_key,\n    };\n}\nexports.signerExternal = signerExternal;\nfunction signerKeys(keys) {\n    return {\n        type: 'Keys',\n        keys,\n    };\n}\nexports.signerKeys = signerKeys;\nfunction signerSigningBox(handle) {\n    return {\n        type: 'SigningBox',\n        handle,\n    };\n}\nexports.signerSigningBox = signerSigningBox;\nvar MessageBodyType;\n(function (MessageBodyType) {\n    MessageBodyType[\"Input\"] = \"Input\";\n    MessageBodyType[\"Output\"] = \"Output\";\n    MessageBodyType[\"InternalOutput\"] = \"InternalOutput\";\n    MessageBodyType[\"Event\"] = \"Event\";\n})(MessageBodyType = exports.MessageBodyType || (exports.MessageBodyType = {}));\nfunction stateInitSourceMessage(source) {\n    return {\n        type: 'Message',\n        source,\n    };\n}\nexports.stateInitSourceMessage = stateInitSourceMessage;\nfunction stateInitSourceStateInit(code, data, library) {\n    return {\n        type: 'StateInit',\n        code,\n        data,\n        library,\n    };\n}\nexports.stateInitSourceStateInit = stateInitSourceStateInit;\nfunction stateInitSourceTvc(tvc, public_key, init_params) {\n    return {\n        type: 'Tvc',\n        tvc,\n        public_key,\n        init_params,\n    };\n}\nexports.stateInitSourceTvc = stateInitSourceTvc;\nfunction messageSourceEncoded(message, abi) {\n    return {\n        type: 'Encoded',\n        message,\n        abi,\n    };\n}\nexports.messageSourceEncoded = messageSourceEncoded;\nfunction messageSourceEncodingParams(params) {\n    return Object.assign({ type: 'EncodingParams' }, params);\n}\nexports.messageSourceEncodingParams = messageSourceEncodingParams;\n/**\n * Provides message encoding and decoding according to the ABI specification.\n */\nclass AbiModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Encodes message body according to ABI function call.\n     *\n     * @param {ParamsOfEncodeMessageBody} params\n     * @returns ResultOfEncodeMessageBody\n     */\n    encode_message_body(params) {\n        return this.client.request('abi.encode_message_body', params);\n    }\n    /**\n     *\n     * @param {ParamsOfAttachSignatureToMessageBody} params\n     * @returns ResultOfAttachSignatureToMessageBody\n     */\n    attach_signature_to_message_body(params) {\n        return this.client.request('abi.attach_signature_to_message_body', params);\n    }\n    /**\n     * Encodes an ABI-compatible message\n     *\n     * @remarks\n     * Allows to encode deploy and function call messages,\n     * both signed and unsigned.\n     *\n     * Use cases include messages of any possible type:\n     * - deploy with initial function call (i.e. `constructor` or any other function that is used for some kind\n     * of initialization);\n     * - deploy without initial function call;\n     * - signed/unsigned + data for signing.\n     *\n     * `Signer` defines how the message should or shouldn't be signed:\n     *\n     * `Signer::None` creates an unsigned message. This may be needed in case of some public methods,\n     * that do not require authorization by pubkey.\n     *\n     * `Signer::External` takes public key and returns `data_to_sign` for later signing.\n     * Use `attach_signature` method with the result signature to get the signed message.\n     *\n     * `Signer::Keys` creates a signed message with provided key pair.\n     *\n     * [SOON] `Signer::SigningBox` Allows using a special interface to implement signing\n     * without private key disclosure to SDK. For instance, in case of using a cold wallet or HSM,\n     * when application calls some API to sign data.\n     *\n     * There is an optional public key can be provided in deploy set in order to substitute one\n     * in TVM file.\n     *\n     * Public key resolving priority:\n     * 1. Public key from deploy set.\n     * 2. Public key, specified in TVM file.\n     * 3. Public key, provided by signer.\n     *\n     * @param {ParamsOfEncodeMessage} params\n     * @returns ResultOfEncodeMessage\n     */\n    encode_message(params) {\n        return this.client.request('abi.encode_message', params);\n    }\n    /**\n     * Encodes an internal ABI-compatible message\n     *\n     * @remarks\n     * Allows to encode deploy and function call messages.\n     *\n     * Use cases include messages of any possible type:\n     * - deploy with initial function call (i.e. `constructor` or any other function that is used for some kind\n     * of initialization);\n     * - deploy without initial function call;\n     * - simple function call\n     *\n     * There is an optional public key can be provided in deploy set in order to substitute one\n     * in TVM file.\n     *\n     * Public key resolving priority:\n     * 1. Public key from deploy set.\n     * 2. Public key, specified in TVM file.\n     *\n     * @param {ParamsOfEncodeInternalMessage} params\n     * @returns ResultOfEncodeInternalMessage\n     */\n    encode_internal_message(params) {\n        return this.client.request('abi.encode_internal_message', params);\n    }\n    /**\n     * Combines `hex`-encoded `signature` with `base64`-encoded `unsigned_message`. Returns signed message encoded in `base64`.\n     *\n     * @param {ParamsOfAttachSignature} params\n     * @returns ResultOfAttachSignature\n     */\n    attach_signature(params) {\n        return this.client.request('abi.attach_signature', params);\n    }\n    /**\n     * Decodes message body using provided message BOC and ABI.\n     *\n     * @param {ParamsOfDecodeMessage} params\n     * @returns DecodedMessageBody\n     */\n    decode_message(params) {\n        return this.client.request('abi.decode_message', params);\n    }\n    /**\n     * Decodes message body using provided body BOC and ABI.\n     *\n     * @param {ParamsOfDecodeMessageBody} params\n     * @returns DecodedMessageBody\n     */\n    decode_message_body(params) {\n        return this.client.request('abi.decode_message_body', params);\n    }\n    /**\n     * Creates account state BOC\n     *\n     * @remarks\n     * Creates account state provided with one of these sets of data :\n     * 1. BOC of code, BOC of data, BOC of library\n     * 2. TVC (string in `base64`), keys, init params\n     *\n     * @param {ParamsOfEncodeAccount} params\n     * @returns ResultOfEncodeAccount\n     */\n    encode_account(params) {\n        return this.client.request('abi.encode_account', params);\n    }\n    /**\n     * Decodes account data using provided data BOC and ABI.\n     *\n     * @remarks\n     * Note: this feature requires ABI 2.1 or higher.\n     *\n     * @param {ParamsOfDecodeAccountData} params\n     * @returns ResultOfDecodeAccountData\n     */\n    decode_account_data(params) {\n        return this.client.request('abi.decode_account_data', params);\n    }\n    /**\n     * Updates initial account data with initial values for the contract's static variables and owner's public key. This operation is applicable only for initial account data (before deploy). If the contract is already deployed, its data doesn't contain this data section any more.\n     *\n     * @param {ParamsOfUpdateInitialData} params\n     * @returns ResultOfUpdateInitialData\n     */\n    update_initial_data(params) {\n        return this.client.request('abi.update_initial_data', params);\n    }\n    /**\n     * Encodes initial account data with initial values for the contract's static variables and owner's public key into a data BOC that can be passed to `encode_tvc` function afterwards.\n     *\n     * @remarks\n     * This function is analogue of `tvm.buildDataInit` function in Solidity.\n     *\n     * @param {ParamsOfEncodeInitialData} params\n     * @returns ResultOfEncodeInitialData\n     */\n    encode_initial_data(params) {\n        return this.client.request('abi.encode_initial_data', params);\n    }\n    /**\n     * Decodes initial values of a contract's static variables and owner's public key from account initial data This operation is applicable only for initial account data (before deploy). If the contract is already deployed, its data doesn't contain this data section any more.\n     *\n     * @param {ParamsOfDecodeInitialData} params\n     * @returns ResultOfDecodeInitialData\n     */\n    decode_initial_data(params) {\n        return this.client.request('abi.decode_initial_data', params);\n    }\n    /**\n     * Decodes BOC into JSON as a set of provided parameters.\n     *\n     * @remarks\n     * Solidity functions use ABI types for [builder encoding](https://github.com/tonlabs/TON-Solidity-Compiler/blob/master/API.md#tvmbuilderstore).\n     * The simplest way to decode such a BOC is to use ABI decoding.\n     * ABI has it own rules for fields layout in cells so manually encoded\n     * BOC can not be described in terms of ABI rules.\n     *\n     * To solve this problem we introduce a new ABI type `Ref(<ParamType>)`\n     * which allows to store `ParamType` ABI parameter in cell reference and, thus,\n     * decode manually encoded BOCs. This type is available only in `decode_boc` function\n     * and will not be available in ABI messages encoding until it is included into some ABI revision.\n     *\n     * Such BOC descriptions covers most users needs. If someone wants to decode some BOC which\n     * can not be described by these rules (i.e. BOC with TLB containing constructors of flags\n     * defining some parsing conditions) then they can decode the fields up to fork condition,\n     * check the parsed data manually, expand the parsing schema and then decode the whole BOC\n     * with the full schema.\n     *\n     * @param {ParamsOfDecodeBoc} params\n     * @returns ResultOfDecodeBoc\n     */\n    decode_boc(params) {\n        return this.client.request('abi.decode_boc', params);\n    }\n    /**\n     * Encodes given parameters in JSON into a BOC using param types from ABI.\n     *\n     * @param {ParamsOfAbiEncodeBoc} params\n     * @returns ResultOfAbiEncodeBoc\n     */\n    encode_boc(params) {\n        return this.client.request('abi.encode_boc', params);\n    }\n    /**\n     * Calculates contract function ID by contract ABI\n     *\n     * @param {ParamsOfCalcFunctionId} params\n     * @returns ResultOfCalcFunctionId\n     */\n    calc_function_id(params) {\n        return this.client.request('abi.calc_function_id', params);\n    }\n}\nexports.AbiModule = AbiModule;\nfunction bocCacheTypePinned(pin) {\n    return {\n        type: 'Pinned',\n        pin,\n    };\n}\nexports.bocCacheTypePinned = bocCacheTypePinned;\nfunction bocCacheTypeUnpinned() {\n    return {\n        type: 'Unpinned',\n    };\n}\nexports.bocCacheTypeUnpinned = bocCacheTypeUnpinned;\nvar BocErrorCode;\n(function (BocErrorCode) {\n    BocErrorCode[BocErrorCode[\"InvalidBoc\"] = 201] = \"InvalidBoc\";\n    BocErrorCode[BocErrorCode[\"SerializationError\"] = 202] = \"SerializationError\";\n    BocErrorCode[BocErrorCode[\"InappropriateBlock\"] = 203] = \"InappropriateBlock\";\n    BocErrorCode[BocErrorCode[\"MissingSourceBoc\"] = 204] = \"MissingSourceBoc\";\n    BocErrorCode[BocErrorCode[\"InsufficientCacheSize\"] = 205] = \"InsufficientCacheSize\";\n    BocErrorCode[BocErrorCode[\"BocRefNotFound\"] = 206] = \"BocRefNotFound\";\n    BocErrorCode[BocErrorCode[\"InvalidBocRef\"] = 207] = \"InvalidBocRef\";\n})(BocErrorCode = exports.BocErrorCode || (exports.BocErrorCode = {}));\nfunction builderOpInteger(size, value) {\n    return {\n        type: 'Integer',\n        size,\n        value,\n    };\n}\nexports.builderOpInteger = builderOpInteger;\nfunction builderOpBitString(value) {\n    return {\n        type: 'BitString',\n        value,\n    };\n}\nexports.builderOpBitString = builderOpBitString;\nfunction builderOpCell(builder) {\n    return {\n        type: 'Cell',\n        builder,\n    };\n}\nexports.builderOpCell = builderOpCell;\nfunction builderOpCellBoc(boc) {\n    return {\n        type: 'CellBoc',\n        boc,\n    };\n}\nexports.builderOpCellBoc = builderOpCellBoc;\nfunction builderOpAddress(address) {\n    return {\n        type: 'Address',\n        address,\n    };\n}\nexports.builderOpAddress = builderOpAddress;\n/**\n * BOC manipulation module.\n */\nclass BocModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Parses message boc into a JSON\n     *\n     * @remarks\n     * JSON structure is compatible with GraphQL API message object\n     *\n     * @param {ParamsOfParse} params\n     * @returns ResultOfParse\n     */\n    parse_message(params) {\n        return this.client.request('boc.parse_message', params);\n    }\n    /**\n     * Parses transaction boc into a JSON\n     *\n     * @remarks\n     * JSON structure is compatible with GraphQL API transaction object\n     *\n     * @param {ParamsOfParse} params\n     * @returns ResultOfParse\n     */\n    parse_transaction(params) {\n        return this.client.request('boc.parse_transaction', params);\n    }\n    /**\n     * Parses account boc into a JSON\n     *\n     * @remarks\n     * JSON structure is compatible with GraphQL API account object\n     *\n     * @param {ParamsOfParse} params\n     * @returns ResultOfParse\n     */\n    parse_account(params) {\n        return this.client.request('boc.parse_account', params);\n    }\n    /**\n     * Parses block boc into a JSON\n     *\n     * @remarks\n     * JSON structure is compatible with GraphQL API block object\n     *\n     * @param {ParamsOfParse} params\n     * @returns ResultOfParse\n     */\n    parse_block(params) {\n        return this.client.request('boc.parse_block', params);\n    }\n    /**\n     * Parses shardstate boc into a JSON\n     *\n     * @remarks\n     * JSON structure is compatible with GraphQL API shardstate object\n     *\n     * @param {ParamsOfParseShardstate} params\n     * @returns ResultOfParse\n     */\n    parse_shardstate(params) {\n        return this.client.request('boc.parse_shardstate', params);\n    }\n    /**\n     * Extract blockchain configuration from key block and also from zerostate.\n     *\n     * @param {ParamsOfGetBlockchainConfig} params\n     * @returns ResultOfGetBlockchainConfig\n     */\n    get_blockchain_config(params) {\n        return this.client.request('boc.get_blockchain_config', params);\n    }\n    /**\n     * Calculates BOC root hash\n     *\n     * @param {ParamsOfGetBocHash} params\n     * @returns ResultOfGetBocHash\n     */\n    get_boc_hash(params) {\n        return this.client.request('boc.get_boc_hash', params);\n    }\n    /**\n     * Calculates BOC depth\n     *\n     * @param {ParamsOfGetBocDepth} params\n     * @returns ResultOfGetBocDepth\n     */\n    get_boc_depth(params) {\n        return this.client.request('boc.get_boc_depth', params);\n    }\n    /**\n     * Extracts code from TVC contract image\n     *\n     * @param {ParamsOfGetCodeFromTvc} params\n     * @returns ResultOfGetCodeFromTvc\n     */\n    get_code_from_tvc(params) {\n        return this.client.request('boc.get_code_from_tvc', params);\n    }\n    /**\n     * Get BOC from cache\n     *\n     * @param {ParamsOfBocCacheGet} params\n     * @returns ResultOfBocCacheGet\n     */\n    cache_get(params) {\n        return this.client.request('boc.cache_get', params);\n    }\n    /**\n     * Save BOC into cache or increase pin counter for existing pinned BOC\n     *\n     * @param {ParamsOfBocCacheSet} params\n     * @returns ResultOfBocCacheSet\n     */\n    cache_set(params) {\n        return this.client.request('boc.cache_set', params);\n    }\n    /**\n     * Unpin BOCs with specified pin defined in the `cache_set`. Decrease pin reference counter for BOCs with specified pin defined in the `cache_set`. BOCs which have only 1 pin and its reference counter become 0 will be removed from cache\n     *\n     * @param {ParamsOfBocCacheUnpin} params\n     * @returns\n     */\n    cache_unpin(params) {\n        return this.client.request('boc.cache_unpin', params);\n    }\n    /**\n     * Encodes bag of cells (BOC) with builder operations. This method provides the same functionality as Solidity TvmBuilder. Resulting BOC of this method can be passed into Solidity and C++ contracts as TvmCell type.\n     *\n     * @param {ParamsOfEncodeBoc} params\n     * @returns ResultOfEncodeBoc\n     */\n    encode_boc(params) {\n        return this.client.request('boc.encode_boc', params);\n    }\n    /**\n     * Returns the contract code's salt if it is present.\n     *\n     * @param {ParamsOfGetCodeSalt} params\n     * @returns ResultOfGetCodeSalt\n     */\n    get_code_salt(params) {\n        return this.client.request('boc.get_code_salt', params);\n    }\n    /**\n     * Sets new salt to contract code.\n     *\n     * @remarks\n     * Returns the new contract code with salt.\n     *\n     * @param {ParamsOfSetCodeSalt} params\n     * @returns ResultOfSetCodeSalt\n     */\n    set_code_salt(params) {\n        return this.client.request('boc.set_code_salt', params);\n    }\n    /**\n     * Decodes tvc into code, data, libraries and special options.\n     *\n     * @param {ParamsOfDecodeTvc} params\n     * @returns ResultOfDecodeTvc\n     */\n    decode_tvc(params) {\n        return this.client.request('boc.decode_tvc', params);\n    }\n    /**\n     * Encodes tvc from code, data, libraries ans special options (see input params)\n     *\n     * @param {ParamsOfEncodeTvc} params\n     * @returns ResultOfEncodeTvc\n     */\n    encode_tvc(params) {\n        return this.client.request('boc.encode_tvc', params);\n    }\n    /**\n     * Encodes a message\n     *\n     * @remarks\n     * Allows to encode any external inbound message.\n     *\n     * @param {ParamsOfEncodeExternalInMessage} params\n     * @returns ResultOfEncodeExternalInMessage\n     */\n    encode_external_in_message(params) {\n        return this.client.request('boc.encode_external_in_message', params);\n    }\n    /**\n     * Returns the compiler version used to compile the code.\n     *\n     * @param {ParamsOfGetCompilerVersion} params\n     * @returns ResultOfGetCompilerVersion\n     */\n    get_compiler_version(params) {\n        return this.client.request('boc.get_compiler_version', params);\n    }\n}\nexports.BocModule = BocModule;\n// processing module\nvar ProcessingErrorCode;\n(function (ProcessingErrorCode) {\n    ProcessingErrorCode[ProcessingErrorCode[\"MessageAlreadyExpired\"] = 501] = \"MessageAlreadyExpired\";\n    ProcessingErrorCode[ProcessingErrorCode[\"MessageHasNotDestinationAddress\"] = 502] = \"MessageHasNotDestinationAddress\";\n    ProcessingErrorCode[ProcessingErrorCode[\"CanNotBuildMessageCell\"] = 503] = \"CanNotBuildMessageCell\";\n    ProcessingErrorCode[ProcessingErrorCode[\"FetchBlockFailed\"] = 504] = \"FetchBlockFailed\";\n    ProcessingErrorCode[ProcessingErrorCode[\"SendMessageFailed\"] = 505] = \"SendMessageFailed\";\n    ProcessingErrorCode[ProcessingErrorCode[\"InvalidMessageBoc\"] = 506] = \"InvalidMessageBoc\";\n    ProcessingErrorCode[ProcessingErrorCode[\"MessageExpired\"] = 507] = \"MessageExpired\";\n    ProcessingErrorCode[ProcessingErrorCode[\"TransactionWaitTimeout\"] = 508] = \"TransactionWaitTimeout\";\n    ProcessingErrorCode[ProcessingErrorCode[\"InvalidBlockReceived\"] = 509] = \"InvalidBlockReceived\";\n    ProcessingErrorCode[ProcessingErrorCode[\"CanNotCheckBlockShard\"] = 510] = \"CanNotCheckBlockShard\";\n    ProcessingErrorCode[ProcessingErrorCode[\"BlockNotFound\"] = 511] = \"BlockNotFound\";\n    ProcessingErrorCode[ProcessingErrorCode[\"InvalidData\"] = 512] = \"InvalidData\";\n    ProcessingErrorCode[ProcessingErrorCode[\"ExternalSignerMustNotBeUsed\"] = 513] = \"ExternalSignerMustNotBeUsed\";\n    ProcessingErrorCode[ProcessingErrorCode[\"MessageRejected\"] = 514] = \"MessageRejected\";\n    ProcessingErrorCode[ProcessingErrorCode[\"InvalidRempStatus\"] = 515] = \"InvalidRempStatus\";\n    ProcessingErrorCode[ProcessingErrorCode[\"NextRempStatusTimeout\"] = 516] = \"NextRempStatusTimeout\";\n})(ProcessingErrorCode = exports.ProcessingErrorCode || (exports.ProcessingErrorCode = {}));\nfunction processingEventWillFetchFirstBlock() {\n    return {\n        type: 'WillFetchFirstBlock',\n    };\n}\nexports.processingEventWillFetchFirstBlock = processingEventWillFetchFirstBlock;\nfunction processingEventFetchFirstBlockFailed(error) {\n    return {\n        type: 'FetchFirstBlockFailed',\n        error,\n    };\n}\nexports.processingEventFetchFirstBlockFailed = processingEventFetchFirstBlockFailed;\nfunction processingEventWillSend(shard_block_id, message_id, message) {\n    return {\n        type: 'WillSend',\n        shard_block_id,\n        message_id,\n        message,\n    };\n}\nexports.processingEventWillSend = processingEventWillSend;\nfunction processingEventDidSend(shard_block_id, message_id, message) {\n    return {\n        type: 'DidSend',\n        shard_block_id,\n        message_id,\n        message,\n    };\n}\nexports.processingEventDidSend = processingEventDidSend;\nfunction processingEventSendFailed(shard_block_id, message_id, message, error) {\n    return {\n        type: 'SendFailed',\n        shard_block_id,\n        message_id,\n        message,\n        error,\n    };\n}\nexports.processingEventSendFailed = processingEventSendFailed;\nfunction processingEventWillFetchNextBlock(shard_block_id, message_id, message) {\n    return {\n        type: 'WillFetchNextBlock',\n        shard_block_id,\n        message_id,\n        message,\n    };\n}\nexports.processingEventWillFetchNextBlock = processingEventWillFetchNextBlock;\nfunction processingEventFetchNextBlockFailed(shard_block_id, message_id, message, error) {\n    return {\n        type: 'FetchNextBlockFailed',\n        shard_block_id,\n        message_id,\n        message,\n        error,\n    };\n}\nexports.processingEventFetchNextBlockFailed = processingEventFetchNextBlockFailed;\nfunction processingEventMessageExpired(message_id, message, error) {\n    return {\n        type: 'MessageExpired',\n        message_id,\n        message,\n        error,\n    };\n}\nexports.processingEventMessageExpired = processingEventMessageExpired;\nfunction processingEventRempSentToValidators(message_id, timestamp, json) {\n    return {\n        type: 'RempSentToValidators',\n        message_id,\n        timestamp,\n        json,\n    };\n}\nexports.processingEventRempSentToValidators = processingEventRempSentToValidators;\nfunction processingEventRempIncludedIntoBlock(message_id, timestamp, json) {\n    return {\n        type: 'RempIncludedIntoBlock',\n        message_id,\n        timestamp,\n        json,\n    };\n}\nexports.processingEventRempIncludedIntoBlock = processingEventRempIncludedIntoBlock;\nfunction processingEventRempIncludedIntoAcceptedBlock(message_id, timestamp, json) {\n    return {\n        type: 'RempIncludedIntoAcceptedBlock',\n        message_id,\n        timestamp,\n        json,\n    };\n}\nexports.processingEventRempIncludedIntoAcceptedBlock = processingEventRempIncludedIntoAcceptedBlock;\nfunction processingEventRempOther(message_id, timestamp, json) {\n    return {\n        type: 'RempOther',\n        message_id,\n        timestamp,\n        json,\n    };\n}\nexports.processingEventRempOther = processingEventRempOther;\nfunction processingEventRempError(error) {\n    return {\n        type: 'RempError',\n        error,\n    };\n}\nexports.processingEventRempError = processingEventRempError;\n/**\n * Message processing module.\n *\n * @remarks\n * This module incorporates functions related to complex message\n * processing scenarios.\n */\nclass ProcessingModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Sends message to the network\n     *\n     * @remarks\n     * Sends message to the network and returns the last generated shard block of the destination account\n     * before the message was sent. It will be required later for message processing.\n     *\n     * @param {ParamsOfSendMessage} params\n     * @returns ResultOfSendMessage\n     */\n    send_message(params, responseHandler) {\n        return this.client.request('processing.send_message', params, responseHandler);\n    }\n    /**\n     * Performs monitoring of the network for the result transaction of the external inbound message processing.\n     *\n     * @remarks\n     * `send_events` enables intermediate events, such as `WillFetchNextBlock`,\n     * `FetchNextBlockFailed` that may be useful for logging of new shard blocks creation\n     * during message processing.\n     *\n     * Note, that presence of the `abi` parameter is critical for ABI\n     * compliant contracts. Message processing uses drastically\n     * different strategy for processing message for contracts which\n     * ABI includes \"expire\" header.\n     *\n     * When the ABI header `expire` is present, the processing uses\n     * `message expiration` strategy:\n     * - The maximum block gen time is set to\n     *   `message_expiration_timeout + transaction_wait_timeout`.\n     * - When maximum block gen time is reached, the processing will\n     *   be finished with `MessageExpired` error.\n     *\n     * When the ABI header `expire` isn't present or `abi` parameter\n     * isn't specified, the processing uses `transaction waiting`\n     * strategy:\n     * - The maximum block gen time is set to\n     *   `now() + transaction_wait_timeout`.\n     *\n     * - If maximum block gen time is reached and no result transaction is found,\n     * the processing will exit with an error.\n     *\n     * @param {ParamsOfWaitForTransaction} params\n     * @returns ResultOfProcessMessage\n     */\n    wait_for_transaction(params, responseHandler) {\n        return this.client.request('processing.wait_for_transaction', params, responseHandler);\n    }\n    /**\n     * Creates message, sends it to the network and monitors its processing.\n     *\n     * @remarks\n     * Creates ABI-compatible message,\n     * sends it to the network and monitors for the result transaction.\n     * Decodes the output messages' bodies.\n     *\n     * If contract's ABI includes \"expire\" header, then\n     * SDK implements retries in case of unsuccessful message delivery within the expiration\n     * timeout: SDK recreates the message, sends it and processes it again.\n     *\n     * The intermediate events, such as `WillFetchFirstBlock`, `WillSend`, `DidSend`,\n     * `WillFetchNextBlock`, etc - are switched on/off by `send_events` flag\n     * and logged into the supplied callback function.\n     *\n     * The retry configuration parameters are defined in the client's `NetworkConfig` and `AbiConfig`.\n     *\n     * If contract's ABI does not include \"expire\" header\n     * then, if no transaction is found within the network timeout (see config parameter ), exits with error.\n     *\n     * @param {ParamsOfProcessMessage} params\n     * @returns ResultOfProcessMessage\n     */\n    process_message(params, responseHandler) {\n        return this.client.request('processing.process_message', params, responseHandler);\n    }\n}\nexports.ProcessingModule = ProcessingModule;\nfunction addressStringFormatAccountId() {\n    return {\n        type: 'AccountId',\n    };\n}\nexports.addressStringFormatAccountId = addressStringFormatAccountId;\nfunction addressStringFormatHex() {\n    return {\n        type: 'Hex',\n    };\n}\nexports.addressStringFormatHex = addressStringFormatHex;\nfunction addressStringFormatBase64(url, test, bounce) {\n    return {\n        type: 'Base64',\n        url,\n        test,\n        bounce,\n    };\n}\nexports.addressStringFormatBase64 = addressStringFormatBase64;\nvar AccountAddressType;\n(function (AccountAddressType) {\n    AccountAddressType[\"AccountId\"] = \"AccountId\";\n    AccountAddressType[\"Hex\"] = \"Hex\";\n    AccountAddressType[\"Base64\"] = \"Base64\";\n})(AccountAddressType = exports.AccountAddressType || (exports.AccountAddressType = {}));\n/**\n * Misc utility Functions.\n */\nclass UtilsModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Converts address from any TON format to any TON format\n     *\n     * @param {ParamsOfConvertAddress} params\n     * @returns ResultOfConvertAddress\n     */\n    convert_address(params) {\n        return this.client.request('utils.convert_address', params);\n    }\n    /**\n     * Validates and returns the type of any TON address.\n     *\n     * @remarks\n     * Address types are the following\n     *\n     * `0:919db8e740d50bf349df2eea03fa30c385d846b991ff5542e67098ee833fc7f7` - standard TON address most\n     * commonly used in all cases. Also called as hex address\n     * `919db8e740d50bf349df2eea03fa30c385d846b991ff5542e67098ee833fc7f7` - account ID. A part of full\n     * address. Identifies account inside particular workchain\n     * `EQCRnbjnQNUL80nfLuoD+jDDhdhGuZH/VULmcJjugz/H9wam` - base64 address. Also called \"user-friendly\".\n     * Was used at the beginning of TON. Now it is supported for compatibility\n     *\n     * @param {ParamsOfGetAddressType} params\n     * @returns ResultOfGetAddressType\n     */\n    get_address_type(params) {\n        return this.client.request('utils.get_address_type', params);\n    }\n    /**\n     * Calculates storage fee for an account over a specified time period\n     *\n     * @param {ParamsOfCalcStorageFee} params\n     * @returns ResultOfCalcStorageFee\n     */\n    calc_storage_fee(params) {\n        return this.client.request('utils.calc_storage_fee', params);\n    }\n    /**\n     * Compresses data using Zstandard algorithm\n     *\n     * @param {ParamsOfCompressZstd} params\n     * @returns ResultOfCompressZstd\n     */\n    compress_zstd(params) {\n        return this.client.request('utils.compress_zstd', params);\n    }\n    /**\n     * Decompresses data using Zstandard algorithm\n     *\n     * @param {ParamsOfDecompressZstd} params\n     * @returns ResultOfDecompressZstd\n     */\n    decompress_zstd(params) {\n        return this.client.request('utils.decompress_zstd', params);\n    }\n}\nexports.UtilsModule = UtilsModule;\n// tvm module\nvar TvmErrorCode;\n(function (TvmErrorCode) {\n    TvmErrorCode[TvmErrorCode[\"CanNotReadTransaction\"] = 401] = \"CanNotReadTransaction\";\n    TvmErrorCode[TvmErrorCode[\"CanNotReadBlockchainConfig\"] = 402] = \"CanNotReadBlockchainConfig\";\n    TvmErrorCode[TvmErrorCode[\"TransactionAborted\"] = 403] = \"TransactionAborted\";\n    TvmErrorCode[TvmErrorCode[\"InternalError\"] = 404] = \"InternalError\";\n    TvmErrorCode[TvmErrorCode[\"ActionPhaseFailed\"] = 405] = \"ActionPhaseFailed\";\n    TvmErrorCode[TvmErrorCode[\"AccountCodeMissing\"] = 406] = \"AccountCodeMissing\";\n    TvmErrorCode[TvmErrorCode[\"LowBalance\"] = 407] = \"LowBalance\";\n    TvmErrorCode[TvmErrorCode[\"AccountFrozenOrDeleted\"] = 408] = \"AccountFrozenOrDeleted\";\n    TvmErrorCode[TvmErrorCode[\"AccountMissing\"] = 409] = \"AccountMissing\";\n    TvmErrorCode[TvmErrorCode[\"UnknownExecutionError\"] = 410] = \"UnknownExecutionError\";\n    TvmErrorCode[TvmErrorCode[\"InvalidInputStack\"] = 411] = \"InvalidInputStack\";\n    TvmErrorCode[TvmErrorCode[\"InvalidAccountBoc\"] = 412] = \"InvalidAccountBoc\";\n    TvmErrorCode[TvmErrorCode[\"InvalidMessageType\"] = 413] = \"InvalidMessageType\";\n    TvmErrorCode[TvmErrorCode[\"ContractExecutionError\"] = 414] = \"ContractExecutionError\";\n})(TvmErrorCode = exports.TvmErrorCode || (exports.TvmErrorCode = {}));\nfunction accountForExecutorNone() {\n    return {\n        type: 'None',\n    };\n}\nexports.accountForExecutorNone = accountForExecutorNone;\nfunction accountForExecutorUninit() {\n    return {\n        type: 'Uninit',\n    };\n}\nexports.accountForExecutorUninit = accountForExecutorUninit;\nfunction accountForExecutorAccount(boc, unlimited_balance) {\n    return {\n        type: 'Account',\n        boc,\n        unlimited_balance,\n    };\n}\nexports.accountForExecutorAccount = accountForExecutorAccount;\nclass TvmModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Emulates all the phases of contract execution locally\n     *\n     * @remarks\n     * Performs all the phases of contract execution on Transaction Executor -\n     * the same component that is used on Validator Nodes.\n     *\n     * Can be used for contract debugging, to find out the reason why a message was not delivered successfully.\n     * Validators throw away the failed external inbound messages (if they failed bedore `ACCEPT`) in the real network.\n     * This is why these messages are impossible to debug in the real network.\n     * With the help of run_executor you can do that. In fact, `process_message` function\n     * performs local check with `run_executor` if there was no transaction as a result of processing\n     * and returns the error, if there is one.\n     *\n     * Another use case to use `run_executor` is to estimate fees for message execution.\n     * Set  `AccountForExecutor::Account.unlimited_balance`\n     * to `true` so that emulation will not depend on the actual balance.\n     * This may be needed to calculate deploy fees for an account that does not exist yet.\n     * JSON with fees is in `fees` field of the result.\n     *\n     * One more use case - you can produce the sequence of operations,\n     * thus emulating the sequential contract calls locally.\n     * And so on.\n     *\n     * Transaction executor requires account BOC (bag of cells) as a parameter.\n     * To get the account BOC - use `net.query` method to download it from GraphQL API\n     * (field `boc` of `account`) or generate it with `abi.encode_account` method.\n     *\n     * Also it requires message BOC. To get the message BOC - use `abi.encode_message` or `abi.encode_internal_message`.\n     *\n     * If you need this emulation to be as precise as possible (for instance - emulate transaction\n     * with particular lt in particular block or use particular blockchain config,\n     * downloaded from a particular key block - then specify `execution_options` parameter.\n     *\n     * If you need to see the aborted transaction as a result, not as an error, set `skip_transaction_check` to `true`.\n     *\n     * @param {ParamsOfRunExecutor} params\n     * @returns ResultOfRunExecutor\n     */\n    run_executor(params) {\n        return this.client.request('tvm.run_executor', params);\n    }\n    /**\n     * Executes get-methods of ABI-compatible contracts\n     *\n     * @remarks\n     * Performs only a part of compute phase of transaction execution\n     * that is used to run get-methods of ABI-compatible contracts.\n     *\n     * If you try to run get-methods with `run_executor` you will get an error, because it checks ACCEPT and exits\n     * if there is none, which is actually true for get-methods.\n     *\n     *  To get the account BOC (bag of cells) - use `net.query` method to download it from GraphQL API\n     * (field `boc` of `account`) or generate it with `abi.encode_account method`.\n     * To get the message BOC - use `abi.encode_message` or prepare it any other way, for instance, with FIFT script.\n     *\n     * Attention! Updated account state is produces as well, but only\n     * `account_state.storage.state.data`  part of the BOC is updated.\n     *\n     * @param {ParamsOfRunTvm} params\n     * @returns ResultOfRunTvm\n     */\n    run_tvm(params) {\n        return this.client.request('tvm.run_tvm', params);\n    }\n    /**\n     * Executes a get-method of FIFT contract\n     *\n     * @remarks\n     * Executes a get-method of FIFT contract that fulfills the smc-guidelines https://test.ton.org/smc-guidelines.txt\n     * and returns the result data from TVM's stack\n     *\n     * @param {ParamsOfRunGet} params\n     * @returns ResultOfRunGet\n     */\n    run_get(params) {\n        return this.client.request('tvm.run_get', params);\n    }\n}\nexports.TvmModule = TvmModule;\n// net module\nvar NetErrorCode;\n(function (NetErrorCode) {\n    NetErrorCode[NetErrorCode[\"QueryFailed\"] = 601] = \"QueryFailed\";\n    NetErrorCode[NetErrorCode[\"SubscribeFailed\"] = 602] = \"SubscribeFailed\";\n    NetErrorCode[NetErrorCode[\"WaitForFailed\"] = 603] = \"WaitForFailed\";\n    NetErrorCode[NetErrorCode[\"GetSubscriptionResultFailed\"] = 604] = \"GetSubscriptionResultFailed\";\n    NetErrorCode[NetErrorCode[\"InvalidServerResponse\"] = 605] = \"InvalidServerResponse\";\n    NetErrorCode[NetErrorCode[\"ClockOutOfSync\"] = 606] = \"ClockOutOfSync\";\n    NetErrorCode[NetErrorCode[\"WaitForTimeout\"] = 607] = \"WaitForTimeout\";\n    NetErrorCode[NetErrorCode[\"GraphqlError\"] = 608] = \"GraphqlError\";\n    NetErrorCode[NetErrorCode[\"NetworkModuleSuspended\"] = 609] = \"NetworkModuleSuspended\";\n    NetErrorCode[NetErrorCode[\"WebsocketDisconnected\"] = 610] = \"WebsocketDisconnected\";\n    NetErrorCode[NetErrorCode[\"NotSupported\"] = 611] = \"NotSupported\";\n    NetErrorCode[NetErrorCode[\"NoEndpointsProvided\"] = 612] = \"NoEndpointsProvided\";\n    NetErrorCode[NetErrorCode[\"GraphqlWebsocketInitError\"] = 613] = \"GraphqlWebsocketInitError\";\n    NetErrorCode[NetErrorCode[\"NetworkModuleResumed\"] = 614] = \"NetworkModuleResumed\";\n    NetErrorCode[NetErrorCode[\"Unauthorized\"] = 615] = \"Unauthorized\";\n})(NetErrorCode = exports.NetErrorCode || (exports.NetErrorCode = {}));\nvar SortDirection;\n(function (SortDirection) {\n    SortDirection[\"ASC\"] = \"ASC\";\n    SortDirection[\"DESC\"] = \"DESC\";\n})(SortDirection = exports.SortDirection || (exports.SortDirection = {}));\nfunction paramsOfQueryOperationQueryCollection(params) {\n    return Object.assign({ type: 'QueryCollection' }, params);\n}\nexports.paramsOfQueryOperationQueryCollection = paramsOfQueryOperationQueryCollection;\nfunction paramsOfQueryOperationWaitForCollection(params) {\n    return Object.assign({ type: 'WaitForCollection' }, params);\n}\nexports.paramsOfQueryOperationWaitForCollection = paramsOfQueryOperationWaitForCollection;\nfunction paramsOfQueryOperationAggregateCollection(params) {\n    return Object.assign({ type: 'AggregateCollection' }, params);\n}\nexports.paramsOfQueryOperationAggregateCollection = paramsOfQueryOperationAggregateCollection;\nfunction paramsOfQueryOperationQueryCounterparties(params) {\n    return Object.assign({ type: 'QueryCounterparties' }, params);\n}\nexports.paramsOfQueryOperationQueryCounterparties = paramsOfQueryOperationQueryCounterparties;\nvar AggregationFn;\n(function (AggregationFn) {\n    AggregationFn[\"COUNT\"] = \"COUNT\";\n    AggregationFn[\"MIN\"] = \"MIN\";\n    AggregationFn[\"MAX\"] = \"MAX\";\n    AggregationFn[\"SUM\"] = \"SUM\";\n    AggregationFn[\"AVERAGE\"] = \"AVERAGE\";\n})(AggregationFn = exports.AggregationFn || (exports.AggregationFn = {}));\n/**\n * Network access.\n */\nclass NetModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Performs DAppServer GraphQL query.\n     *\n     * @param {ParamsOfQuery} params\n     * @returns ResultOfQuery\n     */\n    query(params) {\n        return this.client.request('net.query', params);\n    }\n    /**\n     * Performs multiple queries per single fetch.\n     *\n     * @param {ParamsOfBatchQuery} params\n     * @returns ResultOfBatchQuery\n     */\n    batch_query(params) {\n        return this.client.request('net.batch_query', params);\n    }\n    /**\n     * Queries collection data\n     *\n     * @remarks\n     * Queries data that satisfies the `filter` conditions,\n     * limits the number of returned records and orders them.\n     * The projection fields are limited to `result` fields\n     *\n     * @param {ParamsOfQueryCollection} params\n     * @returns ResultOfQueryCollection\n     */\n    query_collection(params) {\n        return this.client.request('net.query_collection', params);\n    }\n    /**\n     * Aggregates collection data.\n     *\n     * @remarks\n     * Aggregates values from the specified `fields` for records\n     * that satisfies the `filter` conditions,\n     *\n     * @param {ParamsOfAggregateCollection} params\n     * @returns ResultOfAggregateCollection\n     */\n    aggregate_collection(params) {\n        return this.client.request('net.aggregate_collection', params);\n    }\n    /**\n     * Returns an object that fulfills the conditions or waits for its appearance\n     *\n     * @remarks\n     * Triggers only once.\n     * If object that satisfies the `filter` conditions\n     * already exists - returns it immediately.\n     * If not - waits for insert/update of data within the specified `timeout`,\n     * and returns it.\n     * The projection fields are limited to `result` fields\n     *\n     * @param {ParamsOfWaitForCollection} params\n     * @returns ResultOfWaitForCollection\n     */\n    wait_for_collection(params) {\n        return this.client.request('net.wait_for_collection', params);\n    }\n    /**\n     * Cancels a subscription\n     *\n     * @remarks\n     * Cancels a subscription specified by its handle.\n     *\n     * @param {ResultOfSubscribeCollection} params\n     * @returns\n     */\n    unsubscribe(params) {\n        return this.client.request('net.unsubscribe', params);\n    }\n    /**\n     * Creates a collection subscription\n     *\n     * @remarks\n     * Triggers for each insert/update of data that satisfies\n     * the `filter` conditions.\n     * The projection fields are limited to `result` fields.\n     *\n     * The subscription is a persistent communication channel between\n     * client and Free TON Network.\n     * All changes in the blockchain will be reflected in realtime.\n     * Changes means inserts and updates of the blockchain entities.\n     *\n     * ### Important Notes on Subscriptions\n     *\n     * Unfortunately sometimes the connection with the network brakes down.\n     * In this situation the library attempts to reconnect to the network.\n     * This reconnection sequence can take significant time.\n     * All of this time the client is disconnected from the network.\n     *\n     * Bad news is that all blockchain changes that happened while\n     * the client was disconnected are lost.\n     *\n     * Good news is that the client report errors to the callback when\n     * it loses and resumes connection.\n     *\n     * So, if the lost changes are important to the application then\n     * the application must handle these error reports.\n     *\n     * Library reports errors with `responseType` == 101\n     * and the error object passed via `params`.\n     *\n     * When the library has successfully reconnected\n     * the application receives callback with\n     * `responseType` == 101 and `params.code` == 614 (NetworkModuleResumed).\n     *\n     * Application can use several ways to handle this situation:\n     * - If application monitors changes for the single blockchain\n     * object (for example specific account):  application\n     * can perform a query for this object and handle actual data as a\n     * regular data from the subscription.\n     * - If application monitors sequence of some blockchain objects\n     * (for example transactions of the specific account): application must\n     * refresh all cached (or visible to user) lists where this sequences presents.\n     *\n     * @param {ParamsOfSubscribeCollection} params\n     * @returns ResultOfSubscribeCollection\n     */\n    subscribe_collection(params, responseHandler) {\n        return this.client.request('net.subscribe_collection', params, responseHandler);\n    }\n    /**\n     * Creates a subscription\n     *\n     * @remarks\n     * The subscription is a persistent communication channel between\n     * client and Everscale Network.\n     *\n     * ### Important Notes on Subscriptions\n     *\n     * Unfortunately sometimes the connection with the network breakes down.\n     * In this situation the library attempts to reconnect to the network.\n     * This reconnection sequence can take significant time.\n     * All of this time the client is disconnected from the network.\n     *\n     * Bad news is that all changes that happened while\n     * the client was disconnected are lost.\n     *\n     * Good news is that the client report errors to the callback when\n     * it loses and resumes connection.\n     *\n     * So, if the lost changes are important to the application then\n     * the application must handle these error reports.\n     *\n     * Library reports errors with `responseType` == 101\n     * and the error object passed via `params`.\n     *\n     * When the library has successfully reconnected\n     * the application receives callback with\n     * `responseType` == 101 and `params.code` == 614 (NetworkModuleResumed).\n     *\n     * Application can use several ways to handle this situation:\n     * - If application monitors changes for the single\n     * object (for example specific account):  application\n     * can perform a query for this object and handle actual data as a\n     * regular data from the subscription.\n     * - If application monitors sequence of some objects\n     * (for example transactions of the specific account): application must\n     * refresh all cached (or visible to user) lists where this sequences presents.\n     *\n     * @param {ParamsOfSubscribe} params\n     * @returns ResultOfSubscribeCollection\n     */\n    subscribe(params, responseHandler) {\n        return this.client.request('net.subscribe', params, responseHandler);\n    }\n    /**\n     * Suspends network module to stop any network activity\n     * @returns\n     */\n    suspend() {\n        return this.client.request('net.suspend');\n    }\n    /**\n     * Resumes network module to enable network activity\n     * @returns\n     */\n    resume() {\n        return this.client.request('net.resume');\n    }\n    /**\n     * Returns ID of the last block in a specified account shard\n     *\n     * @param {ParamsOfFindLastShardBlock} params\n     * @returns ResultOfFindLastShardBlock\n     */\n    find_last_shard_block(params) {\n        return this.client.request('net.find_last_shard_block', params);\n    }\n    /**\n     * Requests the list of alternative endpoints from server\n     * @returns EndpointsSet\n     */\n    fetch_endpoints() {\n        return this.client.request('net.fetch_endpoints');\n    }\n    /**\n     * Sets the list of endpoints to use on reinit\n     *\n     * @param {EndpointsSet} params\n     * @returns\n     */\n    set_endpoints(params) {\n        return this.client.request('net.set_endpoints', params);\n    }\n    /**\n     * Requests the list of alternative endpoints from server\n     * @returns ResultOfGetEndpoints\n     */\n    get_endpoints() {\n        return this.client.request('net.get_endpoints');\n    }\n    /**\n     * Allows to query and paginate through the list of accounts that the specified account has interacted with, sorted by the time of the last internal message between accounts\n     *\n     * @remarks\n     * *Attention* this query retrieves data from 'Counterparties' service which is not supported in\n     * the opensource version of DApp Server (and will not be supported) as well as in Evernode SE (will be supported in SE in future),\n     * but is always accessible via [EVER OS Clouds](../ton-os-api/networks.md)\n     *\n     * @param {ParamsOfQueryCounterparties} params\n     * @returns ResultOfQueryCollection\n     */\n    query_counterparties(params) {\n        return this.client.request('net.query_counterparties', params);\n    }\n    /**\n     * Returns a tree of transactions triggered by a specific message.\n     *\n     * @remarks\n     * Performs recursive retrieval of a transactions tree produced by a specific message:\n     * in_msg -> dst_transaction -> out_messages -> dst_transaction -> ...\n     * If the chain of transactions execution is in progress while the function is running,\n     * it will wait for the next transactions to appear until the full tree or more than 50 transactions\n     * are received.\n     *\n     * All the retrieved messages and transactions are included\n     * into `result.messages` and `result.transactions` respectively.\n     *\n     * Function reads transactions layer by layer, by pages of 20 transactions.\n     *\n     * The retrieval prosess goes like this:\n     * Let's assume we have an infinite chain of transactions and each transaction generates 5 messages.\n     * 1. Retrieve 1st message (input parameter) and corresponding transaction - put it into result.\n     * It is the first level of the tree of transactions - its root.\n     * Retrieve 5 out message ids from the transaction for next steps.\n     * 2. Retrieve 5 messages and corresponding transactions on the 2nd layer. Put them into result.\n     * Retrieve 5*5 out message ids from these transactions for next steps\n     * 3. Retrieve 20 (size of the page) messages and transactions (3rd layer) and 20*5=100 message ids (4th layer).\n     * 4. Retrieve the last 5 messages and 5 transactions on the 3rd layer + 15 messages and transactions (of 100) from the 4th layer\n     * + 25 message ids of the 4th layer + 75 message ids of the 5th layer.\n     * 5. Retrieve 20 more messages and 20 more transactions of the 4th layer + 100 more message ids of the 5th layer.\n     * 6. Now we have 1+5+20+20+20 = 66 transactions, which is more than 50. Function exits with the tree of\n     * 1m->1t->5m->5t->25m->25t->35m->35t. If we see any message ids in the last transactions out_msgs, which don't have\n     * corresponding messages in the function result, it means that the full tree was not received and we need to continue iteration.\n     *\n     * To summarize, it is guaranteed that each message in `result.messages` has the corresponding transaction\n     * in the `result.transactions`.\n     * But there is no guarantee that all messages from transactions `out_msgs` are\n     * presented in `result.messages`.\n     * So the application has to continue retrieval for missing messages if it requires.\n     *\n     * @param {ParamsOfQueryTransactionTree} params\n     * @returns ResultOfQueryTransactionTree\n     */\n    query_transaction_tree(params) {\n        return this.client.request('net.query_transaction_tree', params);\n    }\n    /**\n     * Creates block iterator.\n     *\n     * @remarks\n     * Block iterator uses robust iteration methods that guaranties that every\n     * block in the specified range isn't missed or iterated twice.\n     *\n     * Iterated range can be reduced with some filters:\n     * - `start_time`  the bottom time range. Only blocks with `gen_utime`\n     * more or equal to this value is iterated. If this parameter is omitted then there is\n     * no bottom time edge, so all blocks since zero state is iterated.\n     * - `end_time`  the upper time range. Only blocks with `gen_utime`\n     * less then this value is iterated. If this parameter is omitted then there is\n     * no upper time edge, so iterator never finishes.\n     * - `shard_filter`  workchains and shard prefixes that reduce the set of interesting\n     * blocks. Block conforms to the shard filter if it belongs to the filter workchain\n     * and the first bits of block's `shard` fields matches to the shard prefix.\n     * Only blocks with suitable shard are iterated.\n     *\n     * Items iterated is a JSON objects with block data. The minimal set of returned\n     * fields is:\n     * ```text\n     * id\n     * gen_utime\n     * workchain_id\n     * shard\n     * after_split\n     * after_merge\n     * prev_ref {\n     *     root_hash\n     * }\n     * prev_alt_ref {\n     *     root_hash\n     * }\n     * ```\n     * Application can request additional fields in the `result` parameter.\n     *\n     * Application should call the `remove_iterator` when iterator is no longer required.\n     *\n     * @param {ParamsOfCreateBlockIterator} params\n     * @returns RegisteredIterator\n     */\n    create_block_iterator(params) {\n        return this.client.request('net.create_block_iterator', params);\n    }\n    /**\n     * Resumes block iterator.\n     *\n     * @remarks\n     * The iterator stays exactly at the same position where the `resume_state` was catched.\n     *\n     * Application should call the `remove_iterator` when iterator is no longer required.\n     *\n     * @param {ParamsOfResumeBlockIterator} params\n     * @returns RegisteredIterator\n     */\n    resume_block_iterator(params) {\n        return this.client.request('net.resume_block_iterator', params);\n    }\n    /**\n     * Creates transaction iterator.\n     *\n     * @remarks\n     * Transaction iterator uses robust iteration methods that guaranty that every\n     * transaction in the specified range isn't missed or iterated twice.\n     *\n     * Iterated range can be reduced with some filters:\n     * - `start_time`  the bottom time range. Only transactions with `now`\n     * more or equal to this value are iterated. If this parameter is omitted then there is\n     * no bottom time edge, so all the transactions since zero state are iterated.\n     * - `end_time`  the upper time range. Only transactions with `now`\n     * less then this value are iterated. If this parameter is omitted then there is\n     * no upper time edge, so iterator never finishes.\n     * - `shard_filter`  workchains and shard prefixes that reduce the set of interesting\n     * accounts. Account address conforms to the shard filter if\n     * it belongs to the filter workchain and the first bits of address match to\n     * the shard prefix. Only transactions with suitable account addresses are iterated.\n     * - `accounts_filter`  set of account addresses whose transactions must be iterated.\n     * Note that accounts filter can conflict with shard filter so application must combine\n     * these filters carefully.\n     *\n     * Iterated item is a JSON objects with transaction data. The minimal set of returned\n     * fields is:\n     * ```text\n     * id\n     * account_addr\n     * now\n     * balance_delta(format:DEC)\n     * bounce { bounce_type }\n     * in_message {\n     *     id\n     *     value(format:DEC)\n     *     msg_type\n     *     src\n     * }\n     * out_messages {\n     *     id\n     *     value(format:DEC)\n     *     msg_type\n     *     dst\n     * }\n     * ```\n     * Application can request an additional fields in the `result` parameter.\n     *\n     * Another parameter that affects on the returned fields is the `include_transfers`.\n     * When this parameter is `true` the iterator computes and adds `transfer` field containing\n     * list of the useful `TransactionTransfer` objects.\n     * Each transfer is calculated from the particular message related to the transaction\n     * and has the following structure:\n     * - message  source message identifier.\n     * - isBounced  indicates that the transaction is bounced, which means the value will be returned back to the sender.\n     * - isDeposit  indicates that this transfer is the deposit (true) or withdraw (false).\n     * - counterparty  account address of the transfer source or destination depending on `isDeposit`.\n     * - value  amount of nano tokens transferred. The value is represented as a decimal string\n     * because the actual value can be more precise than the JSON number can represent. Application\n     * must use this string carefully  conversion to number can follow to loose of precision.\n     *\n     * Application should call the `remove_iterator` when iterator is no longer required.\n     *\n     * @param {ParamsOfCreateTransactionIterator} params\n     * @returns RegisteredIterator\n     */\n    create_transaction_iterator(params) {\n        return this.client.request('net.create_transaction_iterator', params);\n    }\n    /**\n     * Resumes transaction iterator.\n     *\n     * @remarks\n     * The iterator stays exactly at the same position where the `resume_state` was caught.\n     * Note that `resume_state` doesn't store the account filter. If the application requires\n     * to use the same account filter as it was when the iterator was created then the application\n     * must pass the account filter again in `accounts_filter` parameter.\n     *\n     * Application should call the `remove_iterator` when iterator is no longer required.\n     *\n     * @param {ParamsOfResumeTransactionIterator} params\n     * @returns RegisteredIterator\n     */\n    resume_transaction_iterator(params) {\n        return this.client.request('net.resume_transaction_iterator', params);\n    }\n    /**\n     * Returns next available items.\n     *\n     * @remarks\n     * In addition to available items this function returns the `has_more` flag\n     * indicating that the iterator isn't reach the end of the iterated range yet.\n     *\n     * This function can return the empty list of available items but\n     * indicates that there are more items is available.\n     * This situation appears when the iterator doesn't reach iterated range\n     * but database doesn't contains available items yet.\n     *\n     * If application requests resume state in `return_resume_state` parameter\n     * then this function returns `resume_state` that can be used later to\n     * resume the iteration from the position after returned items.\n     *\n     * The structure of the items returned depends on the iterator used.\n     * See the description to the appropriated iterator creation function.\n     *\n     * @param {ParamsOfIteratorNext} params\n     * @returns ResultOfIteratorNext\n     */\n    iterator_next(params) {\n        return this.client.request('net.iterator_next', params);\n    }\n    /**\n     * Removes an iterator\n     *\n     * @remarks\n     * Frees all resources allocated in library to serve iterator.\n     *\n     * Application always should call the `remove_iterator` when iterator\n     * is no longer required.\n     *\n     * @param {RegisteredIterator} params\n     * @returns\n     */\n    remove_iterator(params) {\n        return this.client.request('net.remove_iterator', params);\n    }\n}\nexports.NetModule = NetModule;\n// debot module\nvar DebotErrorCode;\n(function (DebotErrorCode) {\n    DebotErrorCode[DebotErrorCode[\"DebotStartFailed\"] = 801] = \"DebotStartFailed\";\n    DebotErrorCode[DebotErrorCode[\"DebotFetchFailed\"] = 802] = \"DebotFetchFailed\";\n    DebotErrorCode[DebotErrorCode[\"DebotExecutionFailed\"] = 803] = \"DebotExecutionFailed\";\n    DebotErrorCode[DebotErrorCode[\"DebotInvalidHandle\"] = 804] = \"DebotInvalidHandle\";\n    DebotErrorCode[DebotErrorCode[\"DebotInvalidJsonParams\"] = 805] = \"DebotInvalidJsonParams\";\n    DebotErrorCode[DebotErrorCode[\"DebotInvalidFunctionId\"] = 806] = \"DebotInvalidFunctionId\";\n    DebotErrorCode[DebotErrorCode[\"DebotInvalidAbi\"] = 807] = \"DebotInvalidAbi\";\n    DebotErrorCode[DebotErrorCode[\"DebotGetMethodFailed\"] = 808] = \"DebotGetMethodFailed\";\n    DebotErrorCode[DebotErrorCode[\"DebotInvalidMsg\"] = 809] = \"DebotInvalidMsg\";\n    DebotErrorCode[DebotErrorCode[\"DebotExternalCallFailed\"] = 810] = \"DebotExternalCallFailed\";\n    DebotErrorCode[DebotErrorCode[\"DebotBrowserCallbackFailed\"] = 811] = \"DebotBrowserCallbackFailed\";\n    DebotErrorCode[DebotErrorCode[\"DebotOperationRejected\"] = 812] = \"DebotOperationRejected\";\n    DebotErrorCode[DebotErrorCode[\"DebotNoCode\"] = 813] = \"DebotNoCode\";\n})(DebotErrorCode = exports.DebotErrorCode || (exports.DebotErrorCode = {}));\nfunction debotActivityTransaction(msg, dst, out, fee, setcode, signkey, signing_box_handle) {\n    return {\n        type: 'Transaction',\n        msg,\n        dst,\n        out,\n        fee,\n        setcode,\n        signkey,\n        signing_box_handle,\n    };\n}\nexports.debotActivityTransaction = debotActivityTransaction;\nfunction paramsOfAppDebotBrowserLog(msg) {\n    return {\n        type: 'Log',\n        msg,\n    };\n}\nexports.paramsOfAppDebotBrowserLog = paramsOfAppDebotBrowserLog;\nfunction paramsOfAppDebotBrowserSwitch(context_id) {\n    return {\n        type: 'Switch',\n        context_id,\n    };\n}\nexports.paramsOfAppDebotBrowserSwitch = paramsOfAppDebotBrowserSwitch;\nfunction paramsOfAppDebotBrowserSwitchCompleted() {\n    return {\n        type: 'SwitchCompleted',\n    };\n}\nexports.paramsOfAppDebotBrowserSwitchCompleted = paramsOfAppDebotBrowserSwitchCompleted;\nfunction paramsOfAppDebotBrowserShowAction(action) {\n    return {\n        type: 'ShowAction',\n        action,\n    };\n}\nexports.paramsOfAppDebotBrowserShowAction = paramsOfAppDebotBrowserShowAction;\nfunction paramsOfAppDebotBrowserInput(prompt) {\n    return {\n        type: 'Input',\n        prompt,\n    };\n}\nexports.paramsOfAppDebotBrowserInput = paramsOfAppDebotBrowserInput;\nfunction paramsOfAppDebotBrowserGetSigningBox() {\n    return {\n        type: 'GetSigningBox',\n    };\n}\nexports.paramsOfAppDebotBrowserGetSigningBox = paramsOfAppDebotBrowserGetSigningBox;\nfunction paramsOfAppDebotBrowserInvokeDebot(debot_addr, action) {\n    return {\n        type: 'InvokeDebot',\n        debot_addr,\n        action,\n    };\n}\nexports.paramsOfAppDebotBrowserInvokeDebot = paramsOfAppDebotBrowserInvokeDebot;\nfunction paramsOfAppDebotBrowserSend(message) {\n    return {\n        type: 'Send',\n        message,\n    };\n}\nexports.paramsOfAppDebotBrowserSend = paramsOfAppDebotBrowserSend;\nfunction paramsOfAppDebotBrowserApprove(activity) {\n    return {\n        type: 'Approve',\n        activity,\n    };\n}\nexports.paramsOfAppDebotBrowserApprove = paramsOfAppDebotBrowserApprove;\nfunction resultOfAppDebotBrowserInput(value) {\n    return {\n        type: 'Input',\n        value,\n    };\n}\nexports.resultOfAppDebotBrowserInput = resultOfAppDebotBrowserInput;\nfunction resultOfAppDebotBrowserGetSigningBox(signing_box) {\n    return {\n        type: 'GetSigningBox',\n        signing_box,\n    };\n}\nexports.resultOfAppDebotBrowserGetSigningBox = resultOfAppDebotBrowserGetSigningBox;\nfunction resultOfAppDebotBrowserInvokeDebot() {\n    return {\n        type: 'InvokeDebot',\n    };\n}\nexports.resultOfAppDebotBrowserInvokeDebot = resultOfAppDebotBrowserInvokeDebot;\nfunction resultOfAppDebotBrowserApprove(approved) {\n    return {\n        type: 'Approve',\n        approved,\n    };\n}\nexports.resultOfAppDebotBrowserApprove = resultOfAppDebotBrowserApprove;\nfunction dispatchAppDebotBrowser(obj, params, app_request_id, client) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let result = {};\n            switch (params.type) {\n                case 'Log':\n                    obj.log(params);\n                    break;\n                case 'Switch':\n                    obj.switch(params);\n                    break;\n                case 'SwitchCompleted':\n                    obj.switch_completed();\n                    break;\n                case 'ShowAction':\n                    obj.show_action(params);\n                    break;\n                case 'Input':\n                    result = yield obj.input(params);\n                    break;\n                case 'GetSigningBox':\n                    result = yield obj.get_signing_box();\n                    break;\n                case 'InvokeDebot':\n                    yield obj.invoke_debot(params);\n                    break;\n                case 'Send':\n                    obj.send(params);\n                    break;\n                case 'Approve':\n                    result = yield obj.approve(params);\n                    break;\n            }\n            client.resolve_app_request(app_request_id, Object.assign({ type: params.type }, result));\n        }\n        catch (error) {\n            client.reject_app_request(app_request_id, error);\n        }\n    });\n}\n/**\n * [UNSTABLE](UNSTABLE.md) Module for working with debot.\n */\nclass DebotModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * [UNSTABLE](UNSTABLE.md) Creates and instance of DeBot.\n     *\n     * @remarks\n     * Downloads debot smart contract (code and data) from blockchain and creates\n     * an instance of Debot Engine for it.\n     *\n     * # Remarks\n     * It does not switch debot to context 0. Browser Callbacks are not called.\n     *\n     * @param {ParamsOfInit} params\n     * @returns RegisteredDebot\n     */\n    init(params, obj) {\n        return this.client.request('debot.init', params, (params, responseType) => {\n            if (responseType === 3) {\n                dispatchAppDebotBrowser(obj, params.request_data, params.app_request_id, this.client);\n            }\n            else if (responseType === 4) {\n                dispatchAppDebotBrowser(obj, params, null, this.client);\n            }\n        });\n    }\n    /**\n     * [UNSTABLE](UNSTABLE.md) Starts the DeBot.\n     *\n     * @remarks\n     * Downloads debot smart contract from blockchain and switches it to\n     * context zero.\n     *\n     * This function must be used by Debot Browser to start a dialog with debot.\n     * While the function is executing, several Browser Callbacks can be called,\n     * since the debot tries to display all actions from the context 0 to the user.\n     *\n     * When the debot starts SDK registers `BrowserCallbacks` AppObject.\n     * Therefore when `debote.remove` is called the debot is being deleted and the callback is called\n     * with `finish`=`true` which indicates that it will never be used again.\n     *\n     * @param {ParamsOfStart} params\n     * @returns\n     */\n    start(params) {\n        return this.client.request('debot.start', params);\n    }\n    /**\n     * [UNSTABLE](UNSTABLE.md) Fetches DeBot metadata from blockchain.\n     *\n     * @remarks\n     * Downloads DeBot from blockchain and creates and fetches its metadata.\n     *\n     * @param {ParamsOfFetch} params\n     * @returns ResultOfFetch\n     */\n    fetch(params) {\n        return this.client.request('debot.fetch', params);\n    }\n    /**\n     * [UNSTABLE](UNSTABLE.md) Executes debot action.\n     *\n     * @remarks\n     * Calls debot engine referenced by debot handle to execute input action.\n     * Calls Debot Browser Callbacks if needed.\n     *\n     * # Remarks\n     * Chain of actions can be executed if input action generates a list of subactions.\n     *\n     * @param {ParamsOfExecute} params\n     * @returns\n     */\n    execute(params) {\n        return this.client.request('debot.execute', params);\n    }\n    /**\n     * [UNSTABLE](UNSTABLE.md) Sends message to Debot.\n     *\n     * @remarks\n     * Used by Debot Browser to send response on Dinterface call or from other Debots.\n     *\n     * @param {ParamsOfSend} params\n     * @returns\n     */\n    send(params) {\n        return this.client.request('debot.send', params);\n    }\n    /**\n     * [UNSTABLE](UNSTABLE.md) Destroys debot handle.\n     *\n     * @remarks\n     * Removes handle from Client Context and drops debot engine referenced by that handle.\n     *\n     * @param {ParamsOfRemove} params\n     * @returns\n     */\n    remove(params) {\n        return this.client.request('debot.remove', params);\n    }\n}\nexports.DebotModule = DebotModule;\n// proofs module\nvar ProofsErrorCode;\n(function (ProofsErrorCode) {\n    ProofsErrorCode[ProofsErrorCode[\"InvalidData\"] = 901] = \"InvalidData\";\n    ProofsErrorCode[ProofsErrorCode[\"ProofCheckFailed\"] = 902] = \"ProofCheckFailed\";\n    ProofsErrorCode[ProofsErrorCode[\"InternalError\"] = 903] = \"InternalError\";\n    ProofsErrorCode[ProofsErrorCode[\"DataDiffersFromProven\"] = 904] = \"DataDiffersFromProven\";\n})(ProofsErrorCode = exports.ProofsErrorCode || (exports.ProofsErrorCode = {}));\n/**\n * [UNSTABLE](UNSTABLE.md) Module for proving data, retrieved from TONOS API.\n */\nclass ProofsModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Proves that a given block's data, which is queried from TONOS API, can be trusted.\n     *\n     * @remarks\n     * This function checks block proofs and compares given data with the proven.\n     * If the given data differs from the proven, the exception will be thrown.\n     * The input param is a single block's JSON object, which was queried from DApp server using\n     * functions such as `net.query`, `net.query_collection` or `net.wait_for_collection`.\n     * If block's BOC is not provided in the JSON, it will be queried from DApp server\n     * (in this case it is required to provide at least `id` of block).\n     *\n     * Please note, that joins (like `signatures` in `Block`) are separated entities and not supported,\n     * so function will throw an exception in a case if JSON being checked has such entities in it.\n     *\n     * If `cache_in_local_storage` in config is set to `true` (default), downloaded proofs and\n     * master-chain BOCs are saved into the persistent local storage (e.g. file system for native\n     * environments or browser's IndexedDB for the web); otherwise all the data is cached only in\n     * memory in current client's context and will be lost after destruction of the client.\n     *\n     * **Why Proofs are needed**\n     *\n     * Proofs are needed to ensure that the data downloaded from a DApp server is real blockchain\n     * data. Checking proofs can protect from the malicious DApp server which can potentially provide\n     * fake data, or also from \"Man in the Middle\" attacks class.\n     *\n     * **What Proofs are**\n     *\n     * Simply, proof is a list of signatures of validators', which have signed this particular master-\n     * block.\n     *\n     * The very first validator set's public keys are included in the zero-state. Whe know a root hash\n     * of the zero-state, because it is stored in the network configuration file, it is our authority\n     * root. For proving zero-state it is enough to calculate and compare its root hash.\n     *\n     * In each new validator cycle the validator set is changed. The new one is stored in a key-block,\n     * which is signed by the validator set, which we already trust, the next validator set will be\n     * stored to the new key-block and signed by the current validator set, and so on.\n     *\n     * In order to prove any block in the master-chain we need to check, that it has been signed by\n     * a trusted validator set. So we need to check all key-blocks' proofs, started from the zero-state\n     * and until the block, which we want to prove. But it can take a lot of time and traffic to\n     * download and prove all key-blocks on a client. For solving this, special trusted blocks are used\n     * in Ever-SDK.\n     *\n     * The trusted block is the authority root, as well, as the zero-state. Each trusted block is the\n     * `id` (e.g. `root_hash`) of the already proven key-block. There can be plenty of trusted\n     * blocks, so there can be a lot of authority roots. The hashes of trusted blocks for MainNet\n     * and DevNet are hardcoded in SDK in a separated binary file (trusted_key_blocks.bin) and is\n     * being updated for each release by using `update_trusted_blocks` utility.\n     *\n     * See [update_trusted_blocks](../../../tools/update_trusted_blocks) directory for more info.\n     *\n     * In future SDK releases, one will also be able to provide their hashes of trusted blocks for\n     * other networks, besides for MainNet and DevNet.\n     * By using trusted key-blocks, in order to prove any block, we can prove chain of key-blocks to\n     * the closest previous trusted key-block, not only to the zero-state.\n     *\n     * But shard-blocks don't have proofs on DApp server. In this case, in order to prove any shard-\n     * block data, we search for a corresponding master-block, which contains the root hash of this\n     * shard-block, or some shard block which is linked to that block in shard-chain. After proving\n     * this master-block, we traverse through each link and calculate and compare hashes with links,\n     * one-by-one. After that we can ensure that this shard-block has also been proven.\n     *\n     * @param {ParamsOfProofBlockData} params\n     * @returns\n     */\n    proof_block_data(params) {\n        return this.client.request('proofs.proof_block_data', params);\n    }\n    /**\n     * Proves that a given transaction's data, which is queried from TONOS API, can be trusted.\n     *\n     * @remarks\n     * This function requests the corresponding block, checks block proofs, ensures that given\n     * transaction exists in the proven block and compares given data with the proven.\n     * If the given data differs from the proven, the exception will be thrown.\n     * The input parameter is a single transaction's JSON object (see params description),\n     * which was queried from TONOS API using functions such as `net.query`, `net.query_collection`\n     * or `net.wait_for_collection`.\n     *\n     * If transaction's BOC and/or `block_id` are not provided in the JSON, they will be queried from\n     * TONOS API.\n     *\n     * Please note, that joins (like `account`, `in_message`, `out_messages`, etc. in `Transaction`\n     * entity) are separated entities and not supported, so function will throw an exception in a case\n     * if JSON being checked has such entities in it.\n     *\n     * For more information about proofs checking, see description of `proof_block_data` function.\n     *\n     * @param {ParamsOfProofTransactionData} params\n     * @returns\n     */\n    proof_transaction_data(params) {\n        return this.client.request('proofs.proof_transaction_data', params);\n    }\n    /**\n     * Proves that a given message's data, which is queried from TONOS API, can be trusted.\n     *\n     * @remarks\n     * This function first proves the corresponding transaction, ensures that the proven transaction\n     * refers to the given message and compares given data with the proven.\n     * If the given data differs from the proven, the exception will be thrown.\n     * The input parameter is a single message's JSON object (see params description),\n     * which was queried from TONOS API using functions such as `net.query`, `net.query_collection`\n     * or `net.wait_for_collection`.\n     *\n     * If message's BOC and/or non-null `src_transaction.id` or `dst_transaction.id` are not provided\n     * in the JSON, they will be queried from TONOS API.\n     *\n     * Please note, that joins (like `block`, `dst_account`, `dst_transaction`, `src_account`,\n     * `src_transaction`, etc. in `Message` entity) are separated entities and not supported,\n     * so function will throw an exception in a case if JSON being checked has such entities in it.\n     *\n     * For more information about proofs checking, see description of `proof_block_data` function.\n     *\n     * @param {ParamsOfProofMessageData} params\n     * @returns\n     */\n    proof_message_data(params) {\n        return this.client.request('proofs.proof_message_data', params);\n    }\n}\nexports.ProofsModule = ProofsModule;\n//# sourceMappingURL=modules.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGV2ZXJzZGsvY29yZS9kaXN0L21vZHVsZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9ub2RlX21vZHVsZXMvQGV2ZXJzZGsvY29yZS9kaXN0L21vZHVsZXMuanM/ZTg4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWlsZGVyT3BJbnRlZ2VyID0gZXhwb3J0cy5Cb2NFcnJvckNvZGUgPSBleHBvcnRzLmJvY0NhY2hlVHlwZVVucGlubmVkID0gZXhwb3J0cy5ib2NDYWNoZVR5cGVQaW5uZWQgPSBleHBvcnRzLkFiaU1vZHVsZSA9IGV4cG9ydHMubWVzc2FnZVNvdXJjZUVuY29kaW5nUGFyYW1zID0gZXhwb3J0cy5tZXNzYWdlU291cmNlRW5jb2RlZCA9IGV4cG9ydHMuc3RhdGVJbml0U291cmNlVHZjID0gZXhwb3J0cy5zdGF0ZUluaXRTb3VyY2VTdGF0ZUluaXQgPSBleHBvcnRzLnN0YXRlSW5pdFNvdXJjZU1lc3NhZ2UgPSBleHBvcnRzLk1lc3NhZ2VCb2R5VHlwZSA9IGV4cG9ydHMuc2lnbmVyU2lnbmluZ0JveCA9IGV4cG9ydHMuc2lnbmVyS2V5cyA9IGV4cG9ydHMuc2lnbmVyRXh0ZXJuYWwgPSBleHBvcnRzLnNpZ25lck5vbmUgPSBleHBvcnRzLmFiaVNlcmlhbGl6ZWQgPSBleHBvcnRzLmFiaUhhbmRsZSA9IGV4cG9ydHMuYWJpSnNvbiA9IGV4cG9ydHMuYWJpQ29udHJhY3QgPSBleHBvcnRzLkFiaUVycm9yQ29kZSA9IGV4cG9ydHMuQ3J5cHRvTW9kdWxlID0gZXhwb3J0cy5yZXN1bHRPZkFwcEVuY3J5cHRpb25Cb3hEZWNyeXB0ID0gZXhwb3J0cy5yZXN1bHRPZkFwcEVuY3J5cHRpb25Cb3hFbmNyeXB0ID0gZXhwb3J0cy5yZXN1bHRPZkFwcEVuY3J5cHRpb25Cb3hHZXRJbmZvID0gZXhwb3J0cy5wYXJhbXNPZkFwcEVuY3J5cHRpb25Cb3hEZWNyeXB0ID0gZXhwb3J0cy5wYXJhbXNPZkFwcEVuY3J5cHRpb25Cb3hFbmNyeXB0ID0gZXhwb3J0cy5wYXJhbXNPZkFwcEVuY3J5cHRpb25Cb3hHZXRJbmZvID0gZXhwb3J0cy5yZXN1bHRPZkFwcFNpZ25pbmdCb3hTaWduID0gZXhwb3J0cy5yZXN1bHRPZkFwcFNpZ25pbmdCb3hHZXRQdWJsaWNLZXkgPSBleHBvcnRzLnBhcmFtc09mQXBwU2lnbmluZ0JveFNpZ24gPSBleHBvcnRzLnBhcmFtc09mQXBwU2lnbmluZ0JveEdldFB1YmxpY0tleSA9IGV4cG9ydHMucmVzdWx0T2ZBcHBQYXNzd29yZFByb3ZpZGVyR2V0UGFzc3dvcmQgPSBleHBvcnRzLnBhcmFtc09mQXBwUGFzc3dvcmRQcm92aWRlckdldFBhc3N3b3JkID0gZXhwb3J0cy5ib3hFbmNyeXB0aW9uQWxnb3JpdGhtTmFjbFNlY3JldEJveCA9IGV4cG9ydHMuYm94RW5jcnlwdGlvbkFsZ29yaXRobU5hY2xCb3ggPSBleHBvcnRzLmJveEVuY3J5cHRpb25BbGdvcml0aG1DaGFDaGEyMCA9IGV4cG9ydHMuY3J5cHRvQm94U2VjcmV0RW5jcnlwdGVkU2VjcmV0ID0gZXhwb3J0cy5jcnlwdG9Cb3hTZWNyZXRQcmVkZWZpbmVkU2VlZFBocmFzZSA9IGV4cG9ydHMuY3J5cHRvQm94U2VjcmV0UmFuZG9tU2VlZFBocmFzZSA9IGV4cG9ydHMuQ2lwaGVyTW9kZSA9IGV4cG9ydHMuZW5jcnlwdGlvbkFsZ29yaXRobU5hY2xTZWNyZXRCb3ggPSBleHBvcnRzLmVuY3J5cHRpb25BbGdvcml0aG1OYWNsQm94ID0gZXhwb3J0cy5lbmNyeXB0aW9uQWxnb3JpdGhtQ2hhQ2hhMjAgPSBleHBvcnRzLmVuY3J5cHRpb25BbGdvcml0aG1BRVMgPSBleHBvcnRzLkNyeXB0b0Vycm9yQ29kZSA9IGV4cG9ydHMuQ2xpZW50TW9kdWxlID0gZXhwb3J0cy5hcHBSZXF1ZXN0UmVzdWx0T2sgPSBleHBvcnRzLmFwcFJlcXVlc3RSZXN1bHRFcnJvciA9IGV4cG9ydHMuTmV0d29ya1F1ZXJpZXNQcm90b2NvbCA9IGV4cG9ydHMuQ2xpZW50RXJyb3JDb2RlID0gdm9pZCAwO1xuZXhwb3J0cy5yZXN1bHRPZkFwcERlYm90QnJvd3NlcklucHV0ID0gZXhwb3J0cy5wYXJhbXNPZkFwcERlYm90QnJvd3NlckFwcHJvdmUgPSBleHBvcnRzLnBhcmFtc09mQXBwRGVib3RCcm93c2VyU2VuZCA9IGV4cG9ydHMucGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJJbnZva2VEZWJvdCA9IGV4cG9ydHMucGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJHZXRTaWduaW5nQm94ID0gZXhwb3J0cy5wYXJhbXNPZkFwcERlYm90QnJvd3NlcklucHV0ID0gZXhwb3J0cy5wYXJhbXNPZkFwcERlYm90QnJvd3NlclNob3dBY3Rpb24gPSBleHBvcnRzLnBhcmFtc09mQXBwRGVib3RCcm93c2VyU3dpdGNoQ29tcGxldGVkID0gZXhwb3J0cy5wYXJhbXNPZkFwcERlYm90QnJvd3NlclN3aXRjaCA9IGV4cG9ydHMucGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJMb2cgPSBleHBvcnRzLmRlYm90QWN0aXZpdHlUcmFuc2FjdGlvbiA9IGV4cG9ydHMuRGVib3RFcnJvckNvZGUgPSBleHBvcnRzLk5ldE1vZHVsZSA9IGV4cG9ydHMuQWdncmVnYXRpb25GbiA9IGV4cG9ydHMucGFyYW1zT2ZRdWVyeU9wZXJhdGlvblF1ZXJ5Q291bnRlcnBhcnRpZXMgPSBleHBvcnRzLnBhcmFtc09mUXVlcnlPcGVyYXRpb25BZ2dyZWdhdGVDb2xsZWN0aW9uID0gZXhwb3J0cy5wYXJhbXNPZlF1ZXJ5T3BlcmF0aW9uV2FpdEZvckNvbGxlY3Rpb24gPSBleHBvcnRzLnBhcmFtc09mUXVlcnlPcGVyYXRpb25RdWVyeUNvbGxlY3Rpb24gPSBleHBvcnRzLlNvcnREaXJlY3Rpb24gPSBleHBvcnRzLk5ldEVycm9yQ29kZSA9IGV4cG9ydHMuVHZtTW9kdWxlID0gZXhwb3J0cy5hY2NvdW50Rm9yRXhlY3V0b3JBY2NvdW50ID0gZXhwb3J0cy5hY2NvdW50Rm9yRXhlY3V0b3JVbmluaXQgPSBleHBvcnRzLmFjY291bnRGb3JFeGVjdXRvck5vbmUgPSBleHBvcnRzLlR2bUVycm9yQ29kZSA9IGV4cG9ydHMuVXRpbHNNb2R1bGUgPSBleHBvcnRzLkFjY291bnRBZGRyZXNzVHlwZSA9IGV4cG9ydHMuYWRkcmVzc1N0cmluZ0Zvcm1hdEJhc2U2NCA9IGV4cG9ydHMuYWRkcmVzc1N0cmluZ0Zvcm1hdEhleCA9IGV4cG9ydHMuYWRkcmVzc1N0cmluZ0Zvcm1hdEFjY291bnRJZCA9IGV4cG9ydHMuUHJvY2Vzc2luZ01vZHVsZSA9IGV4cG9ydHMucHJvY2Vzc2luZ0V2ZW50UmVtcEVycm9yID0gZXhwb3J0cy5wcm9jZXNzaW5nRXZlbnRSZW1wT3RoZXIgPSBleHBvcnRzLnByb2Nlc3NpbmdFdmVudFJlbXBJbmNsdWRlZEludG9BY2NlcHRlZEJsb2NrID0gZXhwb3J0cy5wcm9jZXNzaW5nRXZlbnRSZW1wSW5jbHVkZWRJbnRvQmxvY2sgPSBleHBvcnRzLnByb2Nlc3NpbmdFdmVudFJlbXBTZW50VG9WYWxpZGF0b3JzID0gZXhwb3J0cy5wcm9jZXNzaW5nRXZlbnRNZXNzYWdlRXhwaXJlZCA9IGV4cG9ydHMucHJvY2Vzc2luZ0V2ZW50RmV0Y2hOZXh0QmxvY2tGYWlsZWQgPSBleHBvcnRzLnByb2Nlc3NpbmdFdmVudFdpbGxGZXRjaE5leHRCbG9jayA9IGV4cG9ydHMucHJvY2Vzc2luZ0V2ZW50U2VuZEZhaWxlZCA9IGV4cG9ydHMucHJvY2Vzc2luZ0V2ZW50RGlkU2VuZCA9IGV4cG9ydHMucHJvY2Vzc2luZ0V2ZW50V2lsbFNlbmQgPSBleHBvcnRzLnByb2Nlc3NpbmdFdmVudEZldGNoRmlyc3RCbG9ja0ZhaWxlZCA9IGV4cG9ydHMucHJvY2Vzc2luZ0V2ZW50V2lsbEZldGNoRmlyc3RCbG9jayA9IGV4cG9ydHMuUHJvY2Vzc2luZ0Vycm9yQ29kZSA9IGV4cG9ydHMuQm9jTW9kdWxlID0gZXhwb3J0cy5idWlsZGVyT3BBZGRyZXNzID0gZXhwb3J0cy5idWlsZGVyT3BDZWxsQm9jID0gZXhwb3J0cy5idWlsZGVyT3BDZWxsID0gZXhwb3J0cy5idWlsZGVyT3BCaXRTdHJpbmcgPSB2b2lkIDA7XG5leHBvcnRzLlByb29mc01vZHVsZSA9IGV4cG9ydHMuUHJvb2ZzRXJyb3JDb2RlID0gZXhwb3J0cy5EZWJvdE1vZHVsZSA9IGV4cG9ydHMucmVzdWx0T2ZBcHBEZWJvdEJyb3dzZXJBcHByb3ZlID0gZXhwb3J0cy5yZXN1bHRPZkFwcERlYm90QnJvd3Nlckludm9rZURlYm90ID0gZXhwb3J0cy5yZXN1bHRPZkFwcERlYm90QnJvd3NlckdldFNpZ25pbmdCb3ggPSB2b2lkIDA7XG4vLyBjbGllbnQgbW9kdWxlXG52YXIgQ2xpZW50RXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChDbGllbnRFcnJvckNvZGUpIHtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiTm90SW1wbGVtZW50ZWRcIl0gPSAxXSA9IFwiTm90SW1wbGVtZW50ZWRcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiSW52YWxpZEhleFwiXSA9IDJdID0gXCJJbnZhbGlkSGV4XCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkludmFsaWRCYXNlNjRcIl0gPSAzXSA9IFwiSW52YWxpZEJhc2U2NFwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJJbnZhbGlkQWRkcmVzc1wiXSA9IDRdID0gXCJJbnZhbGlkQWRkcmVzc1wiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJDYWxsYmFja1BhcmFtc0NhbnRCZUNvbnZlcnRlZFRvSnNvblwiXSA9IDVdID0gXCJDYWxsYmFja1BhcmFtc0NhbnRCZUNvbnZlcnRlZFRvSnNvblwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJXZWJzb2NrZXRDb25uZWN0RXJyb3JcIl0gPSA2XSA9IFwiV2Vic29ja2V0Q29ubmVjdEVycm9yXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIldlYnNvY2tldFJlY2VpdmVFcnJvclwiXSA9IDddID0gXCJXZWJzb2NrZXRSZWNlaXZlRXJyb3JcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiV2Vic29ja2V0U2VuZEVycm9yXCJdID0gOF0gPSBcIldlYnNvY2tldFNlbmRFcnJvclwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJIdHRwQ2xpZW50Q3JlYXRlRXJyb3JcIl0gPSA5XSA9IFwiSHR0cENsaWVudENyZWF0ZUVycm9yXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkh0dHBSZXF1ZXN0Q3JlYXRlRXJyb3JcIl0gPSAxMF0gPSBcIkh0dHBSZXF1ZXN0Q3JlYXRlRXJyb3JcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiSHR0cFJlcXVlc3RTZW5kRXJyb3JcIl0gPSAxMV0gPSBcIkh0dHBSZXF1ZXN0U2VuZEVycm9yXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkh0dHBSZXF1ZXN0UGFyc2VFcnJvclwiXSA9IDEyXSA9IFwiSHR0cFJlcXVlc3RQYXJzZUVycm9yXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkNhbGxiYWNrTm90UmVnaXN0ZXJlZFwiXSA9IDEzXSA9IFwiQ2FsbGJhY2tOb3RSZWdpc3RlcmVkXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIk5ldE1vZHVsZU5vdEluaXRcIl0gPSAxNF0gPSBcIk5ldE1vZHVsZU5vdEluaXRcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiSW52YWxpZENvbmZpZ1wiXSA9IDE1XSA9IFwiSW52YWxpZENvbmZpZ1wiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJDYW5ub3RDcmVhdGVSdW50aW1lXCJdID0gMTZdID0gXCJDYW5ub3RDcmVhdGVSdW50aW1lXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkludmFsaWRDb250ZXh0SGFuZGxlXCJdID0gMTddID0gXCJJbnZhbGlkQ29udGV4dEhhbmRsZVwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJDYW5ub3RTZXJpYWxpemVSZXN1bHRcIl0gPSAxOF0gPSBcIkNhbm5vdFNlcmlhbGl6ZVJlc3VsdFwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJDYW5ub3RTZXJpYWxpemVFcnJvclwiXSA9IDE5XSA9IFwiQ2Fubm90U2VyaWFsaXplRXJyb3JcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiQ2Fubm90Q29udmVydEpzVmFsdWVUb0pzb25cIl0gPSAyMF0gPSBcIkNhbm5vdENvbnZlcnRKc1ZhbHVlVG9Kc29uXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkNhbm5vdFJlY2VpdmVTcGF3bmVkUmVzdWx0XCJdID0gMjFdID0gXCJDYW5ub3RSZWNlaXZlU3Bhd25lZFJlc3VsdFwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJTZXRUaW1lckVycm9yXCJdID0gMjJdID0gXCJTZXRUaW1lckVycm9yXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkludmFsaWRQYXJhbXNcIl0gPSAyM10gPSBcIkludmFsaWRQYXJhbXNcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiQ29udHJhY3RzQWRkcmVzc0NvbnZlcnNpb25GYWlsZWRcIl0gPSAyNF0gPSBcIkNvbnRyYWN0c0FkZHJlc3NDb252ZXJzaW9uRmFpbGVkXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIlVua25vd25GdW5jdGlvblwiXSA9IDI1XSA9IFwiVW5rbm93bkZ1bmN0aW9uXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkFwcFJlcXVlc3RFcnJvclwiXSA9IDI2XSA9IFwiQXBwUmVxdWVzdEVycm9yXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIk5vU3VjaFJlcXVlc3RcIl0gPSAyN10gPSBcIk5vU3VjaFJlcXVlc3RcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiQ2FuTm90U2VuZFJlcXVlc3RSZXN1bHRcIl0gPSAyOF0gPSBcIkNhbk5vdFNlbmRSZXF1ZXN0UmVzdWx0XCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkNhbk5vdFJlY2VpdmVSZXF1ZXN0UmVzdWx0XCJdID0gMjldID0gXCJDYW5Ob3RSZWNlaXZlUmVxdWVzdFJlc3VsdFwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJDYW5Ob3RQYXJzZVJlcXVlc3RSZXN1bHRcIl0gPSAzMF0gPSBcIkNhbk5vdFBhcnNlUmVxdWVzdFJlc3VsdFwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJVbmV4cGVjdGVkQ2FsbGJhY2tSZXNwb25zZVwiXSA9IDMxXSA9IFwiVW5leHBlY3RlZENhbGxiYWNrUmVzcG9uc2VcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiQ2FuTm90UGFyc2VOdW1iZXJcIl0gPSAzMl0gPSBcIkNhbk5vdFBhcnNlTnVtYmVyXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkludGVybmFsRXJyb3JcIl0gPSAzM10gPSBcIkludGVybmFsRXJyb3JcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiSW52YWxpZEhhbmRsZVwiXSA9IDM0XSA9IFwiSW52YWxpZEhhbmRsZVwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJMb2NhbFN0b3JhZ2VFcnJvclwiXSA9IDM1XSA9IFwiTG9jYWxTdG9yYWdlRXJyb3JcIjtcbn0pKENsaWVudEVycm9yQ29kZSA9IGV4cG9ydHMuQ2xpZW50RXJyb3JDb2RlIHx8IChleHBvcnRzLkNsaWVudEVycm9yQ29kZSA9IHt9KSk7XG4vKipcbiAqIE5ldHdvcmsgcHJvdG9jb2wgdXNlZCB0byBwZXJmb3JtIEdyYXBoUUwgcXVlcmllcy5cbiAqL1xudmFyIE5ldHdvcmtRdWVyaWVzUHJvdG9jb2w7XG4oZnVuY3Rpb24gKE5ldHdvcmtRdWVyaWVzUHJvdG9jb2wpIHtcbiAgICBOZXR3b3JrUXVlcmllc1Byb3RvY29sW1wiSFRUUFwiXSA9IFwiSFRUUFwiO1xuICAgIE5ldHdvcmtRdWVyaWVzUHJvdG9jb2xbXCJXU1wiXSA9IFwiV1NcIjtcbn0pKE5ldHdvcmtRdWVyaWVzUHJvdG9jb2wgPSBleHBvcnRzLk5ldHdvcmtRdWVyaWVzUHJvdG9jb2wgfHwgKGV4cG9ydHMuTmV0d29ya1F1ZXJpZXNQcm90b2NvbCA9IHt9KSk7XG5mdW5jdGlvbiBhcHBSZXF1ZXN0UmVzdWx0RXJyb3IodGV4dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdFcnJvcicsXG4gICAgICAgIHRleHQsXG4gICAgfTtcbn1cbmV4cG9ydHMuYXBwUmVxdWVzdFJlc3VsdEVycm9yID0gYXBwUmVxdWVzdFJlc3VsdEVycm9yO1xuZnVuY3Rpb24gYXBwUmVxdWVzdFJlc3VsdE9rKHJlc3VsdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdPaycsXG4gICAgICAgIHJlc3VsdCxcbiAgICB9O1xufVxuZXhwb3J0cy5hcHBSZXF1ZXN0UmVzdWx0T2sgPSBhcHBSZXF1ZXN0UmVzdWx0T2s7XG4vKipcbiAqIFByb3ZpZGVzIGluZm9ybWF0aW9uIGFib3V0IGxpYnJhcnkuXG4gKi9cbmNsYXNzIENsaWVudE1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIENvcmUgTGlicmFyeSBBUEkgcmVmZXJlbmNlXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZHZXRBcGlSZWZlcmVuY2VcbiAgICAgKi9cbiAgICBnZXRfYXBpX3JlZmVyZW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NsaWVudC5nZXRfYXBpX3JlZmVyZW5jZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIENvcmUgTGlicmFyeSB2ZXJzaW9uXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZWZXJzaW9uXG4gICAgICovXG4gICAgdmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NsaWVudC52ZXJzaW9uJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQ29yZSBMaWJyYXJ5IEFQSSByZWZlcmVuY2VcbiAgICAgKiBAcmV0dXJucyBDbGllbnRDb25maWdcbiAgICAgKi9cbiAgICBjb25maWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjbGllbnQuY29uZmlnJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBidWlsZC5cbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkJ1aWxkSW5mb1xuICAgICAqL1xuICAgIGJ1aWxkX2luZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjbGllbnQuYnVpbGRfaW5mbycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBhcHBsaWNhdGlvbiByZXF1ZXN0IHByb2Nlc3NpbmcgcmVzdWx0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mUmVzb2x2ZUFwcFJlcXVlc3R9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcmVzb2x2ZV9hcHBfcmVxdWVzdChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NsaWVudC5yZXNvbHZlX2FwcF9yZXF1ZXN0JywgcGFyYW1zKTtcbiAgICB9XG59XG5leHBvcnRzLkNsaWVudE1vZHVsZSA9IENsaWVudE1vZHVsZTtcbi8vIGNyeXB0byBtb2R1bGVcbnZhciBDcnlwdG9FcnJvckNvZGU7XG4oZnVuY3Rpb24gKENyeXB0b0Vycm9yQ29kZSkge1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJJbnZhbGlkUHVibGljS2V5XCJdID0gMTAwXSA9IFwiSW52YWxpZFB1YmxpY0tleVwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJJbnZhbGlkU2VjcmV0S2V5XCJdID0gMTAxXSA9IFwiSW52YWxpZFNlY3JldEtleVwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJJbnZhbGlkS2V5XCJdID0gMTAyXSA9IFwiSW52YWxpZEtleVwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJJbnZhbGlkRmFjdG9yaXplQ2hhbGxlbmdlXCJdID0gMTA2XSA9IFwiSW52YWxpZEZhY3Rvcml6ZUNoYWxsZW5nZVwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJJbnZhbGlkQmlnSW50XCJdID0gMTA3XSA9IFwiSW52YWxpZEJpZ0ludFwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJTY3J5cHRGYWlsZWRcIl0gPSAxMDhdID0gXCJTY3J5cHRGYWlsZWRcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiSW52YWxpZEtleVNpemVcIl0gPSAxMDldID0gXCJJbnZhbGlkS2V5U2l6ZVwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJOYWNsU2VjcmV0Qm94RmFpbGVkXCJdID0gMTEwXSA9IFwiTmFjbFNlY3JldEJveEZhaWxlZFwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJOYWNsQm94RmFpbGVkXCJdID0gMTExXSA9IFwiTmFjbEJveEZhaWxlZFwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJOYWNsU2lnbkZhaWxlZFwiXSA9IDExMl0gPSBcIk5hY2xTaWduRmFpbGVkXCI7XG4gICAgQ3J5cHRvRXJyb3JDb2RlW0NyeXB0b0Vycm9yQ29kZVtcIkJpcDM5SW52YWxpZEVudHJvcHlcIl0gPSAxMTNdID0gXCJCaXAzOUludmFsaWRFbnRyb3B5XCI7XG4gICAgQ3J5cHRvRXJyb3JDb2RlW0NyeXB0b0Vycm9yQ29kZVtcIkJpcDM5SW52YWxpZFBocmFzZVwiXSA9IDExNF0gPSBcIkJpcDM5SW52YWxpZFBocmFzZVwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJCaXAzMkludmFsaWRLZXlcIl0gPSAxMTVdID0gXCJCaXAzMkludmFsaWRLZXlcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiQmlwMzJJbnZhbGlkRGVyaXZlUGF0aFwiXSA9IDExNl0gPSBcIkJpcDMySW52YWxpZERlcml2ZVBhdGhcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiQmlwMzlJbnZhbGlkRGljdGlvbmFyeVwiXSA9IDExN10gPSBcIkJpcDM5SW52YWxpZERpY3Rpb25hcnlcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiQmlwMzlJbnZhbGlkV29yZENvdW50XCJdID0gMTE4XSA9IFwiQmlwMzlJbnZhbGlkV29yZENvdW50XCI7XG4gICAgQ3J5cHRvRXJyb3JDb2RlW0NyeXB0b0Vycm9yQ29kZVtcIk1uZW1vbmljR2VuZXJhdGlvbkZhaWxlZFwiXSA9IDExOV0gPSBcIk1uZW1vbmljR2VuZXJhdGlvbkZhaWxlZFwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJNbmVtb25pY0Zyb21FbnRyb3B5RmFpbGVkXCJdID0gMTIwXSA9IFwiTW5lbW9uaWNGcm9tRW50cm9weUZhaWxlZFwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJTaWduaW5nQm94Tm90UmVnaXN0ZXJlZFwiXSA9IDEyMV0gPSBcIlNpZ25pbmdCb3hOb3RSZWdpc3RlcmVkXCI7XG4gICAgQ3J5cHRvRXJyb3JDb2RlW0NyeXB0b0Vycm9yQ29kZVtcIkludmFsaWRTaWduYXR1cmVcIl0gPSAxMjJdID0gXCJJbnZhbGlkU2lnbmF0dXJlXCI7XG4gICAgQ3J5cHRvRXJyb3JDb2RlW0NyeXB0b0Vycm9yQ29kZVtcIkVuY3J5cHRpb25Cb3hOb3RSZWdpc3RlcmVkXCJdID0gMTIzXSA9IFwiRW5jcnlwdGlvbkJveE5vdFJlZ2lzdGVyZWRcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiSW52YWxpZEl2U2l6ZVwiXSA9IDEyNF0gPSBcIkludmFsaWRJdlNpemVcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiVW5zdXBwb3J0ZWRDaXBoZXJNb2RlXCJdID0gMTI1XSA9IFwiVW5zdXBwb3J0ZWRDaXBoZXJNb2RlXCI7XG4gICAgQ3J5cHRvRXJyb3JDb2RlW0NyeXB0b0Vycm9yQ29kZVtcIkNhbm5vdENyZWF0ZUNpcGhlclwiXSA9IDEyNl0gPSBcIkNhbm5vdENyZWF0ZUNpcGhlclwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJFbmNyeXB0RGF0YUVycm9yXCJdID0gMTI3XSA9IFwiRW5jcnlwdERhdGFFcnJvclwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJEZWNyeXB0RGF0YUVycm9yXCJdID0gMTI4XSA9IFwiRGVjcnlwdERhdGFFcnJvclwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJJdlJlcXVpcmVkXCJdID0gMTI5XSA9IFwiSXZSZXF1aXJlZFwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJDcnlwdG9Cb3hOb3RSZWdpc3RlcmVkXCJdID0gMTMwXSA9IFwiQ3J5cHRvQm94Tm90UmVnaXN0ZXJlZFwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJJbnZhbGlkQ3J5cHRvQm94VHlwZVwiXSA9IDEzMV0gPSBcIkludmFsaWRDcnlwdG9Cb3hUeXBlXCI7XG4gICAgQ3J5cHRvRXJyb3JDb2RlW0NyeXB0b0Vycm9yQ29kZVtcIkNyeXB0b0JveFNlY3JldFNlcmlhbGl6YXRpb25FcnJvclwiXSA9IDEzMl0gPSBcIkNyeXB0b0JveFNlY3JldFNlcmlhbGl6YXRpb25FcnJvclwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJDcnlwdG9Cb3hTZWNyZXREZXNlcmlhbGl6YXRpb25FcnJvclwiXSA9IDEzM10gPSBcIkNyeXB0b0JveFNlY3JldERlc2VyaWFsaXphdGlvbkVycm9yXCI7XG4gICAgQ3J5cHRvRXJyb3JDb2RlW0NyeXB0b0Vycm9yQ29kZVtcIkludmFsaWROb25jZVNpemVcIl0gPSAxMzRdID0gXCJJbnZhbGlkTm9uY2VTaXplXCI7XG59KShDcnlwdG9FcnJvckNvZGUgPSBleHBvcnRzLkNyeXB0b0Vycm9yQ29kZSB8fCAoZXhwb3J0cy5DcnlwdG9FcnJvckNvZGUgPSB7fSkpO1xuZnVuY3Rpb24gZW5jcnlwdGlvbkFsZ29yaXRobUFFUyh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdBRVMnLFxuICAgICAgICB2YWx1ZSxcbiAgICB9O1xufVxuZXhwb3J0cy5lbmNyeXB0aW9uQWxnb3JpdGhtQUVTID0gZW5jcnlwdGlvbkFsZ29yaXRobUFFUztcbmZ1bmN0aW9uIGVuY3J5cHRpb25BbGdvcml0aG1DaGFDaGEyMCh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdDaGFDaGEyMCcsXG4gICAgICAgIHZhbHVlLFxuICAgIH07XG59XG5leHBvcnRzLmVuY3J5cHRpb25BbGdvcml0aG1DaGFDaGEyMCA9IGVuY3J5cHRpb25BbGdvcml0aG1DaGFDaGEyMDtcbmZ1bmN0aW9uIGVuY3J5cHRpb25BbGdvcml0aG1OYWNsQm94KHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ05hY2xCb3gnLFxuICAgICAgICB2YWx1ZSxcbiAgICB9O1xufVxuZXhwb3J0cy5lbmNyeXB0aW9uQWxnb3JpdGhtTmFjbEJveCA9IGVuY3J5cHRpb25BbGdvcml0aG1OYWNsQm94O1xuZnVuY3Rpb24gZW5jcnlwdGlvbkFsZ29yaXRobU5hY2xTZWNyZXRCb3godmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnTmFjbFNlY3JldEJveCcsXG4gICAgICAgIHZhbHVlLFxuICAgIH07XG59XG5leHBvcnRzLmVuY3J5cHRpb25BbGdvcml0aG1OYWNsU2VjcmV0Qm94ID0gZW5jcnlwdGlvbkFsZ29yaXRobU5hY2xTZWNyZXRCb3g7XG52YXIgQ2lwaGVyTW9kZTtcbihmdW5jdGlvbiAoQ2lwaGVyTW9kZSkge1xuICAgIENpcGhlck1vZGVbXCJDQkNcIl0gPSBcIkNCQ1wiO1xuICAgIENpcGhlck1vZGVbXCJDRkJcIl0gPSBcIkNGQlwiO1xuICAgIENpcGhlck1vZGVbXCJDVFJcIl0gPSBcIkNUUlwiO1xuICAgIENpcGhlck1vZGVbXCJFQ0JcIl0gPSBcIkVDQlwiO1xuICAgIENpcGhlck1vZGVbXCJPRkJcIl0gPSBcIk9GQlwiO1xufSkoQ2lwaGVyTW9kZSA9IGV4cG9ydHMuQ2lwaGVyTW9kZSB8fCAoZXhwb3J0cy5DaXBoZXJNb2RlID0ge30pKTtcbmZ1bmN0aW9uIGNyeXB0b0JveFNlY3JldFJhbmRvbVNlZWRQaHJhc2UoZGljdGlvbmFyeSwgd29yZGNvdW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1JhbmRvbVNlZWRQaHJhc2UnLFxuICAgICAgICBkaWN0aW9uYXJ5LFxuICAgICAgICB3b3JkY291bnQsXG4gICAgfTtcbn1cbmV4cG9ydHMuY3J5cHRvQm94U2VjcmV0UmFuZG9tU2VlZFBocmFzZSA9IGNyeXB0b0JveFNlY3JldFJhbmRvbVNlZWRQaHJhc2U7XG5mdW5jdGlvbiBjcnlwdG9Cb3hTZWNyZXRQcmVkZWZpbmVkU2VlZFBocmFzZShwaHJhc2UsIGRpY3Rpb25hcnksIHdvcmRjb3VudCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdQcmVkZWZpbmVkU2VlZFBocmFzZScsXG4gICAgICAgIHBocmFzZSxcbiAgICAgICAgZGljdGlvbmFyeSxcbiAgICAgICAgd29yZGNvdW50LFxuICAgIH07XG59XG5leHBvcnRzLmNyeXB0b0JveFNlY3JldFByZWRlZmluZWRTZWVkUGhyYXNlID0gY3J5cHRvQm94U2VjcmV0UHJlZGVmaW5lZFNlZWRQaHJhc2U7XG5mdW5jdGlvbiBjcnlwdG9Cb3hTZWNyZXRFbmNyeXB0ZWRTZWNyZXQoZW5jcnlwdGVkX3NlY3JldCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdFbmNyeXB0ZWRTZWNyZXQnLFxuICAgICAgICBlbmNyeXB0ZWRfc2VjcmV0LFxuICAgIH07XG59XG5leHBvcnRzLmNyeXB0b0JveFNlY3JldEVuY3J5cHRlZFNlY3JldCA9IGNyeXB0b0JveFNlY3JldEVuY3J5cHRlZFNlY3JldDtcbmZ1bmN0aW9uIGJveEVuY3J5cHRpb25BbGdvcml0aG1DaGFDaGEyMCh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdDaGFDaGEyMCcsXG4gICAgICAgIHZhbHVlLFxuICAgIH07XG59XG5leHBvcnRzLmJveEVuY3J5cHRpb25BbGdvcml0aG1DaGFDaGEyMCA9IGJveEVuY3J5cHRpb25BbGdvcml0aG1DaGFDaGEyMDtcbmZ1bmN0aW9uIGJveEVuY3J5cHRpb25BbGdvcml0aG1OYWNsQm94KHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ05hY2xCb3gnLFxuICAgICAgICB2YWx1ZSxcbiAgICB9O1xufVxuZXhwb3J0cy5ib3hFbmNyeXB0aW9uQWxnb3JpdGhtTmFjbEJveCA9IGJveEVuY3J5cHRpb25BbGdvcml0aG1OYWNsQm94O1xuZnVuY3Rpb24gYm94RW5jcnlwdGlvbkFsZ29yaXRobU5hY2xTZWNyZXRCb3godmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnTmFjbFNlY3JldEJveCcsXG4gICAgICAgIHZhbHVlLFxuICAgIH07XG59XG5leHBvcnRzLmJveEVuY3J5cHRpb25BbGdvcml0aG1OYWNsU2VjcmV0Qm94ID0gYm94RW5jcnlwdGlvbkFsZ29yaXRobU5hY2xTZWNyZXRCb3g7XG5mdW5jdGlvbiBwYXJhbXNPZkFwcFBhc3N3b3JkUHJvdmlkZXJHZXRQYXNzd29yZChlbmNyeXB0aW9uX3B1YmxpY19rZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnR2V0UGFzc3dvcmQnLFxuICAgICAgICBlbmNyeXB0aW9uX3B1YmxpY19rZXksXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyYW1zT2ZBcHBQYXNzd29yZFByb3ZpZGVyR2V0UGFzc3dvcmQgPSBwYXJhbXNPZkFwcFBhc3N3b3JkUHJvdmlkZXJHZXRQYXNzd29yZDtcbmZ1bmN0aW9uIHJlc3VsdE9mQXBwUGFzc3dvcmRQcm92aWRlckdldFBhc3N3b3JkKGVuY3J5cHRlZF9wYXNzd29yZCwgYXBwX2VuY3J5cHRpb25fcHVia2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0dldFBhc3N3b3JkJyxcbiAgICAgICAgZW5jcnlwdGVkX3Bhc3N3b3JkLFxuICAgICAgICBhcHBfZW5jcnlwdGlvbl9wdWJrZXksXG4gICAgfTtcbn1cbmV4cG9ydHMucmVzdWx0T2ZBcHBQYXNzd29yZFByb3ZpZGVyR2V0UGFzc3dvcmQgPSByZXN1bHRPZkFwcFBhc3N3b3JkUHJvdmlkZXJHZXRQYXNzd29yZDtcbmZ1bmN0aW9uIHBhcmFtc09mQXBwU2lnbmluZ0JveEdldFB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnR2V0UHVibGljS2V5JyxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJhbXNPZkFwcFNpZ25pbmdCb3hHZXRQdWJsaWNLZXkgPSBwYXJhbXNPZkFwcFNpZ25pbmdCb3hHZXRQdWJsaWNLZXk7XG5mdW5jdGlvbiBwYXJhbXNPZkFwcFNpZ25pbmdCb3hTaWduKHVuc2lnbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1NpZ24nLFxuICAgICAgICB1bnNpZ25lZCxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJhbXNPZkFwcFNpZ25pbmdCb3hTaWduID0gcGFyYW1zT2ZBcHBTaWduaW5nQm94U2lnbjtcbmZ1bmN0aW9uIHJlc3VsdE9mQXBwU2lnbmluZ0JveEdldFB1YmxpY0tleShwdWJsaWNfa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0dldFB1YmxpY0tleScsXG4gICAgICAgIHB1YmxpY19rZXksXG4gICAgfTtcbn1cbmV4cG9ydHMucmVzdWx0T2ZBcHBTaWduaW5nQm94R2V0UHVibGljS2V5ID0gcmVzdWx0T2ZBcHBTaWduaW5nQm94R2V0UHVibGljS2V5O1xuZnVuY3Rpb24gcmVzdWx0T2ZBcHBTaWduaW5nQm94U2lnbihzaWduYXR1cmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnU2lnbicsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICB9O1xufVxuZXhwb3J0cy5yZXN1bHRPZkFwcFNpZ25pbmdCb3hTaWduID0gcmVzdWx0T2ZBcHBTaWduaW5nQm94U2lnbjtcbmZ1bmN0aW9uIHBhcmFtc09mQXBwRW5jcnlwdGlvbkJveEdldEluZm8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0dldEluZm8nLFxuICAgIH07XG59XG5leHBvcnRzLnBhcmFtc09mQXBwRW5jcnlwdGlvbkJveEdldEluZm8gPSBwYXJhbXNPZkFwcEVuY3J5cHRpb25Cb3hHZXRJbmZvO1xuZnVuY3Rpb24gcGFyYW1zT2ZBcHBFbmNyeXB0aW9uQm94RW5jcnlwdChkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0VuY3J5cHQnLFxuICAgICAgICBkYXRhLFxuICAgIH07XG59XG5leHBvcnRzLnBhcmFtc09mQXBwRW5jcnlwdGlvbkJveEVuY3J5cHQgPSBwYXJhbXNPZkFwcEVuY3J5cHRpb25Cb3hFbmNyeXB0O1xuZnVuY3Rpb24gcGFyYW1zT2ZBcHBFbmNyeXB0aW9uQm94RGVjcnlwdChkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0RlY3J5cHQnLFxuICAgICAgICBkYXRhLFxuICAgIH07XG59XG5leHBvcnRzLnBhcmFtc09mQXBwRW5jcnlwdGlvbkJveERlY3J5cHQgPSBwYXJhbXNPZkFwcEVuY3J5cHRpb25Cb3hEZWNyeXB0O1xuZnVuY3Rpb24gcmVzdWx0T2ZBcHBFbmNyeXB0aW9uQm94R2V0SW5mbyhpbmZvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0dldEluZm8nLFxuICAgICAgICBpbmZvLFxuICAgIH07XG59XG5leHBvcnRzLnJlc3VsdE9mQXBwRW5jcnlwdGlvbkJveEdldEluZm8gPSByZXN1bHRPZkFwcEVuY3J5cHRpb25Cb3hHZXRJbmZvO1xuZnVuY3Rpb24gcmVzdWx0T2ZBcHBFbmNyeXB0aW9uQm94RW5jcnlwdChkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0VuY3J5cHQnLFxuICAgICAgICBkYXRhLFxuICAgIH07XG59XG5leHBvcnRzLnJlc3VsdE9mQXBwRW5jcnlwdGlvbkJveEVuY3J5cHQgPSByZXN1bHRPZkFwcEVuY3J5cHRpb25Cb3hFbmNyeXB0O1xuZnVuY3Rpb24gcmVzdWx0T2ZBcHBFbmNyeXB0aW9uQm94RGVjcnlwdChkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0RlY3J5cHQnLFxuICAgICAgICBkYXRhLFxuICAgIH07XG59XG5leHBvcnRzLnJlc3VsdE9mQXBwRW5jcnlwdGlvbkJveERlY3J5cHQgPSByZXN1bHRPZkFwcEVuY3J5cHRpb25Cb3hEZWNyeXB0O1xuZnVuY3Rpb24gZGlzcGF0Y2hBcHBQYXNzd29yZFByb3ZpZGVyKG9iaiwgcGFyYW1zLCBhcHBfcmVxdWVzdF9pZCwgY2xpZW50KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIHN3aXRjaCAocGFyYW1zLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdHZXRQYXNzd29yZCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIG9iai5nZXRfcGFzc3dvcmQocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGllbnQucmVzb2x2ZV9hcHBfcmVxdWVzdChhcHBfcmVxdWVzdF9pZCwgT2JqZWN0LmFzc2lnbih7IHR5cGU6IHBhcmFtcy50eXBlIH0sIHJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2xpZW50LnJlamVjdF9hcHBfcmVxdWVzdChhcHBfcmVxdWVzdF9pZCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBkaXNwYXRjaEFwcFNpZ25pbmdCb3gob2JqLCBwYXJhbXMsIGFwcF9yZXF1ZXN0X2lkLCBjbGllbnQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgc3dpdGNoIChwYXJhbXMudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0dldFB1YmxpY0tleSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIG9iai5nZXRfcHVibGljX2tleSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdTaWduJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgb2JqLnNpZ24ocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGllbnQucmVzb2x2ZV9hcHBfcmVxdWVzdChhcHBfcmVxdWVzdF9pZCwgT2JqZWN0LmFzc2lnbih7IHR5cGU6IHBhcmFtcy50eXBlIH0sIHJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2xpZW50LnJlamVjdF9hcHBfcmVxdWVzdChhcHBfcmVxdWVzdF9pZCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBkaXNwYXRjaEFwcEVuY3J5cHRpb25Cb3gob2JqLCBwYXJhbXMsIGFwcF9yZXF1ZXN0X2lkLCBjbGllbnQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgc3dpdGNoIChwYXJhbXMudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0dldEluZm8nOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCBvYmouZ2V0X2luZm8oKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnRW5jcnlwdCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIG9iai5lbmNyeXB0KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0RlY3J5cHQnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCBvYmouZGVjcnlwdChwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsaWVudC5yZXNvbHZlX2FwcF9yZXF1ZXN0KGFwcF9yZXF1ZXN0X2lkLCBPYmplY3QuYXNzaWduKHsgdHlwZTogcGFyYW1zLnR5cGUgfSwgcmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjbGllbnQucmVqZWN0X2FwcF9yZXF1ZXN0KGFwcF9yZXF1ZXN0X2lkLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogQ3J5cHRvIGZ1bmN0aW9ucy5cbiAqL1xuY2xhc3MgQ3J5cHRvTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVnZXIgZmFjdG9yaXphdGlvblxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBQZXJmb3JtcyBwcmltZSBmYWN0b3JpemF0aW9uIOKAkyBkZWNvbXBvc2l0aW9uIG9mIGEgY29tcG9zaXRlIG51bWJlclxuICAgICAqIGludG8gYSBwcm9kdWN0IG9mIHNtYWxsZXIgcHJpbWUgaW50ZWdlcnMgKGZhY3RvcnMpLlxuICAgICAqIFNlZSBbaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50ZWdlcl9mYWN0b3JpemF0aW9uXVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkZhY3Rvcml6ZX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZGYWN0b3JpemVcbiAgICAgKi9cbiAgICBmYWN0b3JpemUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8uZmFjdG9yaXplJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9kdWxhciBleHBvbmVudGlhdGlvblxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBQZXJmb3JtcyBtb2R1bGFyIGV4cG9uZW50aWF0aW9uIGZvciBiaWcgaW50ZWdlcnMgKGBiYXNlYF5gZXhwb25lbnRgIG1vZCBgbW9kdWx1c2ApLlxuICAgICAqIFNlZSBbaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxhcl9leHBvbmVudGlhdGlvbl1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZNb2R1bGFyUG93ZXJ9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mTW9kdWxhclBvd2VyXG4gICAgICovXG4gICAgbW9kdWxhcl9wb3dlcihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5tb2R1bGFyX3Bvd2VyJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBDUkMxNiB1c2luZyBUT04gYWxnb3JpdGhtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlRvbkNyYzE2fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZlRvbkNyYzE2XG4gICAgICovXG4gICAgdG9uX2NyYzE2KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLnRvbl9jcmMxNicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyByYW5kb20gYnl0ZSBhcnJheSBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aCBhbmQgcmV0dXJucyBpdCBpbiBgYmFzZTY0YCBmb3JtYXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZHZW5lcmF0ZVJhbmRvbUJ5dGVzfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkdlbmVyYXRlUmFuZG9tQnl0ZXNcbiAgICAgKi9cbiAgICBnZW5lcmF0ZV9yYW5kb21fYnl0ZXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8uZ2VuZXJhdGVfcmFuZG9tX2J5dGVzJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgcHVibGljIGtleSB0byB0b24gc2FmZV9mb3JtYXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZDb252ZXJ0UHVibGljS2V5VG9Ub25TYWZlRm9ybWF0fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkNvbnZlcnRQdWJsaWNLZXlUb1RvblNhZmVGb3JtYXRcbiAgICAgKi9cbiAgICBjb252ZXJ0X3B1YmxpY19rZXlfdG9fdG9uX3NhZmVfZm9ybWF0KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLmNvbnZlcnRfcHVibGljX2tleV90b190b25fc2FmZV9mb3JtYXQnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgcmFuZG9tIGVkMjU1MTkga2V5IHBhaXIuXG4gICAgICogQHJldHVybnMgS2V5UGFpclxuICAgICAqL1xuICAgIGdlbmVyYXRlX3JhbmRvbV9zaWduX2tleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8uZ2VuZXJhdGVfcmFuZG9tX3NpZ25fa2V5cycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyBhIGRhdGEgdXNpbmcgdGhlIHByb3ZpZGVkIGtleXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mU2lnbn0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZTaWduXG4gICAgICovXG4gICAgc2lnbihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5zaWduJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgc2lnbmVkIGRhdGEgdXNpbmcgdGhlIHByb3ZpZGVkIHB1YmxpYyBrZXkuIFJhaXNlcyBlcnJvciBpZiB2ZXJpZmljYXRpb24gaXMgZmFpbGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlZlcmlmeVNpZ25hdHVyZX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZWZXJpZnlTaWduYXR1cmVcbiAgICAgKi9cbiAgICB2ZXJpZnlfc2lnbmF0dXJlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLnZlcmlmeV9zaWduYXR1cmUnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIFNIQTI1NiBoYXNoIG9mIHRoZSBzcGVjaWZpZWQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZIYXNofSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkhhc2hcbiAgICAgKi9cbiAgICBzaGEyNTYocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8uc2hhMjU2JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBTSEE1MTIgaGFzaCBvZiB0aGUgc3BlY2lmaWVkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mSGFzaH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZIYXNoXG4gICAgICovXG4gICAgc2hhNTEyKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLnNoYTUxMicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYHNjcnlwdGAgZW5jcnlwdGlvblxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBEZXJpdmVzIGtleSBmcm9tIGBwYXNzd29yZGAgYW5kIGBrZXlgIHVzaW5nIGBzY3J5cHRgIGFsZ29yaXRobS5cbiAgICAgKiBTZWUgW2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NjcnlwdF0uXG4gICAgICpcbiAgICAgKiAjIEFyZ3VtZW50c1xuICAgICAqIC0gYGxvZ19uYCAtIFRoZSBsb2cyIG9mIHRoZSBTY3J5cHQgcGFyYW1ldGVyIGBOYFxuICAgICAqIC0gYHJgIC0gVGhlIFNjcnlwdCBwYXJhbWV0ZXIgYHJgXG4gICAgICogLSBgcGAgLSBUaGUgU2NyeXB0IHBhcmFtZXRlciBgcGBcbiAgICAgKiAjIENvbmRpdGlvbnNcbiAgICAgKiAtIGBsb2dfbmAgbXVzdCBiZSBsZXNzIHRoYW4gYDY0YFxuICAgICAqIC0gYHJgIG11c3QgYmUgZ3JlYXRlciB0aGFuIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGA0Mjk0OTY3Mjk1YFxuICAgICAqIC0gYHBgIG11c3QgYmUgZ3JlYXRlciB0aGFuIGAwYCBhbmQgbGVzcyB0aGFuIGA0Mjk0OTY3Mjk1YFxuICAgICAqICMgUmVjb21tZW5kZWQgdmFsdWVzIHN1ZmZpY2llbnQgZm9yIG1vc3QgdXNlLWNhc2VzXG4gICAgICogLSBgbG9nX24gPSAxNWAgKGBuID0gMzI3NjhgKVxuICAgICAqIC0gYHIgPSA4YFxuICAgICAqIC0gYHAgPSAxYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlNjcnlwdH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZTY3J5cHRcbiAgICAgKi9cbiAgICBzY3J5cHQocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8uc2NyeXB0JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEga2V5IHBhaXIgZm9yIHNpZ25pbmcgZnJvbSB0aGUgc2VjcmV0IGtleVxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiAqKk5PVEU6KiogSW4gdGhlIHJlc3VsdCB0aGUgc2VjcmV0IGtleSBpcyBhY3R1YWxseSB0aGUgY29uY2F0ZW5hdGlvblxuICAgICAqIG9mIHNlY3JldCBhbmQgcHVibGljIGtleXMgKDEyOCBzeW1ib2xzIGhleCBzdHJpbmcpIGJ5IGRlc2lnbiBvZiBbTmFDTF0oaHR0cDovL25hY2wuY3IueXAudG8vc2lnbi5odG1sKS5cbiAgICAgKiBTZWUgYWxzbyBbdGhlIHN0YWNrZXhjaGFuZ2UgcXVlc3Rpb25dKGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NDM1My8pLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZk5hY2xTaWduS2V5UGFpckZyb21TZWNyZXR9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIEtleVBhaXJcbiAgICAgKi9cbiAgICBuYWNsX3NpZ25fa2V5cGFpcl9mcm9tX3NlY3JldF9rZXkocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8ubmFjbF9zaWduX2tleXBhaXJfZnJvbV9zZWNyZXRfa2V5JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgZGF0YSB1c2luZyB0aGUgc2lnbmVyJ3Mgc2VjcmV0IGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZOYWNsU2lnbn0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZOYWNsU2lnblxuICAgICAqL1xuICAgIG5hY2xfc2lnbihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5uYWNsX3NpZ24nLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyB0aGUgc2lnbmF0dXJlIGFuZCByZXR1cm5zIHRoZSB1bnNpZ25lZCBtZXNzYWdlXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFZlcmlmaWVzIHRoZSBzaWduYXR1cmUgaW4gYHNpZ25lZGAgdXNpbmcgdGhlIHNpZ25lcidzIHB1YmxpYyBrZXkgYHB1YmxpY2BcbiAgICAgKiBhbmQgcmV0dXJucyB0aGUgbWVzc2FnZSBgdW5zaWduZWRgLlxuICAgICAqXG4gICAgICogSWYgdGhlIHNpZ25hdHVyZSBmYWlscyB2ZXJpZmljYXRpb24sIGNyeXB0b19zaWduX29wZW4gcmFpc2VzIGFuIGV4Y2VwdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZOYWNsU2lnbk9wZW59IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mTmFjbFNpZ25PcGVuXG4gICAgICovXG4gICAgbmFjbF9zaWduX29wZW4ocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8ubmFjbF9zaWduX29wZW4nLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyB0aGUgbWVzc2FnZSB1c2luZyB0aGUgc2VjcmV0IGtleSBhbmQgcmV0dXJucyBhIHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogU2lnbnMgdGhlIG1lc3NhZ2UgYHVuc2lnbmVkYCB1c2luZyB0aGUgc2VjcmV0IGtleSBgc2VjcmV0YFxuICAgICAqIGFuZCByZXR1cm5zIGEgc2lnbmF0dXJlIGBzaWduYXR1cmVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZk5hY2xTaWdufSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZk5hY2xTaWduRGV0YWNoZWRcbiAgICAgKi9cbiAgICBuYWNsX3NpZ25fZGV0YWNoZWQocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8ubmFjbF9zaWduX2RldGFjaGVkJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhlIHNpZ25hdHVyZSB3aXRoIHB1YmxpYyBrZXkgYW5kIGB1bnNpZ25lZGAgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZOYWNsU2lnbkRldGFjaGVkVmVyaWZ5fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZk5hY2xTaWduRGV0YWNoZWRWZXJpZnlcbiAgICAgKi9cbiAgICBuYWNsX3NpZ25fZGV0YWNoZWRfdmVyaWZ5KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLm5hY2xfc2lnbl9kZXRhY2hlZF92ZXJpZnknLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSByYW5kb20gTmFDbCBrZXkgcGFpclxuICAgICAqIEByZXR1cm5zIEtleVBhaXJcbiAgICAgKi9cbiAgICBuYWNsX2JveF9rZXlwYWlyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLm5hY2xfYm94X2tleXBhaXInKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGtleSBwYWlyIGZyb20gYSBzZWNyZXQga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mTmFjbEJveEtleVBhaXJGcm9tU2VjcmV0fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBLZXlQYWlyXG4gICAgICovXG4gICAgbmFjbF9ib3hfa2V5cGFpcl9mcm9tX3NlY3JldF9rZXkocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8ubmFjbF9ib3hfa2V5cGFpcl9mcm9tX3NlY3JldF9rZXknLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMga2V5IGF1dGhlbnRpY2F0ZWQgZW5jcnlwdGlvblxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBFbmNyeXB0IGFuZCBhdXRoZW50aWNhdGUgYSBtZXNzYWdlIHVzaW5nIHRoZSBzZW5kZXJzIHNlY3JldCBrZXksIHRoZSByZWNlaXZlcnMgcHVibGljXG4gICAgICoga2V5LCBhbmQgYSBub25jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZOYWNsQm94fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZk5hY2xCb3hcbiAgICAgKi9cbiAgICBuYWNsX2JveChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5uYWNsX2JveCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY3J5cHQgYW5kIHZlcmlmeSB0aGUgY2lwaGVyIHRleHQgdXNpbmcgdGhlIHJlY2VpdmVycyBzZWNyZXQga2V5LCB0aGUgc2VuZGVycyBwdWJsaWMga2V5LCBhbmQgdGhlIG5vbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZk5hY2xCb3hPcGVufSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZk5hY2xCb3hPcGVuXG4gICAgICovXG4gICAgbmFjbF9ib3hfb3BlbihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5uYWNsX2JveF9vcGVuJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jcnlwdCBhbmQgYXV0aGVudGljYXRlIG1lc3NhZ2UgdXNpbmcgbm9uY2UgYW5kIHNlY3JldCBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mTmFjbFNlY3JldEJveH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZOYWNsQm94XG4gICAgICovXG4gICAgbmFjbF9zZWNyZXRfYm94KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLm5hY2xfc2VjcmV0X2JveCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY3J5cHRzIGFuZCB2ZXJpZmllcyBjaXBoZXIgdGV4dCB1c2luZyBgbm9uY2VgIGFuZCBzZWNyZXQgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mTmFjbFNlY3JldEJveE9wZW59IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mTmFjbEJveE9wZW5cbiAgICAgKi9cbiAgICBuYWNsX3NlY3JldF9ib3hfb3BlbihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5uYWNsX3NlY3JldF9ib3hfb3BlbicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaW50cyB0aGUgbGlzdCBvZiB3b3JkcyBmcm9tIHRoZSBzcGVjaWZpZWQgZGljdGlvbmFyeVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZk1uZW1vbmljV29yZHN9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mTW5lbW9uaWNXb3Jkc1xuICAgICAqL1xuICAgIG1uZW1vbmljX3dvcmRzKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLm1uZW1vbmljX3dvcmRzJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgcmFuZG9tIG1uZW1vbmljXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEdlbmVyYXRlcyBhIHJhbmRvbSBtbmVtb25pYyBmcm9tIHRoZSBzcGVjaWZpZWQgZGljdGlvbmFyeSBhbmQgd29yZCBjb3VudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZk1uZW1vbmljRnJvbVJhbmRvbX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZNbmVtb25pY0Zyb21SYW5kb21cbiAgICAgKi9cbiAgICBtbmVtb25pY19mcm9tX3JhbmRvbShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5tbmVtb25pY19mcm9tX3JhbmRvbScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBtbmVtb25pYyBmcm9tIHByZS1nZW5lcmF0ZWQgZW50cm9weVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZk1uZW1vbmljRnJvbUVudHJvcHl9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mTW5lbW9uaWNGcm9tRW50cm9weVxuICAgICAqL1xuICAgIG1uZW1vbmljX2Zyb21fZW50cm9weShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5tbmVtb25pY19mcm9tX2VudHJvcHknLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgYSBtbmVtb25pYyBwaHJhc2VcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIHBocmFzZSBzdXBwbGllZCB3aWxsIGJlIGNoZWNrZWQgZm9yIHdvcmQgbGVuZ3RoIGFuZCB2YWxpZGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjaGVja3N1bVxuICAgICAqIHNwZWNpZmllZCBpbiBCSVAwMDM5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZk1uZW1vbmljVmVyaWZ5fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZk1uZW1vbmljVmVyaWZ5XG4gICAgICovXG4gICAgbW5lbW9uaWNfdmVyaWZ5KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLm1uZW1vbmljX3ZlcmlmeScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcml2ZXMgYSBrZXkgcGFpciBmb3Igc2lnbmluZyBmcm9tIHRoZSBzZWVkIHBocmFzZVxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIHNlZWQgcGhyYXNlLCBnZW5lcmF0ZXMgbWFzdGVyIGtleSBhbmQgdGhlbiBkZXJpdmVzXG4gICAgICogdGhlIGtleSBwYWlyIGZyb20gdGhlIG1hc3RlciBrZXkgYW5kIHRoZSBzcGVjaWZpZWQgcGF0aFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZk1uZW1vbmljRGVyaXZlU2lnbktleXN9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIEtleVBhaXJcbiAgICAgKi9cbiAgICBtbmVtb25pY19kZXJpdmVfc2lnbl9rZXlzKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLm1uZW1vbmljX2Rlcml2ZV9zaWduX2tleXMnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gZXh0ZW5kZWQgbWFzdGVyIHByaXZhdGUga2V5IHRoYXQgd2lsbCBiZSB0aGUgcm9vdCBmb3IgYWxsIHRoZSBkZXJpdmVkIGtleXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZIREtleVhQcnZGcm9tTW5lbW9uaWN9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mSERLZXlYUHJ2RnJvbU1uZW1vbmljXG4gICAgICovXG4gICAgaGRrZXlfeHBydl9mcm9tX21uZW1vbmljKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLmhka2V5X3hwcnZfZnJvbV9tbmVtb25pYycsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgZGVyaXZlZCBmcm9tIHRoZSBzcGVjaWZpZWQgZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgYW5kIGNoaWxkIGluZGV4XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mSERLZXlEZXJpdmVGcm9tWFBydn0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZIREtleURlcml2ZUZyb21YUHJ2XG4gICAgICovXG4gICAgaGRrZXlfZGVyaXZlX2Zyb21feHBydihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5oZGtleV9kZXJpdmVfZnJvbV94cHJ2JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVyaXZlcyB0aGUgZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgZnJvbSB0aGUgc3BlY2lmaWVkIGtleSBhbmQgcGF0aFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkhES2V5RGVyaXZlRnJvbVhQcnZQYXRofSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkhES2V5RGVyaXZlRnJvbVhQcnZQYXRoXG4gICAgICovXG4gICAgaGRrZXlfZGVyaXZlX2Zyb21feHBydl9wYXRoKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLmhka2V5X2Rlcml2ZV9mcm9tX3hwcnZfcGF0aCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBwcml2YXRlIGtleSBmcm9tIHRoZSBzZXJpYWxpemVkIGV4dGVuZGVkIHByaXZhdGUga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mSERLZXlTZWNyZXRGcm9tWFBydn0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZIREtleVNlY3JldEZyb21YUHJ2XG4gICAgICovXG4gICAgaGRrZXlfc2VjcmV0X2Zyb21feHBydihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5oZGtleV9zZWNyZXRfZnJvbV94cHJ2JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHB1YmxpYyBrZXkgZnJvbSB0aGUgc2VyaWFsaXplZCBleHRlbmRlZCBwcml2YXRlIGtleVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkhES2V5UHVibGljRnJvbVhQcnZ9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mSERLZXlQdWJsaWNGcm9tWFBydlxuICAgICAqL1xuICAgIGhka2V5X3B1YmxpY19mcm9tX3hwcnYocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8uaGRrZXlfcHVibGljX2Zyb21feHBydicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHN5bW1ldHJpYyBgY2hhY2hhMjBgIGVuY3J5cHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mQ2hhQ2hhMjB9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mQ2hhQ2hhMjBcbiAgICAgKi9cbiAgICBjaGFjaGEyMChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5jaGFjaGEyMCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBDcnlwdG8gQm94IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBDcnlwdG8gQm94IGlzIGEgcm9vdCBjcnlwdG8gb2JqZWN0LCB0aGF0IGVuY2Fwc3VsYXRlcyBzb21lIHNlY3JldCAoc2VlZCBwaHJhc2UgdXN1YWxseSlcbiAgICAgKiBpbiBlbmNyeXB0ZWQgZm9ybSBhbmQgYWN0cyBhcyBhIGZhY3RvcnkgZm9yIGFsbCBjcnlwdG8gcHJpbWl0aXZlcyB1c2VkIGluIFNESzpcbiAgICAgKiBrZXlzIGZvciBzaWduaW5nIGFuZCBlbmNyeXB0aW9uLCBkZXJpdmVkIGZyb20gdGhpcyBzZWNyZXQuXG4gICAgICpcbiAgICAgKiBDcnlwdG8gQm94IGVuY3J5cHRzIG9yaWdpbmFsIFNlZWQgUGhyYXNlIHdpdGggc2FsdCBhbmQgcGFzc3dvcmQgdGhhdCBpcyByZXRyaWV2ZWRcbiAgICAgKiBmcm9tIGBwYXNzd29yZF9wcm92aWRlcmAgY2FsbGJhY2ssIGltcGxlbWVudGVkIG9uIEFwcGxpY2F0aW9uIHNpZGUuXG4gICAgICpcbiAgICAgKiBXaGVuIHVzZWQsIGRlY3J5cHRlZCBzZWNyZXQgc2hvd3MgdXAgaW4gY29yZSBsaWJyYXJ5J3MgbWVtb3J5IGZvciBhIHZlcnkgc2hvcnQgcGVyaW9kXG4gICAgICogb2YgdGltZSBhbmQgdGhlbiBpcyBpbW1lZGlhdGVseSBvdmVyd3JpdHRlbiB3aXRoIHplcm9lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZDcmVhdGVDcnlwdG9Cb3h9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlZ2lzdGVyZWRDcnlwdG9Cb3hcbiAgICAgKi9cbiAgICBjcmVhdGVfY3J5cHRvX2JveChwYXJhbXMsIG9iaikge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLmNyZWF0ZV9jcnlwdG9fYm94JywgcGFyYW1zLCAocGFyYW1zLCByZXNwb25zZVR5cGUpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEFwcFBhc3N3b3JkUHJvdmlkZXIob2JqLCBwYXJhbXMucmVxdWVzdF9kYXRhLCBwYXJhbXMuYXBwX3JlcXVlc3RfaWQsIHRoaXMuY2xpZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlVHlwZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoQXBwUGFzc3dvcmRQcm92aWRlcihvYmosIHBhcmFtcywgbnVsbCwgdGhpcy5jbGllbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBDcnlwdG8gQm94LiBDbGVhcnMgYWxsIHNlY3JldCBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWdpc3RlcmVkQ3J5cHRvQm94fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHJlbW92ZV9jcnlwdG9fYm94KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLnJlbW92ZV9jcnlwdG9fYm94JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IENyeXB0byBCb3ggSW5mby4gVXNlZCB0byBnZXQgYGVuY3J5cHRlZF9zZWNyZXRgIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIGFsbCB0aGUgY3J5cHRvYm94IGluaXRpYWxpemF0aW9ucyBleGNlcHQgdGhlIGZpcnN0IG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVnaXN0ZXJlZENyeXB0b0JveH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZHZXRDcnlwdG9Cb3hJbmZvXG4gICAgICovXG4gICAgZ2V0X2NyeXB0b19ib3hfaW5mbyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5nZXRfY3J5cHRvX2JveF9pbmZvJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IENyeXB0byBCb3ggU2VlZCBQaHJhc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEF0dGVudGlvbiEgU3RvcmUgdGhpcyBkYXRhIGluIHlvdXIgYXBwbGljYXRpb24gZm9yIGEgdmVyeSBzaG9ydCBwZXJpb2Qgb2YgdGltZSBhbmQgb3ZlcndyaXRlIGl0IHdpdGggemVyb2VzIEFTQVAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlZ2lzdGVyZWRDcnlwdG9Cb3h9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mR2V0Q3J5cHRvQm94U2VlZFBocmFzZVxuICAgICAqL1xuICAgIGdldF9jcnlwdG9fYm94X3NlZWRfcGhyYXNlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLmdldF9jcnlwdG9fYm94X3NlZWRfcGhyYXNlJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGhhbmRsZSBvZiBTaWduaW5nIEJveCBkZXJpdmVkIGZyb20gQ3J5cHRvIEJveC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZHZXRTaWduaW5nQm94RnJvbUNyeXB0b0JveH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVnaXN0ZXJlZFNpZ25pbmdCb3hcbiAgICAgKi9cbiAgICBnZXRfc2lnbmluZ19ib3hfZnJvbV9jcnlwdG9fYm94KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLmdldF9zaWduaW5nX2JveF9mcm9tX2NyeXB0b19ib3gnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIEVuY3J5cHRpb24gQm94IGZyb20gQ3J5cHRvIEJveC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRGVyaXZlcyBlbmNyeXB0aW9uIGtleXBhaXIgZnJvbSBjcnlwdG9ib3ggc2VjcmV0IGFuZCBoZHBhdGggYW5kXG4gICAgICogc3RvcmVzIGl0IGluIGNhY2hlIGZvciBgc2VjcmV0X2xpZmV0aW1lYFxuICAgICAqIG9yIHVudGlsIGV4cGxpY2l0bHkgY2xlYXJlZCBieSBgY2xlYXJfY3J5cHRvX2JveF9zZWNyZXRfY2FjaGVgIG1ldGhvZC5cbiAgICAgKiBJZiBgc2VjcmV0X2xpZmV0aW1lYCBpcyBub3Qgc3BlY2lmaWVkIC0gb3ZlcndyaXRlcyBlbmNyeXB0aW9uIHNlY3JldCB3aXRoIHplcm9lcyBpbW1lZGlhdGVseSBhZnRlclxuICAgICAqIGVuY3J5cHRpb24gb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkdldEVuY3J5cHRpb25Cb3hGcm9tQ3J5cHRvQm94fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZWdpc3RlcmVkRW5jcnlwdGlvbkJveFxuICAgICAqL1xuICAgIGdldF9lbmNyeXB0aW9uX2JveF9mcm9tX2NyeXB0b19ib3gocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8uZ2V0X2VuY3J5cHRpb25fYm94X2Zyb21fY3J5cHRvX2JveCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgY2FjaGVkIHNlY3JldHMgKG92ZXJ3cml0ZXMgd2l0aCB6ZXJvZXMpIGZyb20gYWxsIHNpZ25pbmcgYW5kIGVuY3J5cHRpb24gYm94ZXMsIGRlcml2ZWQgZnJvbSBjcnlwdG8gYm94LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWdpc3RlcmVkQ3J5cHRvQm94fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGNsZWFyX2NyeXB0b19ib3hfc2VjcmV0X2NhY2hlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLmNsZWFyX2NyeXB0b19ib3hfc2VjcmV0X2NhY2hlJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYW4gYXBwbGljYXRpb24gaW1wbGVtZW50ZWQgc2lnbmluZyBib3guXG4gICAgICogQHJldHVybnMgUmVnaXN0ZXJlZFNpZ25pbmdCb3hcbiAgICAgKi9cbiAgICByZWdpc3Rlcl9zaWduaW5nX2JveChvYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5yZWdpc3Rlcl9zaWduaW5nX2JveCcsIHVuZGVmaW5lZCwgKHBhcmFtcywgcmVzcG9uc2VUeXBlKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hBcHBTaWduaW5nQm94KG9iaiwgcGFyYW1zLnJlcXVlc3RfZGF0YSwgcGFyYW1zLmFwcF9yZXF1ZXN0X2lkLCB0aGlzLmNsaWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEFwcFNpZ25pbmdCb3gob2JqLCBwYXJhbXMsIG51bGwsIHRoaXMuY2xpZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWZhdWx0IHNpZ25pbmcgYm94IGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtLZXlQYWlyfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZWdpc3RlcmVkU2lnbmluZ0JveFxuICAgICAqL1xuICAgIGdldF9zaWduaW5nX2JveChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5nZXRfc2lnbmluZ19ib3gnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHB1YmxpYyBrZXkgb2Ygc2lnbmluZyBrZXkgcGFpci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVnaXN0ZXJlZFNpZ25pbmdCb3h9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mU2lnbmluZ0JveEdldFB1YmxpY0tleVxuICAgICAqL1xuICAgIHNpZ25pbmdfYm94X2dldF9wdWJsaWNfa2V5KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLnNpZ25pbmdfYm94X2dldF9wdWJsaWNfa2V5JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzaWduZWQgdXNlciBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlNpZ25pbmdCb3hTaWdufSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZlNpZ25pbmdCb3hTaWduXG4gICAgICovXG4gICAgc2lnbmluZ19ib3hfc2lnbihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5zaWduaW5nX2JveF9zaWduJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBzaWduaW5nIGJveCBmcm9tIFNESy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVnaXN0ZXJlZFNpZ25pbmdCb3h9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcmVtb3ZlX3NpZ25pbmdfYm94KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLnJlbW92ZV9zaWduaW5nX2JveCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFuIGFwcGxpY2F0aW9uIGltcGxlbWVudGVkIGVuY3J5cHRpb24gYm94LlxuICAgICAqIEByZXR1cm5zIFJlZ2lzdGVyZWRFbmNyeXB0aW9uQm94XG4gICAgICovXG4gICAgcmVnaXN0ZXJfZW5jcnlwdGlvbl9ib3gob2JqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8ucmVnaXN0ZXJfZW5jcnlwdGlvbl9ib3gnLCB1bmRlZmluZWQsIChwYXJhbXMsIHJlc3BvbnNlVHlwZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoQXBwRW5jcnlwdGlvbkJveChvYmosIHBhcmFtcy5yZXF1ZXN0X2RhdGEsIHBhcmFtcy5hcHBfcmVxdWVzdF9pZCwgdGhpcy5jbGllbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hBcHBFbmNyeXB0aW9uQm94KG9iaiwgcGFyYW1zLCBudWxsLCB0aGlzLmNsaWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGVuY3J5cHRpb24gYm94IGZyb20gU0RLXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlZ2lzdGVyZWRFbmNyeXB0aW9uQm94fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHJlbW92ZV9lbmNyeXB0aW9uX2JveChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5yZW1vdmVfZW5jcnlwdGlvbl9ib3gnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyaWVzIGluZm8gZnJvbSB0aGUgZ2l2ZW4gZW5jcnlwdGlvbiBib3hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZFbmNyeXB0aW9uQm94R2V0SW5mb30gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZFbmNyeXB0aW9uQm94R2V0SW5mb1xuICAgICAqL1xuICAgIGVuY3J5cHRpb25fYm94X2dldF9pbmZvKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLmVuY3J5cHRpb25fYm94X2dldF9pbmZvJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jcnlwdHMgZGF0YSB1c2luZyBnaXZlbiBlbmNyeXB0aW9uIGJveCBOb3RlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBCbG9jayBjaXBoZXIgYWxnb3JpdGhtcyBwYWQgZGF0YSB0byBjaXBoZXIgYmxvY2sgc2l6ZSBzbyBlbmNyeXB0ZWQgZGF0YSBjYW4gYmUgbG9uZ2VyIHRoZW4gb3JpZ2luYWwgZGF0YS4gQ2xpZW50IHNob3VsZCBzdG9yZSB0aGUgb3JpZ2luYWwgZGF0YSBzaXplIGFmdGVyIGVuY3J5cHRpb24gYW5kIHVzZSBpdCBhZnRlclxuICAgICAqIGRlY3J5cHRpb24gdG8gcmV0cmlldmUgdGhlIG9yaWdpbmFsIGRhdGEgZnJvbSBkZWNyeXB0ZWQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZFbmNyeXB0aW9uQm94RW5jcnlwdH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZFbmNyeXB0aW9uQm94RW5jcnlwdFxuICAgICAqL1xuICAgIGVuY3J5cHRpb25fYm94X2VuY3J5cHQocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8uZW5jcnlwdGlvbl9ib3hfZW5jcnlwdCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY3J5cHRzIGRhdGEgdXNpbmcgZ2l2ZW4gZW5jcnlwdGlvbiBib3ggTm90ZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQmxvY2sgY2lwaGVyIGFsZ29yaXRobXMgcGFkIGRhdGEgdG8gY2lwaGVyIGJsb2NrIHNpemUgc28gZW5jcnlwdGVkIGRhdGEgY2FuIGJlIGxvbmdlciB0aGVuIG9yaWdpbmFsIGRhdGEuIENsaWVudCBzaG91bGQgc3RvcmUgdGhlIG9yaWdpbmFsIGRhdGEgc2l6ZSBhZnRlciBlbmNyeXB0aW9uIGFuZCB1c2UgaXQgYWZ0ZXJcbiAgICAgKiBkZWNyeXB0aW9uIHRvIHJldHJpZXZlIHRoZSBvcmlnaW5hbCBkYXRhIGZyb20gZGVjcnlwdGVkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mRW5jcnlwdGlvbkJveERlY3J5cHR9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mRW5jcnlwdGlvbkJveERlY3J5cHRcbiAgICAgKi9cbiAgICBlbmNyeXB0aW9uX2JveF9kZWNyeXB0KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLmVuY3J5cHRpb25fYm94X2RlY3J5cHQnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGVuY3J5cHRpb24gYm94IHdpdGggc3BlY2lmaWVkIGFsZ29yaXRobVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkNyZWF0ZUVuY3J5cHRpb25Cb3h9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlZ2lzdGVyZWRFbmNyeXB0aW9uQm94XG4gICAgICovXG4gICAgY3JlYXRlX2VuY3J5cHRpb25fYm94KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLmNyZWF0ZV9lbmNyeXB0aW9uX2JveCcsIHBhcmFtcyk7XG4gICAgfVxufVxuZXhwb3J0cy5DcnlwdG9Nb2R1bGUgPSBDcnlwdG9Nb2R1bGU7XG4vLyBhYmkgbW9kdWxlXG52YXIgQWJpRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChBYmlFcnJvckNvZGUpIHtcbiAgICBBYmlFcnJvckNvZGVbQWJpRXJyb3JDb2RlW1wiUmVxdWlyZWRBZGRyZXNzTWlzc2luZ0ZvckVuY29kZU1lc3NhZ2VcIl0gPSAzMDFdID0gXCJSZXF1aXJlZEFkZHJlc3NNaXNzaW5nRm9yRW5jb2RlTWVzc2FnZVwiO1xuICAgIEFiaUVycm9yQ29kZVtBYmlFcnJvckNvZGVbXCJSZXF1aXJlZENhbGxTZXRNaXNzaW5nRm9yRW5jb2RlTWVzc2FnZVwiXSA9IDMwMl0gPSBcIlJlcXVpcmVkQ2FsbFNldE1pc3NpbmdGb3JFbmNvZGVNZXNzYWdlXCI7XG4gICAgQWJpRXJyb3JDb2RlW0FiaUVycm9yQ29kZVtcIkludmFsaWRKc29uXCJdID0gMzAzXSA9IFwiSW52YWxpZEpzb25cIjtcbiAgICBBYmlFcnJvckNvZGVbQWJpRXJyb3JDb2RlW1wiSW52YWxpZE1lc3NhZ2VcIl0gPSAzMDRdID0gXCJJbnZhbGlkTWVzc2FnZVwiO1xuICAgIEFiaUVycm9yQ29kZVtBYmlFcnJvckNvZGVbXCJFbmNvZGVEZXBsb3lNZXNzYWdlRmFpbGVkXCJdID0gMzA1XSA9IFwiRW5jb2RlRGVwbG95TWVzc2FnZUZhaWxlZFwiO1xuICAgIEFiaUVycm9yQ29kZVtBYmlFcnJvckNvZGVbXCJFbmNvZGVSdW5NZXNzYWdlRmFpbGVkXCJdID0gMzA2XSA9IFwiRW5jb2RlUnVuTWVzc2FnZUZhaWxlZFwiO1xuICAgIEFiaUVycm9yQ29kZVtBYmlFcnJvckNvZGVbXCJBdHRhY2hTaWduYXR1cmVGYWlsZWRcIl0gPSAzMDddID0gXCJBdHRhY2hTaWduYXR1cmVGYWlsZWRcIjtcbiAgICBBYmlFcnJvckNvZGVbQWJpRXJyb3JDb2RlW1wiSW52YWxpZFR2Y0ltYWdlXCJdID0gMzA4XSA9IFwiSW52YWxpZFR2Y0ltYWdlXCI7XG4gICAgQWJpRXJyb3JDb2RlW0FiaUVycm9yQ29kZVtcIlJlcXVpcmVkUHVibGljS2V5TWlzc2luZ0ZvckZ1bmN0aW9uSGVhZGVyXCJdID0gMzA5XSA9IFwiUmVxdWlyZWRQdWJsaWNLZXlNaXNzaW5nRm9yRnVuY3Rpb25IZWFkZXJcIjtcbiAgICBBYmlFcnJvckNvZGVbQWJpRXJyb3JDb2RlW1wiSW52YWxpZFNpZ25lclwiXSA9IDMxMF0gPSBcIkludmFsaWRTaWduZXJcIjtcbiAgICBBYmlFcnJvckNvZGVbQWJpRXJyb3JDb2RlW1wiSW52YWxpZEFiaVwiXSA9IDMxMV0gPSBcIkludmFsaWRBYmlcIjtcbiAgICBBYmlFcnJvckNvZGVbQWJpRXJyb3JDb2RlW1wiSW52YWxpZEZ1bmN0aW9uSWRcIl0gPSAzMTJdID0gXCJJbnZhbGlkRnVuY3Rpb25JZFwiO1xuICAgIEFiaUVycm9yQ29kZVtBYmlFcnJvckNvZGVbXCJJbnZhbGlkRGF0YVwiXSA9IDMxM10gPSBcIkludmFsaWREYXRhXCI7XG4gICAgQWJpRXJyb3JDb2RlW0FiaUVycm9yQ29kZVtcIkVuY29kZUluaXRpYWxEYXRhRmFpbGVkXCJdID0gMzE0XSA9IFwiRW5jb2RlSW5pdGlhbERhdGFGYWlsZWRcIjtcbiAgICBBYmlFcnJvckNvZGVbQWJpRXJyb3JDb2RlW1wiSW52YWxpZEZ1bmN0aW9uTmFtZVwiXSA9IDMxNV0gPSBcIkludmFsaWRGdW5jdGlvbk5hbWVcIjtcbn0pKEFiaUVycm9yQ29kZSA9IGV4cG9ydHMuQWJpRXJyb3JDb2RlIHx8IChleHBvcnRzLkFiaUVycm9yQ29kZSA9IHt9KSk7XG5mdW5jdGlvbiBhYmlDb250cmFjdCh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdDb250cmFjdCcsXG4gICAgICAgIHZhbHVlLFxuICAgIH07XG59XG5leHBvcnRzLmFiaUNvbnRyYWN0ID0gYWJpQ29udHJhY3Q7XG5mdW5jdGlvbiBhYmlKc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0pzb24nLFxuICAgICAgICB2YWx1ZSxcbiAgICB9O1xufVxuZXhwb3J0cy5hYmlKc29uID0gYWJpSnNvbjtcbmZ1bmN0aW9uIGFiaUhhbmRsZSh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdIYW5kbGUnLFxuICAgICAgICB2YWx1ZSxcbiAgICB9O1xufVxuZXhwb3J0cy5hYmlIYW5kbGUgPSBhYmlIYW5kbGU7XG5mdW5jdGlvbiBhYmlTZXJpYWxpemVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1NlcmlhbGl6ZWQnLFxuICAgICAgICB2YWx1ZSxcbiAgICB9O1xufVxuZXhwb3J0cy5hYmlTZXJpYWxpemVkID0gYWJpU2VyaWFsaXplZDtcbmZ1bmN0aW9uIHNpZ25lck5vbmUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ05vbmUnLFxuICAgIH07XG59XG5leHBvcnRzLnNpZ25lck5vbmUgPSBzaWduZXJOb25lO1xuZnVuY3Rpb24gc2lnbmVyRXh0ZXJuYWwocHVibGljX2tleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdFeHRlcm5hbCcsXG4gICAgICAgIHB1YmxpY19rZXksXG4gICAgfTtcbn1cbmV4cG9ydHMuc2lnbmVyRXh0ZXJuYWwgPSBzaWduZXJFeHRlcm5hbDtcbmZ1bmN0aW9uIHNpZ25lcktleXMoa2V5cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdLZXlzJyxcbiAgICAgICAga2V5cyxcbiAgICB9O1xufVxuZXhwb3J0cy5zaWduZXJLZXlzID0gc2lnbmVyS2V5cztcbmZ1bmN0aW9uIHNpZ25lclNpZ25pbmdCb3goaGFuZGxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1NpZ25pbmdCb3gnLFxuICAgICAgICBoYW5kbGUsXG4gICAgfTtcbn1cbmV4cG9ydHMuc2lnbmVyU2lnbmluZ0JveCA9IHNpZ25lclNpZ25pbmdCb3g7XG52YXIgTWVzc2FnZUJvZHlUeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlQm9keVR5cGUpIHtcbiAgICBNZXNzYWdlQm9keVR5cGVbXCJJbnB1dFwiXSA9IFwiSW5wdXRcIjtcbiAgICBNZXNzYWdlQm9keVR5cGVbXCJPdXRwdXRcIl0gPSBcIk91dHB1dFwiO1xuICAgIE1lc3NhZ2VCb2R5VHlwZVtcIkludGVybmFsT3V0cHV0XCJdID0gXCJJbnRlcm5hbE91dHB1dFwiO1xuICAgIE1lc3NhZ2VCb2R5VHlwZVtcIkV2ZW50XCJdID0gXCJFdmVudFwiO1xufSkoTWVzc2FnZUJvZHlUeXBlID0gZXhwb3J0cy5NZXNzYWdlQm9keVR5cGUgfHwgKGV4cG9ydHMuTWVzc2FnZUJvZHlUeXBlID0ge30pKTtcbmZ1bmN0aW9uIHN0YXRlSW5pdFNvdXJjZU1lc3NhZ2Uoc291cmNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ01lc3NhZ2UnLFxuICAgICAgICBzb3VyY2UsXG4gICAgfTtcbn1cbmV4cG9ydHMuc3RhdGVJbml0U291cmNlTWVzc2FnZSA9IHN0YXRlSW5pdFNvdXJjZU1lc3NhZ2U7XG5mdW5jdGlvbiBzdGF0ZUluaXRTb3VyY2VTdGF0ZUluaXQoY29kZSwgZGF0YSwgbGlicmFyeSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdTdGF0ZUluaXQnLFxuICAgICAgICBjb2RlLFxuICAgICAgICBkYXRhLFxuICAgICAgICBsaWJyYXJ5LFxuICAgIH07XG59XG5leHBvcnRzLnN0YXRlSW5pdFNvdXJjZVN0YXRlSW5pdCA9IHN0YXRlSW5pdFNvdXJjZVN0YXRlSW5pdDtcbmZ1bmN0aW9uIHN0YXRlSW5pdFNvdXJjZVR2Yyh0dmMsIHB1YmxpY19rZXksIGluaXRfcGFyYW1zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1R2YycsXG4gICAgICAgIHR2YyxcbiAgICAgICAgcHVibGljX2tleSxcbiAgICAgICAgaW5pdF9wYXJhbXMsXG4gICAgfTtcbn1cbmV4cG9ydHMuc3RhdGVJbml0U291cmNlVHZjID0gc3RhdGVJbml0U291cmNlVHZjO1xuZnVuY3Rpb24gbWVzc2FnZVNvdXJjZUVuY29kZWQobWVzc2FnZSwgYWJpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0VuY29kZWQnLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBhYmksXG4gICAgfTtcbn1cbmV4cG9ydHMubWVzc2FnZVNvdXJjZUVuY29kZWQgPSBtZXNzYWdlU291cmNlRW5jb2RlZDtcbmZ1bmN0aW9uIG1lc3NhZ2VTb3VyY2VFbmNvZGluZ1BhcmFtcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdFbmNvZGluZ1BhcmFtcycgfSwgcGFyYW1zKTtcbn1cbmV4cG9ydHMubWVzc2FnZVNvdXJjZUVuY29kaW5nUGFyYW1zID0gbWVzc2FnZVNvdXJjZUVuY29kaW5nUGFyYW1zO1xuLyoqXG4gKiBQcm92aWRlcyBtZXNzYWdlIGVuY29kaW5nIGFuZCBkZWNvZGluZyBhY2NvcmRpbmcgdG8gdGhlIEFCSSBzcGVjaWZpY2F0aW9uLlxuICovXG5jbGFzcyBBYmlNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBtZXNzYWdlIGJvZHkgYWNjb3JkaW5nIHRvIEFCSSBmdW5jdGlvbiBjYWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkVuY29kZU1lc3NhZ2VCb2R5fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkVuY29kZU1lc3NhZ2VCb2R5XG4gICAgICovXG4gICAgZW5jb2RlX21lc3NhZ2VfYm9keShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2FiaS5lbmNvZGVfbWVzc2FnZV9ib2R5JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mQXR0YWNoU2lnbmF0dXJlVG9NZXNzYWdlQm9keX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZBdHRhY2hTaWduYXR1cmVUb01lc3NhZ2VCb2R5XG4gICAgICovXG4gICAgYXR0YWNoX3NpZ25hdHVyZV90b19tZXNzYWdlX2JvZHkocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdhYmkuYXR0YWNoX3NpZ25hdHVyZV90b19tZXNzYWdlX2JvZHknLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGFuIEFCSS1jb21wYXRpYmxlIG1lc3NhZ2VcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQWxsb3dzIHRvIGVuY29kZSBkZXBsb3kgYW5kIGZ1bmN0aW9uIGNhbGwgbWVzc2FnZXMsXG4gICAgICogYm90aCBzaWduZWQgYW5kIHVuc2lnbmVkLlxuICAgICAqXG4gICAgICogVXNlIGNhc2VzIGluY2x1ZGUgbWVzc2FnZXMgb2YgYW55IHBvc3NpYmxlIHR5cGU6XG4gICAgICogLSBkZXBsb3kgd2l0aCBpbml0aWFsIGZ1bmN0aW9uIGNhbGwgKGkuZS4gYGNvbnN0cnVjdG9yYCBvciBhbnkgb3RoZXIgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIGZvciBzb21lIGtpbmRcbiAgICAgKiBvZiBpbml0aWFsaXphdGlvbik7XG4gICAgICogLSBkZXBsb3kgd2l0aG91dCBpbml0aWFsIGZ1bmN0aW9uIGNhbGw7XG4gICAgICogLSBzaWduZWQvdW5zaWduZWQgKyBkYXRhIGZvciBzaWduaW5nLlxuICAgICAqXG4gICAgICogYFNpZ25lcmAgZGVmaW5lcyBob3cgdGhlIG1lc3NhZ2Ugc2hvdWxkIG9yIHNob3VsZG4ndCBiZSBzaWduZWQ6XG4gICAgICpcbiAgICAgKiBgU2lnbmVyOjpOb25lYCBjcmVhdGVzIGFuIHVuc2lnbmVkIG1lc3NhZ2UuIFRoaXMgbWF5IGJlIG5lZWRlZCBpbiBjYXNlIG9mIHNvbWUgcHVibGljIG1ldGhvZHMsXG4gICAgICogdGhhdCBkbyBub3QgcmVxdWlyZSBhdXRob3JpemF0aW9uIGJ5IHB1YmtleS5cbiAgICAgKlxuICAgICAqIGBTaWduZXI6OkV4dGVybmFsYCB0YWtlcyBwdWJsaWMga2V5IGFuZCByZXR1cm5zIGBkYXRhX3RvX3NpZ25gIGZvciBsYXRlciBzaWduaW5nLlxuICAgICAqIFVzZSBgYXR0YWNoX3NpZ25hdHVyZWAgbWV0aG9kIHdpdGggdGhlIHJlc3VsdCBzaWduYXR1cmUgdG8gZ2V0IHRoZSBzaWduZWQgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIGBTaWduZXI6OktleXNgIGNyZWF0ZXMgYSBzaWduZWQgbWVzc2FnZSB3aXRoIHByb3ZpZGVkIGtleSBwYWlyLlxuICAgICAqXG4gICAgICogW1NPT05dIGBTaWduZXI6OlNpZ25pbmdCb3hgIEFsbG93cyB1c2luZyBhIHNwZWNpYWwgaW50ZXJmYWNlIHRvIGltcGxlbWVudCBzaWduaW5nXG4gICAgICogd2l0aG91dCBwcml2YXRlIGtleSBkaXNjbG9zdXJlIHRvIFNESy4gRm9yIGluc3RhbmNlLCBpbiBjYXNlIG9mIHVzaW5nIGEgY29sZCB3YWxsZXQgb3IgSFNNLFxuICAgICAqIHdoZW4gYXBwbGljYXRpb24gY2FsbHMgc29tZSBBUEkgdG8gc2lnbiBkYXRhLlxuICAgICAqXG4gICAgICogVGhlcmUgaXMgYW4gb3B0aW9uYWwgcHVibGljIGtleSBjYW4gYmUgcHJvdmlkZWQgaW4gZGVwbG95IHNldCBpbiBvcmRlciB0byBzdWJzdGl0dXRlIG9uZVxuICAgICAqIGluIFRWTSBmaWxlLlxuICAgICAqXG4gICAgICogUHVibGljIGtleSByZXNvbHZpbmcgcHJpb3JpdHk6XG4gICAgICogMS4gUHVibGljIGtleSBmcm9tIGRlcGxveSBzZXQuXG4gICAgICogMi4gUHVibGljIGtleSwgc3BlY2lmaWVkIGluIFRWTSBmaWxlLlxuICAgICAqIDMuIFB1YmxpYyBrZXksIHByb3ZpZGVkIGJ5IHNpZ25lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZFbmNvZGVNZXNzYWdlfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkVuY29kZU1lc3NhZ2VcbiAgICAgKi9cbiAgICBlbmNvZGVfbWVzc2FnZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2FiaS5lbmNvZGVfbWVzc2FnZScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgYW4gaW50ZXJuYWwgQUJJLWNvbXBhdGlibGUgbWVzc2FnZVxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBBbGxvd3MgdG8gZW5jb2RlIGRlcGxveSBhbmQgZnVuY3Rpb24gY2FsbCBtZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIFVzZSBjYXNlcyBpbmNsdWRlIG1lc3NhZ2VzIG9mIGFueSBwb3NzaWJsZSB0eXBlOlxuICAgICAqIC0gZGVwbG95IHdpdGggaW5pdGlhbCBmdW5jdGlvbiBjYWxsIChpLmUuIGBjb25zdHJ1Y3RvcmAgb3IgYW55IG90aGVyIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCBmb3Igc29tZSBraW5kXG4gICAgICogb2YgaW5pdGlhbGl6YXRpb24pO1xuICAgICAqIC0gZGVwbG95IHdpdGhvdXQgaW5pdGlhbCBmdW5jdGlvbiBjYWxsO1xuICAgICAqIC0gc2ltcGxlIGZ1bmN0aW9uIGNhbGxcbiAgICAgKlxuICAgICAqIFRoZXJlIGlzIGFuIG9wdGlvbmFsIHB1YmxpYyBrZXkgY2FuIGJlIHByb3ZpZGVkIGluIGRlcGxveSBzZXQgaW4gb3JkZXIgdG8gc3Vic3RpdHV0ZSBvbmVcbiAgICAgKiBpbiBUVk0gZmlsZS5cbiAgICAgKlxuICAgICAqIFB1YmxpYyBrZXkgcmVzb2x2aW5nIHByaW9yaXR5OlxuICAgICAqIDEuIFB1YmxpYyBrZXkgZnJvbSBkZXBsb3kgc2V0LlxuICAgICAqIDIuIFB1YmxpYyBrZXksIHNwZWNpZmllZCBpbiBUVk0gZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZFbmNvZGVJbnRlcm5hbE1lc3NhZ2V9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mRW5jb2RlSW50ZXJuYWxNZXNzYWdlXG4gICAgICovXG4gICAgZW5jb2RlX2ludGVybmFsX21lc3NhZ2UocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdhYmkuZW5jb2RlX2ludGVybmFsX21lc3NhZ2UnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21iaW5lcyBgaGV4YC1lbmNvZGVkIGBzaWduYXR1cmVgIHdpdGggYGJhc2U2NGAtZW5jb2RlZCBgdW5zaWduZWRfbWVzc2FnZWAuIFJldHVybnMgc2lnbmVkIG1lc3NhZ2UgZW5jb2RlZCBpbiBgYmFzZTY0YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZBdHRhY2hTaWduYXR1cmV9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mQXR0YWNoU2lnbmF0dXJlXG4gICAgICovXG4gICAgYXR0YWNoX3NpZ25hdHVyZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2FiaS5hdHRhY2hfc2lnbmF0dXJlJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBtZXNzYWdlIGJvZHkgdXNpbmcgcHJvdmlkZWQgbWVzc2FnZSBCT0MgYW5kIEFCSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZEZWNvZGVNZXNzYWdlfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBEZWNvZGVkTWVzc2FnZUJvZHlcbiAgICAgKi9cbiAgICBkZWNvZGVfbWVzc2FnZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2FiaS5kZWNvZGVfbWVzc2FnZScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXMgbWVzc2FnZSBib2R5IHVzaW5nIHByb3ZpZGVkIGJvZHkgQk9DIGFuZCBBQkkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mRGVjb2RlTWVzc2FnZUJvZHl9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIERlY29kZWRNZXNzYWdlQm9keVxuICAgICAqL1xuICAgIGRlY29kZV9tZXNzYWdlX2JvZHkocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdhYmkuZGVjb2RlX21lc3NhZ2VfYm9keScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYWNjb3VudCBzdGF0ZSBCT0NcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQ3JlYXRlcyBhY2NvdW50IHN0YXRlIHByb3ZpZGVkIHdpdGggb25lIG9mIHRoZXNlIHNldHMgb2YgZGF0YSA6XG4gICAgICogMS4gQk9DIG9mIGNvZGUsIEJPQyBvZiBkYXRhLCBCT0Mgb2YgbGlicmFyeVxuICAgICAqIDIuIFRWQyAoc3RyaW5nIGluIGBiYXNlNjRgKSwga2V5cywgaW5pdCBwYXJhbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZFbmNvZGVBY2NvdW50fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkVuY29kZUFjY291bnRcbiAgICAgKi9cbiAgICBlbmNvZGVfYWNjb3VudChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2FiaS5lbmNvZGVfYWNjb3VudCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYWNjb3VudCBkYXRhIHVzaW5nIHByb3ZpZGVkIGRhdGEgQk9DIGFuZCBBQkkuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIE5vdGU6IHRoaXMgZmVhdHVyZSByZXF1aXJlcyBBQkkgMi4xIG9yIGhpZ2hlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZEZWNvZGVBY2NvdW50RGF0YX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZEZWNvZGVBY2NvdW50RGF0YVxuICAgICAqL1xuICAgIGRlY29kZV9hY2NvdW50X2RhdGEocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdhYmkuZGVjb2RlX2FjY291bnRfZGF0YScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgaW5pdGlhbCBhY2NvdW50IGRhdGEgd2l0aCBpbml0aWFsIHZhbHVlcyBmb3IgdGhlIGNvbnRyYWN0J3Mgc3RhdGljIHZhcmlhYmxlcyBhbmQgb3duZXIncyBwdWJsaWMga2V5LiBUaGlzIG9wZXJhdGlvbiBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIGluaXRpYWwgYWNjb3VudCBkYXRhIChiZWZvcmUgZGVwbG95KS4gSWYgdGhlIGNvbnRyYWN0IGlzIGFscmVhZHkgZGVwbG95ZWQsIGl0cyBkYXRhIGRvZXNuJ3QgY29udGFpbiB0aGlzIGRhdGEgc2VjdGlvbiBhbnkgbW9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZVcGRhdGVJbml0aWFsRGF0YX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZVcGRhdGVJbml0aWFsRGF0YVxuICAgICAqL1xuICAgIHVwZGF0ZV9pbml0aWFsX2RhdGEocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdhYmkudXBkYXRlX2luaXRpYWxfZGF0YScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgaW5pdGlhbCBhY2NvdW50IGRhdGEgd2l0aCBpbml0aWFsIHZhbHVlcyBmb3IgdGhlIGNvbnRyYWN0J3Mgc3RhdGljIHZhcmlhYmxlcyBhbmQgb3duZXIncyBwdWJsaWMga2V5IGludG8gYSBkYXRhIEJPQyB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gYGVuY29kZV90dmNgIGZ1bmN0aW9uIGFmdGVyd2FyZHMuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYW5hbG9ndWUgb2YgYHR2bS5idWlsZERhdGFJbml0YCBmdW5jdGlvbiBpbiBTb2xpZGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZFbmNvZGVJbml0aWFsRGF0YX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZFbmNvZGVJbml0aWFsRGF0YVxuICAgICAqL1xuICAgIGVuY29kZV9pbml0aWFsX2RhdGEocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdhYmkuZW5jb2RlX2luaXRpYWxfZGF0YScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXMgaW5pdGlhbCB2YWx1ZXMgb2YgYSBjb250cmFjdCdzIHN0YXRpYyB2YXJpYWJsZXMgYW5kIG93bmVyJ3MgcHVibGljIGtleSBmcm9tIGFjY291bnQgaW5pdGlhbCBkYXRhIFRoaXMgb3BlcmF0aW9uIGlzIGFwcGxpY2FibGUgb25seSBmb3IgaW5pdGlhbCBhY2NvdW50IGRhdGEgKGJlZm9yZSBkZXBsb3kpLiBJZiB0aGUgY29udHJhY3QgaXMgYWxyZWFkeSBkZXBsb3llZCwgaXRzIGRhdGEgZG9lc24ndCBjb250YWluIHRoaXMgZGF0YSBzZWN0aW9uIGFueSBtb3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkRlY29kZUluaXRpYWxEYXRhfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkRlY29kZUluaXRpYWxEYXRhXG4gICAgICovXG4gICAgZGVjb2RlX2luaXRpYWxfZGF0YShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2FiaS5kZWNvZGVfaW5pdGlhbF9kYXRhJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBCT0MgaW50byBKU09OIGFzIGEgc2V0IG9mIHByb3ZpZGVkIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFNvbGlkaXR5IGZ1bmN0aW9ucyB1c2UgQUJJIHR5cGVzIGZvciBbYnVpbGRlciBlbmNvZGluZ10oaHR0cHM6Ly9naXRodWIuY29tL3RvbmxhYnMvVE9OLVNvbGlkaXR5LUNvbXBpbGVyL2Jsb2IvbWFzdGVyL0FQSS5tZCN0dm1idWlsZGVyc3RvcmUpLlxuICAgICAqIFRoZSBzaW1wbGVzdCB3YXkgdG8gZGVjb2RlIHN1Y2ggYSBCT0MgaXMgdG8gdXNlIEFCSSBkZWNvZGluZy5cbiAgICAgKiBBQkkgaGFzIGl0IG93biBydWxlcyBmb3IgZmllbGRzIGxheW91dCBpbiBjZWxscyBzbyBtYW51YWxseSBlbmNvZGVkXG4gICAgICogQk9DIGNhbiBub3QgYmUgZGVzY3JpYmVkIGluIHRlcm1zIG9mIEFCSSBydWxlcy5cbiAgICAgKlxuICAgICAqIFRvIHNvbHZlIHRoaXMgcHJvYmxlbSB3ZSBpbnRyb2R1Y2UgYSBuZXcgQUJJIHR5cGUgYFJlZig8UGFyYW1UeXBlPilgXG4gICAgICogd2hpY2ggYWxsb3dzIHRvIHN0b3JlIGBQYXJhbVR5cGVgIEFCSSBwYXJhbWV0ZXIgaW4gY2VsbCByZWZlcmVuY2UgYW5kLCB0aHVzLFxuICAgICAqIGRlY29kZSBtYW51YWxseSBlbmNvZGVkIEJPQ3MuIFRoaXMgdHlwZSBpcyBhdmFpbGFibGUgb25seSBpbiBgZGVjb2RlX2JvY2AgZnVuY3Rpb25cbiAgICAgKiBhbmQgd2lsbCBub3QgYmUgYXZhaWxhYmxlIGluIEFCSSBtZXNzYWdlcyBlbmNvZGluZyB1bnRpbCBpdCBpcyBpbmNsdWRlZCBpbnRvIHNvbWUgQUJJIHJldmlzaW9uLlxuICAgICAqXG4gICAgICogU3VjaCBCT0MgZGVzY3JpcHRpb25zIGNvdmVycyBtb3N0IHVzZXJzIG5lZWRzLiBJZiBzb21lb25lIHdhbnRzIHRvIGRlY29kZSBzb21lIEJPQyB3aGljaFxuICAgICAqIGNhbiBub3QgYmUgZGVzY3JpYmVkIGJ5IHRoZXNlIHJ1bGVzIChpLmUuIEJPQyB3aXRoIFRMQiBjb250YWluaW5nIGNvbnN0cnVjdG9ycyBvZiBmbGFnc1xuICAgICAqIGRlZmluaW5nIHNvbWUgcGFyc2luZyBjb25kaXRpb25zKSB0aGVuIHRoZXkgY2FuIGRlY29kZSB0aGUgZmllbGRzIHVwIHRvIGZvcmsgY29uZGl0aW9uLFxuICAgICAqIGNoZWNrIHRoZSBwYXJzZWQgZGF0YSBtYW51YWxseSwgZXhwYW5kIHRoZSBwYXJzaW5nIHNjaGVtYSBhbmQgdGhlbiBkZWNvZGUgdGhlIHdob2xlIEJPQ1xuICAgICAqIHdpdGggdGhlIGZ1bGwgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkRlY29kZUJvY30gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZEZWNvZGVCb2NcbiAgICAgKi9cbiAgICBkZWNvZGVfYm9jKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYWJpLmRlY29kZV9ib2MnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGdpdmVuIHBhcmFtZXRlcnMgaW4gSlNPTiBpbnRvIGEgQk9DIHVzaW5nIHBhcmFtIHR5cGVzIGZyb20gQUJJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkFiaUVuY29kZUJvY30gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZBYmlFbmNvZGVCb2NcbiAgICAgKi9cbiAgICBlbmNvZGVfYm9jKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYWJpLmVuY29kZV9ib2MnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGNvbnRyYWN0IGZ1bmN0aW9uIElEIGJ5IGNvbnRyYWN0IEFCSVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkNhbGNGdW5jdGlvbklkfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkNhbGNGdW5jdGlvbklkXG4gICAgICovXG4gICAgY2FsY19mdW5jdGlvbl9pZChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2FiaS5jYWxjX2Z1bmN0aW9uX2lkJywgcGFyYW1zKTtcbiAgICB9XG59XG5leHBvcnRzLkFiaU1vZHVsZSA9IEFiaU1vZHVsZTtcbmZ1bmN0aW9uIGJvY0NhY2hlVHlwZVBpbm5lZChwaW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnUGlubmVkJyxcbiAgICAgICAgcGluLFxuICAgIH07XG59XG5leHBvcnRzLmJvY0NhY2hlVHlwZVBpbm5lZCA9IGJvY0NhY2hlVHlwZVBpbm5lZDtcbmZ1bmN0aW9uIGJvY0NhY2hlVHlwZVVucGlubmVkKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdVbnBpbm5lZCcsXG4gICAgfTtcbn1cbmV4cG9ydHMuYm9jQ2FjaGVUeXBlVW5waW5uZWQgPSBib2NDYWNoZVR5cGVVbnBpbm5lZDtcbnZhciBCb2NFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEJvY0Vycm9yQ29kZSkge1xuICAgIEJvY0Vycm9yQ29kZVtCb2NFcnJvckNvZGVbXCJJbnZhbGlkQm9jXCJdID0gMjAxXSA9IFwiSW52YWxpZEJvY1wiO1xuICAgIEJvY0Vycm9yQ29kZVtCb2NFcnJvckNvZGVbXCJTZXJpYWxpemF0aW9uRXJyb3JcIl0gPSAyMDJdID0gXCJTZXJpYWxpemF0aW9uRXJyb3JcIjtcbiAgICBCb2NFcnJvckNvZGVbQm9jRXJyb3JDb2RlW1wiSW5hcHByb3ByaWF0ZUJsb2NrXCJdID0gMjAzXSA9IFwiSW5hcHByb3ByaWF0ZUJsb2NrXCI7XG4gICAgQm9jRXJyb3JDb2RlW0JvY0Vycm9yQ29kZVtcIk1pc3NpbmdTb3VyY2VCb2NcIl0gPSAyMDRdID0gXCJNaXNzaW5nU291cmNlQm9jXCI7XG4gICAgQm9jRXJyb3JDb2RlW0JvY0Vycm9yQ29kZVtcIkluc3VmZmljaWVudENhY2hlU2l6ZVwiXSA9IDIwNV0gPSBcIkluc3VmZmljaWVudENhY2hlU2l6ZVwiO1xuICAgIEJvY0Vycm9yQ29kZVtCb2NFcnJvckNvZGVbXCJCb2NSZWZOb3RGb3VuZFwiXSA9IDIwNl0gPSBcIkJvY1JlZk5vdEZvdW5kXCI7XG4gICAgQm9jRXJyb3JDb2RlW0JvY0Vycm9yQ29kZVtcIkludmFsaWRCb2NSZWZcIl0gPSAyMDddID0gXCJJbnZhbGlkQm9jUmVmXCI7XG59KShCb2NFcnJvckNvZGUgPSBleHBvcnRzLkJvY0Vycm9yQ29kZSB8fCAoZXhwb3J0cy5Cb2NFcnJvckNvZGUgPSB7fSkpO1xuZnVuY3Rpb24gYnVpbGRlck9wSW50ZWdlcihzaXplLCB2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdJbnRlZ2VyJyxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgfTtcbn1cbmV4cG9ydHMuYnVpbGRlck9wSW50ZWdlciA9IGJ1aWxkZXJPcEludGVnZXI7XG5mdW5jdGlvbiBidWlsZGVyT3BCaXRTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnQml0U3RyaW5nJyxcbiAgICAgICAgdmFsdWUsXG4gICAgfTtcbn1cbmV4cG9ydHMuYnVpbGRlck9wQml0U3RyaW5nID0gYnVpbGRlck9wQml0U3RyaW5nO1xuZnVuY3Rpb24gYnVpbGRlck9wQ2VsbChidWlsZGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0NlbGwnLFxuICAgICAgICBidWlsZGVyLFxuICAgIH07XG59XG5leHBvcnRzLmJ1aWxkZXJPcENlbGwgPSBidWlsZGVyT3BDZWxsO1xuZnVuY3Rpb24gYnVpbGRlck9wQ2VsbEJvYyhib2MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnQ2VsbEJvYycsXG4gICAgICAgIGJvYyxcbiAgICB9O1xufVxuZXhwb3J0cy5idWlsZGVyT3BDZWxsQm9jID0gYnVpbGRlck9wQ2VsbEJvYztcbmZ1bmN0aW9uIGJ1aWxkZXJPcEFkZHJlc3MoYWRkcmVzcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdBZGRyZXNzJyxcbiAgICAgICAgYWRkcmVzcyxcbiAgICB9O1xufVxuZXhwb3J0cy5idWlsZGVyT3BBZGRyZXNzID0gYnVpbGRlck9wQWRkcmVzcztcbi8qKlxuICogQk9DIG1hbmlwdWxhdGlvbiBtb2R1bGUuXG4gKi9cbmNsYXNzIEJvY01vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgbWVzc2FnZSBib2MgaW50byBhIEpTT05cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSlNPTiBzdHJ1Y3R1cmUgaXMgY29tcGF0aWJsZSB3aXRoIEdyYXBoUUwgQVBJIG1lc3NhZ2Ugb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mUGFyc2V9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mUGFyc2VcbiAgICAgKi9cbiAgICBwYXJzZV9tZXNzYWdlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYm9jLnBhcnNlX21lc3NhZ2UnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdHJhbnNhY3Rpb24gYm9jIGludG8gYSBKU09OXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEpTT04gc3RydWN0dXJlIGlzIGNvbXBhdGlibGUgd2l0aCBHcmFwaFFMIEFQSSB0cmFuc2FjdGlvbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZQYXJzZX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZQYXJzZVxuICAgICAqL1xuICAgIHBhcnNlX3RyYW5zYWN0aW9uKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYm9jLnBhcnNlX3RyYW5zYWN0aW9uJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFjY291bnQgYm9jIGludG8gYSBKU09OXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEpTT04gc3RydWN0dXJlIGlzIGNvbXBhdGlibGUgd2l0aCBHcmFwaFFMIEFQSSBhY2NvdW50IG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlBhcnNlfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZlBhcnNlXG4gICAgICovXG4gICAgcGFyc2VfYWNjb3VudChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2JvYy5wYXJzZV9hY2NvdW50JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGJsb2NrIGJvYyBpbnRvIGEgSlNPTlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBKU09OIHN0cnVjdHVyZSBpcyBjb21wYXRpYmxlIHdpdGggR3JhcGhRTCBBUEkgYmxvY2sgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mUGFyc2V9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mUGFyc2VcbiAgICAgKi9cbiAgICBwYXJzZV9ibG9jayhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2JvYy5wYXJzZV9ibG9jaycsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBzaGFyZHN0YXRlIGJvYyBpbnRvIGEgSlNPTlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBKU09OIHN0cnVjdHVyZSBpcyBjb21wYXRpYmxlIHdpdGggR3JhcGhRTCBBUEkgc2hhcmRzdGF0ZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZQYXJzZVNoYXJkc3RhdGV9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mUGFyc2VcbiAgICAgKi9cbiAgICBwYXJzZV9zaGFyZHN0YXRlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYm9jLnBhcnNlX3NoYXJkc3RhdGUnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IGJsb2NrY2hhaW4gY29uZmlndXJhdGlvbiBmcm9tIGtleSBibG9jayBhbmQgYWxzbyBmcm9tIHplcm9zdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZHZXRCbG9ja2NoYWluQ29uZmlnfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkdldEJsb2NrY2hhaW5Db25maWdcbiAgICAgKi9cbiAgICBnZXRfYmxvY2tjaGFpbl9jb25maWcocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdib2MuZ2V0X2Jsb2NrY2hhaW5fY29uZmlnJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBCT0Mgcm9vdCBoYXNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mR2V0Qm9jSGFzaH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZHZXRCb2NIYXNoXG4gICAgICovXG4gICAgZ2V0X2JvY19oYXNoKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYm9jLmdldF9ib2NfaGFzaCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgQk9DIGRlcHRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mR2V0Qm9jRGVwdGh9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mR2V0Qm9jRGVwdGhcbiAgICAgKi9cbiAgICBnZXRfYm9jX2RlcHRoKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYm9jLmdldF9ib2NfZGVwdGgnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyBjb2RlIGZyb20gVFZDIGNvbnRyYWN0IGltYWdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mR2V0Q29kZUZyb21UdmN9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mR2V0Q29kZUZyb21UdmNcbiAgICAgKi9cbiAgICBnZXRfY29kZV9mcm9tX3R2YyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2JvYy5nZXRfY29kZV9mcm9tX3R2YycsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBCT0MgZnJvbSBjYWNoZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkJvY0NhY2hlR2V0fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkJvY0NhY2hlR2V0XG4gICAgICovXG4gICAgY2FjaGVfZ2V0KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYm9jLmNhY2hlX2dldCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNhdmUgQk9DIGludG8gY2FjaGUgb3IgaW5jcmVhc2UgcGluIGNvdW50ZXIgZm9yIGV4aXN0aW5nIHBpbm5lZCBCT0NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZCb2NDYWNoZVNldH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZCb2NDYWNoZVNldFxuICAgICAqL1xuICAgIGNhY2hlX3NldChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2JvYy5jYWNoZV9zZXQnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnBpbiBCT0NzIHdpdGggc3BlY2lmaWVkIHBpbiBkZWZpbmVkIGluIHRoZSBgY2FjaGVfc2V0YC4gRGVjcmVhc2UgcGluIHJlZmVyZW5jZSBjb3VudGVyIGZvciBCT0NzIHdpdGggc3BlY2lmaWVkIHBpbiBkZWZpbmVkIGluIHRoZSBgY2FjaGVfc2V0YC4gQk9DcyB3aGljaCBoYXZlIG9ubHkgMSBwaW4gYW5kIGl0cyByZWZlcmVuY2UgY291bnRlciBiZWNvbWUgMCB3aWxsIGJlIHJlbW92ZWQgZnJvbSBjYWNoZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkJvY0NhY2hlVW5waW59IHBhcmFtc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgY2FjaGVfdW5waW4ocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdib2MuY2FjaGVfdW5waW4nLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGJhZyBvZiBjZWxscyAoQk9DKSB3aXRoIGJ1aWxkZXIgb3BlcmF0aW9ucy4gVGhpcyBtZXRob2QgcHJvdmlkZXMgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eSBhcyBTb2xpZGl0eSBUdm1CdWlsZGVyLiBSZXN1bHRpbmcgQk9DIG9mIHRoaXMgbWV0aG9kIGNhbiBiZSBwYXNzZWQgaW50byBTb2xpZGl0eSBhbmQgQysrIGNvbnRyYWN0cyBhcyBUdm1DZWxsIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mRW5jb2RlQm9jfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkVuY29kZUJvY1xuICAgICAqL1xuICAgIGVuY29kZV9ib2MocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdib2MuZW5jb2RlX2JvYycsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbnRyYWN0IGNvZGUncyBzYWx0IGlmIGl0IGlzIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mR2V0Q29kZVNhbHR9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mR2V0Q29kZVNhbHRcbiAgICAgKi9cbiAgICBnZXRfY29kZV9zYWx0KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYm9jLmdldF9jb2RlX3NhbHQnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIG5ldyBzYWx0IHRvIGNvbnRyYWN0IGNvZGUuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFJldHVybnMgdGhlIG5ldyBjb250cmFjdCBjb2RlIHdpdGggc2FsdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZTZXRDb2RlU2FsdH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZTZXRDb2RlU2FsdFxuICAgICAqL1xuICAgIHNldF9jb2RlX3NhbHQocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdib2Muc2V0X2NvZGVfc2FsdCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXMgdHZjIGludG8gY29kZSwgZGF0YSwgbGlicmFyaWVzIGFuZCBzcGVjaWFsIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mRGVjb2RlVHZjfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkRlY29kZVR2Y1xuICAgICAqL1xuICAgIGRlY29kZV90dmMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdib2MuZGVjb2RlX3R2YycsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdHZjIGZyb20gY29kZSwgZGF0YSwgbGlicmFyaWVzIGFucyBzcGVjaWFsIG9wdGlvbnMgKHNlZSBpbnB1dCBwYXJhbXMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mRW5jb2RlVHZjfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkVuY29kZVR2Y1xuICAgICAqL1xuICAgIGVuY29kZV90dmMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdib2MuZW5jb2RlX3R2YycsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgYSBtZXNzYWdlXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEFsbG93cyB0byBlbmNvZGUgYW55IGV4dGVybmFsIGluYm91bmQgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZFbmNvZGVFeHRlcm5hbEluTWVzc2FnZX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZFbmNvZGVFeHRlcm5hbEluTWVzc2FnZVxuICAgICAqL1xuICAgIGVuY29kZV9leHRlcm5hbF9pbl9tZXNzYWdlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYm9jLmVuY29kZV9leHRlcm5hbF9pbl9tZXNzYWdlJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29tcGlsZXIgdmVyc2lvbiB1c2VkIHRvIGNvbXBpbGUgdGhlIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mR2V0Q29tcGlsZXJWZXJzaW9ufSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkdldENvbXBpbGVyVmVyc2lvblxuICAgICAqL1xuICAgIGdldF9jb21waWxlcl92ZXJzaW9uKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYm9jLmdldF9jb21waWxlcl92ZXJzaW9uJywgcGFyYW1zKTtcbiAgICB9XG59XG5leHBvcnRzLkJvY01vZHVsZSA9IEJvY01vZHVsZTtcbi8vIHByb2Nlc3NpbmcgbW9kdWxlXG52YXIgUHJvY2Vzc2luZ0Vycm9yQ29kZTtcbihmdW5jdGlvbiAoUHJvY2Vzc2luZ0Vycm9yQ29kZSkge1xuICAgIFByb2Nlc3NpbmdFcnJvckNvZGVbUHJvY2Vzc2luZ0Vycm9yQ29kZVtcIk1lc3NhZ2VBbHJlYWR5RXhwaXJlZFwiXSA9IDUwMV0gPSBcIk1lc3NhZ2VBbHJlYWR5RXhwaXJlZFwiO1xuICAgIFByb2Nlc3NpbmdFcnJvckNvZGVbUHJvY2Vzc2luZ0Vycm9yQ29kZVtcIk1lc3NhZ2VIYXNOb3REZXN0aW5hdGlvbkFkZHJlc3NcIl0gPSA1MDJdID0gXCJNZXNzYWdlSGFzTm90RGVzdGluYXRpb25BZGRyZXNzXCI7XG4gICAgUHJvY2Vzc2luZ0Vycm9yQ29kZVtQcm9jZXNzaW5nRXJyb3JDb2RlW1wiQ2FuTm90QnVpbGRNZXNzYWdlQ2VsbFwiXSA9IDUwM10gPSBcIkNhbk5vdEJ1aWxkTWVzc2FnZUNlbGxcIjtcbiAgICBQcm9jZXNzaW5nRXJyb3JDb2RlW1Byb2Nlc3NpbmdFcnJvckNvZGVbXCJGZXRjaEJsb2NrRmFpbGVkXCJdID0gNTA0XSA9IFwiRmV0Y2hCbG9ja0ZhaWxlZFwiO1xuICAgIFByb2Nlc3NpbmdFcnJvckNvZGVbUHJvY2Vzc2luZ0Vycm9yQ29kZVtcIlNlbmRNZXNzYWdlRmFpbGVkXCJdID0gNTA1XSA9IFwiU2VuZE1lc3NhZ2VGYWlsZWRcIjtcbiAgICBQcm9jZXNzaW5nRXJyb3JDb2RlW1Byb2Nlc3NpbmdFcnJvckNvZGVbXCJJbnZhbGlkTWVzc2FnZUJvY1wiXSA9IDUwNl0gPSBcIkludmFsaWRNZXNzYWdlQm9jXCI7XG4gICAgUHJvY2Vzc2luZ0Vycm9yQ29kZVtQcm9jZXNzaW5nRXJyb3JDb2RlW1wiTWVzc2FnZUV4cGlyZWRcIl0gPSA1MDddID0gXCJNZXNzYWdlRXhwaXJlZFwiO1xuICAgIFByb2Nlc3NpbmdFcnJvckNvZGVbUHJvY2Vzc2luZ0Vycm9yQ29kZVtcIlRyYW5zYWN0aW9uV2FpdFRpbWVvdXRcIl0gPSA1MDhdID0gXCJUcmFuc2FjdGlvbldhaXRUaW1lb3V0XCI7XG4gICAgUHJvY2Vzc2luZ0Vycm9yQ29kZVtQcm9jZXNzaW5nRXJyb3JDb2RlW1wiSW52YWxpZEJsb2NrUmVjZWl2ZWRcIl0gPSA1MDldID0gXCJJbnZhbGlkQmxvY2tSZWNlaXZlZFwiO1xuICAgIFByb2Nlc3NpbmdFcnJvckNvZGVbUHJvY2Vzc2luZ0Vycm9yQ29kZVtcIkNhbk5vdENoZWNrQmxvY2tTaGFyZFwiXSA9IDUxMF0gPSBcIkNhbk5vdENoZWNrQmxvY2tTaGFyZFwiO1xuICAgIFByb2Nlc3NpbmdFcnJvckNvZGVbUHJvY2Vzc2luZ0Vycm9yQ29kZVtcIkJsb2NrTm90Rm91bmRcIl0gPSA1MTFdID0gXCJCbG9ja05vdEZvdW5kXCI7XG4gICAgUHJvY2Vzc2luZ0Vycm9yQ29kZVtQcm9jZXNzaW5nRXJyb3JDb2RlW1wiSW52YWxpZERhdGFcIl0gPSA1MTJdID0gXCJJbnZhbGlkRGF0YVwiO1xuICAgIFByb2Nlc3NpbmdFcnJvckNvZGVbUHJvY2Vzc2luZ0Vycm9yQ29kZVtcIkV4dGVybmFsU2lnbmVyTXVzdE5vdEJlVXNlZFwiXSA9IDUxM10gPSBcIkV4dGVybmFsU2lnbmVyTXVzdE5vdEJlVXNlZFwiO1xuICAgIFByb2Nlc3NpbmdFcnJvckNvZGVbUHJvY2Vzc2luZ0Vycm9yQ29kZVtcIk1lc3NhZ2VSZWplY3RlZFwiXSA9IDUxNF0gPSBcIk1lc3NhZ2VSZWplY3RlZFwiO1xuICAgIFByb2Nlc3NpbmdFcnJvckNvZGVbUHJvY2Vzc2luZ0Vycm9yQ29kZVtcIkludmFsaWRSZW1wU3RhdHVzXCJdID0gNTE1XSA9IFwiSW52YWxpZFJlbXBTdGF0dXNcIjtcbiAgICBQcm9jZXNzaW5nRXJyb3JDb2RlW1Byb2Nlc3NpbmdFcnJvckNvZGVbXCJOZXh0UmVtcFN0YXR1c1RpbWVvdXRcIl0gPSA1MTZdID0gXCJOZXh0UmVtcFN0YXR1c1RpbWVvdXRcIjtcbn0pKFByb2Nlc3NpbmdFcnJvckNvZGUgPSBleHBvcnRzLlByb2Nlc3NpbmdFcnJvckNvZGUgfHwgKGV4cG9ydHMuUHJvY2Vzc2luZ0Vycm9yQ29kZSA9IHt9KSk7XG5mdW5jdGlvbiBwcm9jZXNzaW5nRXZlbnRXaWxsRmV0Y2hGaXJzdEJsb2NrKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdXaWxsRmV0Y2hGaXJzdEJsb2NrJyxcbiAgICB9O1xufVxuZXhwb3J0cy5wcm9jZXNzaW5nRXZlbnRXaWxsRmV0Y2hGaXJzdEJsb2NrID0gcHJvY2Vzc2luZ0V2ZW50V2lsbEZldGNoRmlyc3RCbG9jaztcbmZ1bmN0aW9uIHByb2Nlc3NpbmdFdmVudEZldGNoRmlyc3RCbG9ja0ZhaWxlZChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZXRjaEZpcnN0QmxvY2tGYWlsZWQnLFxuICAgICAgICBlcnJvcixcbiAgICB9O1xufVxuZXhwb3J0cy5wcm9jZXNzaW5nRXZlbnRGZXRjaEZpcnN0QmxvY2tGYWlsZWQgPSBwcm9jZXNzaW5nRXZlbnRGZXRjaEZpcnN0QmxvY2tGYWlsZWQ7XG5mdW5jdGlvbiBwcm9jZXNzaW5nRXZlbnRXaWxsU2VuZChzaGFyZF9ibG9ja19pZCwgbWVzc2FnZV9pZCwgbWVzc2FnZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdXaWxsU2VuZCcsXG4gICAgICAgIHNoYXJkX2Jsb2NrX2lkLFxuICAgICAgICBtZXNzYWdlX2lkLFxuICAgICAgICBtZXNzYWdlLFxuICAgIH07XG59XG5leHBvcnRzLnByb2Nlc3NpbmdFdmVudFdpbGxTZW5kID0gcHJvY2Vzc2luZ0V2ZW50V2lsbFNlbmQ7XG5mdW5jdGlvbiBwcm9jZXNzaW5nRXZlbnREaWRTZW5kKHNoYXJkX2Jsb2NrX2lkLCBtZXNzYWdlX2lkLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0RpZFNlbmQnLFxuICAgICAgICBzaGFyZF9ibG9ja19pZCxcbiAgICAgICAgbWVzc2FnZV9pZCxcbiAgICAgICAgbWVzc2FnZSxcbiAgICB9O1xufVxuZXhwb3J0cy5wcm9jZXNzaW5nRXZlbnREaWRTZW5kID0gcHJvY2Vzc2luZ0V2ZW50RGlkU2VuZDtcbmZ1bmN0aW9uIHByb2Nlc3NpbmdFdmVudFNlbmRGYWlsZWQoc2hhcmRfYmxvY2tfaWQsIG1lc3NhZ2VfaWQsIG1lc3NhZ2UsIGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1NlbmRGYWlsZWQnLFxuICAgICAgICBzaGFyZF9ibG9ja19pZCxcbiAgICAgICAgbWVzc2FnZV9pZCxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgZXJyb3IsXG4gICAgfTtcbn1cbmV4cG9ydHMucHJvY2Vzc2luZ0V2ZW50U2VuZEZhaWxlZCA9IHByb2Nlc3NpbmdFdmVudFNlbmRGYWlsZWQ7XG5mdW5jdGlvbiBwcm9jZXNzaW5nRXZlbnRXaWxsRmV0Y2hOZXh0QmxvY2soc2hhcmRfYmxvY2tfaWQsIG1lc3NhZ2VfaWQsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnV2lsbEZldGNoTmV4dEJsb2NrJyxcbiAgICAgICAgc2hhcmRfYmxvY2tfaWQsXG4gICAgICAgIG1lc3NhZ2VfaWQsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgfTtcbn1cbmV4cG9ydHMucHJvY2Vzc2luZ0V2ZW50V2lsbEZldGNoTmV4dEJsb2NrID0gcHJvY2Vzc2luZ0V2ZW50V2lsbEZldGNoTmV4dEJsb2NrO1xuZnVuY3Rpb24gcHJvY2Vzc2luZ0V2ZW50RmV0Y2hOZXh0QmxvY2tGYWlsZWQoc2hhcmRfYmxvY2tfaWQsIG1lc3NhZ2VfaWQsIG1lc3NhZ2UsIGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0ZldGNoTmV4dEJsb2NrRmFpbGVkJyxcbiAgICAgICAgc2hhcmRfYmxvY2tfaWQsXG4gICAgICAgIG1lc3NhZ2VfaWQsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIGVycm9yLFxuICAgIH07XG59XG5leHBvcnRzLnByb2Nlc3NpbmdFdmVudEZldGNoTmV4dEJsb2NrRmFpbGVkID0gcHJvY2Vzc2luZ0V2ZW50RmV0Y2hOZXh0QmxvY2tGYWlsZWQ7XG5mdW5jdGlvbiBwcm9jZXNzaW5nRXZlbnRNZXNzYWdlRXhwaXJlZChtZXNzYWdlX2lkLCBtZXNzYWdlLCBlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdNZXNzYWdlRXhwaXJlZCcsXG4gICAgICAgIG1lc3NhZ2VfaWQsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIGVycm9yLFxuICAgIH07XG59XG5leHBvcnRzLnByb2Nlc3NpbmdFdmVudE1lc3NhZ2VFeHBpcmVkID0gcHJvY2Vzc2luZ0V2ZW50TWVzc2FnZUV4cGlyZWQ7XG5mdW5jdGlvbiBwcm9jZXNzaW5nRXZlbnRSZW1wU2VudFRvVmFsaWRhdG9ycyhtZXNzYWdlX2lkLCB0aW1lc3RhbXAsIGpzb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnUmVtcFNlbnRUb1ZhbGlkYXRvcnMnLFxuICAgICAgICBtZXNzYWdlX2lkLFxuICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgIGpzb24sXG4gICAgfTtcbn1cbmV4cG9ydHMucHJvY2Vzc2luZ0V2ZW50UmVtcFNlbnRUb1ZhbGlkYXRvcnMgPSBwcm9jZXNzaW5nRXZlbnRSZW1wU2VudFRvVmFsaWRhdG9ycztcbmZ1bmN0aW9uIHByb2Nlc3NpbmdFdmVudFJlbXBJbmNsdWRlZEludG9CbG9jayhtZXNzYWdlX2lkLCB0aW1lc3RhbXAsIGpzb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnUmVtcEluY2x1ZGVkSW50b0Jsb2NrJyxcbiAgICAgICAgbWVzc2FnZV9pZCxcbiAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICBqc29uLFxuICAgIH07XG59XG5leHBvcnRzLnByb2Nlc3NpbmdFdmVudFJlbXBJbmNsdWRlZEludG9CbG9jayA9IHByb2Nlc3NpbmdFdmVudFJlbXBJbmNsdWRlZEludG9CbG9jaztcbmZ1bmN0aW9uIHByb2Nlc3NpbmdFdmVudFJlbXBJbmNsdWRlZEludG9BY2NlcHRlZEJsb2NrKG1lc3NhZ2VfaWQsIHRpbWVzdGFtcCwganNvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdSZW1wSW5jbHVkZWRJbnRvQWNjZXB0ZWRCbG9jaycsXG4gICAgICAgIG1lc3NhZ2VfaWQsXG4gICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAganNvbixcbiAgICB9O1xufVxuZXhwb3J0cy5wcm9jZXNzaW5nRXZlbnRSZW1wSW5jbHVkZWRJbnRvQWNjZXB0ZWRCbG9jayA9IHByb2Nlc3NpbmdFdmVudFJlbXBJbmNsdWRlZEludG9BY2NlcHRlZEJsb2NrO1xuZnVuY3Rpb24gcHJvY2Vzc2luZ0V2ZW50UmVtcE90aGVyKG1lc3NhZ2VfaWQsIHRpbWVzdGFtcCwganNvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdSZW1wT3RoZXInLFxuICAgICAgICBtZXNzYWdlX2lkLFxuICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgIGpzb24sXG4gICAgfTtcbn1cbmV4cG9ydHMucHJvY2Vzc2luZ0V2ZW50UmVtcE90aGVyID0gcHJvY2Vzc2luZ0V2ZW50UmVtcE90aGVyO1xuZnVuY3Rpb24gcHJvY2Vzc2luZ0V2ZW50UmVtcEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1JlbXBFcnJvcicsXG4gICAgICAgIGVycm9yLFxuICAgIH07XG59XG5leHBvcnRzLnByb2Nlc3NpbmdFdmVudFJlbXBFcnJvciA9IHByb2Nlc3NpbmdFdmVudFJlbXBFcnJvcjtcbi8qKlxuICogTWVzc2FnZSBwcm9jZXNzaW5nIG1vZHVsZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBtb2R1bGUgaW5jb3Jwb3JhdGVzIGZ1bmN0aW9ucyByZWxhdGVkIHRvIGNvbXBsZXggbWVzc2FnZVxuICogcHJvY2Vzc2luZyBzY2VuYXJpb3MuXG4gKi9cbmNsYXNzIFByb2Nlc3NpbmdNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgbWVzc2FnZSB0byB0aGUgbmV0d29ya1xuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBTZW5kcyBtZXNzYWdlIHRvIHRoZSBuZXR3b3JrIGFuZCByZXR1cm5zIHRoZSBsYXN0IGdlbmVyYXRlZCBzaGFyZCBibG9jayBvZiB0aGUgZGVzdGluYXRpb24gYWNjb3VudFxuICAgICAqIGJlZm9yZSB0aGUgbWVzc2FnZSB3YXMgc2VudC4gSXQgd2lsbCBiZSByZXF1aXJlZCBsYXRlciBmb3IgbWVzc2FnZSBwcm9jZXNzaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlNlbmRNZXNzYWdlfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZlNlbmRNZXNzYWdlXG4gICAgICovXG4gICAgc2VuZF9tZXNzYWdlKHBhcmFtcywgcmVzcG9uc2VIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdwcm9jZXNzaW5nLnNlbmRfbWVzc2FnZScsIHBhcmFtcywgcmVzcG9uc2VIYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbW9uaXRvcmluZyBvZiB0aGUgbmV0d29yayBmb3IgdGhlIHJlc3VsdCB0cmFuc2FjdGlvbiBvZiB0aGUgZXh0ZXJuYWwgaW5ib3VuZCBtZXNzYWdlIHByb2Nlc3NpbmcuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIGBzZW5kX2V2ZW50c2AgZW5hYmxlcyBpbnRlcm1lZGlhdGUgZXZlbnRzLCBzdWNoIGFzIGBXaWxsRmV0Y2hOZXh0QmxvY2tgLFxuICAgICAqIGBGZXRjaE5leHRCbG9ja0ZhaWxlZGAgdGhhdCBtYXkgYmUgdXNlZnVsIGZvciBsb2dnaW5nIG9mIG5ldyBzaGFyZCBibG9ja3MgY3JlYXRpb25cbiAgICAgKiBkdXJpbmcgbWVzc2FnZSBwcm9jZXNzaW5nLlxuICAgICAqXG4gICAgICogTm90ZSwgdGhhdCBwcmVzZW5jZSBvZiB0aGUgYGFiaWAgcGFyYW1ldGVyIGlzIGNyaXRpY2FsIGZvciBBQklcbiAgICAgKiBjb21wbGlhbnQgY29udHJhY3RzLiBNZXNzYWdlIHByb2Nlc3NpbmcgdXNlcyBkcmFzdGljYWxseVxuICAgICAqIGRpZmZlcmVudCBzdHJhdGVneSBmb3IgcHJvY2Vzc2luZyBtZXNzYWdlIGZvciBjb250cmFjdHMgd2hpY2hcbiAgICAgKiBBQkkgaW5jbHVkZXMgXCJleHBpcmVcIiBoZWFkZXIuXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSBBQkkgaGVhZGVyIGBleHBpcmVgIGlzIHByZXNlbnQsIHRoZSBwcm9jZXNzaW5nIHVzZXNcbiAgICAgKiBgbWVzc2FnZSBleHBpcmF0aW9uYCBzdHJhdGVneTpcbiAgICAgKiAtIFRoZSBtYXhpbXVtIGJsb2NrIGdlbiB0aW1lIGlzIHNldCB0b1xuICAgICAqICAgYG1lc3NhZ2VfZXhwaXJhdGlvbl90aW1lb3V0ICsgdHJhbnNhY3Rpb25fd2FpdF90aW1lb3V0YC5cbiAgICAgKiAtIFdoZW4gbWF4aW11bSBibG9jayBnZW4gdGltZSBpcyByZWFjaGVkLCB0aGUgcHJvY2Vzc2luZyB3aWxsXG4gICAgICogICBiZSBmaW5pc2hlZCB3aXRoIGBNZXNzYWdlRXhwaXJlZGAgZXJyb3IuXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSBBQkkgaGVhZGVyIGBleHBpcmVgIGlzbid0IHByZXNlbnQgb3IgYGFiaWAgcGFyYW1ldGVyXG4gICAgICogaXNuJ3Qgc3BlY2lmaWVkLCB0aGUgcHJvY2Vzc2luZyB1c2VzIGB0cmFuc2FjdGlvbiB3YWl0aW5nYFxuICAgICAqIHN0cmF0ZWd5OlxuICAgICAqIC0gVGhlIG1heGltdW0gYmxvY2sgZ2VuIHRpbWUgaXMgc2V0IHRvXG4gICAgICogICBgbm93KCkgKyB0cmFuc2FjdGlvbl93YWl0X3RpbWVvdXRgLlxuICAgICAqXG4gICAgICogLSBJZiBtYXhpbXVtIGJsb2NrIGdlbiB0aW1lIGlzIHJlYWNoZWQgYW5kIG5vIHJlc3VsdCB0cmFuc2FjdGlvbiBpcyBmb3VuZCxcbiAgICAgKiB0aGUgcHJvY2Vzc2luZyB3aWxsIGV4aXQgd2l0aCBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZXYWl0Rm9yVHJhbnNhY3Rpb259IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mUHJvY2Vzc01lc3NhZ2VcbiAgICAgKi9cbiAgICB3YWl0X2Zvcl90cmFuc2FjdGlvbihwYXJhbXMsIHJlc3BvbnNlSGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgncHJvY2Vzc2luZy53YWl0X2Zvcl90cmFuc2FjdGlvbicsIHBhcmFtcywgcmVzcG9uc2VIYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBtZXNzYWdlLCBzZW5kcyBpdCB0byB0aGUgbmV0d29yayBhbmQgbW9uaXRvcnMgaXRzIHByb2Nlc3NpbmcuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIENyZWF0ZXMgQUJJLWNvbXBhdGlibGUgbWVzc2FnZSxcbiAgICAgKiBzZW5kcyBpdCB0byB0aGUgbmV0d29yayBhbmQgbW9uaXRvcnMgZm9yIHRoZSByZXN1bHQgdHJhbnNhY3Rpb24uXG4gICAgICogRGVjb2RlcyB0aGUgb3V0cHV0IG1lc3NhZ2VzJyBib2RpZXMuXG4gICAgICpcbiAgICAgKiBJZiBjb250cmFjdCdzIEFCSSBpbmNsdWRlcyBcImV4cGlyZVwiIGhlYWRlciwgdGhlblxuICAgICAqIFNESyBpbXBsZW1lbnRzIHJldHJpZXMgaW4gY2FzZSBvZiB1bnN1Y2Nlc3NmdWwgbWVzc2FnZSBkZWxpdmVyeSB3aXRoaW4gdGhlIGV4cGlyYXRpb25cbiAgICAgKiB0aW1lb3V0OiBTREsgcmVjcmVhdGVzIHRoZSBtZXNzYWdlLCBzZW5kcyBpdCBhbmQgcHJvY2Vzc2VzIGl0IGFnYWluLlxuICAgICAqXG4gICAgICogVGhlIGludGVybWVkaWF0ZSBldmVudHMsIHN1Y2ggYXMgYFdpbGxGZXRjaEZpcnN0QmxvY2tgLCBgV2lsbFNlbmRgLCBgRGlkU2VuZGAsXG4gICAgICogYFdpbGxGZXRjaE5leHRCbG9ja2AsIGV0YyAtIGFyZSBzd2l0Y2hlZCBvbi9vZmYgYnkgYHNlbmRfZXZlbnRzYCBmbGFnXG4gICAgICogYW5kIGxvZ2dlZCBpbnRvIHRoZSBzdXBwbGllZCBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSByZXRyeSBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgYXJlIGRlZmluZWQgaW4gdGhlIGNsaWVudCdzIGBOZXR3b3JrQ29uZmlnYCBhbmQgYEFiaUNvbmZpZ2AuXG4gICAgICpcbiAgICAgKiBJZiBjb250cmFjdCdzIEFCSSBkb2VzIG5vdCBpbmNsdWRlIFwiZXhwaXJlXCIgaGVhZGVyXG4gICAgICogdGhlbiwgaWYgbm8gdHJhbnNhY3Rpb24gaXMgZm91bmQgd2l0aGluIHRoZSBuZXR3b3JrIHRpbWVvdXQgKHNlZSBjb25maWcgcGFyYW1ldGVyICksIGV4aXRzIHdpdGggZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mUHJvY2Vzc01lc3NhZ2V9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mUHJvY2Vzc01lc3NhZ2VcbiAgICAgKi9cbiAgICBwcm9jZXNzX21lc3NhZ2UocGFyYW1zLCByZXNwb25zZUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ3Byb2Nlc3NpbmcucHJvY2Vzc19tZXNzYWdlJywgcGFyYW1zLCByZXNwb25zZUhhbmRsZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvY2Vzc2luZ01vZHVsZSA9IFByb2Nlc3NpbmdNb2R1bGU7XG5mdW5jdGlvbiBhZGRyZXNzU3RyaW5nRm9ybWF0QWNjb3VudElkKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdBY2NvdW50SWQnLFxuICAgIH07XG59XG5leHBvcnRzLmFkZHJlc3NTdHJpbmdGb3JtYXRBY2NvdW50SWQgPSBhZGRyZXNzU3RyaW5nRm9ybWF0QWNjb3VudElkO1xuZnVuY3Rpb24gYWRkcmVzc1N0cmluZ0Zvcm1hdEhleCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnSGV4JyxcbiAgICB9O1xufVxuZXhwb3J0cy5hZGRyZXNzU3RyaW5nRm9ybWF0SGV4ID0gYWRkcmVzc1N0cmluZ0Zvcm1hdEhleDtcbmZ1bmN0aW9uIGFkZHJlc3NTdHJpbmdGb3JtYXRCYXNlNjQodXJsLCB0ZXN0LCBib3VuY2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnQmFzZTY0JyxcbiAgICAgICAgdXJsLFxuICAgICAgICB0ZXN0LFxuICAgICAgICBib3VuY2UsXG4gICAgfTtcbn1cbmV4cG9ydHMuYWRkcmVzc1N0cmluZ0Zvcm1hdEJhc2U2NCA9IGFkZHJlc3NTdHJpbmdGb3JtYXRCYXNlNjQ7XG52YXIgQWNjb3VudEFkZHJlc3NUeXBlO1xuKGZ1bmN0aW9uIChBY2NvdW50QWRkcmVzc1R5cGUpIHtcbiAgICBBY2NvdW50QWRkcmVzc1R5cGVbXCJBY2NvdW50SWRcIl0gPSBcIkFjY291bnRJZFwiO1xuICAgIEFjY291bnRBZGRyZXNzVHlwZVtcIkhleFwiXSA9IFwiSGV4XCI7XG4gICAgQWNjb3VudEFkZHJlc3NUeXBlW1wiQmFzZTY0XCJdID0gXCJCYXNlNjRcIjtcbn0pKEFjY291bnRBZGRyZXNzVHlwZSA9IGV4cG9ydHMuQWNjb3VudEFkZHJlc3NUeXBlIHx8IChleHBvcnRzLkFjY291bnRBZGRyZXNzVHlwZSA9IHt9KSk7XG4vKipcbiAqIE1pc2MgdXRpbGl0eSBGdW5jdGlvbnMuXG4gKi9cbmNsYXNzIFV0aWxzTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFkZHJlc3MgZnJvbSBhbnkgVE9OIGZvcm1hdCB0byBhbnkgVE9OIGZvcm1hdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkNvbnZlcnRBZGRyZXNzfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkNvbnZlcnRBZGRyZXNzXG4gICAgICovXG4gICAgY29udmVydF9hZGRyZXNzKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgndXRpbHMuY29udmVydF9hZGRyZXNzJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIGFuZCByZXR1cm5zIHRoZSB0eXBlIG9mIGFueSBUT04gYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQWRkcmVzcyB0eXBlcyBhcmUgdGhlIGZvbGxvd2luZ1xuICAgICAqXG4gICAgICogYDA6OTE5ZGI4ZTc0MGQ1MGJmMzQ5ZGYyZWVhMDNmYTMwYzM4NWQ4NDZiOTkxZmY1NTQyZTY3MDk4ZWU4MzNmYzdmN2AgLSBzdGFuZGFyZCBUT04gYWRkcmVzcyBtb3N0XG4gICAgICogY29tbW9ubHkgdXNlZCBpbiBhbGwgY2FzZXMuIEFsc28gY2FsbGVkIGFzIGhleCBhZGRyZXNzXG4gICAgICogYDkxOWRiOGU3NDBkNTBiZjM0OWRmMmVlYTAzZmEzMGMzODVkODQ2Yjk5MWZmNTU0MmU2NzA5OGVlODMzZmM3ZjdgIC0gYWNjb3VudCBJRC4gQSBwYXJ0IG9mIGZ1bGxcbiAgICAgKiBhZGRyZXNzLiBJZGVudGlmaWVzIGFjY291bnQgaW5zaWRlIHBhcnRpY3VsYXIgd29ya2NoYWluXG4gICAgICogYEVRQ1JuYmpuUU5VTDgwbmZMdW9EK2pERGhkaEd1WkgvVlVMbWNKanVnei9IOXdhbWAgLSBiYXNlNjQgYWRkcmVzcy4gQWxzbyBjYWxsZWQgXCJ1c2VyLWZyaWVuZGx5XCIuXG4gICAgICogV2FzIHVzZWQgYXQgdGhlIGJlZ2lubmluZyBvZiBUT04uIE5vdyBpdCBpcyBzdXBwb3J0ZWQgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZHZXRBZGRyZXNzVHlwZX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZHZXRBZGRyZXNzVHlwZVxuICAgICAqL1xuICAgIGdldF9hZGRyZXNzX3R5cGUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCd1dGlscy5nZXRfYWRkcmVzc190eXBlJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBzdG9yYWdlIGZlZSBmb3IgYW4gYWNjb3VudCBvdmVyIGEgc3BlY2lmaWVkIHRpbWUgcGVyaW9kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mQ2FsY1N0b3JhZ2VGZWV9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mQ2FsY1N0b3JhZ2VGZWVcbiAgICAgKi9cbiAgICBjYWxjX3N0b3JhZ2VfZmVlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgndXRpbHMuY2FsY19zdG9yYWdlX2ZlZScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXByZXNzZXMgZGF0YSB1c2luZyBac3RhbmRhcmQgYWxnb3JpdGhtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mQ29tcHJlc3Nac3RkfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkNvbXByZXNzWnN0ZFxuICAgICAqL1xuICAgIGNvbXByZXNzX3pzdGQocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCd1dGlscy5jb21wcmVzc196c3RkJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb21wcmVzc2VzIGRhdGEgdXNpbmcgWnN0YW5kYXJkIGFsZ29yaXRobVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkRlY29tcHJlc3Nac3RkfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkRlY29tcHJlc3Nac3RkXG4gICAgICovXG4gICAgZGVjb21wcmVzc196c3RkKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgndXRpbHMuZGVjb21wcmVzc196c3RkJywgcGFyYW1zKTtcbiAgICB9XG59XG5leHBvcnRzLlV0aWxzTW9kdWxlID0gVXRpbHNNb2R1bGU7XG4vLyB0dm0gbW9kdWxlXG52YXIgVHZtRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChUdm1FcnJvckNvZGUpIHtcbiAgICBUdm1FcnJvckNvZGVbVHZtRXJyb3JDb2RlW1wiQ2FuTm90UmVhZFRyYW5zYWN0aW9uXCJdID0gNDAxXSA9IFwiQ2FuTm90UmVhZFRyYW5zYWN0aW9uXCI7XG4gICAgVHZtRXJyb3JDb2RlW1R2bUVycm9yQ29kZVtcIkNhbk5vdFJlYWRCbG9ja2NoYWluQ29uZmlnXCJdID0gNDAyXSA9IFwiQ2FuTm90UmVhZEJsb2NrY2hhaW5Db25maWdcIjtcbiAgICBUdm1FcnJvckNvZGVbVHZtRXJyb3JDb2RlW1wiVHJhbnNhY3Rpb25BYm9ydGVkXCJdID0gNDAzXSA9IFwiVHJhbnNhY3Rpb25BYm9ydGVkXCI7XG4gICAgVHZtRXJyb3JDb2RlW1R2bUVycm9yQ29kZVtcIkludGVybmFsRXJyb3JcIl0gPSA0MDRdID0gXCJJbnRlcm5hbEVycm9yXCI7XG4gICAgVHZtRXJyb3JDb2RlW1R2bUVycm9yQ29kZVtcIkFjdGlvblBoYXNlRmFpbGVkXCJdID0gNDA1XSA9IFwiQWN0aW9uUGhhc2VGYWlsZWRcIjtcbiAgICBUdm1FcnJvckNvZGVbVHZtRXJyb3JDb2RlW1wiQWNjb3VudENvZGVNaXNzaW5nXCJdID0gNDA2XSA9IFwiQWNjb3VudENvZGVNaXNzaW5nXCI7XG4gICAgVHZtRXJyb3JDb2RlW1R2bUVycm9yQ29kZVtcIkxvd0JhbGFuY2VcIl0gPSA0MDddID0gXCJMb3dCYWxhbmNlXCI7XG4gICAgVHZtRXJyb3JDb2RlW1R2bUVycm9yQ29kZVtcIkFjY291bnRGcm96ZW5PckRlbGV0ZWRcIl0gPSA0MDhdID0gXCJBY2NvdW50RnJvemVuT3JEZWxldGVkXCI7XG4gICAgVHZtRXJyb3JDb2RlW1R2bUVycm9yQ29kZVtcIkFjY291bnRNaXNzaW5nXCJdID0gNDA5XSA9IFwiQWNjb3VudE1pc3NpbmdcIjtcbiAgICBUdm1FcnJvckNvZGVbVHZtRXJyb3JDb2RlW1wiVW5rbm93bkV4ZWN1dGlvbkVycm9yXCJdID0gNDEwXSA9IFwiVW5rbm93bkV4ZWN1dGlvbkVycm9yXCI7XG4gICAgVHZtRXJyb3JDb2RlW1R2bUVycm9yQ29kZVtcIkludmFsaWRJbnB1dFN0YWNrXCJdID0gNDExXSA9IFwiSW52YWxpZElucHV0U3RhY2tcIjtcbiAgICBUdm1FcnJvckNvZGVbVHZtRXJyb3JDb2RlW1wiSW52YWxpZEFjY291bnRCb2NcIl0gPSA0MTJdID0gXCJJbnZhbGlkQWNjb3VudEJvY1wiO1xuICAgIFR2bUVycm9yQ29kZVtUdm1FcnJvckNvZGVbXCJJbnZhbGlkTWVzc2FnZVR5cGVcIl0gPSA0MTNdID0gXCJJbnZhbGlkTWVzc2FnZVR5cGVcIjtcbiAgICBUdm1FcnJvckNvZGVbVHZtRXJyb3JDb2RlW1wiQ29udHJhY3RFeGVjdXRpb25FcnJvclwiXSA9IDQxNF0gPSBcIkNvbnRyYWN0RXhlY3V0aW9uRXJyb3JcIjtcbn0pKFR2bUVycm9yQ29kZSA9IGV4cG9ydHMuVHZtRXJyb3JDb2RlIHx8IChleHBvcnRzLlR2bUVycm9yQ29kZSA9IHt9KSk7XG5mdW5jdGlvbiBhY2NvdW50Rm9yRXhlY3V0b3JOb25lKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdOb25lJyxcbiAgICB9O1xufVxuZXhwb3J0cy5hY2NvdW50Rm9yRXhlY3V0b3JOb25lID0gYWNjb3VudEZvckV4ZWN1dG9yTm9uZTtcbmZ1bmN0aW9uIGFjY291bnRGb3JFeGVjdXRvclVuaW5pdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnVW5pbml0JyxcbiAgICB9O1xufVxuZXhwb3J0cy5hY2NvdW50Rm9yRXhlY3V0b3JVbmluaXQgPSBhY2NvdW50Rm9yRXhlY3V0b3JVbmluaXQ7XG5mdW5jdGlvbiBhY2NvdW50Rm9yRXhlY3V0b3JBY2NvdW50KGJvYywgdW5saW1pdGVkX2JhbGFuY2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnQWNjb3VudCcsXG4gICAgICAgIGJvYyxcbiAgICAgICAgdW5saW1pdGVkX2JhbGFuY2UsXG4gICAgfTtcbn1cbmV4cG9ydHMuYWNjb3VudEZvckV4ZWN1dG9yQWNjb3VudCA9IGFjY291bnRGb3JFeGVjdXRvckFjY291bnQ7XG5jbGFzcyBUdm1Nb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW11bGF0ZXMgYWxsIHRoZSBwaGFzZXMgb2YgY29udHJhY3QgZXhlY3V0aW9uIGxvY2FsbHlcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUGVyZm9ybXMgYWxsIHRoZSBwaGFzZXMgb2YgY29udHJhY3QgZXhlY3V0aW9uIG9uIFRyYW5zYWN0aW9uIEV4ZWN1dG9yIC1cbiAgICAgKiB0aGUgc2FtZSBjb21wb25lbnQgdGhhdCBpcyB1c2VkIG9uIFZhbGlkYXRvciBOb2Rlcy5cbiAgICAgKlxuICAgICAqIENhbiBiZSB1c2VkIGZvciBjb250cmFjdCBkZWJ1Z2dpbmcsIHRvIGZpbmQgb3V0IHRoZSByZWFzb24gd2h5IGEgbWVzc2FnZSB3YXMgbm90IGRlbGl2ZXJlZCBzdWNjZXNzZnVsbHkuXG4gICAgICogVmFsaWRhdG9ycyB0aHJvdyBhd2F5IHRoZSBmYWlsZWQgZXh0ZXJuYWwgaW5ib3VuZCBtZXNzYWdlcyAoaWYgdGhleSBmYWlsZWQgYmVkb3JlIGBBQ0NFUFRgKSBpbiB0aGUgcmVhbCBuZXR3b3JrLlxuICAgICAqIFRoaXMgaXMgd2h5IHRoZXNlIG1lc3NhZ2VzIGFyZSBpbXBvc3NpYmxlIHRvIGRlYnVnIGluIHRoZSByZWFsIG5ldHdvcmsuXG4gICAgICogV2l0aCB0aGUgaGVscCBvZiBydW5fZXhlY3V0b3IgeW91IGNhbiBkbyB0aGF0LiBJbiBmYWN0LCBgcHJvY2Vzc19tZXNzYWdlYCBmdW5jdGlvblxuICAgICAqIHBlcmZvcm1zIGxvY2FsIGNoZWNrIHdpdGggYHJ1bl9leGVjdXRvcmAgaWYgdGhlcmUgd2FzIG5vIHRyYW5zYWN0aW9uIGFzIGEgcmVzdWx0IG9mIHByb2Nlc3NpbmdcbiAgICAgKiBhbmQgcmV0dXJucyB0aGUgZXJyb3IsIGlmIHRoZXJlIGlzIG9uZS5cbiAgICAgKlxuICAgICAqIEFub3RoZXIgdXNlIGNhc2UgdG8gdXNlIGBydW5fZXhlY3V0b3JgIGlzIHRvIGVzdGltYXRlIGZlZXMgZm9yIG1lc3NhZ2UgZXhlY3V0aW9uLlxuICAgICAqIFNldCAgYEFjY291bnRGb3JFeGVjdXRvcjo6QWNjb3VudC51bmxpbWl0ZWRfYmFsYW5jZWBcbiAgICAgKiB0byBgdHJ1ZWAgc28gdGhhdCBlbXVsYXRpb24gd2lsbCBub3QgZGVwZW5kIG9uIHRoZSBhY3R1YWwgYmFsYW5jZS5cbiAgICAgKiBUaGlzIG1heSBiZSBuZWVkZWQgdG8gY2FsY3VsYXRlIGRlcGxveSBmZWVzIGZvciBhbiBhY2NvdW50IHRoYXQgZG9lcyBub3QgZXhpc3QgeWV0LlxuICAgICAqIEpTT04gd2l0aCBmZWVzIGlzIGluIGBmZWVzYCBmaWVsZCBvZiB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogT25lIG1vcmUgdXNlIGNhc2UgLSB5b3UgY2FuIHByb2R1Y2UgdGhlIHNlcXVlbmNlIG9mIG9wZXJhdGlvbnMsXG4gICAgICogdGh1cyBlbXVsYXRpbmcgdGhlIHNlcXVlbnRpYWwgY29udHJhY3QgY2FsbHMgbG9jYWxseS5cbiAgICAgKiBBbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBUcmFuc2FjdGlvbiBleGVjdXRvciByZXF1aXJlcyBhY2NvdW50IEJPQyAoYmFnIG9mIGNlbGxzKSBhcyBhIHBhcmFtZXRlci5cbiAgICAgKiBUbyBnZXQgdGhlIGFjY291bnQgQk9DIC0gdXNlIGBuZXQucXVlcnlgIG1ldGhvZCB0byBkb3dubG9hZCBpdCBmcm9tIEdyYXBoUUwgQVBJXG4gICAgICogKGZpZWxkIGBib2NgIG9mIGBhY2NvdW50YCkgb3IgZ2VuZXJhdGUgaXQgd2l0aCBgYWJpLmVuY29kZV9hY2NvdW50YCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBBbHNvIGl0IHJlcXVpcmVzIG1lc3NhZ2UgQk9DLiBUbyBnZXQgdGhlIG1lc3NhZ2UgQk9DIC0gdXNlIGBhYmkuZW5jb2RlX21lc3NhZ2VgIG9yIGBhYmkuZW5jb2RlX2ludGVybmFsX21lc3NhZ2VgLlxuICAgICAqXG4gICAgICogSWYgeW91IG5lZWQgdGhpcyBlbXVsYXRpb24gdG8gYmUgYXMgcHJlY2lzZSBhcyBwb3NzaWJsZSAoZm9yIGluc3RhbmNlIC0gZW11bGF0ZSB0cmFuc2FjdGlvblxuICAgICAqIHdpdGggcGFydGljdWxhciBsdCBpbiBwYXJ0aWN1bGFyIGJsb2NrIG9yIHVzZSBwYXJ0aWN1bGFyIGJsb2NrY2hhaW4gY29uZmlnLFxuICAgICAqIGRvd25sb2FkZWQgZnJvbSBhIHBhcnRpY3VsYXIga2V5IGJsb2NrIC0gdGhlbiBzcGVjaWZ5IGBleGVjdXRpb25fb3B0aW9uc2AgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogSWYgeW91IG5lZWQgdG8gc2VlIHRoZSBhYm9ydGVkIHRyYW5zYWN0aW9uIGFzIGEgcmVzdWx0LCBub3QgYXMgYW4gZXJyb3IsIHNldCBgc2tpcF90cmFuc2FjdGlvbl9jaGVja2AgdG8gYHRydWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlJ1bkV4ZWN1dG9yfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZlJ1bkV4ZWN1dG9yXG4gICAgICovXG4gICAgcnVuX2V4ZWN1dG9yKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgndHZtLnJ1bl9leGVjdXRvcicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGdldC1tZXRob2RzIG9mIEFCSS1jb21wYXRpYmxlIGNvbnRyYWN0c1xuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBQZXJmb3JtcyBvbmx5IGEgcGFydCBvZiBjb21wdXRlIHBoYXNlIG9mIHRyYW5zYWN0aW9uIGV4ZWN1dGlvblxuICAgICAqIHRoYXQgaXMgdXNlZCB0byBydW4gZ2V0LW1ldGhvZHMgb2YgQUJJLWNvbXBhdGlibGUgY29udHJhY3RzLlxuICAgICAqXG4gICAgICogSWYgeW91IHRyeSB0byBydW4gZ2V0LW1ldGhvZHMgd2l0aCBgcnVuX2V4ZWN1dG9yYCB5b3Ugd2lsbCBnZXQgYW4gZXJyb3IsIGJlY2F1c2UgaXQgY2hlY2tzIEFDQ0VQVCBhbmQgZXhpdHNcbiAgICAgKiBpZiB0aGVyZSBpcyBub25lLCB3aGljaCBpcyBhY3R1YWxseSB0cnVlIGZvciBnZXQtbWV0aG9kcy5cbiAgICAgKlxuICAgICAqICBUbyBnZXQgdGhlIGFjY291bnQgQk9DIChiYWcgb2YgY2VsbHMpIC0gdXNlIGBuZXQucXVlcnlgIG1ldGhvZCB0byBkb3dubG9hZCBpdCBmcm9tIEdyYXBoUUwgQVBJXG4gICAgICogKGZpZWxkIGBib2NgIG9mIGBhY2NvdW50YCkgb3IgZ2VuZXJhdGUgaXQgd2l0aCBgYWJpLmVuY29kZV9hY2NvdW50IG1ldGhvZGAuXG4gICAgICogVG8gZ2V0IHRoZSBtZXNzYWdlIEJPQyAtIHVzZSBgYWJpLmVuY29kZV9tZXNzYWdlYCBvciBwcmVwYXJlIGl0IGFueSBvdGhlciB3YXksIGZvciBpbnN0YW5jZSwgd2l0aCBGSUZUIHNjcmlwdC5cbiAgICAgKlxuICAgICAqIEF0dGVudGlvbiEgVXBkYXRlZCBhY2NvdW50IHN0YXRlIGlzIHByb2R1Y2VzIGFzIHdlbGwsIGJ1dCBvbmx5XG4gICAgICogYGFjY291bnRfc3RhdGUuc3RvcmFnZS5zdGF0ZS5kYXRhYCAgcGFydCBvZiB0aGUgQk9DIGlzIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mUnVuVHZtfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZlJ1blR2bVxuICAgICAqL1xuICAgIHJ1bl90dm0ocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCd0dm0ucnVuX3R2bScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGEgZ2V0LW1ldGhvZCBvZiBGSUZUIGNvbnRyYWN0XG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEV4ZWN1dGVzIGEgZ2V0LW1ldGhvZCBvZiBGSUZUIGNvbnRyYWN0IHRoYXQgZnVsZmlsbHMgdGhlIHNtYy1ndWlkZWxpbmVzIGh0dHBzOi8vdGVzdC50b24ub3JnL3NtYy1ndWlkZWxpbmVzLnR4dFxuICAgICAqIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgZGF0YSBmcm9tIFRWTSdzIHN0YWNrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mUnVuR2V0fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZlJ1bkdldFxuICAgICAqL1xuICAgIHJ1bl9nZXQocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCd0dm0ucnVuX2dldCcsIHBhcmFtcyk7XG4gICAgfVxufVxuZXhwb3J0cy5Udm1Nb2R1bGUgPSBUdm1Nb2R1bGU7XG4vLyBuZXQgbW9kdWxlXG52YXIgTmV0RXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChOZXRFcnJvckNvZGUpIHtcbiAgICBOZXRFcnJvckNvZGVbTmV0RXJyb3JDb2RlW1wiUXVlcnlGYWlsZWRcIl0gPSA2MDFdID0gXCJRdWVyeUZhaWxlZFwiO1xuICAgIE5ldEVycm9yQ29kZVtOZXRFcnJvckNvZGVbXCJTdWJzY3JpYmVGYWlsZWRcIl0gPSA2MDJdID0gXCJTdWJzY3JpYmVGYWlsZWRcIjtcbiAgICBOZXRFcnJvckNvZGVbTmV0RXJyb3JDb2RlW1wiV2FpdEZvckZhaWxlZFwiXSA9IDYwM10gPSBcIldhaXRGb3JGYWlsZWRcIjtcbiAgICBOZXRFcnJvckNvZGVbTmV0RXJyb3JDb2RlW1wiR2V0U3Vic2NyaXB0aW9uUmVzdWx0RmFpbGVkXCJdID0gNjA0XSA9IFwiR2V0U3Vic2NyaXB0aW9uUmVzdWx0RmFpbGVkXCI7XG4gICAgTmV0RXJyb3JDb2RlW05ldEVycm9yQ29kZVtcIkludmFsaWRTZXJ2ZXJSZXNwb25zZVwiXSA9IDYwNV0gPSBcIkludmFsaWRTZXJ2ZXJSZXNwb25zZVwiO1xuICAgIE5ldEVycm9yQ29kZVtOZXRFcnJvckNvZGVbXCJDbG9ja091dE9mU3luY1wiXSA9IDYwNl0gPSBcIkNsb2NrT3V0T2ZTeW5jXCI7XG4gICAgTmV0RXJyb3JDb2RlW05ldEVycm9yQ29kZVtcIldhaXRGb3JUaW1lb3V0XCJdID0gNjA3XSA9IFwiV2FpdEZvclRpbWVvdXRcIjtcbiAgICBOZXRFcnJvckNvZGVbTmV0RXJyb3JDb2RlW1wiR3JhcGhxbEVycm9yXCJdID0gNjA4XSA9IFwiR3JhcGhxbEVycm9yXCI7XG4gICAgTmV0RXJyb3JDb2RlW05ldEVycm9yQ29kZVtcIk5ldHdvcmtNb2R1bGVTdXNwZW5kZWRcIl0gPSA2MDldID0gXCJOZXR3b3JrTW9kdWxlU3VzcGVuZGVkXCI7XG4gICAgTmV0RXJyb3JDb2RlW05ldEVycm9yQ29kZVtcIldlYnNvY2tldERpc2Nvbm5lY3RlZFwiXSA9IDYxMF0gPSBcIldlYnNvY2tldERpc2Nvbm5lY3RlZFwiO1xuICAgIE5ldEVycm9yQ29kZVtOZXRFcnJvckNvZGVbXCJOb3RTdXBwb3J0ZWRcIl0gPSA2MTFdID0gXCJOb3RTdXBwb3J0ZWRcIjtcbiAgICBOZXRFcnJvckNvZGVbTmV0RXJyb3JDb2RlW1wiTm9FbmRwb2ludHNQcm92aWRlZFwiXSA9IDYxMl0gPSBcIk5vRW5kcG9pbnRzUHJvdmlkZWRcIjtcbiAgICBOZXRFcnJvckNvZGVbTmV0RXJyb3JDb2RlW1wiR3JhcGhxbFdlYnNvY2tldEluaXRFcnJvclwiXSA9IDYxM10gPSBcIkdyYXBocWxXZWJzb2NrZXRJbml0RXJyb3JcIjtcbiAgICBOZXRFcnJvckNvZGVbTmV0RXJyb3JDb2RlW1wiTmV0d29ya01vZHVsZVJlc3VtZWRcIl0gPSA2MTRdID0gXCJOZXR3b3JrTW9kdWxlUmVzdW1lZFwiO1xuICAgIE5ldEVycm9yQ29kZVtOZXRFcnJvckNvZGVbXCJVbmF1dGhvcml6ZWRcIl0gPSA2MTVdID0gXCJVbmF1dGhvcml6ZWRcIjtcbn0pKE5ldEVycm9yQ29kZSA9IGV4cG9ydHMuTmV0RXJyb3JDb2RlIHx8IChleHBvcnRzLk5ldEVycm9yQ29kZSA9IHt9KSk7XG52YXIgU29ydERpcmVjdGlvbjtcbihmdW5jdGlvbiAoU29ydERpcmVjdGlvbikge1xuICAgIFNvcnREaXJlY3Rpb25bXCJBU0NcIl0gPSBcIkFTQ1wiO1xuICAgIFNvcnREaXJlY3Rpb25bXCJERVNDXCJdID0gXCJERVNDXCI7XG59KShTb3J0RGlyZWN0aW9uID0gZXhwb3J0cy5Tb3J0RGlyZWN0aW9uIHx8IChleHBvcnRzLlNvcnREaXJlY3Rpb24gPSB7fSkpO1xuZnVuY3Rpb24gcGFyYW1zT2ZRdWVyeU9wZXJhdGlvblF1ZXJ5Q29sbGVjdGlvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdRdWVyeUNvbGxlY3Rpb24nIH0sIHBhcmFtcyk7XG59XG5leHBvcnRzLnBhcmFtc09mUXVlcnlPcGVyYXRpb25RdWVyeUNvbGxlY3Rpb24gPSBwYXJhbXNPZlF1ZXJ5T3BlcmF0aW9uUXVlcnlDb2xsZWN0aW9uO1xuZnVuY3Rpb24gcGFyYW1zT2ZRdWVyeU9wZXJhdGlvbldhaXRGb3JDb2xsZWN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgdHlwZTogJ1dhaXRGb3JDb2xsZWN0aW9uJyB9LCBwYXJhbXMpO1xufVxuZXhwb3J0cy5wYXJhbXNPZlF1ZXJ5T3BlcmF0aW9uV2FpdEZvckNvbGxlY3Rpb24gPSBwYXJhbXNPZlF1ZXJ5T3BlcmF0aW9uV2FpdEZvckNvbGxlY3Rpb247XG5mdW5jdGlvbiBwYXJhbXNPZlF1ZXJ5T3BlcmF0aW9uQWdncmVnYXRlQ29sbGVjdGlvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdBZ2dyZWdhdGVDb2xsZWN0aW9uJyB9LCBwYXJhbXMpO1xufVxuZXhwb3J0cy5wYXJhbXNPZlF1ZXJ5T3BlcmF0aW9uQWdncmVnYXRlQ29sbGVjdGlvbiA9IHBhcmFtc09mUXVlcnlPcGVyYXRpb25BZ2dyZWdhdGVDb2xsZWN0aW9uO1xuZnVuY3Rpb24gcGFyYW1zT2ZRdWVyeU9wZXJhdGlvblF1ZXJ5Q291bnRlcnBhcnRpZXMocGFyYW1zKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnUXVlcnlDb3VudGVycGFydGllcycgfSwgcGFyYW1zKTtcbn1cbmV4cG9ydHMucGFyYW1zT2ZRdWVyeU9wZXJhdGlvblF1ZXJ5Q291bnRlcnBhcnRpZXMgPSBwYXJhbXNPZlF1ZXJ5T3BlcmF0aW9uUXVlcnlDb3VudGVycGFydGllcztcbnZhciBBZ2dyZWdhdGlvbkZuO1xuKGZ1bmN0aW9uIChBZ2dyZWdhdGlvbkZuKSB7XG4gICAgQWdncmVnYXRpb25GbltcIkNPVU5UXCJdID0gXCJDT1VOVFwiO1xuICAgIEFnZ3JlZ2F0aW9uRm5bXCJNSU5cIl0gPSBcIk1JTlwiO1xuICAgIEFnZ3JlZ2F0aW9uRm5bXCJNQVhcIl0gPSBcIk1BWFwiO1xuICAgIEFnZ3JlZ2F0aW9uRm5bXCJTVU1cIl0gPSBcIlNVTVwiO1xuICAgIEFnZ3JlZ2F0aW9uRm5bXCJBVkVSQUdFXCJdID0gXCJBVkVSQUdFXCI7XG59KShBZ2dyZWdhdGlvbkZuID0gZXhwb3J0cy5BZ2dyZWdhdGlvbkZuIHx8IChleHBvcnRzLkFnZ3JlZ2F0aW9uRm4gPSB7fSkpO1xuLyoqXG4gKiBOZXR3b3JrIGFjY2Vzcy5cbiAqL1xuY2xhc3MgTmV0TW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIERBcHBTZXJ2ZXIgR3JhcGhRTCBxdWVyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZRdWVyeX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZRdWVyeVxuICAgICAqL1xuICAgIHF1ZXJ5KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnbmV0LnF1ZXJ5JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbXVsdGlwbGUgcXVlcmllcyBwZXIgc2luZ2xlIGZldGNoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkJhdGNoUXVlcnl9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mQmF0Y2hRdWVyeVxuICAgICAqL1xuICAgIGJhdGNoX3F1ZXJ5KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnbmV0LmJhdGNoX3F1ZXJ5JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcmllcyBjb2xsZWN0aW9uIGRhdGFcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUXVlcmllcyBkYXRhIHRoYXQgc2F0aXNmaWVzIHRoZSBgZmlsdGVyYCBjb25kaXRpb25zLFxuICAgICAqIGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJldHVybmVkIHJlY29yZHMgYW5kIG9yZGVycyB0aGVtLlxuICAgICAqIFRoZSBwcm9qZWN0aW9uIGZpZWxkcyBhcmUgbGltaXRlZCB0byBgcmVzdWx0YCBmaWVsZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZRdWVyeUNvbGxlY3Rpb259IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mUXVlcnlDb2xsZWN0aW9uXG4gICAgICovXG4gICAgcXVlcnlfY29sbGVjdGlvbihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC5xdWVyeV9jb2xsZWN0aW9uJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWdncmVnYXRlcyBjb2xsZWN0aW9uIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEFnZ3JlZ2F0ZXMgdmFsdWVzIGZyb20gdGhlIHNwZWNpZmllZCBgZmllbGRzYCBmb3IgcmVjb3Jkc1xuICAgICAqIHRoYXQgc2F0aXNmaWVzIHRoZSBgZmlsdGVyYCBjb25kaXRpb25zLFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkFnZ3JlZ2F0ZUNvbGxlY3Rpb259IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mQWdncmVnYXRlQ29sbGVjdGlvblxuICAgICAqL1xuICAgIGFnZ3JlZ2F0ZV9jb2xsZWN0aW9uKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnbmV0LmFnZ3JlZ2F0ZV9jb2xsZWN0aW9uJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBmdWxmaWxscyB0aGUgY29uZGl0aW9ucyBvciB3YWl0cyBmb3IgaXRzIGFwcGVhcmFuY2VcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVHJpZ2dlcnMgb25seSBvbmNlLlxuICAgICAqIElmIG9iamVjdCB0aGF0IHNhdGlzZmllcyB0aGUgYGZpbHRlcmAgY29uZGl0aW9uc1xuICAgICAqIGFscmVhZHkgZXhpc3RzIC0gcmV0dXJucyBpdCBpbW1lZGlhdGVseS5cbiAgICAgKiBJZiBub3QgLSB3YWl0cyBmb3IgaW5zZXJ0L3VwZGF0ZSBvZiBkYXRhIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGB0aW1lb3V0YCxcbiAgICAgKiBhbmQgcmV0dXJucyBpdC5cbiAgICAgKiBUaGUgcHJvamVjdGlvbiBmaWVsZHMgYXJlIGxpbWl0ZWQgdG8gYHJlc3VsdGAgZmllbGRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mV2FpdEZvckNvbGxlY3Rpb259IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mV2FpdEZvckNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICB3YWl0X2Zvcl9jb2xsZWN0aW9uKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnbmV0LndhaXRfZm9yX2NvbGxlY3Rpb24nLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGEgc3Vic2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIENhbmNlbHMgYSBzdWJzY3JpcHRpb24gc3BlY2lmaWVkIGJ5IGl0cyBoYW5kbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Jlc3VsdE9mU3Vic2NyaWJlQ29sbGVjdGlvbn0gcGFyYW1zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC51bnN1YnNjcmliZScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb2xsZWN0aW9uIHN1YnNjcmlwdGlvblxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUcmlnZ2VycyBmb3IgZWFjaCBpbnNlcnQvdXBkYXRlIG9mIGRhdGEgdGhhdCBzYXRpc2ZpZXNcbiAgICAgKiB0aGUgYGZpbHRlcmAgY29uZGl0aW9ucy5cbiAgICAgKiBUaGUgcHJvamVjdGlvbiBmaWVsZHMgYXJlIGxpbWl0ZWQgdG8gYHJlc3VsdGAgZmllbGRzLlxuICAgICAqXG4gICAgICogVGhlIHN1YnNjcmlwdGlvbiBpcyBhIHBlcnNpc3RlbnQgY29tbXVuaWNhdGlvbiBjaGFubmVsIGJldHdlZW5cbiAgICAgKiBjbGllbnQgYW5kIEZyZWUgVE9OIE5ldHdvcmsuXG4gICAgICogQWxsIGNoYW5nZXMgaW4gdGhlIGJsb2NrY2hhaW4gd2lsbCBiZSByZWZsZWN0ZWQgaW4gcmVhbHRpbWUuXG4gICAgICogQ2hhbmdlcyBtZWFucyBpbnNlcnRzIGFuZCB1cGRhdGVzIG9mIHRoZSBibG9ja2NoYWluIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogIyMjIEltcG9ydGFudCBOb3RlcyBvbiBTdWJzY3JpcHRpb25zXG4gICAgICpcbiAgICAgKiBVbmZvcnR1bmF0ZWx5IHNvbWV0aW1lcyB0aGUgY29ubmVjdGlvbiB3aXRoIHRoZSBuZXR3b3JrIGJyYWtlcyBkb3duLlxuICAgICAqIEluIHRoaXMgc2l0dWF0aW9uIHRoZSBsaWJyYXJ5IGF0dGVtcHRzIHRvIHJlY29ubmVjdCB0byB0aGUgbmV0d29yay5cbiAgICAgKiBUaGlzIHJlY29ubmVjdGlvbiBzZXF1ZW5jZSBjYW4gdGFrZSBzaWduaWZpY2FudCB0aW1lLlxuICAgICAqIEFsbCBvZiB0aGlzIHRpbWUgdGhlIGNsaWVudCBpcyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEJhZCBuZXdzIGlzIHRoYXQgYWxsIGJsb2NrY2hhaW4gY2hhbmdlcyB0aGF0IGhhcHBlbmVkIHdoaWxlXG4gICAgICogdGhlIGNsaWVudCB3YXMgZGlzY29ubmVjdGVkIGFyZSBsb3N0LlxuICAgICAqXG4gICAgICogR29vZCBuZXdzIGlzIHRoYXQgdGhlIGNsaWVudCByZXBvcnQgZXJyb3JzIHRvIHRoZSBjYWxsYmFjayB3aGVuXG4gICAgICogaXQgbG9zZXMgYW5kIHJlc3VtZXMgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIFNvLCBpZiB0aGUgbG9zdCBjaGFuZ2VzIGFyZSBpbXBvcnRhbnQgdG8gdGhlIGFwcGxpY2F0aW9uIHRoZW5cbiAgICAgKiB0aGUgYXBwbGljYXRpb24gbXVzdCBoYW5kbGUgdGhlc2UgZXJyb3IgcmVwb3J0cy5cbiAgICAgKlxuICAgICAqIExpYnJhcnkgcmVwb3J0cyBlcnJvcnMgd2l0aCBgcmVzcG9uc2VUeXBlYCA9PSAxMDFcbiAgICAgKiBhbmQgdGhlIGVycm9yIG9iamVjdCBwYXNzZWQgdmlhIGBwYXJhbXNgLlxuICAgICAqXG4gICAgICogV2hlbiB0aGUgbGlicmFyeSBoYXMgc3VjY2Vzc2Z1bGx5IHJlY29ubmVjdGVkXG4gICAgICogdGhlIGFwcGxpY2F0aW9uIHJlY2VpdmVzIGNhbGxiYWNrIHdpdGhcbiAgICAgKiBgcmVzcG9uc2VUeXBlYCA9PSAxMDEgYW5kIGBwYXJhbXMuY29kZWAgPT0gNjE0IChOZXR3b3JrTW9kdWxlUmVzdW1lZCkuXG4gICAgICpcbiAgICAgKiBBcHBsaWNhdGlvbiBjYW4gdXNlIHNldmVyYWwgd2F5cyB0byBoYW5kbGUgdGhpcyBzaXR1YXRpb246XG4gICAgICogLSBJZiBhcHBsaWNhdGlvbiBtb25pdG9ycyBjaGFuZ2VzIGZvciB0aGUgc2luZ2xlIGJsb2NrY2hhaW5cbiAgICAgKiBvYmplY3QgKGZvciBleGFtcGxlIHNwZWNpZmljIGFjY291bnQpOiAgYXBwbGljYXRpb25cbiAgICAgKiBjYW4gcGVyZm9ybSBhIHF1ZXJ5IGZvciB0aGlzIG9iamVjdCBhbmQgaGFuZGxlIGFjdHVhbCBkYXRhIGFzIGFcbiAgICAgKiByZWd1bGFyIGRhdGEgZnJvbSB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAqIC0gSWYgYXBwbGljYXRpb24gbW9uaXRvcnMgc2VxdWVuY2Ugb2Ygc29tZSBibG9ja2NoYWluIG9iamVjdHNcbiAgICAgKiAoZm9yIGV4YW1wbGUgdHJhbnNhY3Rpb25zIG9mIHRoZSBzcGVjaWZpYyBhY2NvdW50KTogYXBwbGljYXRpb24gbXVzdFxuICAgICAqIHJlZnJlc2ggYWxsIGNhY2hlZCAob3IgdmlzaWJsZSB0byB1c2VyKSBsaXN0cyB3aGVyZSB0aGlzIHNlcXVlbmNlcyBwcmVzZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZTdWJzY3JpYmVDb2xsZWN0aW9ufSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZlN1YnNjcmliZUNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICBzdWJzY3JpYmVfY29sbGVjdGlvbihwYXJhbXMsIHJlc3BvbnNlSGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnbmV0LnN1YnNjcmliZV9jb2xsZWN0aW9uJywgcGFyYW1zLCByZXNwb25zZUhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3Vic2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBzdWJzY3JpcHRpb24gaXMgYSBwZXJzaXN0ZW50IGNvbW11bmljYXRpb24gY2hhbm5lbCBiZXR3ZWVuXG4gICAgICogY2xpZW50IGFuZCBFdmVyc2NhbGUgTmV0d29yay5cbiAgICAgKlxuICAgICAqICMjIyBJbXBvcnRhbnQgTm90ZXMgb24gU3Vic2NyaXB0aW9uc1xuICAgICAqXG4gICAgICogVW5mb3J0dW5hdGVseSBzb21ldGltZXMgdGhlIGNvbm5lY3Rpb24gd2l0aCB0aGUgbmV0d29yayBicmVha2VzIGRvd24uXG4gICAgICogSW4gdGhpcyBzaXR1YXRpb24gdGhlIGxpYnJhcnkgYXR0ZW1wdHMgdG8gcmVjb25uZWN0IHRvIHRoZSBuZXR3b3JrLlxuICAgICAqIFRoaXMgcmVjb25uZWN0aW9uIHNlcXVlbmNlIGNhbiB0YWtlIHNpZ25pZmljYW50IHRpbWUuXG4gICAgICogQWxsIG9mIHRoaXMgdGltZSB0aGUgY2xpZW50IGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQmFkIG5ld3MgaXMgdGhhdCBhbGwgY2hhbmdlcyB0aGF0IGhhcHBlbmVkIHdoaWxlXG4gICAgICogdGhlIGNsaWVudCB3YXMgZGlzY29ubmVjdGVkIGFyZSBsb3N0LlxuICAgICAqXG4gICAgICogR29vZCBuZXdzIGlzIHRoYXQgdGhlIGNsaWVudCByZXBvcnQgZXJyb3JzIHRvIHRoZSBjYWxsYmFjayB3aGVuXG4gICAgICogaXQgbG9zZXMgYW5kIHJlc3VtZXMgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIFNvLCBpZiB0aGUgbG9zdCBjaGFuZ2VzIGFyZSBpbXBvcnRhbnQgdG8gdGhlIGFwcGxpY2F0aW9uIHRoZW5cbiAgICAgKiB0aGUgYXBwbGljYXRpb24gbXVzdCBoYW5kbGUgdGhlc2UgZXJyb3IgcmVwb3J0cy5cbiAgICAgKlxuICAgICAqIExpYnJhcnkgcmVwb3J0cyBlcnJvcnMgd2l0aCBgcmVzcG9uc2VUeXBlYCA9PSAxMDFcbiAgICAgKiBhbmQgdGhlIGVycm9yIG9iamVjdCBwYXNzZWQgdmlhIGBwYXJhbXNgLlxuICAgICAqXG4gICAgICogV2hlbiB0aGUgbGlicmFyeSBoYXMgc3VjY2Vzc2Z1bGx5IHJlY29ubmVjdGVkXG4gICAgICogdGhlIGFwcGxpY2F0aW9uIHJlY2VpdmVzIGNhbGxiYWNrIHdpdGhcbiAgICAgKiBgcmVzcG9uc2VUeXBlYCA9PSAxMDEgYW5kIGBwYXJhbXMuY29kZWAgPT0gNjE0IChOZXR3b3JrTW9kdWxlUmVzdW1lZCkuXG4gICAgICpcbiAgICAgKiBBcHBsaWNhdGlvbiBjYW4gdXNlIHNldmVyYWwgd2F5cyB0byBoYW5kbGUgdGhpcyBzaXR1YXRpb246XG4gICAgICogLSBJZiBhcHBsaWNhdGlvbiBtb25pdG9ycyBjaGFuZ2VzIGZvciB0aGUgc2luZ2xlXG4gICAgICogb2JqZWN0IChmb3IgZXhhbXBsZSBzcGVjaWZpYyBhY2NvdW50KTogIGFwcGxpY2F0aW9uXG4gICAgICogY2FuIHBlcmZvcm0gYSBxdWVyeSBmb3IgdGhpcyBvYmplY3QgYW5kIGhhbmRsZSBhY3R1YWwgZGF0YSBhcyBhXG4gICAgICogcmVndWxhciBkYXRhIGZyb20gdGhlIHN1YnNjcmlwdGlvbi5cbiAgICAgKiAtIElmIGFwcGxpY2F0aW9uIG1vbml0b3JzIHNlcXVlbmNlIG9mIHNvbWUgb2JqZWN0c1xuICAgICAqIChmb3IgZXhhbXBsZSB0cmFuc2FjdGlvbnMgb2YgdGhlIHNwZWNpZmljIGFjY291bnQpOiBhcHBsaWNhdGlvbiBtdXN0XG4gICAgICogcmVmcmVzaCBhbGwgY2FjaGVkIChvciB2aXNpYmxlIHRvIHVzZXIpIGxpc3RzIHdoZXJlIHRoaXMgc2VxdWVuY2VzIHByZXNlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlN1YnNjcmliZX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZTdWJzY3JpYmVDb2xsZWN0aW9uXG4gICAgICovXG4gICAgc3Vic2NyaWJlKHBhcmFtcywgcmVzcG9uc2VIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCduZXQuc3Vic2NyaWJlJywgcGFyYW1zLCByZXNwb25zZUhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdXNwZW5kcyBuZXR3b3JrIG1vZHVsZSB0byBzdG9wIGFueSBuZXR3b3JrIGFjdGl2aXR5XG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdXNwZW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnbmV0LnN1c3BlbmQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdW1lcyBuZXR3b3JrIG1vZHVsZSB0byBlbmFibGUgbmV0d29yayBhY3Rpdml0eVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnbmV0LnJlc3VtZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIElEIG9mIHRoZSBsYXN0IGJsb2NrIGluIGEgc3BlY2lmaWVkIGFjY291bnQgc2hhcmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZGaW5kTGFzdFNoYXJkQmxvY2t9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mRmluZExhc3RTaGFyZEJsb2NrXG4gICAgICovXG4gICAgZmluZF9sYXN0X3NoYXJkX2Jsb2NrKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnbmV0LmZpbmRfbGFzdF9zaGFyZF9ibG9jaycsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIHRoZSBsaXN0IG9mIGFsdGVybmF0aXZlIGVuZHBvaW50cyBmcm9tIHNlcnZlclxuICAgICAqIEByZXR1cm5zIEVuZHBvaW50c1NldFxuICAgICAqL1xuICAgIGZldGNoX2VuZHBvaW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC5mZXRjaF9lbmRwb2ludHMnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGlzdCBvZiBlbmRwb2ludHMgdG8gdXNlIG9uIHJlaW5pdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbmRwb2ludHNTZXR9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc2V0X2VuZHBvaW50cyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC5zZXRfZW5kcG9pbnRzJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgdGhlIGxpc3Qgb2YgYWx0ZXJuYXRpdmUgZW5kcG9pbnRzIGZyb20gc2VydmVyXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZHZXRFbmRwb2ludHNcbiAgICAgKi9cbiAgICBnZXRfZW5kcG9pbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnbmV0LmdldF9lbmRwb2ludHMnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRvIHF1ZXJ5IGFuZCBwYWdpbmF0ZSB0aHJvdWdoIHRoZSBsaXN0IG9mIGFjY291bnRzIHRoYXQgdGhlIHNwZWNpZmllZCBhY2NvdW50IGhhcyBpbnRlcmFjdGVkIHdpdGgsIHNvcnRlZCBieSB0aGUgdGltZSBvZiB0aGUgbGFzdCBpbnRlcm5hbCBtZXNzYWdlIGJldHdlZW4gYWNjb3VudHNcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogKkF0dGVudGlvbiogdGhpcyBxdWVyeSByZXRyaWV2ZXMgZGF0YSBmcm9tICdDb3VudGVycGFydGllcycgc2VydmljZSB3aGljaCBpcyBub3Qgc3VwcG9ydGVkIGluXG4gICAgICogdGhlIG9wZW5zb3VyY2UgdmVyc2lvbiBvZiBEQXBwIFNlcnZlciAoYW5kIHdpbGwgbm90IGJlIHN1cHBvcnRlZCkgYXMgd2VsbCBhcyBpbiBFdmVybm9kZSBTRSAod2lsbCBiZSBzdXBwb3J0ZWQgaW4gU0UgaW4gZnV0dXJlKSxcbiAgICAgKiBidXQgaXMgYWx3YXlzIGFjY2Vzc2libGUgdmlhIFtFVkVSIE9TIENsb3Vkc10oLi4vdG9uLW9zLWFwaS9uZXR3b3Jrcy5tZClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZRdWVyeUNvdW50ZXJwYXJ0aWVzfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZlF1ZXJ5Q29sbGVjdGlvblxuICAgICAqL1xuICAgIHF1ZXJ5X2NvdW50ZXJwYXJ0aWVzKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnbmV0LnF1ZXJ5X2NvdW50ZXJwYXJ0aWVzJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRyZWUgb2YgdHJhbnNhY3Rpb25zIHRyaWdnZXJlZCBieSBhIHNwZWNpZmljIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFBlcmZvcm1zIHJlY3Vyc2l2ZSByZXRyaWV2YWwgb2YgYSB0cmFuc2FjdGlvbnMgdHJlZSBwcm9kdWNlZCBieSBhIHNwZWNpZmljIG1lc3NhZ2U6XG4gICAgICogaW5fbXNnIC0+IGRzdF90cmFuc2FjdGlvbiAtPiBvdXRfbWVzc2FnZXMgLT4gZHN0X3RyYW5zYWN0aW9uIC0+IC4uLlxuICAgICAqIElmIHRoZSBjaGFpbiBvZiB0cmFuc2FjdGlvbnMgZXhlY3V0aW9uIGlzIGluIHByb2dyZXNzIHdoaWxlIHRoZSBmdW5jdGlvbiBpcyBydW5uaW5nLFxuICAgICAqIGl0IHdpbGwgd2FpdCBmb3IgdGhlIG5leHQgdHJhbnNhY3Rpb25zIHRvIGFwcGVhciB1bnRpbCB0aGUgZnVsbCB0cmVlIG9yIG1vcmUgdGhhbiA1MCB0cmFuc2FjdGlvbnNcbiAgICAgKiBhcmUgcmVjZWl2ZWQuXG4gICAgICpcbiAgICAgKiBBbGwgdGhlIHJldHJpZXZlZCBtZXNzYWdlcyBhbmQgdHJhbnNhY3Rpb25zIGFyZSBpbmNsdWRlZFxuICAgICAqIGludG8gYHJlc3VsdC5tZXNzYWdlc2AgYW5kIGByZXN1bHQudHJhbnNhY3Rpb25zYCByZXNwZWN0aXZlbHkuXG4gICAgICpcbiAgICAgKiBGdW5jdGlvbiByZWFkcyB0cmFuc2FjdGlvbnMgbGF5ZXIgYnkgbGF5ZXIsIGJ5IHBhZ2VzIG9mIDIwIHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqIFRoZSByZXRyaWV2YWwgcHJvc2VzcyBnb2VzIGxpa2UgdGhpczpcbiAgICAgKiBMZXQncyBhc3N1bWUgd2UgaGF2ZSBhbiBpbmZpbml0ZSBjaGFpbiBvZiB0cmFuc2FjdGlvbnMgYW5kIGVhY2ggdHJhbnNhY3Rpb24gZ2VuZXJhdGVzIDUgbWVzc2FnZXMuXG4gICAgICogMS4gUmV0cmlldmUgMXN0IG1lc3NhZ2UgKGlucHV0IHBhcmFtZXRlcikgYW5kIGNvcnJlc3BvbmRpbmcgdHJhbnNhY3Rpb24gLSBwdXQgaXQgaW50byByZXN1bHQuXG4gICAgICogSXQgaXMgdGhlIGZpcnN0IGxldmVsIG9mIHRoZSB0cmVlIG9mIHRyYW5zYWN0aW9ucyAtIGl0cyByb290LlxuICAgICAqIFJldHJpZXZlIDUgb3V0IG1lc3NhZ2UgaWRzIGZyb20gdGhlIHRyYW5zYWN0aW9uIGZvciBuZXh0IHN0ZXBzLlxuICAgICAqIDIuIFJldHJpZXZlIDUgbWVzc2FnZXMgYW5kIGNvcnJlc3BvbmRpbmcgdHJhbnNhY3Rpb25zIG9uIHRoZSAybmQgbGF5ZXIuIFB1dCB0aGVtIGludG8gcmVzdWx0LlxuICAgICAqIFJldHJpZXZlIDUqNSBvdXQgbWVzc2FnZSBpZHMgZnJvbSB0aGVzZSB0cmFuc2FjdGlvbnMgZm9yIG5leHQgc3RlcHNcbiAgICAgKiAzLiBSZXRyaWV2ZSAyMCAoc2l6ZSBvZiB0aGUgcGFnZSkgbWVzc2FnZXMgYW5kIHRyYW5zYWN0aW9ucyAoM3JkIGxheWVyKSBhbmQgMjAqNT0xMDAgbWVzc2FnZSBpZHMgKDR0aCBsYXllcikuXG4gICAgICogNC4gUmV0cmlldmUgdGhlIGxhc3QgNSBtZXNzYWdlcyBhbmQgNSB0cmFuc2FjdGlvbnMgb24gdGhlIDNyZCBsYXllciArIDE1IG1lc3NhZ2VzIGFuZCB0cmFuc2FjdGlvbnMgKG9mIDEwMCkgZnJvbSB0aGUgNHRoIGxheWVyXG4gICAgICogKyAyNSBtZXNzYWdlIGlkcyBvZiB0aGUgNHRoIGxheWVyICsgNzUgbWVzc2FnZSBpZHMgb2YgdGhlIDV0aCBsYXllci5cbiAgICAgKiA1LiBSZXRyaWV2ZSAyMCBtb3JlIG1lc3NhZ2VzIGFuZCAyMCBtb3JlIHRyYW5zYWN0aW9ucyBvZiB0aGUgNHRoIGxheWVyICsgMTAwIG1vcmUgbWVzc2FnZSBpZHMgb2YgdGhlIDV0aCBsYXllci5cbiAgICAgKiA2LiBOb3cgd2UgaGF2ZSAxKzUrMjArMjArMjAgPSA2NiB0cmFuc2FjdGlvbnMsIHdoaWNoIGlzIG1vcmUgdGhhbiA1MC4gRnVuY3Rpb24gZXhpdHMgd2l0aCB0aGUgdHJlZSBvZlxuICAgICAqIDFtLT4xdC0+NW0tPjV0LT4yNW0tPjI1dC0+MzVtLT4zNXQuIElmIHdlIHNlZSBhbnkgbWVzc2FnZSBpZHMgaW4gdGhlIGxhc3QgdHJhbnNhY3Rpb25zIG91dF9tc2dzLCB3aGljaCBkb24ndCBoYXZlXG4gICAgICogY29ycmVzcG9uZGluZyBtZXNzYWdlcyBpbiB0aGUgZnVuY3Rpb24gcmVzdWx0LCBpdCBtZWFucyB0aGF0IHRoZSBmdWxsIHRyZWUgd2FzIG5vdCByZWNlaXZlZCBhbmQgd2UgbmVlZCB0byBjb250aW51ZSBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBUbyBzdW1tYXJpemUsIGl0IGlzIGd1YXJhbnRlZWQgdGhhdCBlYWNoIG1lc3NhZ2UgaW4gYHJlc3VsdC5tZXNzYWdlc2AgaGFzIHRoZSBjb3JyZXNwb25kaW5nIHRyYW5zYWN0aW9uXG4gICAgICogaW4gdGhlIGByZXN1bHQudHJhbnNhY3Rpb25zYC5cbiAgICAgKiBCdXQgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYWxsIG1lc3NhZ2VzIGZyb20gdHJhbnNhY3Rpb25zIGBvdXRfbXNnc2AgYXJlXG4gICAgICogcHJlc2VudGVkIGluIGByZXN1bHQubWVzc2FnZXNgLlxuICAgICAqIFNvIHRoZSBhcHBsaWNhdGlvbiBoYXMgdG8gY29udGludWUgcmV0cmlldmFsIGZvciBtaXNzaW5nIG1lc3NhZ2VzIGlmIGl0IHJlcXVpcmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlF1ZXJ5VHJhbnNhY3Rpb25UcmVlfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZlF1ZXJ5VHJhbnNhY3Rpb25UcmVlXG4gICAgICovXG4gICAgcXVlcnlfdHJhbnNhY3Rpb25fdHJlZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC5xdWVyeV90cmFuc2FjdGlvbl90cmVlJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBibG9jayBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQmxvY2sgaXRlcmF0b3IgdXNlcyByb2J1c3QgaXRlcmF0aW9uIG1ldGhvZHMgdGhhdCBndWFyYW50aWVzIHRoYXQgZXZlcnlcbiAgICAgKiBibG9jayBpbiB0aGUgc3BlY2lmaWVkIHJhbmdlIGlzbid0IG1pc3NlZCBvciBpdGVyYXRlZCB0d2ljZS5cbiAgICAgKlxuICAgICAqIEl0ZXJhdGVkIHJhbmdlIGNhbiBiZSByZWR1Y2VkIHdpdGggc29tZSBmaWx0ZXJzOlxuICAgICAqIC0gYHN0YXJ0X3RpbWVgIOKAkyB0aGUgYm90dG9tIHRpbWUgcmFuZ2UuIE9ubHkgYmxvY2tzIHdpdGggYGdlbl91dGltZWBcbiAgICAgKiBtb3JlIG9yIGVxdWFsIHRvIHRoaXMgdmFsdWUgaXMgaXRlcmF0ZWQuIElmIHRoaXMgcGFyYW1ldGVyIGlzIG9taXR0ZWQgdGhlbiB0aGVyZSBpc1xuICAgICAqIG5vIGJvdHRvbSB0aW1lIGVkZ2UsIHNvIGFsbCBibG9ja3Mgc2luY2UgemVybyBzdGF0ZSBpcyBpdGVyYXRlZC5cbiAgICAgKiAtIGBlbmRfdGltZWAg4oCTIHRoZSB1cHBlciB0aW1lIHJhbmdlLiBPbmx5IGJsb2NrcyB3aXRoIGBnZW5fdXRpbWVgXG4gICAgICogbGVzcyB0aGVuIHRoaXMgdmFsdWUgaXMgaXRlcmF0ZWQuIElmIHRoaXMgcGFyYW1ldGVyIGlzIG9taXR0ZWQgdGhlbiB0aGVyZSBpc1xuICAgICAqIG5vIHVwcGVyIHRpbWUgZWRnZSwgc28gaXRlcmF0b3IgbmV2ZXIgZmluaXNoZXMuXG4gICAgICogLSBgc2hhcmRfZmlsdGVyYCDigJMgd29ya2NoYWlucyBhbmQgc2hhcmQgcHJlZml4ZXMgdGhhdCByZWR1Y2UgdGhlIHNldCBvZiBpbnRlcmVzdGluZ1xuICAgICAqIGJsb2Nrcy4gQmxvY2sgY29uZm9ybXMgdG8gdGhlIHNoYXJkIGZpbHRlciBpZiBpdCBiZWxvbmdzIHRvIHRoZSBmaWx0ZXIgd29ya2NoYWluXG4gICAgICogYW5kIHRoZSBmaXJzdCBiaXRzIG9mIGJsb2NrJ3MgYHNoYXJkYCBmaWVsZHMgbWF0Y2hlcyB0byB0aGUgc2hhcmQgcHJlZml4LlxuICAgICAqIE9ubHkgYmxvY2tzIHdpdGggc3VpdGFibGUgc2hhcmQgYXJlIGl0ZXJhdGVkLlxuICAgICAqXG4gICAgICogSXRlbXMgaXRlcmF0ZWQgaXMgYSBKU09OIG9iamVjdHMgd2l0aCBibG9jayBkYXRhLiBUaGUgbWluaW1hbCBzZXQgb2YgcmV0dXJuZWRcbiAgICAgKiBmaWVsZHMgaXM6XG4gICAgICogYGBgdGV4dFxuICAgICAqIGlkXG4gICAgICogZ2VuX3V0aW1lXG4gICAgICogd29ya2NoYWluX2lkXG4gICAgICogc2hhcmRcbiAgICAgKiBhZnRlcl9zcGxpdFxuICAgICAqIGFmdGVyX21lcmdlXG4gICAgICogcHJldl9yZWYge1xuICAgICAqICAgICByb290X2hhc2hcbiAgICAgKiB9XG4gICAgICogcHJldl9hbHRfcmVmIHtcbiAgICAgKiAgICAgcm9vdF9oYXNoXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEFwcGxpY2F0aW9uIGNhbiByZXF1ZXN0IGFkZGl0aW9uYWwgZmllbGRzIGluIHRoZSBgcmVzdWx0YCBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBBcHBsaWNhdGlvbiBzaG91bGQgY2FsbCB0aGUgYHJlbW92ZV9pdGVyYXRvcmAgd2hlbiBpdGVyYXRvciBpcyBubyBsb25nZXIgcmVxdWlyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mQ3JlYXRlQmxvY2tJdGVyYXRvcn0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVnaXN0ZXJlZEl0ZXJhdG9yXG4gICAgICovXG4gICAgY3JlYXRlX2Jsb2NrX2l0ZXJhdG9yKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnbmV0LmNyZWF0ZV9ibG9ja19pdGVyYXRvcicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgYmxvY2sgaXRlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBpdGVyYXRvciBzdGF5cyBleGFjdGx5IGF0IHRoZSBzYW1lIHBvc2l0aW9uIHdoZXJlIHRoZSBgcmVzdW1lX3N0YXRlYCB3YXMgY2F0Y2hlZC5cbiAgICAgKlxuICAgICAqIEFwcGxpY2F0aW9uIHNob3VsZCBjYWxsIHRoZSBgcmVtb3ZlX2l0ZXJhdG9yYCB3aGVuIGl0ZXJhdG9yIGlzIG5vIGxvbmdlciByZXF1aXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZSZXN1bWVCbG9ja0l0ZXJhdG9yfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZWdpc3RlcmVkSXRlcmF0b3JcbiAgICAgKi9cbiAgICByZXN1bWVfYmxvY2tfaXRlcmF0b3IocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCduZXQucmVzdW1lX2Jsb2NrX2l0ZXJhdG9yJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0cmFuc2FjdGlvbiBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVHJhbnNhY3Rpb24gaXRlcmF0b3IgdXNlcyByb2J1c3QgaXRlcmF0aW9uIG1ldGhvZHMgdGhhdCBndWFyYW50eSB0aGF0IGV2ZXJ5XG4gICAgICogdHJhbnNhY3Rpb24gaW4gdGhlIHNwZWNpZmllZCByYW5nZSBpc24ndCBtaXNzZWQgb3IgaXRlcmF0ZWQgdHdpY2UuXG4gICAgICpcbiAgICAgKiBJdGVyYXRlZCByYW5nZSBjYW4gYmUgcmVkdWNlZCB3aXRoIHNvbWUgZmlsdGVyczpcbiAgICAgKiAtIGBzdGFydF90aW1lYCDigJMgdGhlIGJvdHRvbSB0aW1lIHJhbmdlLiBPbmx5IHRyYW5zYWN0aW9ucyB3aXRoIGBub3dgXG4gICAgICogbW9yZSBvciBlcXVhbCB0byB0aGlzIHZhbHVlIGFyZSBpdGVyYXRlZC4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZCB0aGVuIHRoZXJlIGlzXG4gICAgICogbm8gYm90dG9tIHRpbWUgZWRnZSwgc28gYWxsIHRoZSB0cmFuc2FjdGlvbnMgc2luY2UgemVybyBzdGF0ZSBhcmUgaXRlcmF0ZWQuXG4gICAgICogLSBgZW5kX3RpbWVgIOKAkyB0aGUgdXBwZXIgdGltZSByYW5nZS4gT25seSB0cmFuc2FjdGlvbnMgd2l0aCBgbm93YFxuICAgICAqIGxlc3MgdGhlbiB0aGlzIHZhbHVlIGFyZSBpdGVyYXRlZC4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZCB0aGVuIHRoZXJlIGlzXG4gICAgICogbm8gdXBwZXIgdGltZSBlZGdlLCBzbyBpdGVyYXRvciBuZXZlciBmaW5pc2hlcy5cbiAgICAgKiAtIGBzaGFyZF9maWx0ZXJgIOKAkyB3b3JrY2hhaW5zIGFuZCBzaGFyZCBwcmVmaXhlcyB0aGF0IHJlZHVjZSB0aGUgc2V0IG9mIGludGVyZXN0aW5nXG4gICAgICogYWNjb3VudHMuIEFjY291bnQgYWRkcmVzcyBjb25mb3JtcyB0byB0aGUgc2hhcmQgZmlsdGVyIGlmXG4gICAgICogaXQgYmVsb25ncyB0byB0aGUgZmlsdGVyIHdvcmtjaGFpbiBhbmQgdGhlIGZpcnN0IGJpdHMgb2YgYWRkcmVzcyBtYXRjaCB0b1xuICAgICAqIHRoZSBzaGFyZCBwcmVmaXguIE9ubHkgdHJhbnNhY3Rpb25zIHdpdGggc3VpdGFibGUgYWNjb3VudCBhZGRyZXNzZXMgYXJlIGl0ZXJhdGVkLlxuICAgICAqIC0gYGFjY291bnRzX2ZpbHRlcmAg4oCTIHNldCBvZiBhY2NvdW50IGFkZHJlc3NlcyB3aG9zZSB0cmFuc2FjdGlvbnMgbXVzdCBiZSBpdGVyYXRlZC5cbiAgICAgKiBOb3RlIHRoYXQgYWNjb3VudHMgZmlsdGVyIGNhbiBjb25mbGljdCB3aXRoIHNoYXJkIGZpbHRlciBzbyBhcHBsaWNhdGlvbiBtdXN0IGNvbWJpbmVcbiAgICAgKiB0aGVzZSBmaWx0ZXJzIGNhcmVmdWxseS5cbiAgICAgKlxuICAgICAqIEl0ZXJhdGVkIGl0ZW0gaXMgYSBKU09OIG9iamVjdHMgd2l0aCB0cmFuc2FjdGlvbiBkYXRhLiBUaGUgbWluaW1hbCBzZXQgb2YgcmV0dXJuZWRcbiAgICAgKiBmaWVsZHMgaXM6XG4gICAgICogYGBgdGV4dFxuICAgICAqIGlkXG4gICAgICogYWNjb3VudF9hZGRyXG4gICAgICogbm93XG4gICAgICogYmFsYW5jZV9kZWx0YShmb3JtYXQ6REVDKVxuICAgICAqIGJvdW5jZSB7IGJvdW5jZV90eXBlIH1cbiAgICAgKiBpbl9tZXNzYWdlIHtcbiAgICAgKiAgICAgaWRcbiAgICAgKiAgICAgdmFsdWUoZm9ybWF0OkRFQylcbiAgICAgKiAgICAgbXNnX3R5cGVcbiAgICAgKiAgICAgc3JjXG4gICAgICogfVxuICAgICAqIG91dF9tZXNzYWdlcyB7XG4gICAgICogICAgIGlkXG4gICAgICogICAgIHZhbHVlKGZvcm1hdDpERUMpXG4gICAgICogICAgIG1zZ190eXBlXG4gICAgICogICAgIGRzdFxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBBcHBsaWNhdGlvbiBjYW4gcmVxdWVzdCBhbiBhZGRpdGlvbmFsIGZpZWxkcyBpbiB0aGUgYHJlc3VsdGAgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQW5vdGhlciBwYXJhbWV0ZXIgdGhhdCBhZmZlY3RzIG9uIHRoZSByZXR1cm5lZCBmaWVsZHMgaXMgdGhlIGBpbmNsdWRlX3RyYW5zZmVyc2AuXG4gICAgICogV2hlbiB0aGlzIHBhcmFtZXRlciBpcyBgdHJ1ZWAgdGhlIGl0ZXJhdG9yIGNvbXB1dGVzIGFuZCBhZGRzIGB0cmFuc2ZlcmAgZmllbGQgY29udGFpbmluZ1xuICAgICAqIGxpc3Qgb2YgdGhlIHVzZWZ1bCBgVHJhbnNhY3Rpb25UcmFuc2ZlcmAgb2JqZWN0cy5cbiAgICAgKiBFYWNoIHRyYW5zZmVyIGlzIGNhbGN1bGF0ZWQgZnJvbSB0aGUgcGFydGljdWxhciBtZXNzYWdlIHJlbGF0ZWQgdG8gdGhlIHRyYW5zYWN0aW9uXG4gICAgICogYW5kIGhhcyB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAgICAgKiAtIG1lc3NhZ2Ug4oCTIHNvdXJjZSBtZXNzYWdlIGlkZW50aWZpZXIuXG4gICAgICogLSBpc0JvdW5jZWQg4oCTIGluZGljYXRlcyB0aGF0IHRoZSB0cmFuc2FjdGlvbiBpcyBib3VuY2VkLCB3aGljaCBtZWFucyB0aGUgdmFsdWUgd2lsbCBiZSByZXR1cm5lZCBiYWNrIHRvIHRoZSBzZW5kZXIuXG4gICAgICogLSBpc0RlcG9zaXQg4oCTIGluZGljYXRlcyB0aGF0IHRoaXMgdHJhbnNmZXIgaXMgdGhlIGRlcG9zaXQgKHRydWUpIG9yIHdpdGhkcmF3IChmYWxzZSkuXG4gICAgICogLSBjb3VudGVycGFydHkg4oCTIGFjY291bnQgYWRkcmVzcyBvZiB0aGUgdHJhbnNmZXIgc291cmNlIG9yIGRlc3RpbmF0aW9uIGRlcGVuZGluZyBvbiBgaXNEZXBvc2l0YC5cbiAgICAgKiAtIHZhbHVlIOKAkyBhbW91bnQgb2YgbmFubyB0b2tlbnMgdHJhbnNmZXJyZWQuIFRoZSB2YWx1ZSBpcyByZXByZXNlbnRlZCBhcyBhIGRlY2ltYWwgc3RyaW5nXG4gICAgICogYmVjYXVzZSB0aGUgYWN0dWFsIHZhbHVlIGNhbiBiZSBtb3JlIHByZWNpc2UgdGhhbiB0aGUgSlNPTiBudW1iZXIgY2FuIHJlcHJlc2VudC4gQXBwbGljYXRpb25cbiAgICAgKiBtdXN0IHVzZSB0aGlzIHN0cmluZyBjYXJlZnVsbHkg4oCTIGNvbnZlcnNpb24gdG8gbnVtYmVyIGNhbiBmb2xsb3cgdG8gbG9vc2Ugb2YgcHJlY2lzaW9uLlxuICAgICAqXG4gICAgICogQXBwbGljYXRpb24gc2hvdWxkIGNhbGwgdGhlIGByZW1vdmVfaXRlcmF0b3JgIHdoZW4gaXRlcmF0b3IgaXMgbm8gbG9uZ2VyIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkNyZWF0ZVRyYW5zYWN0aW9uSXRlcmF0b3J9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlZ2lzdGVyZWRJdGVyYXRvclxuICAgICAqL1xuICAgIGNyZWF0ZV90cmFuc2FjdGlvbl9pdGVyYXRvcihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC5jcmVhdGVfdHJhbnNhY3Rpb25faXRlcmF0b3InLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIHRyYW5zYWN0aW9uIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgaXRlcmF0b3Igc3RheXMgZXhhY3RseSBhdCB0aGUgc2FtZSBwb3NpdGlvbiB3aGVyZSB0aGUgYHJlc3VtZV9zdGF0ZWAgd2FzIGNhdWdodC5cbiAgICAgKiBOb3RlIHRoYXQgYHJlc3VtZV9zdGF0ZWAgZG9lc24ndCBzdG9yZSB0aGUgYWNjb3VudCBmaWx0ZXIuIElmIHRoZSBhcHBsaWNhdGlvbiByZXF1aXJlc1xuICAgICAqIHRvIHVzZSB0aGUgc2FtZSBhY2NvdW50IGZpbHRlciBhcyBpdCB3YXMgd2hlbiB0aGUgaXRlcmF0b3Igd2FzIGNyZWF0ZWQgdGhlbiB0aGUgYXBwbGljYXRpb25cbiAgICAgKiBtdXN0IHBhc3MgdGhlIGFjY291bnQgZmlsdGVyIGFnYWluIGluIGBhY2NvdW50c19maWx0ZXJgIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEFwcGxpY2F0aW9uIHNob3VsZCBjYWxsIHRoZSBgcmVtb3ZlX2l0ZXJhdG9yYCB3aGVuIGl0ZXJhdG9yIGlzIG5vIGxvbmdlciByZXF1aXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZSZXN1bWVUcmFuc2FjdGlvbkl0ZXJhdG9yfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZWdpc3RlcmVkSXRlcmF0b3JcbiAgICAgKi9cbiAgICByZXN1bWVfdHJhbnNhY3Rpb25faXRlcmF0b3IocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCduZXQucmVzdW1lX3RyYW5zYWN0aW9uX2l0ZXJhdG9yJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBuZXh0IGF2YWlsYWJsZSBpdGVtcy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSW4gYWRkaXRpb24gdG8gYXZhaWxhYmxlIGl0ZW1zIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgYGhhc19tb3JlYCBmbGFnXG4gICAgICogaW5kaWNhdGluZyB0aGF0IHRoZSBpdGVyYXRvciBpc24ndCByZWFjaCB0aGUgZW5kIG9mIHRoZSBpdGVyYXRlZCByYW5nZSB5ZXQuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiByZXR1cm4gdGhlIGVtcHR5IGxpc3Qgb2YgYXZhaWxhYmxlIGl0ZW1zIGJ1dFxuICAgICAqIGluZGljYXRlcyB0aGF0IHRoZXJlIGFyZSBtb3JlIGl0ZW1zIGlzIGF2YWlsYWJsZS5cbiAgICAgKiBUaGlzIHNpdHVhdGlvbiBhcHBlYXJzIHdoZW4gdGhlIGl0ZXJhdG9yIGRvZXNuJ3QgcmVhY2ggaXRlcmF0ZWQgcmFuZ2VcbiAgICAgKiBidXQgZGF0YWJhc2UgZG9lc24ndCBjb250YWlucyBhdmFpbGFibGUgaXRlbXMgeWV0LlxuICAgICAqXG4gICAgICogSWYgYXBwbGljYXRpb24gcmVxdWVzdHMgcmVzdW1lIHN0YXRlIGluIGByZXR1cm5fcmVzdW1lX3N0YXRlYCBwYXJhbWV0ZXJcbiAgICAgKiB0aGVuIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgcmVzdW1lX3N0YXRlYCB0aGF0IGNhbiBiZSB1c2VkIGxhdGVyIHRvXG4gICAgICogcmVzdW1lIHRoZSBpdGVyYXRpb24gZnJvbSB0aGUgcG9zaXRpb24gYWZ0ZXIgcmV0dXJuZWQgaXRlbXMuXG4gICAgICpcbiAgICAgKiBUaGUgc3RydWN0dXJlIG9mIHRoZSBpdGVtcyByZXR1cm5lZCBkZXBlbmRzIG9uIHRoZSBpdGVyYXRvciB1c2VkLlxuICAgICAqIFNlZSB0aGUgZGVzY3JpcHRpb24gdG8gdGhlIGFwcHJvcHJpYXRlZCBpdGVyYXRvciBjcmVhdGlvbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZJdGVyYXRvck5leHR9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mSXRlcmF0b3JOZXh0XG4gICAgICovXG4gICAgaXRlcmF0b3JfbmV4dChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC5pdGVyYXRvcl9uZXh0JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpdGVyYXRvclxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBGcmVlcyBhbGwgcmVzb3VyY2VzIGFsbG9jYXRlZCBpbiBsaWJyYXJ5IHRvIHNlcnZlIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQXBwbGljYXRpb24gYWx3YXlzIHNob3VsZCBjYWxsIHRoZSBgcmVtb3ZlX2l0ZXJhdG9yYCB3aGVuIGl0ZXJhdG9yXG4gICAgICogaXMgbm8gbG9uZ2VyIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWdpc3RlcmVkSXRlcmF0b3J9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcmVtb3ZlX2l0ZXJhdG9yKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnbmV0LnJlbW92ZV9pdGVyYXRvcicsIHBhcmFtcyk7XG4gICAgfVxufVxuZXhwb3J0cy5OZXRNb2R1bGUgPSBOZXRNb2R1bGU7XG4vLyBkZWJvdCBtb2R1bGVcbnZhciBEZWJvdEVycm9yQ29kZTtcbihmdW5jdGlvbiAoRGVib3RFcnJvckNvZGUpIHtcbiAgICBEZWJvdEVycm9yQ29kZVtEZWJvdEVycm9yQ29kZVtcIkRlYm90U3RhcnRGYWlsZWRcIl0gPSA4MDFdID0gXCJEZWJvdFN0YXJ0RmFpbGVkXCI7XG4gICAgRGVib3RFcnJvckNvZGVbRGVib3RFcnJvckNvZGVbXCJEZWJvdEZldGNoRmFpbGVkXCJdID0gODAyXSA9IFwiRGVib3RGZXRjaEZhaWxlZFwiO1xuICAgIERlYm90RXJyb3JDb2RlW0RlYm90RXJyb3JDb2RlW1wiRGVib3RFeGVjdXRpb25GYWlsZWRcIl0gPSA4MDNdID0gXCJEZWJvdEV4ZWN1dGlvbkZhaWxlZFwiO1xuICAgIERlYm90RXJyb3JDb2RlW0RlYm90RXJyb3JDb2RlW1wiRGVib3RJbnZhbGlkSGFuZGxlXCJdID0gODA0XSA9IFwiRGVib3RJbnZhbGlkSGFuZGxlXCI7XG4gICAgRGVib3RFcnJvckNvZGVbRGVib3RFcnJvckNvZGVbXCJEZWJvdEludmFsaWRKc29uUGFyYW1zXCJdID0gODA1XSA9IFwiRGVib3RJbnZhbGlkSnNvblBhcmFtc1wiO1xuICAgIERlYm90RXJyb3JDb2RlW0RlYm90RXJyb3JDb2RlW1wiRGVib3RJbnZhbGlkRnVuY3Rpb25JZFwiXSA9IDgwNl0gPSBcIkRlYm90SW52YWxpZEZ1bmN0aW9uSWRcIjtcbiAgICBEZWJvdEVycm9yQ29kZVtEZWJvdEVycm9yQ29kZVtcIkRlYm90SW52YWxpZEFiaVwiXSA9IDgwN10gPSBcIkRlYm90SW52YWxpZEFiaVwiO1xuICAgIERlYm90RXJyb3JDb2RlW0RlYm90RXJyb3JDb2RlW1wiRGVib3RHZXRNZXRob2RGYWlsZWRcIl0gPSA4MDhdID0gXCJEZWJvdEdldE1ldGhvZEZhaWxlZFwiO1xuICAgIERlYm90RXJyb3JDb2RlW0RlYm90RXJyb3JDb2RlW1wiRGVib3RJbnZhbGlkTXNnXCJdID0gODA5XSA9IFwiRGVib3RJbnZhbGlkTXNnXCI7XG4gICAgRGVib3RFcnJvckNvZGVbRGVib3RFcnJvckNvZGVbXCJEZWJvdEV4dGVybmFsQ2FsbEZhaWxlZFwiXSA9IDgxMF0gPSBcIkRlYm90RXh0ZXJuYWxDYWxsRmFpbGVkXCI7XG4gICAgRGVib3RFcnJvckNvZGVbRGVib3RFcnJvckNvZGVbXCJEZWJvdEJyb3dzZXJDYWxsYmFja0ZhaWxlZFwiXSA9IDgxMV0gPSBcIkRlYm90QnJvd3NlckNhbGxiYWNrRmFpbGVkXCI7XG4gICAgRGVib3RFcnJvckNvZGVbRGVib3RFcnJvckNvZGVbXCJEZWJvdE9wZXJhdGlvblJlamVjdGVkXCJdID0gODEyXSA9IFwiRGVib3RPcGVyYXRpb25SZWplY3RlZFwiO1xuICAgIERlYm90RXJyb3JDb2RlW0RlYm90RXJyb3JDb2RlW1wiRGVib3ROb0NvZGVcIl0gPSA4MTNdID0gXCJEZWJvdE5vQ29kZVwiO1xufSkoRGVib3RFcnJvckNvZGUgPSBleHBvcnRzLkRlYm90RXJyb3JDb2RlIHx8IChleHBvcnRzLkRlYm90RXJyb3JDb2RlID0ge30pKTtcbmZ1bmN0aW9uIGRlYm90QWN0aXZpdHlUcmFuc2FjdGlvbihtc2csIGRzdCwgb3V0LCBmZWUsIHNldGNvZGUsIHNpZ25rZXksIHNpZ25pbmdfYm94X2hhbmRsZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdUcmFuc2FjdGlvbicsXG4gICAgICAgIG1zZyxcbiAgICAgICAgZHN0LFxuICAgICAgICBvdXQsXG4gICAgICAgIGZlZSxcbiAgICAgICAgc2V0Y29kZSxcbiAgICAgICAgc2lnbmtleSxcbiAgICAgICAgc2lnbmluZ19ib3hfaGFuZGxlLFxuICAgIH07XG59XG5leHBvcnRzLmRlYm90QWN0aXZpdHlUcmFuc2FjdGlvbiA9IGRlYm90QWN0aXZpdHlUcmFuc2FjdGlvbjtcbmZ1bmN0aW9uIHBhcmFtc09mQXBwRGVib3RCcm93c2VyTG9nKG1zZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdMb2cnLFxuICAgICAgICBtc2csXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJMb2cgPSBwYXJhbXNPZkFwcERlYm90QnJvd3NlckxvZztcbmZ1bmN0aW9uIHBhcmFtc09mQXBwRGVib3RCcm93c2VyU3dpdGNoKGNvbnRleHRfaWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnU3dpdGNoJyxcbiAgICAgICAgY29udGV4dF9pZCxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJhbXNPZkFwcERlYm90QnJvd3NlclN3aXRjaCA9IHBhcmFtc09mQXBwRGVib3RCcm93c2VyU3dpdGNoO1xuZnVuY3Rpb24gcGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJTd2l0Y2hDb21wbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1N3aXRjaENvbXBsZXRlZCcsXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJTd2l0Y2hDb21wbGV0ZWQgPSBwYXJhbXNPZkFwcERlYm90QnJvd3NlclN3aXRjaENvbXBsZXRlZDtcbmZ1bmN0aW9uIHBhcmFtc09mQXBwRGVib3RCcm93c2VyU2hvd0FjdGlvbihhY3Rpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnU2hvd0FjdGlvbicsXG4gICAgICAgIGFjdGlvbixcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJhbXNPZkFwcERlYm90QnJvd3NlclNob3dBY3Rpb24gPSBwYXJhbXNPZkFwcERlYm90QnJvd3NlclNob3dBY3Rpb247XG5mdW5jdGlvbiBwYXJhbXNPZkFwcERlYm90QnJvd3NlcklucHV0KHByb21wdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdJbnB1dCcsXG4gICAgICAgIHByb21wdCxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJhbXNPZkFwcERlYm90QnJvd3NlcklucHV0ID0gcGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJJbnB1dDtcbmZ1bmN0aW9uIHBhcmFtc09mQXBwRGVib3RCcm93c2VyR2V0U2lnbmluZ0JveCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnR2V0U2lnbmluZ0JveCcsXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJHZXRTaWduaW5nQm94ID0gcGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJHZXRTaWduaW5nQm94O1xuZnVuY3Rpb24gcGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJJbnZva2VEZWJvdChkZWJvdF9hZGRyLCBhY3Rpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnSW52b2tlRGVib3QnLFxuICAgICAgICBkZWJvdF9hZGRyLFxuICAgICAgICBhY3Rpb24sXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJJbnZva2VEZWJvdCA9IHBhcmFtc09mQXBwRGVib3RCcm93c2VySW52b2tlRGVib3Q7XG5mdW5jdGlvbiBwYXJhbXNPZkFwcERlYm90QnJvd3NlclNlbmQobWVzc2FnZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdTZW5kJyxcbiAgICAgICAgbWVzc2FnZSxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJhbXNPZkFwcERlYm90QnJvd3NlclNlbmQgPSBwYXJhbXNPZkFwcERlYm90QnJvd3NlclNlbmQ7XG5mdW5jdGlvbiBwYXJhbXNPZkFwcERlYm90QnJvd3NlckFwcHJvdmUoYWN0aXZpdHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnQXBwcm92ZScsXG4gICAgICAgIGFjdGl2aXR5LFxuICAgIH07XG59XG5leHBvcnRzLnBhcmFtc09mQXBwRGVib3RCcm93c2VyQXBwcm92ZSA9IHBhcmFtc09mQXBwRGVib3RCcm93c2VyQXBwcm92ZTtcbmZ1bmN0aW9uIHJlc3VsdE9mQXBwRGVib3RCcm93c2VySW5wdXQodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnSW5wdXQnLFxuICAgICAgICB2YWx1ZSxcbiAgICB9O1xufVxuZXhwb3J0cy5yZXN1bHRPZkFwcERlYm90QnJvd3NlcklucHV0ID0gcmVzdWx0T2ZBcHBEZWJvdEJyb3dzZXJJbnB1dDtcbmZ1bmN0aW9uIHJlc3VsdE9mQXBwRGVib3RCcm93c2VyR2V0U2lnbmluZ0JveChzaWduaW5nX2JveCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdHZXRTaWduaW5nQm94JyxcbiAgICAgICAgc2lnbmluZ19ib3gsXG4gICAgfTtcbn1cbmV4cG9ydHMucmVzdWx0T2ZBcHBEZWJvdEJyb3dzZXJHZXRTaWduaW5nQm94ID0gcmVzdWx0T2ZBcHBEZWJvdEJyb3dzZXJHZXRTaWduaW5nQm94O1xuZnVuY3Rpb24gcmVzdWx0T2ZBcHBEZWJvdEJyb3dzZXJJbnZva2VEZWJvdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnSW52b2tlRGVib3QnLFxuICAgIH07XG59XG5leHBvcnRzLnJlc3VsdE9mQXBwRGVib3RCcm93c2VySW52b2tlRGVib3QgPSByZXN1bHRPZkFwcERlYm90QnJvd3Nlckludm9rZURlYm90O1xuZnVuY3Rpb24gcmVzdWx0T2ZBcHBEZWJvdEJyb3dzZXJBcHByb3ZlKGFwcHJvdmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0FwcHJvdmUnLFxuICAgICAgICBhcHByb3ZlZCxcbiAgICB9O1xufVxuZXhwb3J0cy5yZXN1bHRPZkFwcERlYm90QnJvd3NlckFwcHJvdmUgPSByZXN1bHRPZkFwcERlYm90QnJvd3NlckFwcHJvdmU7XG5mdW5jdGlvbiBkaXNwYXRjaEFwcERlYm90QnJvd3NlcihvYmosIHBhcmFtcywgYXBwX3JlcXVlc3RfaWQsIGNsaWVudCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcmFtcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnTG9nJzpcbiAgICAgICAgICAgICAgICAgICAgb2JqLmxvZyhwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdTd2l0Y2gnOlxuICAgICAgICAgICAgICAgICAgICBvYmouc3dpdGNoKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1N3aXRjaENvbXBsZXRlZCc6XG4gICAgICAgICAgICAgICAgICAgIG9iai5zd2l0Y2hfY29tcGxldGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1Nob3dBY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICBvYmouc2hvd19hY3Rpb24ocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnSW5wdXQnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCBvYmouaW5wdXQocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnR2V0U2lnbmluZ0JveCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIG9iai5nZXRfc2lnbmluZ19ib3goKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnSW52b2tlRGVib3QnOlxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBvYmouaW52b2tlX2RlYm90KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NlbmQnOlxuICAgICAgICAgICAgICAgICAgICBvYmouc2VuZChwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdBcHByb3ZlJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgb2JqLmFwcHJvdmUocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGllbnQucmVzb2x2ZV9hcHBfcmVxdWVzdChhcHBfcmVxdWVzdF9pZCwgT2JqZWN0LmFzc2lnbih7IHR5cGU6IHBhcmFtcy50eXBlIH0sIHJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2xpZW50LnJlamVjdF9hcHBfcmVxdWVzdChhcHBfcmVxdWVzdF9pZCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIFtVTlNUQUJMRV0oVU5TVEFCTEUubWQpIE1vZHVsZSBmb3Igd29ya2luZyB3aXRoIGRlYm90LlxuICovXG5jbGFzcyBEZWJvdE1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBbVU5TVEFCTEVdKFVOU1RBQkxFLm1kKSBDcmVhdGVzIGFuZCBpbnN0YW5jZSBvZiBEZUJvdC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRG93bmxvYWRzIGRlYm90IHNtYXJ0IGNvbnRyYWN0IChjb2RlIGFuZCBkYXRhKSBmcm9tIGJsb2NrY2hhaW4gYW5kIGNyZWF0ZXNcbiAgICAgKiBhbiBpbnN0YW5jZSBvZiBEZWJvdCBFbmdpbmUgZm9yIGl0LlxuICAgICAqXG4gICAgICogIyBSZW1hcmtzXG4gICAgICogSXQgZG9lcyBub3Qgc3dpdGNoIGRlYm90IHRvIGNvbnRleHQgMC4gQnJvd3NlciBDYWxsYmFja3MgYXJlIG5vdCBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mSW5pdH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVnaXN0ZXJlZERlYm90XG4gICAgICovXG4gICAgaW5pdChwYXJhbXMsIG9iaikge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnZGVib3QuaW5pdCcsIHBhcmFtcywgKHBhcmFtcywgcmVzcG9uc2VUeXBlKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hBcHBEZWJvdEJyb3dzZXIob2JqLCBwYXJhbXMucmVxdWVzdF9kYXRhLCBwYXJhbXMuYXBwX3JlcXVlc3RfaWQsIHRoaXMuY2xpZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlVHlwZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoQXBwRGVib3RCcm93c2VyKG9iaiwgcGFyYW1zLCBudWxsLCB0aGlzLmNsaWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBbVU5TVEFCTEVdKFVOU1RBQkxFLm1kKSBTdGFydHMgdGhlIERlQm90LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBEb3dubG9hZHMgZGVib3Qgc21hcnQgY29udHJhY3QgZnJvbSBibG9ja2NoYWluIGFuZCBzd2l0Y2hlcyBpdCB0b1xuICAgICAqIGNvbnRleHQgemVyby5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkIGJ5IERlYm90IEJyb3dzZXIgdG8gc3RhcnQgYSBkaWFsb2cgd2l0aCBkZWJvdC5cbiAgICAgKiBXaGlsZSB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0aW5nLCBzZXZlcmFsIEJyb3dzZXIgQ2FsbGJhY2tzIGNhbiBiZSBjYWxsZWQsXG4gICAgICogc2luY2UgdGhlIGRlYm90IHRyaWVzIHRvIGRpc3BsYXkgYWxsIGFjdGlvbnMgZnJvbSB0aGUgY29udGV4dCAwIHRvIHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogV2hlbiB0aGUgZGVib3Qgc3RhcnRzIFNESyByZWdpc3RlcnMgYEJyb3dzZXJDYWxsYmFja3NgIEFwcE9iamVjdC5cbiAgICAgKiBUaGVyZWZvcmUgd2hlbiBgZGVib3RlLnJlbW92ZWAgaXMgY2FsbGVkIHRoZSBkZWJvdCBpcyBiZWluZyBkZWxldGVkIGFuZCB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkXG4gICAgICogd2l0aCBgZmluaXNoYD1gdHJ1ZWAgd2hpY2ggaW5kaWNhdGVzIHRoYXQgaXQgd2lsbCBuZXZlciBiZSB1c2VkIGFnYWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlN0YXJ0fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHN0YXJ0KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnZGVib3Quc3RhcnQnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBbVU5TVEFCTEVdKFVOU1RBQkxFLm1kKSBGZXRjaGVzIERlQm90IG1ldGFkYXRhIGZyb20gYmxvY2tjaGFpbi5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRG93bmxvYWRzIERlQm90IGZyb20gYmxvY2tjaGFpbiBhbmQgY3JlYXRlcyBhbmQgZmV0Y2hlcyBpdHMgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mRmV0Y2h9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mRmV0Y2hcbiAgICAgKi9cbiAgICBmZXRjaChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2RlYm90LmZldGNoJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogW1VOU1RBQkxFXShVTlNUQUJMRS5tZCkgRXhlY3V0ZXMgZGVib3QgYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBDYWxscyBkZWJvdCBlbmdpbmUgcmVmZXJlbmNlZCBieSBkZWJvdCBoYW5kbGUgdG8gZXhlY3V0ZSBpbnB1dCBhY3Rpb24uXG4gICAgICogQ2FsbHMgRGVib3QgQnJvd3NlciBDYWxsYmFja3MgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogIyBSZW1hcmtzXG4gICAgICogQ2hhaW4gb2YgYWN0aW9ucyBjYW4gYmUgZXhlY3V0ZWQgaWYgaW5wdXQgYWN0aW9uIGdlbmVyYXRlcyBhIGxpc3Qgb2Ygc3ViYWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZFeGVjdXRlfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGV4ZWN1dGUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdkZWJvdC5leGVjdXRlJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogW1VOU1RBQkxFXShVTlNUQUJMRS5tZCkgU2VuZHMgbWVzc2FnZSB0byBEZWJvdC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVXNlZCBieSBEZWJvdCBCcm93c2VyIHRvIHNlbmQgcmVzcG9uc2Ugb24gRGludGVyZmFjZSBjYWxsIG9yIGZyb20gb3RoZXIgRGVib3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlNlbmR9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc2VuZChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2RlYm90LnNlbmQnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBbVU5TVEFCTEVdKFVOU1RBQkxFLm1kKSBEZXN0cm95cyBkZWJvdCBoYW5kbGUuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFJlbW92ZXMgaGFuZGxlIGZyb20gQ2xpZW50IENvbnRleHQgYW5kIGRyb3BzIGRlYm90IGVuZ2luZSByZWZlcmVuY2VkIGJ5IHRoYXQgaGFuZGxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlJlbW92ZX0gcGFyYW1zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICByZW1vdmUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdkZWJvdC5yZW1vdmUnLCBwYXJhbXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuRGVib3RNb2R1bGUgPSBEZWJvdE1vZHVsZTtcbi8vIHByb29mcyBtb2R1bGVcbnZhciBQcm9vZnNFcnJvckNvZGU7XG4oZnVuY3Rpb24gKFByb29mc0Vycm9yQ29kZSkge1xuICAgIFByb29mc0Vycm9yQ29kZVtQcm9vZnNFcnJvckNvZGVbXCJJbnZhbGlkRGF0YVwiXSA9IDkwMV0gPSBcIkludmFsaWREYXRhXCI7XG4gICAgUHJvb2ZzRXJyb3JDb2RlW1Byb29mc0Vycm9yQ29kZVtcIlByb29mQ2hlY2tGYWlsZWRcIl0gPSA5MDJdID0gXCJQcm9vZkNoZWNrRmFpbGVkXCI7XG4gICAgUHJvb2ZzRXJyb3JDb2RlW1Byb29mc0Vycm9yQ29kZVtcIkludGVybmFsRXJyb3JcIl0gPSA5MDNdID0gXCJJbnRlcm5hbEVycm9yXCI7XG4gICAgUHJvb2ZzRXJyb3JDb2RlW1Byb29mc0Vycm9yQ29kZVtcIkRhdGFEaWZmZXJzRnJvbVByb3ZlblwiXSA9IDkwNF0gPSBcIkRhdGFEaWZmZXJzRnJvbVByb3ZlblwiO1xufSkoUHJvb2ZzRXJyb3JDb2RlID0gZXhwb3J0cy5Qcm9vZnNFcnJvckNvZGUgfHwgKGV4cG9ydHMuUHJvb2ZzRXJyb3JDb2RlID0ge30pKTtcbi8qKlxuICogW1VOU1RBQkxFXShVTlNUQUJMRS5tZCkgTW9kdWxlIGZvciBwcm92aW5nIGRhdGEsIHJldHJpZXZlZCBmcm9tIFRPTk9TIEFQSS5cbiAqL1xuY2xhc3MgUHJvb2ZzTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZlcyB0aGF0IGEgZ2l2ZW4gYmxvY2sncyBkYXRhLCB3aGljaCBpcyBxdWVyaWVkIGZyb20gVE9OT1MgQVBJLCBjYW4gYmUgdHJ1c3RlZC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhpcyBmdW5jdGlvbiBjaGVja3MgYmxvY2sgcHJvb2ZzIGFuZCBjb21wYXJlcyBnaXZlbiBkYXRhIHdpdGggdGhlIHByb3Zlbi5cbiAgICAgKiBJZiB0aGUgZ2l2ZW4gZGF0YSBkaWZmZXJzIGZyb20gdGhlIHByb3ZlbiwgdGhlIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAgICAgKiBUaGUgaW5wdXQgcGFyYW0gaXMgYSBzaW5nbGUgYmxvY2sncyBKU09OIG9iamVjdCwgd2hpY2ggd2FzIHF1ZXJpZWQgZnJvbSBEQXBwIHNlcnZlciB1c2luZ1xuICAgICAqIGZ1bmN0aW9ucyBzdWNoIGFzIGBuZXQucXVlcnlgLCBgbmV0LnF1ZXJ5X2NvbGxlY3Rpb25gIG9yIGBuZXQud2FpdF9mb3JfY29sbGVjdGlvbmAuXG4gICAgICogSWYgYmxvY2sncyBCT0MgaXMgbm90IHByb3ZpZGVkIGluIHRoZSBKU09OLCBpdCB3aWxsIGJlIHF1ZXJpZWQgZnJvbSBEQXBwIHNlcnZlclxuICAgICAqIChpbiB0aGlzIGNhc2UgaXQgaXMgcmVxdWlyZWQgdG8gcHJvdmlkZSBhdCBsZWFzdCBgaWRgIG9mIGJsb2NrKS5cbiAgICAgKlxuICAgICAqIFBsZWFzZSBub3RlLCB0aGF0IGpvaW5zIChsaWtlIGBzaWduYXR1cmVzYCBpbiBgQmxvY2tgKSBhcmUgc2VwYXJhdGVkIGVudGl0aWVzIGFuZCBub3Qgc3VwcG9ydGVkLFxuICAgICAqIHNvIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGluIGEgY2FzZSBpZiBKU09OIGJlaW5nIGNoZWNrZWQgaGFzIHN1Y2ggZW50aXRpZXMgaW4gaXQuXG4gICAgICpcbiAgICAgKiBJZiBgY2FjaGVfaW5fbG9jYWxfc3RvcmFnZWAgaW4gY29uZmlnIGlzIHNldCB0byBgdHJ1ZWAgKGRlZmF1bHQpLCBkb3dubG9hZGVkIHByb29mcyBhbmRcbiAgICAgKiBtYXN0ZXItY2hhaW4gQk9DcyBhcmUgc2F2ZWQgaW50byB0aGUgcGVyc2lzdGVudCBsb2NhbCBzdG9yYWdlIChlLmcuIGZpbGUgc3lzdGVtIGZvciBuYXRpdmVcbiAgICAgKiBlbnZpcm9ubWVudHMgb3IgYnJvd3NlcidzIEluZGV4ZWREQiBmb3IgdGhlIHdlYik7IG90aGVyd2lzZSBhbGwgdGhlIGRhdGEgaXMgY2FjaGVkIG9ubHkgaW5cbiAgICAgKiBtZW1vcnkgaW4gY3VycmVudCBjbGllbnQncyBjb250ZXh0IGFuZCB3aWxsIGJlIGxvc3QgYWZ0ZXIgZGVzdHJ1Y3Rpb24gb2YgdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqICoqV2h5IFByb29mcyBhcmUgbmVlZGVkKipcbiAgICAgKlxuICAgICAqIFByb29mcyBhcmUgbmVlZGVkIHRvIGVuc3VyZSB0aGF0IHRoZSBkYXRhIGRvd25sb2FkZWQgZnJvbSBhIERBcHAgc2VydmVyIGlzIHJlYWwgYmxvY2tjaGFpblxuICAgICAqIGRhdGEuIENoZWNraW5nIHByb29mcyBjYW4gcHJvdGVjdCBmcm9tIHRoZSBtYWxpY2lvdXMgREFwcCBzZXJ2ZXIgd2hpY2ggY2FuIHBvdGVudGlhbGx5IHByb3ZpZGVcbiAgICAgKiBmYWtlIGRhdGEsIG9yIGFsc28gZnJvbSBcIk1hbiBpbiB0aGUgTWlkZGxlXCIgYXR0YWNrcyBjbGFzcy5cbiAgICAgKlxuICAgICAqICoqV2hhdCBQcm9vZnMgYXJlKipcbiAgICAgKlxuICAgICAqIFNpbXBseSwgcHJvb2YgaXMgYSBsaXN0IG9mIHNpZ25hdHVyZXMgb2YgdmFsaWRhdG9ycycsIHdoaWNoIGhhdmUgc2lnbmVkIHRoaXMgcGFydGljdWxhciBtYXN0ZXItXG4gICAgICogYmxvY2suXG4gICAgICpcbiAgICAgKiBUaGUgdmVyeSBmaXJzdCB2YWxpZGF0b3Igc2V0J3MgcHVibGljIGtleXMgYXJlIGluY2x1ZGVkIGluIHRoZSB6ZXJvLXN0YXRlLiBXaGUga25vdyBhIHJvb3QgaGFzaFxuICAgICAqIG9mIHRoZSB6ZXJvLXN0YXRlLCBiZWNhdXNlIGl0IGlzIHN0b3JlZCBpbiB0aGUgbmV0d29yayBjb25maWd1cmF0aW9uIGZpbGUsIGl0IGlzIG91ciBhdXRob3JpdHlcbiAgICAgKiByb290LiBGb3IgcHJvdmluZyB6ZXJvLXN0YXRlIGl0IGlzIGVub3VnaCB0byBjYWxjdWxhdGUgYW5kIGNvbXBhcmUgaXRzIHJvb3QgaGFzaC5cbiAgICAgKlxuICAgICAqIEluIGVhY2ggbmV3IHZhbGlkYXRvciBjeWNsZSB0aGUgdmFsaWRhdG9yIHNldCBpcyBjaGFuZ2VkLiBUaGUgbmV3IG9uZSBpcyBzdG9yZWQgaW4gYSBrZXktYmxvY2ssXG4gICAgICogd2hpY2ggaXMgc2lnbmVkIGJ5IHRoZSB2YWxpZGF0b3Igc2V0LCB3aGljaCB3ZSBhbHJlYWR5IHRydXN0LCB0aGUgbmV4dCB2YWxpZGF0b3Igc2V0IHdpbGwgYmVcbiAgICAgKiBzdG9yZWQgdG8gdGhlIG5ldyBrZXktYmxvY2sgYW5kIHNpZ25lZCBieSB0aGUgY3VycmVudCB2YWxpZGF0b3Igc2V0LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBJbiBvcmRlciB0byBwcm92ZSBhbnkgYmxvY2sgaW4gdGhlIG1hc3Rlci1jaGFpbiB3ZSBuZWVkIHRvIGNoZWNrLCB0aGF0IGl0IGhhcyBiZWVuIHNpZ25lZCBieVxuICAgICAqIGEgdHJ1c3RlZCB2YWxpZGF0b3Igc2V0LiBTbyB3ZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXktYmxvY2tzJyBwcm9vZnMsIHN0YXJ0ZWQgZnJvbSB0aGUgemVyby1zdGF0ZVxuICAgICAqIGFuZCB1bnRpbCB0aGUgYmxvY2ssIHdoaWNoIHdlIHdhbnQgdG8gcHJvdmUuIEJ1dCBpdCBjYW4gdGFrZSBhIGxvdCBvZiB0aW1lIGFuZCB0cmFmZmljIHRvXG4gICAgICogZG93bmxvYWQgYW5kIHByb3ZlIGFsbCBrZXktYmxvY2tzIG9uIGEgY2xpZW50LiBGb3Igc29sdmluZyB0aGlzLCBzcGVjaWFsIHRydXN0ZWQgYmxvY2tzIGFyZSB1c2VkXG4gICAgICogaW4gRXZlci1TREsuXG4gICAgICpcbiAgICAgKiBUaGUgdHJ1c3RlZCBibG9jayBpcyB0aGUgYXV0aG9yaXR5IHJvb3QsIGFzIHdlbGwsIGFzIHRoZSB6ZXJvLXN0YXRlLiBFYWNoIHRydXN0ZWQgYmxvY2sgaXMgdGhlXG4gICAgICogYGlkYCAoZS5nLiBgcm9vdF9oYXNoYCkgb2YgdGhlIGFscmVhZHkgcHJvdmVuIGtleS1ibG9jay4gVGhlcmUgY2FuIGJlIHBsZW50eSBvZiB0cnVzdGVkXG4gICAgICogYmxvY2tzLCBzbyB0aGVyZSBjYW4gYmUgYSBsb3Qgb2YgYXV0aG9yaXR5IHJvb3RzLiBUaGUgaGFzaGVzIG9mIHRydXN0ZWQgYmxvY2tzIGZvciBNYWluTmV0XG4gICAgICogYW5kIERldk5ldCBhcmUgaGFyZGNvZGVkIGluIFNESyBpbiBhIHNlcGFyYXRlZCBiaW5hcnkgZmlsZSAodHJ1c3RlZF9rZXlfYmxvY2tzLmJpbikgYW5kIGlzXG4gICAgICogYmVpbmcgdXBkYXRlZCBmb3IgZWFjaCByZWxlYXNlIGJ5IHVzaW5nIGB1cGRhdGVfdHJ1c3RlZF9ibG9ja3NgIHV0aWxpdHkuXG4gICAgICpcbiAgICAgKiBTZWUgW3VwZGF0ZV90cnVzdGVkX2Jsb2Nrc10oLi4vLi4vLi4vdG9vbHMvdXBkYXRlX3RydXN0ZWRfYmxvY2tzKSBkaXJlY3RvcnkgZm9yIG1vcmUgaW5mby5cbiAgICAgKlxuICAgICAqIEluIGZ1dHVyZSBTREsgcmVsZWFzZXMsIG9uZSB3aWxsIGFsc28gYmUgYWJsZSB0byBwcm92aWRlIHRoZWlyIGhhc2hlcyBvZiB0cnVzdGVkIGJsb2NrcyBmb3JcbiAgICAgKiBvdGhlciBuZXR3b3JrcywgYmVzaWRlcyBmb3IgTWFpbk5ldCBhbmQgRGV2TmV0LlxuICAgICAqIEJ5IHVzaW5nIHRydXN0ZWQga2V5LWJsb2NrcywgaW4gb3JkZXIgdG8gcHJvdmUgYW55IGJsb2NrLCB3ZSBjYW4gcHJvdmUgY2hhaW4gb2Yga2V5LWJsb2NrcyB0b1xuICAgICAqIHRoZSBjbG9zZXN0IHByZXZpb3VzIHRydXN0ZWQga2V5LWJsb2NrLCBub3Qgb25seSB0byB0aGUgemVyby1zdGF0ZS5cbiAgICAgKlxuICAgICAqIEJ1dCBzaGFyZC1ibG9ja3MgZG9uJ3QgaGF2ZSBwcm9vZnMgb24gREFwcCBzZXJ2ZXIuIEluIHRoaXMgY2FzZSwgaW4gb3JkZXIgdG8gcHJvdmUgYW55IHNoYXJkLVxuICAgICAqIGJsb2NrIGRhdGEsIHdlIHNlYXJjaCBmb3IgYSBjb3JyZXNwb25kaW5nIG1hc3Rlci1ibG9jaywgd2hpY2ggY29udGFpbnMgdGhlIHJvb3QgaGFzaCBvZiB0aGlzXG4gICAgICogc2hhcmQtYmxvY2ssIG9yIHNvbWUgc2hhcmQgYmxvY2sgd2hpY2ggaXMgbGlua2VkIHRvIHRoYXQgYmxvY2sgaW4gc2hhcmQtY2hhaW4uIEFmdGVyIHByb3ZpbmdcbiAgICAgKiB0aGlzIG1hc3Rlci1ibG9jaywgd2UgdHJhdmVyc2UgdGhyb3VnaCBlYWNoIGxpbmsgYW5kIGNhbGN1bGF0ZSBhbmQgY29tcGFyZSBoYXNoZXMgd2l0aCBsaW5rcyxcbiAgICAgKiBvbmUtYnktb25lLiBBZnRlciB0aGF0IHdlIGNhbiBlbnN1cmUgdGhhdCB0aGlzIHNoYXJkLWJsb2NrIGhhcyBhbHNvIGJlZW4gcHJvdmVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlByb29mQmxvY2tEYXRhfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHByb29mX2Jsb2NrX2RhdGEocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdwcm9vZnMucHJvb2ZfYmxvY2tfZGF0YScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZlcyB0aGF0IGEgZ2l2ZW4gdHJhbnNhY3Rpb24ncyBkYXRhLCB3aGljaCBpcyBxdWVyaWVkIGZyb20gVE9OT1MgQVBJLCBjYW4gYmUgdHJ1c3RlZC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhpcyBmdW5jdGlvbiByZXF1ZXN0cyB0aGUgY29ycmVzcG9uZGluZyBibG9jaywgY2hlY2tzIGJsb2NrIHByb29mcywgZW5zdXJlcyB0aGF0IGdpdmVuXG4gICAgICogdHJhbnNhY3Rpb24gZXhpc3RzIGluIHRoZSBwcm92ZW4gYmxvY2sgYW5kIGNvbXBhcmVzIGdpdmVuIGRhdGEgd2l0aCB0aGUgcHJvdmVuLlxuICAgICAqIElmIHRoZSBnaXZlbiBkYXRhIGRpZmZlcnMgZnJvbSB0aGUgcHJvdmVuLCB0aGUgZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICAgICAqIFRoZSBpbnB1dCBwYXJhbWV0ZXIgaXMgYSBzaW5nbGUgdHJhbnNhY3Rpb24ncyBKU09OIG9iamVjdCAoc2VlIHBhcmFtcyBkZXNjcmlwdGlvbiksXG4gICAgICogd2hpY2ggd2FzIHF1ZXJpZWQgZnJvbSBUT05PUyBBUEkgdXNpbmcgZnVuY3Rpb25zIHN1Y2ggYXMgYG5ldC5xdWVyeWAsIGBuZXQucXVlcnlfY29sbGVjdGlvbmBcbiAgICAgKiBvciBgbmV0LndhaXRfZm9yX2NvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogSWYgdHJhbnNhY3Rpb24ncyBCT0MgYW5kL29yIGBibG9ja19pZGAgYXJlIG5vdCBwcm92aWRlZCBpbiB0aGUgSlNPTiwgdGhleSB3aWxsIGJlIHF1ZXJpZWQgZnJvbVxuICAgICAqIFRPTk9TIEFQSS5cbiAgICAgKlxuICAgICAqIFBsZWFzZSBub3RlLCB0aGF0IGpvaW5zIChsaWtlIGBhY2NvdW50YCwgYGluX21lc3NhZ2VgLCBgb3V0X21lc3NhZ2VzYCwgZXRjLiBpbiBgVHJhbnNhY3Rpb25gXG4gICAgICogZW50aXR5KSBhcmUgc2VwYXJhdGVkIGVudGl0aWVzIGFuZCBub3Qgc3VwcG9ydGVkLCBzbyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpbiBhIGNhc2VcbiAgICAgKiBpZiBKU09OIGJlaW5nIGNoZWNrZWQgaGFzIHN1Y2ggZW50aXRpZXMgaW4gaXQuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBwcm9vZnMgY2hlY2tpbmcsIHNlZSBkZXNjcmlwdGlvbiBvZiBgcHJvb2ZfYmxvY2tfZGF0YWAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mUHJvb2ZUcmFuc2FjdGlvbkRhdGF9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcHJvb2ZfdHJhbnNhY3Rpb25fZGF0YShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ3Byb29mcy5wcm9vZl90cmFuc2FjdGlvbl9kYXRhJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmVzIHRoYXQgYSBnaXZlbiBtZXNzYWdlJ3MgZGF0YSwgd2hpY2ggaXMgcXVlcmllZCBmcm9tIFRPTk9TIEFQSSwgY2FuIGJlIHRydXN0ZWQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoaXMgZnVuY3Rpb24gZmlyc3QgcHJvdmVzIHRoZSBjb3JyZXNwb25kaW5nIHRyYW5zYWN0aW9uLCBlbnN1cmVzIHRoYXQgdGhlIHByb3ZlbiB0cmFuc2FjdGlvblxuICAgICAqIHJlZmVycyB0byB0aGUgZ2l2ZW4gbWVzc2FnZSBhbmQgY29tcGFyZXMgZ2l2ZW4gZGF0YSB3aXRoIHRoZSBwcm92ZW4uXG4gICAgICogSWYgdGhlIGdpdmVuIGRhdGEgZGlmZmVycyBmcm9tIHRoZSBwcm92ZW4sIHRoZSBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gICAgICogVGhlIGlucHV0IHBhcmFtZXRlciBpcyBhIHNpbmdsZSBtZXNzYWdlJ3MgSlNPTiBvYmplY3QgKHNlZSBwYXJhbXMgZGVzY3JpcHRpb24pLFxuICAgICAqIHdoaWNoIHdhcyBxdWVyaWVkIGZyb20gVE9OT1MgQVBJIHVzaW5nIGZ1bmN0aW9ucyBzdWNoIGFzIGBuZXQucXVlcnlgLCBgbmV0LnF1ZXJ5X2NvbGxlY3Rpb25gXG4gICAgICogb3IgYG5ldC53YWl0X2Zvcl9jb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIElmIG1lc3NhZ2UncyBCT0MgYW5kL29yIG5vbi1udWxsIGBzcmNfdHJhbnNhY3Rpb24uaWRgIG9yIGBkc3RfdHJhbnNhY3Rpb24uaWRgIGFyZSBub3QgcHJvdmlkZWRcbiAgICAgKiBpbiB0aGUgSlNPTiwgdGhleSB3aWxsIGJlIHF1ZXJpZWQgZnJvbSBUT05PUyBBUEkuXG4gICAgICpcbiAgICAgKiBQbGVhc2Ugbm90ZSwgdGhhdCBqb2lucyAobGlrZSBgYmxvY2tgLCBgZHN0X2FjY291bnRgLCBgZHN0X3RyYW5zYWN0aW9uYCwgYHNyY19hY2NvdW50YCxcbiAgICAgKiBgc3JjX3RyYW5zYWN0aW9uYCwgZXRjLiBpbiBgTWVzc2FnZWAgZW50aXR5KSBhcmUgc2VwYXJhdGVkIGVudGl0aWVzIGFuZCBub3Qgc3VwcG9ydGVkLFxuICAgICAqIHNvIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGluIGEgY2FzZSBpZiBKU09OIGJlaW5nIGNoZWNrZWQgaGFzIHN1Y2ggZW50aXRpZXMgaW4gaXQuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBwcm9vZnMgY2hlY2tpbmcsIHNlZSBkZXNjcmlwdGlvbiBvZiBgcHJvb2ZfYmxvY2tfZGF0YWAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mUHJvb2ZNZXNzYWdlRGF0YX0gcGFyYW1zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBwcm9vZl9tZXNzYWdlX2RhdGEocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdwcm9vZnMucHJvb2ZfbWVzc2FnZV9kYXRhJywgcGFyYW1zKTtcbiAgICB9XG59XG5leHBvcnRzLlByb29mc01vZHVsZSA9IFByb29mc01vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZXMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@eversdk/core/dist/modules.js\n");

/***/ }),

/***/ "./node_modules/@eversdk/lib-web/index.js":
/*!************************************************!*\
  !*** ./node_modules/@eversdk/lib-web/index.js ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"libWebSetup\": () => (/* binding */ libWebSetup),\n/* harmony export */   \"libWeb\": () => (/* binding */ libWeb)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n/*\n * Copyright 2018-2020 TON Labs LTD.\n *\n * Licensed under the SOFTWARE EVALUATION License (the \"License\"); you may not use\n * this file except in compliance with the License.\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific TON DEV software governing permissions and\n * limitations under the License.\n *\n */\n\n// This file is just a template that used to generate index.js at npm installation stage\n\nconst workerScript = `//****************************************************************** WRAPPER BEGIN\n\nlet wasm;\n\nconst cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = new Uint8Array();\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = new TextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedInt32Memory0 = new Int32Array();\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nlet cachedFloat64Memory0 = new Float64Array();\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nlet cachedBigInt64Memory0 = new BigInt64Array();\n\nfunction getBigInt64Memory0() {\n    if (cachedBigInt64Memory0.byteLength === 0) {\n        cachedBigInt64Memory0 = new BigInt64Array(wasm.memory.buffer);\n    }\n    return cachedBigInt64Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  \\`\\${val}\\`;\n    }\n    if (type == 'string') {\n        return \\`\"\\${val}\"\\`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return \\`Symbol(\\${description})\\`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return \\`Function(\\${name})\\`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\\\[object ([^\\\\]]+)\\\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of \\`val\\`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return \\`\\${val.name}: \\${val.message}\\\\n\\${val.stack}\\`;\n    }\n    // TODO we could test for more things here, like \\`Set\\`s and \\`Map\\`s.\n    return className;\n}\n\nfunction makeClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        try {\n            return f(state.a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(state.a, state.b);\n                state.a = 0;\n\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_50(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__Fn__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__he8db5fa167706a09(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wbg_adapter_53(arg0, arg1) {\n    wasm._dyn_core__ops__function__Fn_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hed540c88454df031(arg0, arg1);\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);\n\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_56(arg0, arg1) {\n    wasm._dyn_core__ops__function__FnMut_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hc182e4d50354196b(arg0, arg1);\n}\n\nfunction __wbg_adapter_59(arg0, arg1, arg2) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h7cbc3c322963706f(retptr, arg0, arg1, addHeapObject(arg2));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        if (r1) {\n            throw takeObject(r0);\n        }\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction __wbg_adapter_62(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h3709808ff1741914(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wbg_adapter_65(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h6c6161aacd664479(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wbg_adapter_68(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h68aa97d113ee360c(arg0, arg1, addHeapObject(arg2));\n}\n\n/**\n* @param {string} config_json\n* @returns {string}\n*/\nfunction core_create_context(config_json) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(config_json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.core_create_context(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\n/**\n* @param {number} context\n*/\nfunction core_destroy_context(context) {\n    wasm.core_destroy_context(context);\n}\n\n/**\n* @param {number} context\n* @param {string} function_name\n* @param {any} params\n* @param {number} request_id\n*/\nfunction core_request(context, function_name, params, request_id) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(function_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.core_request(retptr, context, ptr0, len0, addHeapObject(params), request_id);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        if (r1) {\n            throw takeObject(r0);\n        }\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nasync function load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"\\`WebAssembly.instantiateStreaming\\` failed because your server does not serve wasm with \\`application/wasm\\` MIME type. Falling back to \\`WebAssembly.instantiate\\` which is slower. Original error:\\\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction getImports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_new_8d2af00bc1e329ee = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_buffer_3f3d764d4747d564 = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_d9aa266703cb98be = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbg_newwithlength_7c42f7e738a9d5d3 = function(arg0) {\n        const ret = new Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_a68214f35c417fa9 = function(arg0, arg1, arg2) {\n        getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_newwithu8arraysequence_f863246af83e1785 = function() { return handleError(function (arg0) {\n        const ret = new Blob(getObject(arg0));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_get_765201544a2b6869 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_ArrayBuffer_e5e48f4762c5610b = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof ArrayBuffer;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbg_new_8c3f0052272a457a = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_keys_0702294afaeb6044 = function(arg0) {\n        const ret = Object.keys(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_length_6e3bbe7c8bd4dbd8 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_get_57245cc7d7c7619d = function(arg0, arg1) {\n        const ret = getObject(arg0)[arg1 >>> 0];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_new0_a57059d72c5b7aee = function() {\n        const ret = new Date();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getTime_cb82adb2556ed13e = function(arg0) {\n        const ret = getObject(arg0).getTime();\n        return ret;\n    };\n    imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {\n        const ret = getObject(arg0) == getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = getObject(arg0);\n        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_bigint = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'bigint';\n        return ret;\n    };\n    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'number' ? obj : undefined;\n        getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n    };\n    imports.wbg.__wbg_isSafeInteger_dfa0593e8d7ac35a = function(arg0) {\n        const ret = Number.isSafeInteger(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbindgen_bigint_get_as_i64 = function(arg0, arg1) {\n        const v = getObject(arg1);\n        const ret = typeof(v) === 'bigint' ? v : undefined;\n        getBigInt64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0n : ret;\n        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n    };\n    imports.wbg.__wbindgen_bigint_from_i64 = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_jsval_eq = function(arg0, arg1) {\n        const ret = getObject(arg0) === getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {\n        const ret = BigInt.asUintN(64, arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_isArray_27c46c67f498e15d = function(arg0) {\n        const ret = Array.isArray(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_iterator_6f9d4f28845f426c = function() {\n        const ret = Symbol.iterator;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_in = function(arg0, arg1) {\n        const ret = getObject(arg0) in getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg_entries_65a76a413fc91037 = function(arg0) {\n        const ret = Object.entries(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_null = function(arg0) {\n        const ret = getObject(arg0) === null;\n        return ret;\n    };\n    imports.wbg.__wbg_String_91fba7ded13ba54c = function(arg0, arg1) {\n        const ret = String(getObject(arg1));\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_0b9bfdd97583284e = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_String_33099856e8a8246a = function(arg0, arg1) {\n        const ret = String(getObject(arg1));\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_coreresponsehandler_a52879454c60c764 = function(arg0, arg1, arg2, arg3) {\n        core_response_handler(arg0 >>> 0, takeObject(arg1), arg2 >>> 0, arg3 !== 0);\n    };\n    imports.wbg.__wbg_message_fe2af63ccc8985bc = function(arg0) {\n        const ret = getObject(arg0).message;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_1d9a920c6bfc44a8 = function() {\n        const ret = new Array();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_268f7b7dd3430798 = function() {\n        const ret = new Map();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_933729cf5b66ac11 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbg_set_fbc33d020f507b72 = function(arg0, arg1, arg2) {\n        getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_process_0cc2ada8524d6f83 = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_versions_c11acceab27a6c87 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_node_7ff1ce49caf23815 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_NODE_MODULE_cf6401cc1091279e = function() {\n        const ret = module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_a746e79b322b9336 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_crypto_2036bed7c44c25e7 = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_msCrypto_a21fc88caf1ecdc8 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_f5933855e4f48a19 = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transaction_cce96cbebd81fe1c = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        const ret = getObject(arg0).transaction(getStringFromWasm0(arg1, arg2), takeObject(arg3));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_setoncomplete_3e57a8cec8327f66 = function(arg0, arg1) {\n        getObject(arg0).oncomplete = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonerror_00051c0213f27b2c = function(arg0, arg1) {\n        getObject(arg0).onerror = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonabort_404bee3b9940d03d = function(arg0, arg1) {\n        getObject(arg0).onabort = getObject(arg1);\n    };\n    imports.wbg.__wbg_item_52a6bec36314687b = function(arg0, arg1, arg2) {\n        const ret = getObject(arg1).item(arg2 >>> 0);\n        var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_objectStore_f17976b0e6377830 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).objectStore(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_target_bf704b7db7ad1387 = function(arg0) {\n        const ret = getObject(arg0).target;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_readyState_fb287f170113917c = function(arg0) {\n        const ret = getObject(arg0).readyState;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_setonsuccess_5f71593bc51653a3 = function(arg0, arg1) {\n        getObject(arg0).onsuccess = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonerror_d5771cc5bf9ea74c = function(arg0, arg1) {\n        getObject(arg0).onerror = getObject(arg1);\n    };\n    imports.wbg.__wbindgen_cb_drop = function(arg0) {\n        const obj = takeObject(arg0).original;\n        if (obj.cnt-- == 1) {\n            obj.a = 0;\n            return true;\n        }\n        const ret = false;\n        return ret;\n    };\n    imports.wbg.__wbg_next_aaef7c8aa5e212ac = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).next();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_done_1b73b0672e15f234 = function(arg0) {\n        const ret = getObject(arg0).done;\n        return ret;\n    };\n    imports.wbg.__wbg_value_1ccc36bc03462d71 = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbg_call_97ae9d8645dc388b = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_next_579e583d33566a86 = function(arg0) {\n        const ret = getObject(arg0).next;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_self_6d479506f72c6a71 = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_window_f2557cc78490aceb = function() { return handleError(function () {\n        const ret = window.window;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_7f206bda628d5286 = function() { return handleError(function () {\n        const ret = globalThis.globalThis;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_global_ba75c50d1cf384f4 = function() { return handleError(function () {\n        const ret = global.global;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_newnoargs_b5b063fc6c2f0376 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_83db9690f9353e79 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_length_9e1ae1900cb0fbd5 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_set_bf3f89b92d5a34bf = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_self_7eede1f4488bf346 = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_crypto_c909fb428dcbddb6 = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_msCrypto_511eefefbfc70ae4 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_MODULE_ef3aa2eb251158a5 = function() {\n        const ret = module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_900d5c3984fe7703 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getRandomValues_307049345d0bd88c = function(arg0) {\n        const ret = getObject(arg0).getRandomValues;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_randomFillSync_85b3f4c52c56c313 = function(arg0, arg1, arg2) {\n        getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n    };\n    imports.wbg.__wbg_subarray_58ad4efbb5bcb886 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getRandomValues_cd175915511f705e = function(arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    };\n    imports.wbg.__wbg_randomFillSync_065afffde01daa66 = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_getRandomValues_b99eec4244a475bb = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_Uint8Array_971eeda69eb75003 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Uint8Array;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_put_84e7fc93eee27b28 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).put(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_delete_8abedd1043b4105d = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).delete(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_setTimeout_d6fcf0d9067b8e64 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).setTimeout(getObject(arg1), arg2);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_clearTimeout_7d6f7bfeed34b348 = function(arg0, arg1) {\n        getObject(arg0).clearTimeout(arg1);\n    };\n    imports.wbg.__wbg_newwithstrandinit_05d7180788420c40 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_headers_85824e993aa739bf = function(arg0) {\n        const ret = getObject(arg0).headers;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_992c1d31586b2957 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).set(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n    }, arguments) };\n    imports.wbg.__wbg_fetch_0fe04905cccfc2aa = function(arg0, arg1) {\n        const ret = getObject(arg0).fetch(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_instanceof_Response_eaa426220848a39e = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Response;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_status_c4ef3dd591e63435 = function(arg0) {\n        const ret = getObject(arg0).status;\n        return ret;\n    };\n    imports.wbg.__wbg_url_74285ddf2747cb3d = function(arg0, arg1) {\n        const ret = getObject(arg1).url;\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_setonversionchange_840d65cd0888dfb0 = function(arg0, arg1) {\n        getObject(arg0).onversionchange = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonupgradeneeded_17d0b9530f1e0cac = function(arg0, arg1) {\n        getObject(arg0).onupgradeneeded = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonblocked_e66d6be5c879980d = function(arg0, arg1) {\n        getObject(arg0).onblocked = getObject(arg1);\n    };\n    imports.wbg.__wbg_message_a7af3ee0cc0fe28d = function(arg0, arg1) {\n        const ret = getObject(arg1).message;\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_Window_5684341ff6dfe3ad = function(arg0) {\n        const ret = getObject(arg0).Window;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_WorkerGlobalScope_e0447ffcae8bb272 = function(arg0) {\n        const ret = getObject(arg0).WorkerGlobalScope;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_indexedDB_050f0962ab607ac5 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).indexedDB;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_indexedDB_8d9e9ab4616df7f0 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).indexedDB;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_open_a31c3fe1fdc244eb = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).open(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_newwithstr_d5b5f9b985ee84fb = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        const ret = new WebSocket(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_d29e507f6606de91 = function() { return handleError(function (arg0, arg1) {\n        const ret = new WebSocket(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_setonmessage_c5a806b62a0c5607 = function(arg0, arg1) {\n        getObject(arg0).onmessage = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonopen_9ce48dce57e549b5 = function(arg0, arg1) {\n        getObject(arg0).onopen = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonerror_02393260b3e29972 = function(arg0, arg1) {\n        getObject(arg0).onerror = getObject(arg1);\n    };\n    imports.wbg.__wbg_send_80b256d87a6779e5 = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).send(getStringFromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_data_7b1f01f4e6a64fbe = function(arg0) {\n        const ret = getObject(arg0).data;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stringify_d6471d300ded9b68 = function() { return handleError(function (arg0) {\n        const ret = JSON.stringify(getObject(arg0));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_objectStoreNames_8c06c40d2b05141c = function(arg0) {\n        const ret = getObject(arg0).objectStoreNames;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_createObjectStore_d3e2789c13dde1fc = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).createObjectStore(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_Error_56b496a10a56de66 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Error;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_getTimezoneOffset_89bd4275e1ca8341 = function(arg0) {\n        const ret = getObject(arg0).getTimezoneOffset();\n        return ret;\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(getObject(arg1));\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbg_then_cedad20fbbd9418a = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_resolve_99fe17964f31ffc0 = function(arg0) {\n        const ret = Promise.resolve(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_11f7a54d67b4bfad = function(arg0, arg1) {\n        const ret = getObject(arg0).then(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_result_9e399c14676970d9 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).result;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_error_aacf5ac191e54ed0 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).error;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_get_6285bf458a1ee758 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).get(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_Window_acc97ff9f5d2c7b4 = function(arg0) {\n        let result;\n        try {\n            result = true;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_close_45d053bea59e7746 = function() { return handleError(function (arg0) {\n        getObject(arg0).close();\n    }, arguments) };\n    imports.wbg.__wbg_text_1169d752cc697903 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).text();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_closure_wrapper947 = function(arg0, arg1, arg2) {\n        const ret = makeClosure(arg0, arg1, 44, __wbg_adapter_50);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper958 = function(arg0, arg1, arg2) {\n        const ret = makeClosure(arg0, arg1, 47, __wbg_adapter_53);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6159 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 238, __wbg_adapter_56);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6824 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 247, __wbg_adapter_59);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6874 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 244, __wbg_adapter_62);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6875 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 1206, __wbg_adapter_65);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6876 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 241, __wbg_adapter_68);\n        return addHeapObject(ret);\n    };\n\n    return imports;\n}\n\nfunction initMemory(imports, maybe_memory) {\n\n}\n\nfunction finalizeInit(instance, module) {\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n    cachedBigInt64Memory0 = new BigInt64Array();\n    cachedFloat64Memory0 = new Float64Array();\n    cachedInt32Memory0 = new Int32Array();\n    cachedUint8Memory0 = new Uint8Array();\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    const imports = getImports();\n\n    initMemory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return finalizeInit(instance, module);\n}\n\nasync function init(input) {\n    if (typeof input === 'undefined') {    }\n    const imports = getImports();\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    initMemory(imports);\n\n    const { instance, module } = await load(await input, imports);\n\n    return finalizeInit(instance, module);\n}\n\n\n//****************************************************************** WRAPPER END\n\nfunction replaceUndefinedWithNulls(value) {\n    if (value === undefined) {\n        return null;\n    }\n    if (value instanceof Blob) {\n        return value;\n    }\n    if (typeof value === \"object\" && value !== null) {\n        const result = Array.isArray(value) ? [] : {};\n        for (const key in value) {\n            result[key] = replaceUndefinedWithNulls(value[key]);\n        }\n        return result;\n    }\n    return value;\n};\n\nfunction core_response_handler(request_id, params, response_type, finished) {\n    postMessage({\n        type: 'response',\n        requestId: request_id,\n        params: replaceUndefinedWithNulls(params),\n        responseType: response_type,\n        finished,\n    });\n}\n\nasync function replaceBlobsWithArrayBuffers(value) {\n    if (value instanceof Blob) {\n        return await value.arrayBuffer();\n    }\n    if (typeof value === \"bigint\") {\n        if (value < Number.MAX_SAFE_INTEGER && value > Number.MIN_SAFE_INTEGER) {\n            return Number(value);\n        } else {\n            return value.toString();\n        }\n    }\n    if (typeof value === \"object\" && value !== null) {\n        const result = Array.isArray(value) ? [] : {};\n        for (const key in value) {\n            result[key] = await replaceBlobsWithArrayBuffers(value[key]);\n        }\n        return result;\n    }\n    return value;\n}\n\nself.onmessage = (e) => {\n    const message = e.data;\n    switch (message.type) {\n    case 'init':\n        (async () => {\n            await init(message.wasmModule);\n            postMessage({ type: 'init' });\n        })();\n        break;\n\n    case 'createContext':\n        postMessage({\n            type: 'createContext',\n            result: core_create_context(message.configJson),\n            requestId: message.requestId,\n        });\n        break;\n\n    case 'destroyContext':\n        core_destroy_context(message.context);\n        postMessage({\n            type: 'destroyContext'\n        });\n        break;\n\n    case 'request':\n        (async () => {\n            core_request(\n                message.context,\n                message.functionName,\n                await replaceBlobsWithArrayBuffers(message.functionParams),\n                message.requestId,\n            );\n        })();\n        break;\n    }\n};\n`;\n\nlet options = null;\n\nfunction libWebSetup(libOptions) {\n    options = libOptions;\n}\n\nfunction debugLog(message) {\n    if (options && options.debugLog) {\n        options.debugLog(message);\n    }\n}\n\n\nasync function loadModule() {\n    const startLoadTime = Date.now();\n    let wasmModule;\n    if (options && options.loadModule) {\n        wasmModule = await options.loadModule;\n    } else {\n        const fetched = fetch((options && options.binaryURL) || \"/eversdk.wasm\");\n        if (WebAssembly.compileStreaming) {\n            debugLog(\"compileStreaming binary\");\n            return await WebAssembly.compileStreaming(fetched);\n        }\n        debugLog(\"compile binary\");\n        wasmModule = await WebAssembly.compile(await (await fetched).arrayBuffer());\n    }\n    await init(wasmModule);\n    debugLog(`compile time ${Date.now() - startLoadTime}`);\n}\n\nfunction withSeparateWorker() {\n    function debugLog(message) {\n        if (options && options.debugLog) {\n            options.debugLog(message);\n        }\n    }\n\n    const workerBlob = new Blob(\n        [workerScript],\n        { type: \"application/javascript\" },\n    );\n    const workerUrl = URL.createObjectURL(workerBlob);\n    const worker = new Worker(workerUrl);\n\n\n    let nextCreateContextRequestId = 1;\n    const createContextRequests = new Map();\n    let initComplete = false;\n\n    let responseHandler = null;\n\n    worker.onmessage = (evt) => {\n        const message = evt.data;\n        switch (message.type) {\n        case \"init\":\n            initComplete = true;\n            for (const [requestId, request] of createContextRequests.entries()) {\n                worker.postMessage({\n                    type: \"createContext\",\n                    requestId,\n                    configJson: request.configJson,\n                });\n            }\n            break;\n        case \"createContext\":\n            const request = createContextRequests.get(message.requestId);\n            if (request) {\n                createContextRequests.delete(message.requestId);\n                request.resolve(message.result);\n            }\n            break;\n        case \"destroyContext\":\n            break;\n        case \"response\":\n            if (responseHandler) {\n                responseHandler(\n                    message.requestId,\n                    message.params,\n                    message.responseType,\n                    message.finished,\n                );\n            }\n            break;\n        }\n    };\n\n    worker.onerror = (evt) => {\n        console.log(`Error from Web Worker: ${evt.message}`);\n    };\n\n    (async () => {\n        worker.postMessage({\n            type: \"init\",\n            wasmModule: await loadModule(),\n        });\n    })();\n\n    return Promise.resolve({\n        setResponseParamsHandler: (handler) => {\n            responseHandler = handler;\n        },\n        createContext: (configJson) => {\n            return new Promise((resolve) => {\n                const requestId = nextCreateContextRequestId;\n                nextCreateContextRequestId += 1;\n                createContextRequests.set(requestId, {\n                    configJson,\n                    resolve,\n                });\n                if (initComplete) {\n                    worker.postMessage({\n                        type: \"createContext\",\n                        requestId,\n                        configJson,\n                    });\n                }\n            });\n        },\n        destroyContext: (context) => {\n            worker.postMessage({\n                type: \"destroyContext\",\n                context,\n            });\n        },\n        sendRequestParams: (context, requestId, functionName, functionParams) => {\n            worker.postMessage({\n                type: \"request\",\n                context,\n                requestId,\n                functionName,\n                functionParams,\n            });\n        },\n    });\n}\n\nfunction withoutSeparateWorker() {\n//****************************************************************** WRAPPER BEGIN\n\nlet wasm;\n\nconst cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = new Uint8Array();\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = new TextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedInt32Memory0 = new Int32Array();\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nlet cachedFloat64Memory0 = new Float64Array();\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nlet cachedBigInt64Memory0 = new BigInt64Array();\n\nfunction getBigInt64Memory0() {\n    if (cachedBigInt64Memory0.byteLength === 0) {\n        cachedBigInt64Memory0 = new BigInt64Array(wasm.memory.buffer);\n    }\n    return cachedBigInt64Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction makeClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        try {\n            return f(state.a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(state.a, state.b);\n                state.a = 0;\n\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_50(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__Fn__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__he8db5fa167706a09(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wbg_adapter_53(arg0, arg1) {\n    wasm._dyn_core__ops__function__Fn_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hed540c88454df031(arg0, arg1);\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);\n\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_56(arg0, arg1) {\n    wasm._dyn_core__ops__function__FnMut_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hc182e4d50354196b(arg0, arg1);\n}\n\nfunction __wbg_adapter_59(arg0, arg1, arg2) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h7cbc3c322963706f(retptr, arg0, arg1, addHeapObject(arg2));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        if (r1) {\n            throw takeObject(r0);\n        }\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction __wbg_adapter_62(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h3709808ff1741914(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wbg_adapter_65(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h6c6161aacd664479(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wbg_adapter_68(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h68aa97d113ee360c(arg0, arg1, addHeapObject(arg2));\n}\n\n/**\n* @param {string} config_json\n* @returns {string}\n*/\nfunction core_create_context(config_json) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(config_json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.core_create_context(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\n/**\n* @param {number} context\n*/\nfunction core_destroy_context(context) {\n    wasm.core_destroy_context(context);\n}\n\n/**\n* @param {number} context\n* @param {string} function_name\n* @param {any} params\n* @param {number} request_id\n*/\nfunction core_request(context, function_name, params, request_id) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(function_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.core_request(retptr, context, ptr0, len0, addHeapObject(params), request_id);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        if (r1) {\n            throw takeObject(r0);\n        }\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nasync function load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction getImports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_new_8d2af00bc1e329ee = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_buffer_3f3d764d4747d564 = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_d9aa266703cb98be = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbg_newwithlength_7c42f7e738a9d5d3 = function(arg0) {\n        const ret = new Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_a68214f35c417fa9 = function(arg0, arg1, arg2) {\n        getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_newwithu8arraysequence_f863246af83e1785 = function() { return handleError(function (arg0) {\n        const ret = new Blob(getObject(arg0));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_get_765201544a2b6869 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_ArrayBuffer_e5e48f4762c5610b = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof ArrayBuffer;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbg_new_8c3f0052272a457a = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_keys_0702294afaeb6044 = function(arg0) {\n        const ret = Object.keys(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_length_6e3bbe7c8bd4dbd8 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_get_57245cc7d7c7619d = function(arg0, arg1) {\n        const ret = getObject(arg0)[arg1 >>> 0];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_new0_a57059d72c5b7aee = function() {\n        const ret = new Date();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getTime_cb82adb2556ed13e = function(arg0) {\n        const ret = getObject(arg0).getTime();\n        return ret;\n    };\n    imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {\n        const ret = getObject(arg0) == getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = getObject(arg0);\n        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_bigint = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'bigint';\n        return ret;\n    };\n    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'number' ? obj : undefined;\n        getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n    };\n    imports.wbg.__wbg_isSafeInteger_dfa0593e8d7ac35a = function(arg0) {\n        const ret = Number.isSafeInteger(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbindgen_bigint_get_as_i64 = function(arg0, arg1) {\n        const v = getObject(arg1);\n        const ret = typeof(v) === 'bigint' ? v : undefined;\n        getBigInt64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0n : ret;\n        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n    };\n    imports.wbg.__wbindgen_bigint_from_i64 = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_jsval_eq = function(arg0, arg1) {\n        const ret = getObject(arg0) === getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {\n        const ret = BigInt.asUintN(64, arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_isArray_27c46c67f498e15d = function(arg0) {\n        const ret = Array.isArray(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_iterator_6f9d4f28845f426c = function() {\n        const ret = Symbol.iterator;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_in = function(arg0, arg1) {\n        const ret = getObject(arg0) in getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg_entries_65a76a413fc91037 = function(arg0) {\n        const ret = Object.entries(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_null = function(arg0) {\n        const ret = getObject(arg0) === null;\n        return ret;\n    };\n    imports.wbg.__wbg_String_91fba7ded13ba54c = function(arg0, arg1) {\n        const ret = String(getObject(arg1));\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_0b9bfdd97583284e = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_String_33099856e8a8246a = function(arg0, arg1) {\n        const ret = String(getObject(arg1));\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_coreresponsehandler_a52879454c60c764 = function(arg0, arg1, arg2, arg3) {\n        core_response_handler(arg0 >>> 0, takeObject(arg1), arg2 >>> 0, arg3 !== 0);\n    };\n    imports.wbg.__wbg_message_fe2af63ccc8985bc = function(arg0) {\n        const ret = getObject(arg0).message;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_1d9a920c6bfc44a8 = function() {\n        const ret = new Array();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_268f7b7dd3430798 = function() {\n        const ret = new Map();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_933729cf5b66ac11 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbg_set_fbc33d020f507b72 = function(arg0, arg1, arg2) {\n        getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_process_0cc2ada8524d6f83 = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_versions_c11acceab27a6c87 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_node_7ff1ce49caf23815 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_NODE_MODULE_cf6401cc1091279e = function() {\n        const ret = module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_a746e79b322b9336 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_crypto_2036bed7c44c25e7 = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_msCrypto_a21fc88caf1ecdc8 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_f5933855e4f48a19 = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transaction_cce96cbebd81fe1c = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        const ret = getObject(arg0).transaction(getStringFromWasm0(arg1, arg2), takeObject(arg3));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_setoncomplete_3e57a8cec8327f66 = function(arg0, arg1) {\n        getObject(arg0).oncomplete = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonerror_00051c0213f27b2c = function(arg0, arg1) {\n        getObject(arg0).onerror = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonabort_404bee3b9940d03d = function(arg0, arg1) {\n        getObject(arg0).onabort = getObject(arg1);\n    };\n    imports.wbg.__wbg_item_52a6bec36314687b = function(arg0, arg1, arg2) {\n        const ret = getObject(arg1).item(arg2 >>> 0);\n        var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_objectStore_f17976b0e6377830 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).objectStore(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_target_bf704b7db7ad1387 = function(arg0) {\n        const ret = getObject(arg0).target;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_readyState_fb287f170113917c = function(arg0) {\n        const ret = getObject(arg0).readyState;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_setonsuccess_5f71593bc51653a3 = function(arg0, arg1) {\n        getObject(arg0).onsuccess = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonerror_d5771cc5bf9ea74c = function(arg0, arg1) {\n        getObject(arg0).onerror = getObject(arg1);\n    };\n    imports.wbg.__wbindgen_cb_drop = function(arg0) {\n        const obj = takeObject(arg0).original;\n        if (obj.cnt-- == 1) {\n            obj.a = 0;\n            return true;\n        }\n        const ret = false;\n        return ret;\n    };\n    imports.wbg.__wbg_next_aaef7c8aa5e212ac = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).next();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_done_1b73b0672e15f234 = function(arg0) {\n        const ret = getObject(arg0).done;\n        return ret;\n    };\n    imports.wbg.__wbg_value_1ccc36bc03462d71 = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbg_call_97ae9d8645dc388b = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_next_579e583d33566a86 = function(arg0) {\n        const ret = getObject(arg0).next;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_self_6d479506f72c6a71 = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_window_f2557cc78490aceb = function() { return handleError(function () {\n        const ret = window.window;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_7f206bda628d5286 = function() { return handleError(function () {\n        const ret = globalThis.globalThis;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_global_ba75c50d1cf384f4 = function() { return handleError(function () {\n        const ret = __webpack_require__.g.global;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_newnoargs_b5b063fc6c2f0376 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_83db9690f9353e79 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_length_9e1ae1900cb0fbd5 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_set_bf3f89b92d5a34bf = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_self_7eede1f4488bf346 = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_crypto_c909fb428dcbddb6 = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_msCrypto_511eefefbfc70ae4 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_MODULE_ef3aa2eb251158a5 = function() {\n        const ret = module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_900d5c3984fe7703 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getRandomValues_307049345d0bd88c = function(arg0) {\n        const ret = getObject(arg0).getRandomValues;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_randomFillSync_85b3f4c52c56c313 = function(arg0, arg1, arg2) {\n        getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n    };\n    imports.wbg.__wbg_subarray_58ad4efbb5bcb886 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getRandomValues_cd175915511f705e = function(arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    };\n    imports.wbg.__wbg_randomFillSync_065afffde01daa66 = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_getRandomValues_b99eec4244a475bb = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_Uint8Array_971eeda69eb75003 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Uint8Array;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_put_84e7fc93eee27b28 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).put(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_delete_8abedd1043b4105d = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).delete(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_setTimeout_d6fcf0d9067b8e64 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).setTimeout(getObject(arg1), arg2);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_clearTimeout_7d6f7bfeed34b348 = function(arg0, arg1) {\n        getObject(arg0).clearTimeout(arg1);\n    };\n    imports.wbg.__wbg_newwithstrandinit_05d7180788420c40 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_headers_85824e993aa739bf = function(arg0) {\n        const ret = getObject(arg0).headers;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_992c1d31586b2957 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).set(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n    }, arguments) };\n    imports.wbg.__wbg_fetch_0fe04905cccfc2aa = function(arg0, arg1) {\n        const ret = getObject(arg0).fetch(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_instanceof_Response_eaa426220848a39e = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Response;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_status_c4ef3dd591e63435 = function(arg0) {\n        const ret = getObject(arg0).status;\n        return ret;\n    };\n    imports.wbg.__wbg_url_74285ddf2747cb3d = function(arg0, arg1) {\n        const ret = getObject(arg1).url;\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_setonversionchange_840d65cd0888dfb0 = function(arg0, arg1) {\n        getObject(arg0).onversionchange = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonupgradeneeded_17d0b9530f1e0cac = function(arg0, arg1) {\n        getObject(arg0).onupgradeneeded = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonblocked_e66d6be5c879980d = function(arg0, arg1) {\n        getObject(arg0).onblocked = getObject(arg1);\n    };\n    imports.wbg.__wbg_message_a7af3ee0cc0fe28d = function(arg0, arg1) {\n        const ret = getObject(arg1).message;\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_Window_5684341ff6dfe3ad = function(arg0) {\n        const ret = getObject(arg0).Window;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_WorkerGlobalScope_e0447ffcae8bb272 = function(arg0) {\n        const ret = getObject(arg0).WorkerGlobalScope;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_indexedDB_050f0962ab607ac5 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).indexedDB;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_indexedDB_8d9e9ab4616df7f0 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).indexedDB;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_open_a31c3fe1fdc244eb = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).open(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_newwithstr_d5b5f9b985ee84fb = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        const ret = new WebSocket(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_d29e507f6606de91 = function() { return handleError(function (arg0, arg1) {\n        const ret = new WebSocket(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_setonmessage_c5a806b62a0c5607 = function(arg0, arg1) {\n        getObject(arg0).onmessage = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonopen_9ce48dce57e549b5 = function(arg0, arg1) {\n        getObject(arg0).onopen = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonerror_02393260b3e29972 = function(arg0, arg1) {\n        getObject(arg0).onerror = getObject(arg1);\n    };\n    imports.wbg.__wbg_send_80b256d87a6779e5 = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).send(getStringFromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_data_7b1f01f4e6a64fbe = function(arg0) {\n        const ret = getObject(arg0).data;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stringify_d6471d300ded9b68 = function() { return handleError(function (arg0) {\n        const ret = JSON.stringify(getObject(arg0));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_objectStoreNames_8c06c40d2b05141c = function(arg0) {\n        const ret = getObject(arg0).objectStoreNames;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_createObjectStore_d3e2789c13dde1fc = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).createObjectStore(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_Error_56b496a10a56de66 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Error;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_getTimezoneOffset_89bd4275e1ca8341 = function(arg0) {\n        const ret = getObject(arg0).getTimezoneOffset();\n        return ret;\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(getObject(arg1));\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbg_then_cedad20fbbd9418a = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_resolve_99fe17964f31ffc0 = function(arg0) {\n        const ret = Promise.resolve(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_11f7a54d67b4bfad = function(arg0, arg1) {\n        const ret = getObject(arg0).then(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_result_9e399c14676970d9 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).result;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_error_aacf5ac191e54ed0 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).error;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_get_6285bf458a1ee758 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).get(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_Window_acc97ff9f5d2c7b4 = function(arg0) {\n        let result;\n        try {\n            result = true;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_close_45d053bea59e7746 = function() { return handleError(function (arg0) {\n        getObject(arg0).close();\n    }, arguments) };\n    imports.wbg.__wbg_text_1169d752cc697903 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).text();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_closure_wrapper947 = function(arg0, arg1, arg2) {\n        const ret = makeClosure(arg0, arg1, 44, __wbg_adapter_50);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper958 = function(arg0, arg1, arg2) {\n        const ret = makeClosure(arg0, arg1, 47, __wbg_adapter_53);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6159 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 238, __wbg_adapter_56);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6824 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 247, __wbg_adapter_59);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6874 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 244, __wbg_adapter_62);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6875 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 1206, __wbg_adapter_65);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6876 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 241, __wbg_adapter_68);\n        return addHeapObject(ret);\n    };\n\n    return imports;\n}\n\nfunction initMemory(imports, maybe_memory) {\n\n}\n\nfunction finalizeInit(instance, module) {\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n    cachedBigInt64Memory0 = new BigInt64Array();\n    cachedFloat64Memory0 = new Float64Array();\n    cachedInt32Memory0 = new Int32Array();\n    cachedUint8Memory0 = new Uint8Array();\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    const imports = getImports();\n\n    initMemory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return finalizeInit(instance, module);\n}\n\nasync function init(input) {\n    if (typeof input === 'undefined') {    }\n    const imports = getImports();\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    initMemory(imports);\n\n    const { instance, module } = await load(await input, imports);\n\n    return finalizeInit(instance, module);\n}\n\n\n//****************************************************************** WRAPPER END\n    function replaceUndefinedWithNulls(value) {\n        if (value === undefined) {\n            return null;\n        }\n        if (value instanceof Blob) {\n            return value;\n        }\n        if (typeof value === \"object\" && value !== null) {\n            const result = Array.isArray(value) ? [] : {};\n            for (const key in value) {\n                result[key] = replaceUndefinedWithNulls(value[key]);\n            }\n            return result;\n        }\n        return value;\n    }\n\n    async function replaceBlobsWithArrayBuffers(value) {\n        if (value instanceof Blob) {\n            return await value.arrayBuffer();\n        }\n        if (typeof value === \"bigint\") {\n            if (value < Number.MAX_SAFE_INTEGER && value > Number.MIN_SAFE_INTEGER) {\n                return Number(value);\n            } else {\n                return value.toString();\n            }\n        }\n        if (typeof value === \"object\" && value !== null) {\n            const result = Array.isArray(value) ? [] : {};\n            for (const key in value) {\n                result[key] = await replaceBlobsWithArrayBuffers(value[key]);\n            }\n            return result;\n        }\n        return value;\n    }\n\n\n    let deferredCreateContext = [];\n    let responseHandler = null;\n\n    function core_response_handler(request_id, params, response_type, finished) {\n        if (responseHandler) {\n            responseHandler(\n                request_id,\n                params,\n                response_type,\n                finished,\n            );\n        }\n    }\n\n    (async () => {\n        await init(await loadModule());\n        for (const createContext of deferredCreateContext) {\n            createContext.resolve(core_create_context(createContext.configJson));\n        }\n        deferredCreateContext = null;\n    })();\n\n    return Promise.resolve({\n        setResponseParamsHandler: (handler) => {\n            responseHandler = handler;\n        },\n        createContext: (configJson) => {\n            return deferredCreateContext === null\n                ? Promise.resolve(core_create_context(configJson))\n                : new Promise((resolve) => {\n                    deferredCreateContext.push({\n                        configJson,\n                        resolve,\n                    });\n                });\n        },\n        destroyContext: (context) => {\n            core_destroy_context(context);\n        },\n        sendRequestParams: (context, requestId, functionName, functionParams) => {\n            (async () => {\n                core_request(\n                    context,\n                    functionName,\n                    await replaceBlobsWithArrayBuffers(functionParams),\n                    requestId,\n                );\n            })();\n        },\n    });\n\n}\n\nfunction libWeb() {\n    return options && options.disableSeparateWorker ? withoutSeparateWorker() : withSeparateWorker();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGV2ZXJzZGsvbGliLXdlYi9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9AZXZlcnNkay9saWItd2ViL2luZGV4LmpzPzc4MzMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDE4LTIwMjAgVE9OIExhYnMgTFRELlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBTT0ZUV0FSRSBFVkFMVUFUSU9OIExpY2Vuc2UgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxuICogdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBUT04gREVWIHNvZnR3YXJlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG4vLyBUaGlzIGZpbGUgaXMganVzdCBhIHRlbXBsYXRlIHRoYXQgdXNlZCB0byBnZW5lcmF0ZSBpbmRleC5qcyBhdCBucG0gaW5zdGFsbGF0aW9uIHN0YWdlXG5cbmNvbnN0IHdvcmtlclNjcmlwdCA9IGAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBXUkFQUEVSIEJFR0lOXG5cbmxldCB3YXNtO1xuXG5jb25zdCBjYWNoZWRUZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGlnbm9yZUJPTTogdHJ1ZSwgZmF0YWw6IHRydWUgfSk7XG5cbmNhY2hlZFRleHREZWNvZGVyLmRlY29kZSgpO1xuXG5sZXQgY2FjaGVkVWludDhNZW1vcnkwID0gbmV3IFVpbnQ4QXJyYXkoKTtcblxuZnVuY3Rpb24gZ2V0VWludDhNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWRVaW50OE1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRVaW50OE1lbW9yeTAgPSBuZXcgVWludDhBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkVWludDhNZW1vcnkwO1xufVxuXG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyLCBsZW4pIHtcbiAgICByZXR1cm4gY2FjaGVkVGV4dERlY29kZXIuZGVjb2RlKGdldFVpbnQ4TWVtb3J5MCgpLnN1YmFycmF5KHB0ciwgcHRyICsgbGVuKSk7XG59XG5cbmNvbnN0IGhlYXAgPSBuZXcgQXJyYXkoMzIpLmZpbGwodW5kZWZpbmVkKTtcblxuaGVhcC5wdXNoKHVuZGVmaW5lZCwgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xuXG5sZXQgaGVhcF9uZXh0ID0gaGVhcC5sZW5ndGg7XG5cbmZ1bmN0aW9uIGFkZEhlYXBPYmplY3Qob2JqKSB7XG4gICAgaWYgKGhlYXBfbmV4dCA9PT0gaGVhcC5sZW5ndGgpIGhlYXAucHVzaChoZWFwLmxlbmd0aCArIDEpO1xuICAgIGNvbnN0IGlkeCA9IGhlYXBfbmV4dDtcbiAgICBoZWFwX25leHQgPSBoZWFwW2lkeF07XG5cbiAgICBoZWFwW2lkeF0gPSBvYmo7XG4gICAgcmV0dXJuIGlkeDtcbn1cblxuZnVuY3Rpb24gZ2V0T2JqZWN0KGlkeCkgeyByZXR1cm4gaGVhcFtpZHhdOyB9XG5cbmZ1bmN0aW9uIGRyb3BPYmplY3QoaWR4KSB7XG4gICAgaWYgKGlkeCA8IDM2KSByZXR1cm47XG4gICAgaGVhcFtpZHhdID0gaGVhcF9uZXh0O1xuICAgIGhlYXBfbmV4dCA9IGlkeDtcbn1cblxuZnVuY3Rpb24gdGFrZU9iamVjdChpZHgpIHtcbiAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoaWR4KTtcbiAgICBkcm9wT2JqZWN0KGlkeCk7XG4gICAgcmV0dXJuIHJldDtcbn1cblxubGV0IFdBU01fVkVDVE9SX0xFTiA9IDA7XG5cbmNvbnN0IGNhY2hlZFRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpO1xuXG5jb25zdCBlbmNvZGVTdHJpbmcgPSAodHlwZW9mIGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZUludG8gPT09ICdmdW5jdGlvbidcbiAgICA/IGZ1bmN0aW9uIChhcmcsIHZpZXcpIHtcbiAgICByZXR1cm4gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlSW50byhhcmcsIHZpZXcpO1xufVxuICAgIDogZnVuY3Rpb24gKGFyZywgdmlldykge1xuICAgIGNvbnN0IGJ1ZiA9IGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZShhcmcpO1xuICAgIHZpZXcuc2V0KGJ1Zik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVhZDogYXJnLmxlbmd0aCxcbiAgICAgICAgd3JpdHRlbjogYnVmLmxlbmd0aFxuICAgIH07XG59KTtcblxuZnVuY3Rpb24gcGFzc1N0cmluZ1RvV2FzbTAoYXJnLCBtYWxsb2MsIHJlYWxsb2MpIHtcblxuICAgIGlmIChyZWFsbG9jID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgYnVmID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlKGFyZyk7XG4gICAgICAgIGNvbnN0IHB0ciA9IG1hbGxvYyhidWYubGVuZ3RoKTtcbiAgICAgICAgZ2V0VWludDhNZW1vcnkwKCkuc3ViYXJyYXkocHRyLCBwdHIgKyBidWYubGVuZ3RoKS5zZXQoYnVmKTtcbiAgICAgICAgV0FTTV9WRUNUT1JfTEVOID0gYnVmLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBsZXQgbGVuID0gYXJnLmxlbmd0aDtcbiAgICBsZXQgcHRyID0gbWFsbG9jKGxlbik7XG5cbiAgICBjb25zdCBtZW0gPSBnZXRVaW50OE1lbW9yeTAoKTtcblxuICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgZm9yICg7IG9mZnNldCA8IGxlbjsgb2Zmc2V0KyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGFyZy5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICAgIGlmIChjb2RlID4gMHg3RikgYnJlYWs7XG4gICAgICAgIG1lbVtwdHIgKyBvZmZzZXRdID0gY29kZTtcbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ICE9PSBsZW4pIHtcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcHRyID0gcmVhbGxvYyhwdHIsIGxlbiwgbGVuID0gb2Zmc2V0ICsgYXJnLmxlbmd0aCAqIDMpO1xuICAgICAgICBjb25zdCB2aWV3ID0gZ2V0VWludDhNZW1vcnkwKCkuc3ViYXJyYXkocHRyICsgb2Zmc2V0LCBwdHIgKyBsZW4pO1xuICAgICAgICBjb25zdCByZXQgPSBlbmNvZGVTdHJpbmcoYXJnLCB2aWV3KTtcblxuICAgICAgICBvZmZzZXQgKz0gcmV0LndyaXR0ZW47XG4gICAgfVxuXG4gICAgV0FTTV9WRUNUT1JfTEVOID0gb2Zmc2V0O1xuICAgIHJldHVybiBwdHI7XG59XG5cbmZ1bmN0aW9uIGlzTGlrZU5vbmUoeCkge1xuICAgIHJldHVybiB4ID09PSB1bmRlZmluZWQgfHwgeCA9PT0gbnVsbDtcbn1cblxubGV0IGNhY2hlZEludDMyTWVtb3J5MCA9IG5ldyBJbnQzMkFycmF5KCk7XG5cbmZ1bmN0aW9uIGdldEludDMyTWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkSW50MzJNZW1vcnkwLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FjaGVkSW50MzJNZW1vcnkwID0gbmV3IEludDMyQXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZEludDMyTWVtb3J5MDtcbn1cblxubGV0IGNhY2hlZEZsb2F0NjRNZW1vcnkwID0gbmV3IEZsb2F0NjRBcnJheSgpO1xuXG5mdW5jdGlvbiBnZXRGbG9hdDY0TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkRmxvYXQ2NE1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRGbG9hdDY0TWVtb3J5MCA9IG5ldyBGbG9hdDY0QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZEZsb2F0NjRNZW1vcnkwO1xufVxuXG5sZXQgY2FjaGVkQmlnSW50NjRNZW1vcnkwID0gbmV3IEJpZ0ludDY0QXJyYXkoKTtcblxuZnVuY3Rpb24gZ2V0QmlnSW50NjRNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWRCaWdJbnQ2NE1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRCaWdJbnQ2NE1lbW9yeTAgPSBuZXcgQmlnSW50NjRBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkQmlnSW50NjRNZW1vcnkwO1xufVxuXG5mdW5jdGlvbiBkZWJ1Z1N0cmluZyh2YWwpIHtcbiAgICAvLyBwcmltaXRpdmUgdHlwZXNcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbDtcbiAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdib29sZWFuJyB8fCB2YWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIFxcYFxcJHt2YWx9XFxgO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gXFxgXCJcXCR7dmFsfVwiXFxgO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSAnc3ltYm9sJykge1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbC5kZXNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnU3ltYm9sJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcXGBTeW1ib2woXFwke2Rlc2NyaXB0aW9ufSlcXGA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBuYW1lID0gdmFsLm5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyAmJiBuYW1lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcXGBGdW5jdGlvbihcXCR7bmFtZX0pXFxgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdGdW5jdGlvbic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb2JqZWN0c1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdmFsLmxlbmd0aDtcbiAgICAgICAgbGV0IGRlYnVnID0gJ1snO1xuICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGVidWcgKz0gZGVidWdTdHJpbmcodmFsWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRlYnVnICs9ICcsICcgKyBkZWJ1Z1N0cmluZyh2YWxbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnICs9ICddJztcbiAgICAgICAgcmV0dXJuIGRlYnVnO1xuICAgIH1cbiAgICAvLyBUZXN0IGZvciBidWlsdC1pblxuICAgIGNvbnN0IGJ1aWx0SW5NYXRjaGVzID0gL1xcXFxbb2JqZWN0IChbXlxcXFxdXSspXFxcXF0vLmV4ZWModG9TdHJpbmcuY2FsbCh2YWwpKTtcbiAgICBsZXQgY2xhc3NOYW1lO1xuICAgIGlmIChidWlsdEluTWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IGJ1aWx0SW5NYXRjaGVzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZhaWxlZCB0byBtYXRjaCB0aGUgc3RhbmRhcmQgJ1tvYmplY3QgQ2xhc3NOYW1lXSdcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKTtcbiAgICB9XG4gICAgaWYgKGNsYXNzTmFtZSA9PSAnT2JqZWN0Jykge1xuICAgICAgICAvLyB3ZSdyZSBhIHVzZXIgZGVmaW5lZCBjbGFzcyBvciBPYmplY3RcbiAgICAgICAgLy8gSlNPTi5zdHJpbmdpZnkgYXZvaWRzIHByb2JsZW1zIHdpdGggY3ljbGVzLCBhbmQgaXMgZ2VuZXJhbGx5IG11Y2hcbiAgICAgICAgLy8gZWFzaWVyIHRoYW4gbG9vcGluZyB0aHJvdWdoIG93blByb3BlcnRpZXMgb2YgXFxgdmFsXFxgLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICdPYmplY3QoJyArIEpTT04uc3RyaW5naWZ5KHZhbCkgKyAnKSc7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiAnT2JqZWN0JztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlcnJvcnNcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFxcYFxcJHt2YWwubmFtZX06IFxcJHt2YWwubWVzc2FnZX1cXFxcblxcJHt2YWwuc3RhY2t9XFxgO1xuICAgIH1cbiAgICAvLyBUT0RPIHdlIGNvdWxkIHRlc3QgZm9yIG1vcmUgdGhpbmdzIGhlcmUsIGxpa2UgXFxgU2V0XFxgcyBhbmQgXFxgTWFwXFxgcy5cbiAgICByZXR1cm4gY2xhc3NOYW1lO1xufVxuXG5mdW5jdGlvbiBtYWtlQ2xvc3VyZShhcmcwLCBhcmcxLCBkdG9yLCBmKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB7IGE6IGFyZzAsIGI6IGFyZzEsIGNudDogMSwgZHRvciB9O1xuICAgIGNvbnN0IHJlYWwgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAvLyBGaXJzdCB1cCB3aXRoIGEgY2xvc3VyZSB3ZSBpbmNyZW1lbnQgdGhlIGludGVybmFsIHJlZmVyZW5jZVxuICAgICAgICAvLyBjb3VudC4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIFJ1c3QgY2xvc3VyZSBlbnZpcm9ubWVudCB3b24ndFxuICAgICAgICAvLyBiZSBkZWFsbG9jYXRlZCB3aGlsZSB3ZSdyZSBpbnZva2luZyBpdC5cbiAgICAgICAgc3RhdGUuY250Kys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZihzdGF0ZS5hLCBzdGF0ZS5iLCAuLi5hcmdzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICgtLXN0YXRlLmNudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfMi5nZXQoc3RhdGUuZHRvcikoc3RhdGUuYSwgc3RhdGUuYik7XG4gICAgICAgICAgICAgICAgc3RhdGUuYSA9IDA7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmVhbC5vcmlnaW5hbCA9IHN0YXRlO1xuXG4gICAgcmV0dXJuIHJlYWw7XG59XG5mdW5jdGlvbiBfX3diZ19hZGFwdGVyXzUwKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICB3YXNtLl9keW5fY29yZV9fb3BzX19mdW5jdGlvbl9fRm5fX0FfX19fT3V0cHV0X19fUl9hc193YXNtX2JpbmRnZW5fX2Nsb3N1cmVfX1dhc21DbG9zdXJlX19fZGVzY3JpYmVfX2ludm9rZV9faGU4ZGI1ZmExNjc3MDZhMDkoYXJnMCwgYXJnMSwgYWRkSGVhcE9iamVjdChhcmcyKSk7XG59XG5cbmZ1bmN0aW9uIF9fd2JnX2FkYXB0ZXJfNTMoYXJnMCwgYXJnMSkge1xuICAgIHdhc20uX2R5bl9jb3JlX19vcHNfX2Z1bmN0aW9uX19Gbl9fX19fT3V0cHV0X19fUl9hc193YXNtX2JpbmRnZW5fX2Nsb3N1cmVfX1dhc21DbG9zdXJlX19fZGVzY3JpYmVfX2ludm9rZV9faGVkNTQwYzg4NDU0ZGYwMzEoYXJnMCwgYXJnMSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VNdXRDbG9zdXJlKGFyZzAsIGFyZzEsIGR0b3IsIGYpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHsgYTogYXJnMCwgYjogYXJnMSwgY250OiAxLCBkdG9yIH07XG4gICAgY29uc3QgcmVhbCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIC8vIEZpcnN0IHVwIHdpdGggYSBjbG9zdXJlIHdlIGluY3JlbWVudCB0aGUgaW50ZXJuYWwgcmVmZXJlbmNlXG4gICAgICAgIC8vIGNvdW50LiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgUnVzdCBjbG9zdXJlIGVudmlyb25tZW50IHdvbid0XG4gICAgICAgIC8vIGJlIGRlYWxsb2NhdGVkIHdoaWxlIHdlJ3JlIGludm9raW5nIGl0LlxuICAgICAgICBzdGF0ZS5jbnQrKztcbiAgICAgICAgY29uc3QgYSA9IHN0YXRlLmE7XG4gICAgICAgIHN0YXRlLmEgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGYoYSwgc3RhdGUuYiwgLi4uYXJncyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoLS1zdGF0ZS5jbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIuZ2V0KHN0YXRlLmR0b3IpKGEsIHN0YXRlLmIpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLmEgPSBhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZWFsLm9yaWdpbmFsID0gc3RhdGU7XG5cbiAgICByZXR1cm4gcmVhbDtcbn1cbmZ1bmN0aW9uIF9fd2JnX2FkYXB0ZXJfNTYoYXJnMCwgYXJnMSkge1xuICAgIHdhc20uX2R5bl9jb3JlX19vcHNfX2Z1bmN0aW9uX19Gbk11dF9fX19fT3V0cHV0X19fUl9hc193YXNtX2JpbmRnZW5fX2Nsb3N1cmVfX1dhc21DbG9zdXJlX19fZGVzY3JpYmVfX2ludm9rZV9faGMxODJlNGQ1MDM1NDE5NmIoYXJnMCwgYXJnMSk7XG59XG5cbmZ1bmN0aW9uIF9fd2JnX2FkYXB0ZXJfNTkoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICB3YXNtLl9keW5fY29yZV9fb3BzX19mdW5jdGlvbl9fRm5NdXRfX0FfX19fT3V0cHV0X19fUl9hc193YXNtX2JpbmRnZW5fX2Nsb3N1cmVfX1dhc21DbG9zdXJlX19fZGVzY3JpYmVfX2ludm9rZV9faDdjYmMzYzMyMjk2MzcwNmYocmV0cHRyLCBhcmcwLCBhcmcxLCBhZGRIZWFwT2JqZWN0KGFyZzIpKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX193YmdfYWRhcHRlcl82MihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgd2FzbS5fZHluX2NvcmVfX29wc19fZnVuY3Rpb25fX0ZuTXV0X19BX19fX091dHB1dF9fX1JfYXNfd2FzbV9iaW5kZ2VuX19jbG9zdXJlX19XYXNtQ2xvc3VyZV9fX2Rlc2NyaWJlX19pbnZva2VfX2gzNzA5ODA4ZmYxNzQxOTE0KGFyZzAsIGFyZzEsIGFkZEhlYXBPYmplY3QoYXJnMikpO1xufVxuXG5mdW5jdGlvbiBfX3diZ19hZGFwdGVyXzY1KGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICB3YXNtLl9keW5fY29yZV9fb3BzX19mdW5jdGlvbl9fRm5NdXRfX0FfX19fT3V0cHV0X19fUl9hc193YXNtX2JpbmRnZW5fX2Nsb3N1cmVfX1dhc21DbG9zdXJlX19fZGVzY3JpYmVfX2ludm9rZV9faDZjNjE2MWFhY2Q2NjQ0NzkoYXJnMCwgYXJnMSwgYWRkSGVhcE9iamVjdChhcmcyKSk7XG59XG5cbmZ1bmN0aW9uIF9fd2JnX2FkYXB0ZXJfNjgoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIHdhc20uX2R5bl9jb3JlX19vcHNfX2Z1bmN0aW9uX19Gbk11dF9fQV9fX19PdXRwdXRfX19SX2FzX3dhc21fYmluZGdlbl9fY2xvc3VyZV9fV2FzbUNsb3N1cmVfX19kZXNjcmliZV9faW52b2tlX19oNjhhYTk3ZDExM2VlMzYwYyhhcmcwLCBhcmcxLCBhZGRIZWFwT2JqZWN0KGFyZzIpKTtcbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBjb25maWdfanNvblxuKiBAcmV0dXJucyB7c3RyaW5nfVxuKi9cbmZ1bmN0aW9uIGNvcmVfY3JlYXRlX2NvbnRleHQoY29uZmlnX2pzb24pIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGNvbmZpZ19qc29uLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uY29yZV9jcmVhdGVfY29udGV4dChyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHIwLCByMSk7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtudW1iZXJ9IGNvbnRleHRcbiovXG5mdW5jdGlvbiBjb3JlX2Rlc3Ryb3lfY29udGV4dChjb250ZXh0KSB7XG4gICAgd2FzbS5jb3JlX2Rlc3Ryb3lfY29udGV4dChjb250ZXh0KTtcbn1cblxuLyoqXG4qIEBwYXJhbSB7bnVtYmVyfSBjb250ZXh0XG4qIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbl9uYW1lXG4qIEBwYXJhbSB7YW55fSBwYXJhbXNcbiogQHBhcmFtIHtudW1iZXJ9IHJlcXVlc3RfaWRcbiovXG5mdW5jdGlvbiBjb3JlX3JlcXVlc3QoY29udGV4dCwgZnVuY3Rpb25fbmFtZSwgcGFyYW1zLCByZXF1ZXN0X2lkKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChmdW5jdGlvbl9uYW1lLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uY29yZV9yZXF1ZXN0KHJldHB0ciwgY29udGV4dCwgcHRyMCwgbGVuMCwgYWRkSGVhcE9iamVjdChwYXJhbXMpLCByZXF1ZXN0X2lkKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZiwgYXJncykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4bl9zdG9yZShhZGRIZWFwT2JqZWN0KGUpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5VThGcm9tV2FzbTAocHRyLCBsZW4pIHtcbiAgICByZXR1cm4gZ2V0VWludDhNZW1vcnkwKCkuc3ViYXJyYXkocHRyIC8gMSwgcHRyIC8gMSArIGxlbik7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWQobW9kdWxlLCBpbXBvcnRzKSB7XG4gICAgaWYgKHR5cGVvZiBSZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJyAmJiBtb2R1bGUgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhtb2R1bGUsIGltcG9ydHMpO1xuXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgIT0gJ2FwcGxpY2F0aW9uL3dhc20nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlxcYFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nXFxgIGZhaWxlZCBiZWNhdXNlIHlvdXIgc2VydmVyIGRvZXMgbm90IHNlcnZlIHdhc20gd2l0aCBcXGBhcHBsaWNhdGlvbi93YXNtXFxgIE1JTUUgdHlwZS4gRmFsbGluZyBiYWNrIHRvIFxcYFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlXFxgIHdoaWNoIGlzIHNsb3dlci4gT3JpZ2luYWwgZXJyb3I6XFxcXG5cIiwgZSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgbW9kdWxlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShieXRlcywgaW1wb3J0cyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKG1vZHVsZSwgaW1wb3J0cyk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGluc3RhbmNlLCBtb2R1bGUgfTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRJbXBvcnRzKCkge1xuICAgIGNvbnN0IGltcG9ydHMgPSB7fTtcbiAgICBpbXBvcnRzLndiZyA9IHt9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld184ZDJhZjAwYmMxZTMyOWVlID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgRXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fc3RyaW5nX25ldyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9tZW1vcnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5tZW1vcnk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19idWZmZXJfM2YzZDc2NGQ0NzQ3ZDU2NCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2Q5YWEyNjY3MDNjYjk4YmUgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBVaW50OEFycmF5KGdldE9iamVjdChhcmcwKSwgYXJnMSA+Pj4gMCwgYXJnMiA+Pj4gMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX29iamVjdF9kcm9wX3JlZiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgdGFrZU9iamVjdChhcmcwKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld3dpdGhsZW5ndGhfN2M0MmY3ZTczOGE5ZDVkMyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEFycmF5KGFyZzAgPj4+IDApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X2E2ODIxNGYzNWM0MTdmYTkgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKVthcmcxID4+PiAwXSA9IHRha2VPYmplY3QoYXJnMik7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXd3aXRodThhcnJheXNlcXVlbmNlX2Y4NjMyNDZhZjgzZTE3ODUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBCbG9iKGdldE9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldF83NjUyMDE1NDRhMmI2ODY5ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBSZWZsZWN0LmdldChnZXRPYmplY3QoYXJnMCksIGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luc3RhbmNlb2ZfQXJyYXlCdWZmZXJfZTVlNDhmNDc2MmM1NjEwYiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGdldE9iamVjdChhcmcwKSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5faXNfb2JqZWN0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCB2YWwgPSBnZXRPYmplY3QoYXJnMCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfOGMzZjAwNTIyNzJhNDU3YSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fb2JqZWN0X2Nsb25lX3JlZiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfa2V5c18wNzAyMjk0YWZhZWI2MDQ0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBPYmplY3Qua2V5cyhnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbGVuZ3RoXzZlM2JiZTdjOGJkNGRiZDggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5sZW5ndGg7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRfNTcyNDVjYzdkN2M3NjE5ZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApW2FyZzEgPj4+IDBdO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9zdHJpbmdfZ2V0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCBvYmogPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZihvYmopID09PSAnc3RyaW5nJyA/IG9iaiA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKHJldCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDFdID0gbGVuMDtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAwXSA9IHB0cjA7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXcwX2E1NzA1OWQ3MmM1YjdhZWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFRpbWVfY2I4MmFkYjI1NTZlZDEzZSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fanN2YWxfbG9vc2VfZXEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKSA9PSBnZXRPYmplY3QoYXJnMSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Jvb2xlYW5fZ2V0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCB2ID0gZ2V0T2JqZWN0KGFyZzApO1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YodikgPT09ICdib29sZWFuJyA/ICh2ID8gMSA6IDApIDogMjtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5faXNfYmlnaW50ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YoZ2V0T2JqZWN0KGFyZzApKSA9PT0gJ2JpZ2ludCc7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX251bWJlcl9nZXQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKG9iaikgPT09ICdudW1iZXInID8gb2JqIDogdW5kZWZpbmVkO1xuICAgICAgICBnZXRGbG9hdDY0TWVtb3J5MCgpW2FyZzAgLyA4ICsgMV0gPSBpc0xpa2VOb25lKHJldCkgPyAwIDogcmV0O1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gIWlzTGlrZU5vbmUocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2lzU2FmZUludGVnZXJfZGZhMDU5M2U4ZDdhYzM1YSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gTnVtYmVyLmlzU2FmZUludGVnZXIoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fYmlnaW50X2dldF9hc19pNjQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHYgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZih2KSA9PT0gJ2JpZ2ludCcgPyB2IDogdW5kZWZpbmVkO1xuICAgICAgICBnZXRCaWdJbnQ2NE1lbW9yeTAoKVthcmcwIC8gOCArIDFdID0gaXNMaWtlTm9uZShyZXQpID8gMG4gOiByZXQ7XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMF0gPSAhaXNMaWtlTm9uZShyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9iaWdpbnRfZnJvbV9pNjQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGFyZzA7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2pzdmFsX2VxID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkgPT09IGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fYmlnaW50X2Zyb21fdTY0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBCaWdJbnQuYXNVaW50Tig2NCwgYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Vycm9yX25ldyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEVycm9yKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pc0FycmF5XzI3YzQ2YzY3ZjQ5OGUxNWQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEFycmF5LmlzQXJyYXkoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2l0ZXJhdG9yXzZmOWQ0ZjI4ODQ1ZjQyNmMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gU3ltYm9sLml0ZXJhdG9yO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pbiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApIGluIGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2VudHJpZXNfNjVhNzZhNDEzZmM5MTAzNyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gT2JqZWN0LmVudHJpZXMoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5faXNfdW5kZWZpbmVkID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5faXNfbnVsbCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApID09PSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfU3RyaW5nXzkxZmJhN2RlZDEzYmE1NGMgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFN0cmluZyhnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gcHRyMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fbnVtYmVyX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gYXJnMDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld18wYjliZmRkOTc1ODMyODRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBPYmplY3QoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX1N0cmluZ18zMzA5OTg1NmU4YTgyNDZhID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBTdHJpbmcoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDFdID0gbGVuMDtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAwXSA9IHB0cjA7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jb3JlcmVzcG9uc2VoYW5kbGVyX2E1Mjg3OTQ1NGM2MGM3NjQgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGNvcmVfcmVzcG9uc2VfaGFuZGxlcihhcmcwID4+PiAwLCB0YWtlT2JqZWN0KGFyZzEpLCBhcmcyID4+PiAwLCBhcmczICE9PSAwKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX21lc3NhZ2VfZmUyYWY2M2NjYzg5ODViYyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfMWQ5YTkyMGM2YmZjNDRhOCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld18yNjhmN2I3ZGQzNDMwNzk4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBNYXAoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF85MzM3MjljZjViNjZhYzExID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuc2V0KGdldE9iamVjdChhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5faXNfc3RyaW5nID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YoZ2V0T2JqZWN0KGFyZzApKSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfZmJjMzNkMDIwZjUwN2I3MiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApW3Rha2VPYmplY3QoYXJnMSldID0gdGFrZU9iamVjdChhcmcyKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Byb2Nlc3NfMGNjMmFkYTg1MjRkNmY4MyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnByb2Nlc3M7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ192ZXJzaW9uc19jMTFhY2NlYWIyN2E2Yzg3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudmVyc2lvbnM7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ub2RlXzdmZjFjZTQ5Y2FmMjM4MTUgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5ub2RlO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3RhdGljX2FjY2Vzc29yX05PREVfTU9EVUxFX2NmNjQwMWNjMTA5MTI3OWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbW9kdWxlO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVxdWlyZV9hNzQ2ZTc5YjMyMmI5MzM2ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkucmVxdWlyZShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jcnlwdG9fMjAzNmJlZDdjNDRjMjVlNyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNyeXB0bztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX21zQ3J5cHRvX2EyMWZjODhjYWYxZWNkYzggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5tc0NyeXB0bztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld3dpdGhsZW5ndGhfZjU5MzM4NTVlNGY0OGExOSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoYXJnMCA+Pj4gMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190cmFuc2FjdGlvbl9jY2U5NmNiZWJkODFmZTFjID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudHJhbnNhY3Rpb24oZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpLCB0YWtlT2JqZWN0KGFyZzMpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0b25jb21wbGV0ZV8zZTU3YThjZWM4MzI3ZjY2ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub25jb21wbGV0ZSA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldG9uZXJyb3JfMDAwNTFjMDIxM2YyN2IyYyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9uZXJyb3IgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRvbmFib3J0XzQwNGJlZTNiOTk0MGQwM2QgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbmFib3J0ID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaXRlbV81MmE2YmVjMzYzMTQ2ODdiID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMSkuaXRlbShhcmcyID4+PiAwKTtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKHJldCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDFdID0gbGVuMDtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAwXSA9IHB0cjA7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19vYmplY3RTdG9yZV9mMTc5NzZiMGU2Mzc3ODMwID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkub2JqZWN0U3RvcmUoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdGFyZ2V0X2JmNzA0YjdkYjdhZDEzODcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS50YXJnZXQ7XG4gICAgICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAwIDogYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVhZHlTdGF0ZV9mYjI4N2YxNzAxMTM5MTdjID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkucmVhZHlTdGF0ZTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldG9uc3VjY2Vzc181ZjcxNTkzYmM1MTY1M2EzID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub25zdWNjZXNzID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0b25lcnJvcl9kNTc3MWNjNWJmOWVhNzRjID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub25lcnJvciA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2JfZHJvcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3Qgb2JqID0gdGFrZU9iamVjdChhcmcwKS5vcmlnaW5hbDtcbiAgICAgICAgaWYgKG9iai5jbnQtLSA9PSAxKSB7XG4gICAgICAgICAgICBvYmouYSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25leHRfYWFlZjdjOGFhNWUyMTJhYyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZG9uZV8xYjczYjA2NzJlMTVmMjM0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZG9uZTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3ZhbHVlXzFjY2MzNmJjMDM0NjJkNzEgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5faXNfZnVuY3Rpb24gPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZihnZXRPYmplY3QoYXJnMCkpID09PSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY2FsbF85N2FlOWQ4NjQ1ZGMzODhiID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuY2FsbChnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXh0XzU3OWU1ODNkMzM1NjZhODYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5uZXh0O1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2VsZl82ZDQ3OTUwNmY3MmM2YTcxID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHNlbGYuc2VsZjtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfd2luZG93X2YyNTU3Y2M3ODQ5MGFjZWIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2luZG93LndpbmRvdztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2xvYmFsVGhpc183ZjIwNmJkYTYyOGQ1Mjg2ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdsb2JhbFRoaXMuZ2xvYmFsVGhpcztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2xvYmFsX2JhNzVjNTBkMWNmMzg0ZjQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2xvYmFsLmdsb2JhbDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3bm9hcmdzX2I1YjA2M2ZjNmMyZjAzNzYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBGdW5jdGlvbihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0XzgzZGI5NjkwZjkzNTNlNzkgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5zZXQoZ2V0T2JqZWN0KGFyZzEpLCBhcmcyID4+PiAwKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2xlbmd0aF85ZTFhZTE5MDBjYjBmYmQ1ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X2JmM2Y4OWI5MmQ1YTM0YmYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFJlZmxlY3Quc2V0KGdldE9iamVjdChhcmcwKSwgZ2V0T2JqZWN0KGFyZzEpLCBnZXRPYmplY3QoYXJnMikpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZWxmXzdlZWRlMWY0NDg4YmYzNDYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gc2VsZi5zZWxmO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jcnlwdG9fYzkwOWZiNDI4ZGNiZGRiNiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNyeXB0bztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX21zQ3J5cHRvXzUxMWVlZmVmYmZjNzBhZTQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5tc0NyeXB0bztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9NT0RVTEVfZWYzYWEyZWIyNTExNThhNSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBtb2R1bGU7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZXF1aXJlXzkwMGQ1YzM5ODRmZTc3MDMgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5yZXF1aXJlKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRSYW5kb21WYWx1ZXNfMzA3MDQ5MzQ1ZDBiZDg4YyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmdldFJhbmRvbVZhbHVlcztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3JhbmRvbUZpbGxTeW5jXzg1YjNmNGM1MmM1NmMzMTMgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5yYW5kb21GaWxsU3luYyhnZXRBcnJheVU4RnJvbVdhc20wKGFyZzEsIGFyZzIpKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N1YmFycmF5XzU4YWQ0ZWZiYjViY2I4ODYgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5zdWJhcnJheShhcmcxID4+PiAwLCBhcmcyID4+PiAwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFJhbmRvbVZhbHVlc19jZDE3NTkxNTUxMWY3MDVlID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuZ2V0UmFuZG9tVmFsdWVzKGdldE9iamVjdChhcmcxKSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yYW5kb21GaWxsU3luY18wNjVhZmZmZGUwMWRhYTY2ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkucmFuZG9tRmlsbFN5bmMoZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcxLCBhcmcyKSk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFJhbmRvbVZhbHVlc19iOTllZWM0MjQ0YTQ3NWJiID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuZ2V0UmFuZG9tVmFsdWVzKGdldE9iamVjdChhcmcxKSk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luc3RhbmNlb2ZfVWludDhBcnJheV85NzFlZWRhNjllYjc1MDAzID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZ2V0T2JqZWN0KGFyZzApIGluc3RhbmNlb2YgVWludDhBcnJheTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19wdXRfODRlN2ZjOTNlZWUyN2IyOCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnB1dChnZXRPYmplY3QoYXJnMSksIGdldE9iamVjdChhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2RlbGV0ZV84YWJlZGQxMDQzYjQxMDVkID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZGVsZXRlKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldFRpbWVvdXRfZDZmY2YwZDkwNjdiOGU2NCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnNldFRpbWVvdXQoZ2V0T2JqZWN0KGFyZzEpLCBhcmcyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY2xlYXJUaW1lb3V0XzdkNmY3YmZlZWQzNGIzNDggPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5jbGVhclRpbWVvdXQoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXd3aXRoc3RyYW5kaW5pdF8wNWQ3MTgwNzg4NDIwYzQwID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgUmVxdWVzdChnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSksIGdldE9iamVjdChhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2hlYWRlcnNfODU4MjRlOTkzYWE3MzliZiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmhlYWRlcnM7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfOTkyYzFkMzE1ODZiMjk1NyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnNldChnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMiksIGdldFN0cmluZ0Zyb21XYXNtMChhcmczLCBhcmc0KSk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2ZldGNoXzBmZTA0OTA1Y2NjZmMyYWEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5mZXRjaChnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zdGFuY2VvZl9SZXNwb25zZV9lYWE0MjYyMjA4NDhhMzllID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZ2V0T2JqZWN0KGFyZzApIGluc3RhbmNlb2YgUmVzcG9uc2U7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3RhdHVzX2M0ZWYzZGQ1OTFlNjM0MzUgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5zdGF0dXM7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ191cmxfNzQyODVkZGYyNzQ3Y2IzZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzEpLnVybDtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDFdID0gbGVuMDtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAwXSA9IHB0cjA7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRvbnZlcnNpb25jaGFuZ2VfODQwZDY1Y2QwODg4ZGZiMCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9udmVyc2lvbmNoYW5nZSA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldG9udXBncmFkZW5lZWRlZF8xN2QwYjk1MzBmMWUwY2FjID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub251cGdyYWRlbmVlZGVkID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0b25ibG9ja2VkX2U2NmQ2YmU1Yzg3OTk4MGQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbmJsb2NrZWQgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19tZXNzYWdlX2E3YWYzZWUwY2MwZmUyOGQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcxKS5tZXNzYWdlO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gcHRyMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX1dpbmRvd181Njg0MzQxZmY2ZGZlM2FkID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuV2luZG93O1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfV29ya2VyR2xvYmFsU2NvcGVfZTA0NDdmZmNhZThiYjI3MiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLldvcmtlckdsb2JhbFNjb3BlO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5kZXhlZERCXzA1MGYwOTYyYWI2MDdhYzUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5pbmRleGVkREI7XG4gICAgICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAwIDogYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbmRleGVkREJfOGQ5ZTlhYjQ2MTZkZjdmMCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmluZGV4ZWREQjtcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX29wZW5fYTMxYzNmZTFmZGMyNDRlYiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm9wZW4oZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3d2l0aHN0cl9kNWI1ZjliOTg1ZWU4NGZiID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgV2ViU29ja2V0KGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzIsIGFyZzMpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3X2QyOWU1MDdmNjYwNmRlOTEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBXZWJTb2NrZXQoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0b25tZXNzYWdlX2M1YTgwNmI2MmEwYzU2MDcgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbm1lc3NhZ2UgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRvbm9wZW5fOWNlNDhkY2U1N2U1NDliNSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9ub3BlbiA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldG9uZXJyb3JfMDIzOTMyNjBiM2UyOTk3MiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9uZXJyb3IgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZW5kXzgwYjI1NmQ4N2E2Nzc5ZTUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5zZW5kKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2RhdGFfN2IxZjAxZjRlNmE2NGZiZSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmRhdGE7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdHJpbmdpZnlfZDY0NzFkMzAwZGVkOWI2OCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gSlNPTi5zdHJpbmdpZnkoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfb2JqZWN0U3RvcmVOYW1lc184YzA2YzQwZDJiMDUxNDFjID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkub2JqZWN0U3RvcmVOYW1lcztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NyZWF0ZU9iamVjdFN0b3JlX2QzZTI3ODljMTNkZGUxZmMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5jcmVhdGVPYmplY3RTdG9yZShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbnN0YW5jZW9mX0Vycm9yXzU2YjQ5NmExMGE1NmRlNjYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBnZXRPYmplY3QoYXJnMCkgaW5zdGFuY2VvZiBFcnJvcjtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRUaW1lem9uZU9mZnNldF84OWJkNDI3NWUxY2E4MzQxID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fZGVidWdfc3RyaW5nID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBkZWJ1Z1N0cmluZyhnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gcHRyMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fdGhyb3cgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdGhlbl9jZWRhZDIwZmJiZDk0MThhID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudGhlbihnZXRPYmplY3QoYXJnMSksIGdldE9iamVjdChhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZXNvbHZlXzk5ZmUxNzk2NGYzMWZmYzAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFByb21pc2UucmVzb2x2ZShnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdGhlbl8xMWY3YTU0ZDY3YjRiZmFkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudGhlbihnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVzdWx0XzllMzk5YzE0Njc2OTcwZDkgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5yZXN1bHQ7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2Vycm9yX2FhY2Y1YWMxOTFlNTRlZDAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5lcnJvcjtcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldF82Mjg1YmY0NThhMWVlNzU4ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZ2V0KGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luc3RhbmNlb2ZfV2luZG93X2FjYzk3ZmY5ZjVkMmM3YjQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2Nsb3NlXzQ1ZDA1M2JlYTU5ZTc3NDYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5jbG9zZSgpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190ZXh0XzExNjlkNzUyY2M2OTc5MDMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS50ZXh0KCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2xvc3VyZV93cmFwcGVyOTQ3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBtYWtlQ2xvc3VyZShhcmcwLCBhcmcxLCA0NCwgX193YmdfYWRhcHRlcl81MCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nsb3N1cmVfd3JhcHBlcjk1OCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbWFrZUNsb3N1cmUoYXJnMCwgYXJnMSwgNDcsIF9fd2JnX2FkYXB0ZXJfNTMpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jbG9zdXJlX3dyYXBwZXI2MTU5ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCAyMzgsIF9fd2JnX2FkYXB0ZXJfNTYpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jbG9zdXJlX3dyYXBwZXI2ODI0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCAyNDcsIF9fd2JnX2FkYXB0ZXJfNTkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jbG9zdXJlX3dyYXBwZXI2ODc0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCAyNDQsIF9fd2JnX2FkYXB0ZXJfNjIpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jbG9zdXJlX3dyYXBwZXI2ODc1ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCAxMjA2LCBfX3diZ19hZGFwdGVyXzY1KTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2xvc3VyZV93cmFwcGVyNjg3NiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbWFrZU11dENsb3N1cmUoYXJnMCwgYXJnMSwgMjQxLCBfX3diZ19hZGFwdGVyXzY4KTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGltcG9ydHM7XG59XG5cbmZ1bmN0aW9uIGluaXRNZW1vcnkoaW1wb3J0cywgbWF5YmVfbWVtb3J5KSB7XG5cbn1cblxuZnVuY3Rpb24gZmluYWxpemVJbml0KGluc3RhbmNlLCBtb2R1bGUpIHtcbiAgICB3YXNtID0gaW5zdGFuY2UuZXhwb3J0cztcbiAgICBpbml0Ll9fd2JpbmRnZW5fd2FzbV9tb2R1bGUgPSBtb2R1bGU7XG4gICAgY2FjaGVkQmlnSW50NjRNZW1vcnkwID0gbmV3IEJpZ0ludDY0QXJyYXkoKTtcbiAgICBjYWNoZWRGbG9hdDY0TWVtb3J5MCA9IG5ldyBGbG9hdDY0QXJyYXkoKTtcbiAgICBjYWNoZWRJbnQzMk1lbW9yeTAgPSBuZXcgSW50MzJBcnJheSgpO1xuICAgIGNhY2hlZFVpbnQ4TWVtb3J5MCA9IG5ldyBVaW50OEFycmF5KCk7XG5cblxuICAgIHJldHVybiB3YXNtO1xufVxuXG5mdW5jdGlvbiBpbml0U3luYyhtb2R1bGUpIHtcbiAgICBjb25zdCBpbXBvcnRzID0gZ2V0SW1wb3J0cygpO1xuXG4gICAgaW5pdE1lbW9yeShpbXBvcnRzKTtcblxuICAgIGlmICghKG1vZHVsZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1vZHVsZSkpIHtcbiAgICAgICAgbW9kdWxlID0gbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShtb2R1bGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG1vZHVsZSwgaW1wb3J0cyk7XG5cbiAgICByZXR1cm4gZmluYWxpemVJbml0KGluc3RhbmNlLCBtb2R1bGUpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpbml0KGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcpIHsgICAgfVxuICAgIGNvbnN0IGltcG9ydHMgPSBnZXRJbXBvcnRzKCk7XG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCAodHlwZW9mIFJlcXVlc3QgPT09ICdmdW5jdGlvbicgJiYgaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB8fCAodHlwZW9mIFVSTCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnB1dCBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgaW5wdXQgPSBmZXRjaChpbnB1dCk7XG4gICAgfVxuXG4gICAgaW5pdE1lbW9yeShpbXBvcnRzKTtcblxuICAgIGNvbnN0IHsgaW5zdGFuY2UsIG1vZHVsZSB9ID0gYXdhaXQgbG9hZChhd2FpdCBpbnB1dCwgaW1wb3J0cyk7XG5cbiAgICByZXR1cm4gZmluYWxpemVJbml0KGluc3RhbmNlLCBtb2R1bGUpO1xufVxuXG5cbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFdSQVBQRVIgRU5EXG5cbmZ1bmN0aW9uIHJlcGxhY2VVbmRlZmluZWRXaXRoTnVsbHModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBbXSA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSByZXBsYWNlVW5kZWZpbmVkV2l0aE51bGxzKHZhbHVlW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbmZ1bmN0aW9uIGNvcmVfcmVzcG9uc2VfaGFuZGxlcihyZXF1ZXN0X2lkLCBwYXJhbXMsIHJlc3BvbnNlX3R5cGUsIGZpbmlzaGVkKSB7XG4gICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiAncmVzcG9uc2UnLFxuICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RfaWQsXG4gICAgICAgIHBhcmFtczogcmVwbGFjZVVuZGVmaW5lZFdpdGhOdWxscyhwYXJhbXMpLFxuICAgICAgICByZXNwb25zZVR5cGU6IHJlc3BvbnNlX3R5cGUsXG4gICAgICAgIGZpbmlzaGVkLFxuICAgIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXBsYWNlQmxvYnNXaXRoQXJyYXlCdWZmZXJzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdmFsdWUuYXJyYXlCdWZmZXIoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICBpZiAodmFsdWUgPCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJiB2YWx1ZSA+IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBbXSA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBhd2FpdCByZXBsYWNlQmxvYnNXaXRoQXJyYXlCdWZmZXJzKHZhbHVlW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuc2VsZi5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlLmRhdGE7XG4gICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICBjYXNlICdpbml0JzpcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IGluaXQobWVzc2FnZS53YXNtTW9kdWxlKTtcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZTogJ2luaXQnIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgJ2NyZWF0ZUNvbnRleHQnOlxuICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnY3JlYXRlQ29udGV4dCcsXG4gICAgICAgICAgICByZXN1bHQ6IGNvcmVfY3JlYXRlX2NvbnRleHQobWVzc2FnZS5jb25maWdKc29uKSxcbiAgICAgICAgICAgIHJlcXVlc3RJZDogbWVzc2FnZS5yZXF1ZXN0SWQsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgJ2Rlc3Ryb3lDb250ZXh0JzpcbiAgICAgICAgY29yZV9kZXN0cm95X2NvbnRleHQobWVzc2FnZS5jb250ZXh0KTtcbiAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2Rlc3Ryb3lDb250ZXh0J1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyZXF1ZXN0JzpcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvcmVfcmVxdWVzdChcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5mdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgYXdhaXQgcmVwbGFjZUJsb2JzV2l0aEFycmF5QnVmZmVycyhtZXNzYWdlLmZ1bmN0aW9uUGFyYW1zKSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnJlcXVlc3RJZCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5gO1xuXG5sZXQgb3B0aW9ucyA9IG51bGw7XG5cbmV4cG9ydCBmdW5jdGlvbiBsaWJXZWJTZXR1cChsaWJPcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGxpYk9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGRlYnVnTG9nKG1lc3NhZ2UpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnTG9nKSB7XG4gICAgICAgIG9wdGlvbnMuZGVidWdMb2cobWVzc2FnZSk7XG4gICAgfVxufVxuXG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRNb2R1bGUoKSB7XG4gICAgY29uc3Qgc3RhcnRMb2FkVGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IHdhc21Nb2R1bGU7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5sb2FkTW9kdWxlKSB7XG4gICAgICAgIHdhc21Nb2R1bGUgPSBhd2FpdCBvcHRpb25zLmxvYWRNb2R1bGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmV0Y2hlZCA9IGZldGNoKChvcHRpb25zICYmIG9wdGlvbnMuYmluYXJ5VVJMKSB8fCBcIi9ldmVyc2RrLndhc21cIik7XG4gICAgICAgIGlmIChXZWJBc3NlbWJseS5jb21waWxlU3RyZWFtaW5nKSB7XG4gICAgICAgICAgICBkZWJ1Z0xvZyhcImNvbXBpbGVTdHJlYW1pbmcgYmluYXJ5XCIpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5LmNvbXBpbGVTdHJlYW1pbmcoZmV0Y2hlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWdMb2coXCJjb21waWxlIGJpbmFyeVwiKTtcbiAgICAgICAgd2FzbU1vZHVsZSA9IGF3YWl0IFdlYkFzc2VtYmx5LmNvbXBpbGUoYXdhaXQgKGF3YWl0IGZldGNoZWQpLmFycmF5QnVmZmVyKCkpO1xuICAgIH1cbiAgICBhd2FpdCBpbml0KHdhc21Nb2R1bGUpO1xuICAgIGRlYnVnTG9nKGBjb21waWxlIHRpbWUgJHtEYXRlLm5vdygpIC0gc3RhcnRMb2FkVGltZX1gKTtcbn1cblxuZnVuY3Rpb24gd2l0aFNlcGFyYXRlV29ya2VyKCkge1xuICAgIGZ1bmN0aW9uIGRlYnVnTG9nKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1Z0xvZykge1xuICAgICAgICAgICAgb3B0aW9ucy5kZWJ1Z0xvZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHdvcmtlckJsb2IgPSBuZXcgQmxvYihcbiAgICAgICAgW3dvcmtlclNjcmlwdF0sXG4gICAgICAgIHsgdHlwZTogXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCIgfSxcbiAgICApO1xuICAgIGNvbnN0IHdvcmtlclVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwod29ya2VyQmxvYik7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVcmwpO1xuXG5cbiAgICBsZXQgbmV4dENyZWF0ZUNvbnRleHRSZXF1ZXN0SWQgPSAxO1xuICAgIGNvbnN0IGNyZWF0ZUNvbnRleHRSZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgaW5pdENvbXBsZXRlID0gZmFsc2U7XG5cbiAgICBsZXQgcmVzcG9uc2VIYW5kbGVyID0gbnVsbDtcblxuICAgIHdvcmtlci5vbm1lc3NhZ2UgPSAoZXZ0KSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBldnQuZGF0YTtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImluaXRcIjpcbiAgICAgICAgICAgIGluaXRDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtyZXF1ZXN0SWQsIHJlcXVlc3RdIG9mIGNyZWF0ZUNvbnRleHRSZXF1ZXN0cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNyZWF0ZUNvbnRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICBjb25maWdKc29uOiByZXF1ZXN0LmNvbmZpZ0pzb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNyZWF0ZUNvbnRleHRcIjpcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVDb250ZXh0UmVxdWVzdHMuZ2V0KG1lc3NhZ2UucmVxdWVzdElkKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlQ29udGV4dFJlcXVlc3RzLmRlbGV0ZShtZXNzYWdlLnJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNvbHZlKG1lc3NhZ2UucmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGVzdHJveUNvbnRleHRcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVzcG9uc2VcIjpcbiAgICAgICAgICAgIGlmIChyZXNwb25zZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZUhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXNwb25zZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmluaXNoZWQsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHdvcmtlci5vbmVycm9yID0gKGV2dCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3IgZnJvbSBXZWIgV29ya2VyOiAke2V2dC5tZXNzYWdlfWApO1xuICAgIH07XG5cbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJpbml0XCIsXG4gICAgICAgICAgICB3YXNtTW9kdWxlOiBhd2FpdCBsb2FkTW9kdWxlKCksXG4gICAgICAgIH0pO1xuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgc2V0UmVzcG9uc2VQYXJhbXNIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgcmVzcG9uc2VIYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlQ29udGV4dDogKGNvbmZpZ0pzb24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IG5leHRDcmVhdGVDb250ZXh0UmVxdWVzdElkO1xuICAgICAgICAgICAgICAgIG5leHRDcmVhdGVDb250ZXh0UmVxdWVzdElkICs9IDE7XG4gICAgICAgICAgICAgICAgY3JlYXRlQ29udGV4dFJlcXVlc3RzLnNldChyZXF1ZXN0SWQsIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnSnNvbixcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNyZWF0ZUNvbnRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0pzb24sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95Q29udGV4dDogKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJkZXN0cm95Q29udGV4dFwiLFxuICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZFJlcXVlc3RQYXJhbXM6IChjb250ZXh0LCByZXF1ZXN0SWQsIGZ1bmN0aW9uTmFtZSwgZnVuY3Rpb25QYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUGFyYW1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHdpdGhvdXRTZXBhcmF0ZVdvcmtlcigpIHtcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFdSQVBQRVIgQkVHSU5cblxubGV0IHdhc207XG5cbmNvbnN0IGNhY2hlZFRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgaWdub3JlQk9NOiB0cnVlLCBmYXRhbDogdHJ1ZSB9KTtcblxuY2FjaGVkVGV4dERlY29kZXIuZGVjb2RlKCk7XG5cbmxldCBjYWNoZWRVaW50OE1lbW9yeTAgPSBuZXcgVWludDhBcnJheSgpO1xuXG5mdW5jdGlvbiBnZXRVaW50OE1lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZFVpbnQ4TWVtb3J5MC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhY2hlZFVpbnQ4TWVtb3J5MCA9IG5ldyBVaW50OEFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRVaW50OE1lbW9yeTA7XG59XG5cbmZ1bmN0aW9uIGdldFN0cmluZ0Zyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHJldHVybiBjYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoZ2V0VWludDhNZW1vcnkwKCkuc3ViYXJyYXkocHRyLCBwdHIgKyBsZW4pKTtcbn1cblxuY29uc3QgaGVhcCA9IG5ldyBBcnJheSgzMikuZmlsbCh1bmRlZmluZWQpO1xuXG5oZWFwLnB1c2godW5kZWZpbmVkLCBudWxsLCB0cnVlLCBmYWxzZSk7XG5cbmxldCBoZWFwX25leHQgPSBoZWFwLmxlbmd0aDtcblxuZnVuY3Rpb24gYWRkSGVhcE9iamVjdChvYmopIHtcbiAgICBpZiAoaGVhcF9uZXh0ID09PSBoZWFwLmxlbmd0aCkgaGVhcC5wdXNoKGhlYXAubGVuZ3RoICsgMSk7XG4gICAgY29uc3QgaWR4ID0gaGVhcF9uZXh0O1xuICAgIGhlYXBfbmV4dCA9IGhlYXBbaWR4XTtcblxuICAgIGhlYXBbaWR4XSA9IG9iajtcbiAgICByZXR1cm4gaWR4O1xufVxuXG5mdW5jdGlvbiBnZXRPYmplY3QoaWR4KSB7IHJldHVybiBoZWFwW2lkeF07IH1cblxuZnVuY3Rpb24gZHJvcE9iamVjdChpZHgpIHtcbiAgICBpZiAoaWR4IDwgMzYpIHJldHVybjtcbiAgICBoZWFwW2lkeF0gPSBoZWFwX25leHQ7XG4gICAgaGVhcF9uZXh0ID0gaWR4O1xufVxuXG5mdW5jdGlvbiB0YWtlT2JqZWN0KGlkeCkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChpZHgpO1xuICAgIGRyb3BPYmplY3QoaWR4KTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5sZXQgV0FTTV9WRUNUT1JfTEVOID0gMDtcblxuY29uc3QgY2FjaGVkVGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoJ3V0Zi04Jyk7XG5cbmNvbnN0IGVuY29kZVN0cmluZyA9ICh0eXBlb2YgY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlSW50byA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZnVuY3Rpb24gKGFyZywgdmlldykge1xuICAgIHJldHVybiBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGVJbnRvKGFyZywgdmlldyk7XG59XG4gICAgOiBmdW5jdGlvbiAoYXJnLCB2aWV3KSB7XG4gICAgY29uc3QgYnVmID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlKGFyZyk7XG4gICAgdmlldy5zZXQoYnVmKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWFkOiBhcmcubGVuZ3RoLFxuICAgICAgICB3cml0dGVuOiBidWYubGVuZ3RoXG4gICAgfTtcbn0pO1xuXG5mdW5jdGlvbiBwYXNzU3RyaW5nVG9XYXNtMChhcmcsIG1hbGxvYywgcmVhbGxvYykge1xuXG4gICAgaWYgKHJlYWxsb2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBidWYgPSBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGUoYXJnKTtcbiAgICAgICAgY29uc3QgcHRyID0gbWFsbG9jKGJ1Zi5sZW5ndGgpO1xuICAgICAgICBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIsIHB0ciArIGJ1Zi5sZW5ndGgpLnNldChidWYpO1xuICAgICAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBidWYubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGxldCBsZW4gPSBhcmcubGVuZ3RoO1xuICAgIGxldCBwdHIgPSBtYWxsb2MobGVuKTtcblxuICAgIGNvbnN0IG1lbSA9IGdldFVpbnQ4TWVtb3J5MCgpO1xuXG4gICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICBmb3IgKDsgb2Zmc2V0IDwgbGVuOyBvZmZzZXQrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gYXJnLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgaWYgKGNvZGUgPiAweDdGKSBicmVhaztcbiAgICAgICAgbWVtW3B0ciArIG9mZnNldF0gPSBjb2RlO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXQgIT09IGxlbikge1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBwdHIgPSByZWFsbG9jKHB0ciwgbGVuLCBsZW4gPSBvZmZzZXQgKyBhcmcubGVuZ3RoICogMyk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIgKyBvZmZzZXQsIHB0ciArIGxlbik7XG4gICAgICAgIGNvbnN0IHJldCA9IGVuY29kZVN0cmluZyhhcmcsIHZpZXcpO1xuXG4gICAgICAgIG9mZnNldCArPSByZXQud3JpdHRlbjtcbiAgICB9XG5cbiAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHB0cjtcbn1cblxuZnVuY3Rpb24gaXNMaWtlTm9uZSh4KSB7XG4gICAgcmV0dXJuIHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsO1xufVxuXG5sZXQgY2FjaGVkSW50MzJNZW1vcnkwID0gbmV3IEludDMyQXJyYXkoKTtcblxuZnVuY3Rpb24gZ2V0SW50MzJNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWRJbnQzMk1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRJbnQzMk1lbW9yeTAgPSBuZXcgSW50MzJBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkSW50MzJNZW1vcnkwO1xufVxuXG5sZXQgY2FjaGVkRmxvYXQ2NE1lbW9yeTAgPSBuZXcgRmxvYXQ2NEFycmF5KCk7XG5cbmZ1bmN0aW9uIGdldEZsb2F0NjRNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWRGbG9hdDY0TWVtb3J5MC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhY2hlZEZsb2F0NjRNZW1vcnkwID0gbmV3IEZsb2F0NjRBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkRmxvYXQ2NE1lbW9yeTA7XG59XG5cbmxldCBjYWNoZWRCaWdJbnQ2NE1lbW9yeTAgPSBuZXcgQmlnSW50NjRBcnJheSgpO1xuXG5mdW5jdGlvbiBnZXRCaWdJbnQ2NE1lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZEJpZ0ludDY0TWVtb3J5MC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhY2hlZEJpZ0ludDY0TWVtb3J5MCA9IG5ldyBCaWdJbnQ2NEFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRCaWdJbnQ2NE1lbW9yeTA7XG59XG5cbmZ1bmN0aW9uIGRlYnVnU3RyaW5nKHZhbCkge1xuICAgIC8vIHByaW1pdGl2ZSB0eXBlc1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsO1xuICAgIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAgYCR7dmFsfWA7XG4gICAgfVxuICAgIGlmICh0eXBlID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBgXCIke3ZhbH1cImA7XG4gICAgfVxuICAgIGlmICh0eXBlID09ICdzeW1ib2wnKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdmFsLmRlc2NyaXB0aW9uO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdTeW1ib2wnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBTeW1ib2woJHtkZXNjcmlwdGlvbn0pYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB2YWwubmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnICYmIG5hbWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGBGdW5jdGlvbigke25hbWV9KWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Z1bmN0aW9uJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBvYmplY3RzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSB2YWwubGVuZ3RoO1xuICAgICAgICBsZXQgZGVidWcgPSAnWyc7XG4gICAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkZWJ1ZyArPSBkZWJ1Z1N0cmluZyh2YWxbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVidWcgKz0gJywgJyArIGRlYnVnU3RyaW5nKHZhbFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcgKz0gJ10nO1xuICAgICAgICByZXR1cm4gZGVidWc7XG4gICAgfVxuICAgIC8vIFRlc3QgZm9yIGJ1aWx0LWluXG4gICAgY29uc3QgYnVpbHRJbk1hdGNoZXMgPSAvXFxbb2JqZWN0IChbXlxcXV0rKVxcXS8uZXhlYyh0b1N0cmluZy5jYWxsKHZhbCkpO1xuICAgIGxldCBjbGFzc05hbWU7XG4gICAgaWYgKGJ1aWx0SW5NYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gYnVpbHRJbk1hdGNoZXNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmFpbGVkIHRvIG1hdGNoIHRoZSBzdGFuZGFyZCAnW29iamVjdCBDbGFzc05hbWVdJ1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpO1xuICAgIH1cbiAgICBpZiAoY2xhc3NOYW1lID09ICdPYmplY3QnKSB7XG4gICAgICAgIC8vIHdlJ3JlIGEgdXNlciBkZWZpbmVkIGNsYXNzIG9yIE9iamVjdFxuICAgICAgICAvLyBKU09OLnN0cmluZ2lmeSBhdm9pZHMgcHJvYmxlbXMgd2l0aCBjeWNsZXMsIGFuZCBpcyBnZW5lcmFsbHkgbXVjaFxuICAgICAgICAvLyBlYXNpZXIgdGhhbiBsb29waW5nIHRocm91Z2ggb3duUHJvcGVydGllcyBvZiBgdmFsYC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAnT2JqZWN0KCcgKyBKU09OLnN0cmluZ2lmeSh2YWwpICsgJyknO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gJ09iamVjdCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXJyb3JzXG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBgJHt2YWwubmFtZX06ICR7dmFsLm1lc3NhZ2V9XFxuJHt2YWwuc3RhY2t9YDtcbiAgICB9XG4gICAgLy8gVE9ETyB3ZSBjb3VsZCB0ZXN0IGZvciBtb3JlIHRoaW5ncyBoZXJlLCBsaWtlIGBTZXRgcyBhbmQgYE1hcGBzLlxuICAgIHJldHVybiBjbGFzc05hbWU7XG59XG5cbmZ1bmN0aW9uIG1ha2VDbG9zdXJlKGFyZzAsIGFyZzEsIGR0b3IsIGYpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHsgYTogYXJnMCwgYjogYXJnMSwgY250OiAxLCBkdG9yIH07XG4gICAgY29uc3QgcmVhbCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIC8vIEZpcnN0IHVwIHdpdGggYSBjbG9zdXJlIHdlIGluY3JlbWVudCB0aGUgaW50ZXJuYWwgcmVmZXJlbmNlXG4gICAgICAgIC8vIGNvdW50LiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgUnVzdCBjbG9zdXJlIGVudmlyb25tZW50IHdvbid0XG4gICAgICAgIC8vIGJlIGRlYWxsb2NhdGVkIHdoaWxlIHdlJ3JlIGludm9raW5nIGl0LlxuICAgICAgICBzdGF0ZS5jbnQrKztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmKHN0YXRlLmEsIHN0YXRlLmIsIC4uLmFyZ3MpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKC0tc3RhdGUuY250ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yLmdldChzdGF0ZS5kdG9yKShzdGF0ZS5hLCBzdGF0ZS5iKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hID0gMDtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZWFsLm9yaWdpbmFsID0gc3RhdGU7XG5cbiAgICByZXR1cm4gcmVhbDtcbn1cbmZ1bmN0aW9uIF9fd2JnX2FkYXB0ZXJfNTAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIHdhc20uX2R5bl9jb3JlX19vcHNfX2Z1bmN0aW9uX19Gbl9fQV9fX19PdXRwdXRfX19SX2FzX3dhc21fYmluZGdlbl9fY2xvc3VyZV9fV2FzbUNsb3N1cmVfX19kZXNjcmliZV9faW52b2tlX19oZThkYjVmYTE2NzcwNmEwOShhcmcwLCBhcmcxLCBhZGRIZWFwT2JqZWN0KGFyZzIpKTtcbn1cblxuZnVuY3Rpb24gX193YmdfYWRhcHRlcl81MyhhcmcwLCBhcmcxKSB7XG4gICAgd2FzbS5fZHluX2NvcmVfX29wc19fZnVuY3Rpb25fX0ZuX19fX19PdXRwdXRfX19SX2FzX3dhc21fYmluZGdlbl9fY2xvc3VyZV9fV2FzbUNsb3N1cmVfX19kZXNjcmliZV9faW52b2tlX19oZWQ1NDBjODg0NTRkZjAzMShhcmcwLCBhcmcxKTtcbn1cblxuZnVuY3Rpb24gbWFrZU11dENsb3N1cmUoYXJnMCwgYXJnMSwgZHRvciwgZikge1xuICAgIGNvbnN0IHN0YXRlID0geyBhOiBhcmcwLCBiOiBhcmcxLCBjbnQ6IDEsIGR0b3IgfTtcbiAgICBjb25zdCByZWFsID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgLy8gRmlyc3QgdXAgd2l0aCBhIGNsb3N1cmUgd2UgaW5jcmVtZW50IHRoZSBpbnRlcm5hbCByZWZlcmVuY2VcbiAgICAgICAgLy8gY291bnQuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBSdXN0IGNsb3N1cmUgZW52aXJvbm1lbnQgd29uJ3RcbiAgICAgICAgLy8gYmUgZGVhbGxvY2F0ZWQgd2hpbGUgd2UncmUgaW52b2tpbmcgaXQuXG4gICAgICAgIHN0YXRlLmNudCsrO1xuICAgICAgICBjb25zdCBhID0gc3RhdGUuYTtcbiAgICAgICAgc3RhdGUuYSA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZihhLCBzdGF0ZS5iLCAuLi5hcmdzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICgtLXN0YXRlLmNudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfMi5nZXQoc3RhdGUuZHRvcikoYSwgc3RhdGUuYik7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYSA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJlYWwub3JpZ2luYWwgPSBzdGF0ZTtcblxuICAgIHJldHVybiByZWFsO1xufVxuZnVuY3Rpb24gX193YmdfYWRhcHRlcl81NihhcmcwLCBhcmcxKSB7XG4gICAgd2FzbS5fZHluX2NvcmVfX29wc19fZnVuY3Rpb25fX0ZuTXV0X19fX19PdXRwdXRfX19SX2FzX3dhc21fYmluZGdlbl9fY2xvc3VyZV9fV2FzbUNsb3N1cmVfX19kZXNjcmliZV9faW52b2tlX19oYzE4MmU0ZDUwMzU0MTk2YihhcmcwLCBhcmcxKTtcbn1cblxuZnVuY3Rpb24gX193YmdfYWRhcHRlcl81OShhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIHdhc20uX2R5bl9jb3JlX19vcHNfX2Z1bmN0aW9uX19Gbk11dF9fQV9fX19PdXRwdXRfX19SX2FzX3dhc21fYmluZGdlbl9fY2xvc3VyZV9fV2FzbUNsb3N1cmVfX19kZXNjcmliZV9faW52b2tlX19oN2NiYzNjMzIyOTYzNzA2ZihyZXRwdHIsIGFyZzAsIGFyZzEsIGFkZEhlYXBPYmplY3QoYXJnMikpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfX3diZ19hZGFwdGVyXzYyKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICB3YXNtLl9keW5fY29yZV9fb3BzX19mdW5jdGlvbl9fRm5NdXRfX0FfX19fT3V0cHV0X19fUl9hc193YXNtX2JpbmRnZW5fX2Nsb3N1cmVfX1dhc21DbG9zdXJlX19fZGVzY3JpYmVfX2ludm9rZV9faDM3MDk4MDhmZjE3NDE5MTQoYXJnMCwgYXJnMSwgYWRkSGVhcE9iamVjdChhcmcyKSk7XG59XG5cbmZ1bmN0aW9uIF9fd2JnX2FkYXB0ZXJfNjUoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIHdhc20uX2R5bl9jb3JlX19vcHNfX2Z1bmN0aW9uX19Gbk11dF9fQV9fX19PdXRwdXRfX19SX2FzX3dhc21fYmluZGdlbl9fY2xvc3VyZV9fV2FzbUNsb3N1cmVfX19kZXNjcmliZV9faW52b2tlX19oNmM2MTYxYWFjZDY2NDQ3OShhcmcwLCBhcmcxLCBhZGRIZWFwT2JqZWN0KGFyZzIpKTtcbn1cblxuZnVuY3Rpb24gX193YmdfYWRhcHRlcl82OChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgd2FzbS5fZHluX2NvcmVfX29wc19fZnVuY3Rpb25fX0ZuTXV0X19BX19fX091dHB1dF9fX1JfYXNfd2FzbV9iaW5kZ2VuX19jbG9zdXJlX19XYXNtQ2xvc3VyZV9fX2Rlc2NyaWJlX19pbnZva2VfX2g2OGFhOTdkMTEzZWUzNjBjKGFyZzAsIGFyZzEsIGFkZEhlYXBPYmplY3QoYXJnMikpO1xufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZ19qc29uXG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZnVuY3Rpb24gY29yZV9jcmVhdGVfY29udGV4dChjb25maWdfanNvbikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY29uZmlnX2pzb24sIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5jb3JlX2NyZWF0ZV9jb250ZXh0KHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocjAsIHIxKTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge251bWJlcn0gY29udGV4dFxuKi9cbmZ1bmN0aW9uIGNvcmVfZGVzdHJveV9jb250ZXh0KGNvbnRleHQpIHtcbiAgICB3YXNtLmNvcmVfZGVzdHJveV9jb250ZXh0KGNvbnRleHQpO1xufVxuXG4vKipcbiogQHBhcmFtIHtudW1iZXJ9IGNvbnRleHRcbiogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uX25hbWVcbiogQHBhcmFtIHthbnl9IHBhcmFtc1xuKiBAcGFyYW0ge251bWJlcn0gcmVxdWVzdF9pZFxuKi9cbmZ1bmN0aW9uIGNvcmVfcmVxdWVzdChjb250ZXh0LCBmdW5jdGlvbl9uYW1lLCBwYXJhbXMsIHJlcXVlc3RfaWQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGZ1bmN0aW9uX25hbWUsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5jb3JlX3JlcXVlc3QocmV0cHRyLCBjb250ZXh0LCBwdHIwLCBsZW4wLCBhZGRIZWFwT2JqZWN0KHBhcmFtcyksIHJlcXVlc3RfaWQpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihmLCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhuX3N0b3JlKGFkZEhlYXBPYmplY3QoZSkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXlVOEZyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHJldHVybiBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIgLyAxLCBwdHIgLyAxICsgbGVuKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZChtb2R1bGUsIGltcG9ydHMpIHtcbiAgICBpZiAodHlwZW9mIFJlc3BvbnNlID09PSAnZnVuY3Rpb24nICYmIG1vZHVsZSBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKG1vZHVsZSwgaW1wb3J0cyk7XG5cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kdWxlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSAhPSAnYXBwbGljYXRpb24vd2FzbScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiYFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nYCBmYWlsZWQgYmVjYXVzZSB5b3VyIHNlcnZlciBkb2VzIG5vdCBzZXJ2ZSB3YXNtIHdpdGggYGFwcGxpY2F0aW9uL3dhc21gIE1JTUUgdHlwZS4gRmFsbGluZyBiYWNrIHRvIGBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZWAgd2hpY2ggaXMgc2xvd2VyLiBPcmlnaW5hbCBlcnJvcjpcXG5cIiwgZSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgbW9kdWxlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShieXRlcywgaW1wb3J0cyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKG1vZHVsZSwgaW1wb3J0cyk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGluc3RhbmNlLCBtb2R1bGUgfTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRJbXBvcnRzKCkge1xuICAgIGNvbnN0IGltcG9ydHMgPSB7fTtcbiAgICBpbXBvcnRzLndiZyA9IHt9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld184ZDJhZjAwYmMxZTMyOWVlID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgRXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fc3RyaW5nX25ldyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9tZW1vcnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5tZW1vcnk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19idWZmZXJfM2YzZDc2NGQ0NzQ3ZDU2NCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2Q5YWEyNjY3MDNjYjk4YmUgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBVaW50OEFycmF5KGdldE9iamVjdChhcmcwKSwgYXJnMSA+Pj4gMCwgYXJnMiA+Pj4gMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX29iamVjdF9kcm9wX3JlZiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgdGFrZU9iamVjdChhcmcwKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld3dpdGhsZW5ndGhfN2M0MmY3ZTczOGE5ZDVkMyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEFycmF5KGFyZzAgPj4+IDApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X2E2ODIxNGYzNWM0MTdmYTkgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKVthcmcxID4+PiAwXSA9IHRha2VPYmplY3QoYXJnMik7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXd3aXRodThhcnJheXNlcXVlbmNlX2Y4NjMyNDZhZjgzZTE3ODUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBCbG9iKGdldE9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldF83NjUyMDE1NDRhMmI2ODY5ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBSZWZsZWN0LmdldChnZXRPYmplY3QoYXJnMCksIGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luc3RhbmNlb2ZfQXJyYXlCdWZmZXJfZTVlNDhmNDc2MmM1NjEwYiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGdldE9iamVjdChhcmcwKSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5faXNfb2JqZWN0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCB2YWwgPSBnZXRPYmplY3QoYXJnMCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfOGMzZjAwNTIyNzJhNDU3YSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fb2JqZWN0X2Nsb25lX3JlZiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfa2V5c18wNzAyMjk0YWZhZWI2MDQ0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBPYmplY3Qua2V5cyhnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbGVuZ3RoXzZlM2JiZTdjOGJkNGRiZDggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5sZW5ndGg7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRfNTcyNDVjYzdkN2M3NjE5ZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApW2FyZzEgPj4+IDBdO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9zdHJpbmdfZ2V0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCBvYmogPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZihvYmopID09PSAnc3RyaW5nJyA/IG9iaiA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKHJldCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDFdID0gbGVuMDtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAwXSA9IHB0cjA7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXcwX2E1NzA1OWQ3MmM1YjdhZWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFRpbWVfY2I4MmFkYjI1NTZlZDEzZSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fanN2YWxfbG9vc2VfZXEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKSA9PSBnZXRPYmplY3QoYXJnMSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Jvb2xlYW5fZ2V0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCB2ID0gZ2V0T2JqZWN0KGFyZzApO1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YodikgPT09ICdib29sZWFuJyA/ICh2ID8gMSA6IDApIDogMjtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5faXNfYmlnaW50ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YoZ2V0T2JqZWN0KGFyZzApKSA9PT0gJ2JpZ2ludCc7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX251bWJlcl9nZXQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKG9iaikgPT09ICdudW1iZXInID8gb2JqIDogdW5kZWZpbmVkO1xuICAgICAgICBnZXRGbG9hdDY0TWVtb3J5MCgpW2FyZzAgLyA4ICsgMV0gPSBpc0xpa2VOb25lKHJldCkgPyAwIDogcmV0O1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gIWlzTGlrZU5vbmUocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2lzU2FmZUludGVnZXJfZGZhMDU5M2U4ZDdhYzM1YSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gTnVtYmVyLmlzU2FmZUludGVnZXIoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fYmlnaW50X2dldF9hc19pNjQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHYgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZih2KSA9PT0gJ2JpZ2ludCcgPyB2IDogdW5kZWZpbmVkO1xuICAgICAgICBnZXRCaWdJbnQ2NE1lbW9yeTAoKVthcmcwIC8gOCArIDFdID0gaXNMaWtlTm9uZShyZXQpID8gMG4gOiByZXQ7XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMF0gPSAhaXNMaWtlTm9uZShyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9iaWdpbnRfZnJvbV9pNjQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGFyZzA7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2pzdmFsX2VxID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkgPT09IGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fYmlnaW50X2Zyb21fdTY0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBCaWdJbnQuYXNVaW50Tig2NCwgYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Vycm9yX25ldyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEVycm9yKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pc0FycmF5XzI3YzQ2YzY3ZjQ5OGUxNWQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEFycmF5LmlzQXJyYXkoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2l0ZXJhdG9yXzZmOWQ0ZjI4ODQ1ZjQyNmMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gU3ltYm9sLml0ZXJhdG9yO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pbiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApIGluIGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2VudHJpZXNfNjVhNzZhNDEzZmM5MTAzNyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gT2JqZWN0LmVudHJpZXMoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5faXNfdW5kZWZpbmVkID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5faXNfbnVsbCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApID09PSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfU3RyaW5nXzkxZmJhN2RlZDEzYmE1NGMgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFN0cmluZyhnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gcHRyMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fbnVtYmVyX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gYXJnMDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld18wYjliZmRkOTc1ODMyODRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBPYmplY3QoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX1N0cmluZ18zMzA5OTg1NmU4YTgyNDZhID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBTdHJpbmcoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDFdID0gbGVuMDtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAwXSA9IHB0cjA7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jb3JlcmVzcG9uc2VoYW5kbGVyX2E1Mjg3OTQ1NGM2MGM3NjQgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGNvcmVfcmVzcG9uc2VfaGFuZGxlcihhcmcwID4+PiAwLCB0YWtlT2JqZWN0KGFyZzEpLCBhcmcyID4+PiAwLCBhcmczICE9PSAwKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX21lc3NhZ2VfZmUyYWY2M2NjYzg5ODViYyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfMWQ5YTkyMGM2YmZjNDRhOCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld18yNjhmN2I3ZGQzNDMwNzk4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBNYXAoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF85MzM3MjljZjViNjZhYzExID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuc2V0KGdldE9iamVjdChhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5faXNfc3RyaW5nID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YoZ2V0T2JqZWN0KGFyZzApKSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfZmJjMzNkMDIwZjUwN2I3MiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApW3Rha2VPYmplY3QoYXJnMSldID0gdGFrZU9iamVjdChhcmcyKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Byb2Nlc3NfMGNjMmFkYTg1MjRkNmY4MyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnByb2Nlc3M7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ192ZXJzaW9uc19jMTFhY2NlYWIyN2E2Yzg3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudmVyc2lvbnM7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ub2RlXzdmZjFjZTQ5Y2FmMjM4MTUgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5ub2RlO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3RhdGljX2FjY2Vzc29yX05PREVfTU9EVUxFX2NmNjQwMWNjMTA5MTI3OWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbW9kdWxlO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVxdWlyZV9hNzQ2ZTc5YjMyMmI5MzM2ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkucmVxdWlyZShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jcnlwdG9fMjAzNmJlZDdjNDRjMjVlNyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNyeXB0bztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX21zQ3J5cHRvX2EyMWZjODhjYWYxZWNkYzggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5tc0NyeXB0bztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld3dpdGhsZW5ndGhfZjU5MzM4NTVlNGY0OGExOSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoYXJnMCA+Pj4gMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190cmFuc2FjdGlvbl9jY2U5NmNiZWJkODFmZTFjID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudHJhbnNhY3Rpb24oZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpLCB0YWtlT2JqZWN0KGFyZzMpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0b25jb21wbGV0ZV8zZTU3YThjZWM4MzI3ZjY2ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub25jb21wbGV0ZSA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldG9uZXJyb3JfMDAwNTFjMDIxM2YyN2IyYyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9uZXJyb3IgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRvbmFib3J0XzQwNGJlZTNiOTk0MGQwM2QgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbmFib3J0ID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaXRlbV81MmE2YmVjMzYzMTQ2ODdiID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMSkuaXRlbShhcmcyID4+PiAwKTtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKHJldCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDFdID0gbGVuMDtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAwXSA9IHB0cjA7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19vYmplY3RTdG9yZV9mMTc5NzZiMGU2Mzc3ODMwID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkub2JqZWN0U3RvcmUoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdGFyZ2V0X2JmNzA0YjdkYjdhZDEzODcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS50YXJnZXQ7XG4gICAgICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAwIDogYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVhZHlTdGF0ZV9mYjI4N2YxNzAxMTM5MTdjID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkucmVhZHlTdGF0ZTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldG9uc3VjY2Vzc181ZjcxNTkzYmM1MTY1M2EzID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub25zdWNjZXNzID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0b25lcnJvcl9kNTc3MWNjNWJmOWVhNzRjID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub25lcnJvciA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2JfZHJvcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3Qgb2JqID0gdGFrZU9iamVjdChhcmcwKS5vcmlnaW5hbDtcbiAgICAgICAgaWYgKG9iai5jbnQtLSA9PSAxKSB7XG4gICAgICAgICAgICBvYmouYSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25leHRfYWFlZjdjOGFhNWUyMTJhYyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZG9uZV8xYjczYjA2NzJlMTVmMjM0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZG9uZTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3ZhbHVlXzFjY2MzNmJjMDM0NjJkNzEgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5faXNfZnVuY3Rpb24gPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZihnZXRPYmplY3QoYXJnMCkpID09PSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY2FsbF85N2FlOWQ4NjQ1ZGMzODhiID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuY2FsbChnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXh0XzU3OWU1ODNkMzM1NjZhODYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5uZXh0O1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2VsZl82ZDQ3OTUwNmY3MmM2YTcxID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHNlbGYuc2VsZjtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfd2luZG93X2YyNTU3Y2M3ODQ5MGFjZWIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2luZG93LndpbmRvdztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2xvYmFsVGhpc183ZjIwNmJkYTYyOGQ1Mjg2ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdsb2JhbFRoaXMuZ2xvYmFsVGhpcztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2xvYmFsX2JhNzVjNTBkMWNmMzg0ZjQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2xvYmFsLmdsb2JhbDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3bm9hcmdzX2I1YjA2M2ZjNmMyZjAzNzYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBGdW5jdGlvbihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0XzgzZGI5NjkwZjkzNTNlNzkgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5zZXQoZ2V0T2JqZWN0KGFyZzEpLCBhcmcyID4+PiAwKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2xlbmd0aF85ZTFhZTE5MDBjYjBmYmQ1ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X2JmM2Y4OWI5MmQ1YTM0YmYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFJlZmxlY3Quc2V0KGdldE9iamVjdChhcmcwKSwgZ2V0T2JqZWN0KGFyZzEpLCBnZXRPYmplY3QoYXJnMikpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZWxmXzdlZWRlMWY0NDg4YmYzNDYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gc2VsZi5zZWxmO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jcnlwdG9fYzkwOWZiNDI4ZGNiZGRiNiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNyeXB0bztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX21zQ3J5cHRvXzUxMWVlZmVmYmZjNzBhZTQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5tc0NyeXB0bztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9NT0RVTEVfZWYzYWEyZWIyNTExNThhNSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBtb2R1bGU7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZXF1aXJlXzkwMGQ1YzM5ODRmZTc3MDMgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5yZXF1aXJlKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRSYW5kb21WYWx1ZXNfMzA3MDQ5MzQ1ZDBiZDg4YyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmdldFJhbmRvbVZhbHVlcztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3JhbmRvbUZpbGxTeW5jXzg1YjNmNGM1MmM1NmMzMTMgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5yYW5kb21GaWxsU3luYyhnZXRBcnJheVU4RnJvbVdhc20wKGFyZzEsIGFyZzIpKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N1YmFycmF5XzU4YWQ0ZWZiYjViY2I4ODYgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5zdWJhcnJheShhcmcxID4+PiAwLCBhcmcyID4+PiAwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFJhbmRvbVZhbHVlc19jZDE3NTkxNTUxMWY3MDVlID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuZ2V0UmFuZG9tVmFsdWVzKGdldE9iamVjdChhcmcxKSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yYW5kb21GaWxsU3luY18wNjVhZmZmZGUwMWRhYTY2ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkucmFuZG9tRmlsbFN5bmMoZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcxLCBhcmcyKSk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFJhbmRvbVZhbHVlc19iOTllZWM0MjQ0YTQ3NWJiID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuZ2V0UmFuZG9tVmFsdWVzKGdldE9iamVjdChhcmcxKSk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luc3RhbmNlb2ZfVWludDhBcnJheV85NzFlZWRhNjllYjc1MDAzID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZ2V0T2JqZWN0KGFyZzApIGluc3RhbmNlb2YgVWludDhBcnJheTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19wdXRfODRlN2ZjOTNlZWUyN2IyOCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnB1dChnZXRPYmplY3QoYXJnMSksIGdldE9iamVjdChhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2RlbGV0ZV84YWJlZGQxMDQzYjQxMDVkID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZGVsZXRlKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldFRpbWVvdXRfZDZmY2YwZDkwNjdiOGU2NCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnNldFRpbWVvdXQoZ2V0T2JqZWN0KGFyZzEpLCBhcmcyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY2xlYXJUaW1lb3V0XzdkNmY3YmZlZWQzNGIzNDggPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5jbGVhclRpbWVvdXQoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXd3aXRoc3RyYW5kaW5pdF8wNWQ3MTgwNzg4NDIwYzQwID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgUmVxdWVzdChnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSksIGdldE9iamVjdChhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2hlYWRlcnNfODU4MjRlOTkzYWE3MzliZiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmhlYWRlcnM7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfOTkyYzFkMzE1ODZiMjk1NyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnNldChnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMiksIGdldFN0cmluZ0Zyb21XYXNtMChhcmczLCBhcmc0KSk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2ZldGNoXzBmZTA0OTA1Y2NjZmMyYWEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5mZXRjaChnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zdGFuY2VvZl9SZXNwb25zZV9lYWE0MjYyMjA4NDhhMzllID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZ2V0T2JqZWN0KGFyZzApIGluc3RhbmNlb2YgUmVzcG9uc2U7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3RhdHVzX2M0ZWYzZGQ1OTFlNjM0MzUgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5zdGF0dXM7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ191cmxfNzQyODVkZGYyNzQ3Y2IzZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzEpLnVybDtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDFdID0gbGVuMDtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAwXSA9IHB0cjA7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRvbnZlcnNpb25jaGFuZ2VfODQwZDY1Y2QwODg4ZGZiMCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9udmVyc2lvbmNoYW5nZSA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldG9udXBncmFkZW5lZWRlZF8xN2QwYjk1MzBmMWUwY2FjID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub251cGdyYWRlbmVlZGVkID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0b25ibG9ja2VkX2U2NmQ2YmU1Yzg3OTk4MGQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbmJsb2NrZWQgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19tZXNzYWdlX2E3YWYzZWUwY2MwZmUyOGQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcxKS5tZXNzYWdlO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gcHRyMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX1dpbmRvd181Njg0MzQxZmY2ZGZlM2FkID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuV2luZG93O1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfV29ya2VyR2xvYmFsU2NvcGVfZTA0NDdmZmNhZThiYjI3MiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLldvcmtlckdsb2JhbFNjb3BlO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5kZXhlZERCXzA1MGYwOTYyYWI2MDdhYzUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5pbmRleGVkREI7XG4gICAgICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAwIDogYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbmRleGVkREJfOGQ5ZTlhYjQ2MTZkZjdmMCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmluZGV4ZWREQjtcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX29wZW5fYTMxYzNmZTFmZGMyNDRlYiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm9wZW4oZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3d2l0aHN0cl9kNWI1ZjliOTg1ZWU4NGZiID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgV2ViU29ja2V0KGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzIsIGFyZzMpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3X2QyOWU1MDdmNjYwNmRlOTEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBXZWJTb2NrZXQoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0b25tZXNzYWdlX2M1YTgwNmI2MmEwYzU2MDcgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbm1lc3NhZ2UgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRvbm9wZW5fOWNlNDhkY2U1N2U1NDliNSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9ub3BlbiA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldG9uZXJyb3JfMDIzOTMyNjBiM2UyOTk3MiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9uZXJyb3IgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZW5kXzgwYjI1NmQ4N2E2Nzc5ZTUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5zZW5kKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2RhdGFfN2IxZjAxZjRlNmE2NGZiZSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmRhdGE7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdHJpbmdpZnlfZDY0NzFkMzAwZGVkOWI2OCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gSlNPTi5zdHJpbmdpZnkoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfb2JqZWN0U3RvcmVOYW1lc184YzA2YzQwZDJiMDUxNDFjID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkub2JqZWN0U3RvcmVOYW1lcztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NyZWF0ZU9iamVjdFN0b3JlX2QzZTI3ODljMTNkZGUxZmMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5jcmVhdGVPYmplY3RTdG9yZShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbnN0YW5jZW9mX0Vycm9yXzU2YjQ5NmExMGE1NmRlNjYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBnZXRPYmplY3QoYXJnMCkgaW5zdGFuY2VvZiBFcnJvcjtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRUaW1lem9uZU9mZnNldF84OWJkNDI3NWUxY2E4MzQxID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fZGVidWdfc3RyaW5nID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBkZWJ1Z1N0cmluZyhnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gcHRyMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fdGhyb3cgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdGhlbl9jZWRhZDIwZmJiZDk0MThhID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudGhlbihnZXRPYmplY3QoYXJnMSksIGdldE9iamVjdChhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZXNvbHZlXzk5ZmUxNzk2NGYzMWZmYzAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFByb21pc2UucmVzb2x2ZShnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdGhlbl8xMWY3YTU0ZDY3YjRiZmFkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudGhlbihnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVzdWx0XzllMzk5YzE0Njc2OTcwZDkgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5yZXN1bHQ7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2Vycm9yX2FhY2Y1YWMxOTFlNTRlZDAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5lcnJvcjtcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldF82Mjg1YmY0NThhMWVlNzU4ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZ2V0KGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luc3RhbmNlb2ZfV2luZG93X2FjYzk3ZmY5ZjVkMmM3YjQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2Nsb3NlXzQ1ZDA1M2JlYTU5ZTc3NDYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5jbG9zZSgpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190ZXh0XzExNjlkNzUyY2M2OTc5MDMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS50ZXh0KCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2xvc3VyZV93cmFwcGVyOTQ3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBtYWtlQ2xvc3VyZShhcmcwLCBhcmcxLCA0NCwgX193YmdfYWRhcHRlcl81MCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nsb3N1cmVfd3JhcHBlcjk1OCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbWFrZUNsb3N1cmUoYXJnMCwgYXJnMSwgNDcsIF9fd2JnX2FkYXB0ZXJfNTMpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jbG9zdXJlX3dyYXBwZXI2MTU5ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCAyMzgsIF9fd2JnX2FkYXB0ZXJfNTYpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jbG9zdXJlX3dyYXBwZXI2ODI0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCAyNDcsIF9fd2JnX2FkYXB0ZXJfNTkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jbG9zdXJlX3dyYXBwZXI2ODc0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCAyNDQsIF9fd2JnX2FkYXB0ZXJfNjIpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jbG9zdXJlX3dyYXBwZXI2ODc1ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCAxMjA2LCBfX3diZ19hZGFwdGVyXzY1KTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2xvc3VyZV93cmFwcGVyNjg3NiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbWFrZU11dENsb3N1cmUoYXJnMCwgYXJnMSwgMjQxLCBfX3diZ19hZGFwdGVyXzY4KTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGltcG9ydHM7XG59XG5cbmZ1bmN0aW9uIGluaXRNZW1vcnkoaW1wb3J0cywgbWF5YmVfbWVtb3J5KSB7XG5cbn1cblxuZnVuY3Rpb24gZmluYWxpemVJbml0KGluc3RhbmNlLCBtb2R1bGUpIHtcbiAgICB3YXNtID0gaW5zdGFuY2UuZXhwb3J0cztcbiAgICBpbml0Ll9fd2JpbmRnZW5fd2FzbV9tb2R1bGUgPSBtb2R1bGU7XG4gICAgY2FjaGVkQmlnSW50NjRNZW1vcnkwID0gbmV3IEJpZ0ludDY0QXJyYXkoKTtcbiAgICBjYWNoZWRGbG9hdDY0TWVtb3J5MCA9IG5ldyBGbG9hdDY0QXJyYXkoKTtcbiAgICBjYWNoZWRJbnQzMk1lbW9yeTAgPSBuZXcgSW50MzJBcnJheSgpO1xuICAgIGNhY2hlZFVpbnQ4TWVtb3J5MCA9IG5ldyBVaW50OEFycmF5KCk7XG5cblxuICAgIHJldHVybiB3YXNtO1xufVxuXG5mdW5jdGlvbiBpbml0U3luYyhtb2R1bGUpIHtcbiAgICBjb25zdCBpbXBvcnRzID0gZ2V0SW1wb3J0cygpO1xuXG4gICAgaW5pdE1lbW9yeShpbXBvcnRzKTtcblxuICAgIGlmICghKG1vZHVsZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1vZHVsZSkpIHtcbiAgICAgICAgbW9kdWxlID0gbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShtb2R1bGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG1vZHVsZSwgaW1wb3J0cyk7XG5cbiAgICByZXR1cm4gZmluYWxpemVJbml0KGluc3RhbmNlLCBtb2R1bGUpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpbml0KGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcpIHsgICAgfVxuICAgIGNvbnN0IGltcG9ydHMgPSBnZXRJbXBvcnRzKCk7XG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCAodHlwZW9mIFJlcXVlc3QgPT09ICdmdW5jdGlvbicgJiYgaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB8fCAodHlwZW9mIFVSTCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnB1dCBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgaW5wdXQgPSBmZXRjaChpbnB1dCk7XG4gICAgfVxuXG4gICAgaW5pdE1lbW9yeShpbXBvcnRzKTtcblxuICAgIGNvbnN0IHsgaW5zdGFuY2UsIG1vZHVsZSB9ID0gYXdhaXQgbG9hZChhd2FpdCBpbnB1dCwgaW1wb3J0cyk7XG5cbiAgICByZXR1cm4gZmluYWxpemVJbml0KGluc3RhbmNlLCBtb2R1bGUpO1xufVxuXG5cbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFdSQVBQRVIgRU5EXG4gICAgZnVuY3Rpb24gcmVwbGFjZVVuZGVmaW5lZFdpdGhOdWxscyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gW10gOiB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSByZXBsYWNlVW5kZWZpbmVkV2l0aE51bGxzKHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVwbGFjZUJsb2JzV2l0aEFycmF5QnVmZmVycyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdmFsdWUuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJiB2YWx1ZSA+IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gW10gOiB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBhd2FpdCByZXBsYWNlQmxvYnNXaXRoQXJyYXlCdWZmZXJzKHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG5cbiAgICBsZXQgZGVmZXJyZWRDcmVhdGVDb250ZXh0ID0gW107XG4gICAgbGV0IHJlc3BvbnNlSGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBjb3JlX3Jlc3BvbnNlX2hhbmRsZXIocmVxdWVzdF9pZCwgcGFyYW1zLCByZXNwb25zZV90eXBlLCBmaW5pc2hlZCkge1xuICAgICAgICBpZiAocmVzcG9uc2VIYW5kbGVyKSB7XG4gICAgICAgICAgICByZXNwb25zZUhhbmRsZXIoXG4gICAgICAgICAgICAgICAgcmVxdWVzdF9pZCxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VfdHlwZSxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBpbml0KGF3YWl0IGxvYWRNb2R1bGUoKSk7XG4gICAgICAgIGZvciAoY29uc3QgY3JlYXRlQ29udGV4dCBvZiBkZWZlcnJlZENyZWF0ZUNvbnRleHQpIHtcbiAgICAgICAgICAgIGNyZWF0ZUNvbnRleHQucmVzb2x2ZShjb3JlX2NyZWF0ZV9jb250ZXh0KGNyZWF0ZUNvbnRleHQuY29uZmlnSnNvbikpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmVycmVkQ3JlYXRlQ29udGV4dCA9IG51bGw7XG4gICAgfSkoKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBzZXRSZXNwb25zZVBhcmFtc0hhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICByZXNwb25zZUhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVDb250ZXh0OiAoY29uZmlnSnNvbikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkQ3JlYXRlQ29udGV4dCA9PT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKGNvcmVfY3JlYXRlX2NvbnRleHQoY29uZmlnSnNvbikpXG4gICAgICAgICAgICAgICAgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZENyZWF0ZUNvbnRleHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWdKc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3lDb250ZXh0OiAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgY29yZV9kZXN0cm95X2NvbnRleHQoY29udGV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlbmRSZXF1ZXN0UGFyYW1zOiAoY29udGV4dCwgcmVxdWVzdElkLCBmdW5jdGlvbk5hbWUsIGZ1bmN0aW9uUGFyYW1zKSA9PiB7XG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvcmVfcmVxdWVzdChcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXBsYWNlQmxvYnNXaXRoQXJyYXlCdWZmZXJzKGZ1bmN0aW9uUGFyYW1zKSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9LFxuICAgIH0pO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaWJXZWIoKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5kaXNhYmxlU2VwYXJhdGVXb3JrZXIgPyB3aXRob3V0U2VwYXJhdGVXb3JrZXIoKSA6IHdpdGhTZXBhcmF0ZVdvcmtlcigpO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@eversdk/lib-web/index.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_main_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/main.scss */ \"./src/styles/main.scss\");\n/* harmony import */ var _scripts_display_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scripts/display.js */ \"./src/scripts/display.js\");\n/* harmony import */ var _scripts_controls_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scripts/controls.js */ \"./src/scripts/controls.js\");\n/* harmony import */ var _scripts_ever_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scripts/ever.js */ \"./src/scripts/ever.js\");\n //Import CSS\n\n //Import JS\n\n\n\n //https://github.com/flauwekeul/honeycomb\n//console.clear();\n\n_scripts_display_js__WEBPACK_IMPORTED_MODULE_1__.initiateMap(_scripts_ever_js__WEBPACK_IMPORTED_MODULE_3__);\n_scripts_controls_js__WEBPACK_IMPORTED_MODULE_2__.initiateControls();\n\nif (false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9zcmMvaW5kZXguanM/OTViNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjsgLy9JbXBvcnQgQ1NTXG5cbmltcG9ydCAnLi9zdHlsZXMvbWFpbi5zY3NzJzsgLy9JbXBvcnQgSlNcblxuaW1wb3J0ICogYXMgRElTUExBWSBmcm9tICcuL3NjcmlwdHMvZGlzcGxheS5qcyc7XG5pbXBvcnQgKiBhcyBDT05UUk9MUyBmcm9tICcuL3NjcmlwdHMvY29udHJvbHMuanMnO1xuaW1wb3J0ICogYXMgUFJPVklERVIgZnJvbSAnLi9zY3JpcHRzL2V2ZXIuanMnOyAvL2h0dHBzOi8vZ2l0aHViLmNvbS9mbGF1d2VrZXVsL2hvbmV5Y29tYlxuLy9jb25zb2xlLmNsZWFyKCk7XG5cbkRJU1BMQVkuaW5pdGlhdGVNYXAoUFJPVklERVIpO1xuQ09OVFJPTFMuaW5pdGlhdGVDb250cm9scygpO1xuXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpO1xufSJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/scripts/controls.js":
/*!*********************************!*\
  !*** ./src/scripts/controls.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"initiateControls\": () => (/* binding */ initiateControls)\n/* harmony export */ });\n/* harmony import */ var _scripts_display_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scripts/display.js */ \"./src/scripts/display.js\");\n//Imports\n //Public variables\n//-\n//Private variables\n//-\n//Public functions\n\nfunction initiateControls() {\n  //Camera position controls\n  let timer = null;\n  document.addEventListener('mouseup', () => {\n    clearInterval(timer);\n  });\n  document.addEventListener('keyup', () => {\n    clearInterval(timer);\n  }); //Keyboard controls\n\n  document.addEventListener('keydown', e => {\n    console.log('e.code', e.code);\n\n    switch (e.code) {\n      case \"ArrowUp\":\n      case \"KeyW\":\n        clearInterval(timer);\n        timer = setInterval(() => {\n          _scripts_display_js__WEBPACK_IMPORTED_MODULE_0__.camera.y -= 5;\n        }, 10);\n        break;\n\n      case \"ArrowLeft\":\n      case \"KeyA\":\n        clearInterval(timer);\n        timer = setInterval(() => {\n          _scripts_display_js__WEBPACK_IMPORTED_MODULE_0__.camera.x -= 5;\n        }, 10);\n        break;\n\n      case \"ArrowRight\":\n      case \"KeyD\":\n        clearInterval(timer);\n        timer = setInterval(() => {\n          _scripts_display_js__WEBPACK_IMPORTED_MODULE_0__.camera.x += 5;\n        }, 10);\n        break;\n\n      case \"ArrowDown\":\n      case \"KeyS\":\n        clearInterval(timer);\n        timer = setInterval(() => {\n          _scripts_display_js__WEBPACK_IMPORTED_MODULE_0__.camera.y += 5;\n        }, 10);\n        break;\n    }\n  });\n} //Private functions//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0cy9jb250cm9scy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL3NyYy9zY3JpcHRzL2NvbnRyb2xzLmpzPzA3MTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy9JbXBvcnRzXG5pbXBvcnQgKiBhcyBESVNQTEFZIGZyb20gJy4uL3NjcmlwdHMvZGlzcGxheS5qcyc7IC8vUHVibGljIHZhcmlhYmxlc1xuLy8tXG4vL1ByaXZhdGUgdmFyaWFibGVzXG4vLy1cbi8vUHVibGljIGZ1bmN0aW9uc1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhdGVDb250cm9scygpIHtcbiAgLy9DYW1lcmEgcG9zaXRpb24gY29udHJvbHNcbiAgbGV0IHRpbWVyID0gbnVsbDtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICgpID0+IHtcbiAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgfSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKCkgPT4ge1xuICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICB9KTsgLy9LZXlib2FyZCBjb250cm9sc1xuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBlID0+IHtcbiAgICBjb25zb2xlLmxvZygnZS5jb2RlJywgZS5jb2RlKTtcblxuICAgIHN3aXRjaCAoZS5jb2RlKSB7XG4gICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgY2FzZSBcIktleVdcIjpcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgIERJU1BMQVkuY2FtZXJhLnkgLT0gNTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIkFycm93TGVmdFwiOlxuICAgICAgY2FzZSBcIktleUFcIjpcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgIERJU1BMQVkuY2FtZXJhLnggLT0gNTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgIGNhc2UgXCJLZXlEXCI6XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICB0aW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICBESVNQTEFZLmNhbWVyYS54ICs9IDU7XG4gICAgICAgIH0sIDEwKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgIGNhc2UgXCJLZXlTXCI6XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICB0aW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICBESVNQTEFZLmNhbWVyYS55ICs9IDU7XG4gICAgICAgIH0sIDEwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbn0gLy9Qcml2YXRlIGZ1bmN0aW9ucyJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/scripts/controls.js\n");

/***/ }),

/***/ "./src/scripts/display.js":
/*!********************************!*\
  !*** ./src/scripts/display.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"camera\": () => (/* binding */ camera),\n/* harmony export */   \"currentMap\": () => (/* binding */ currentMap),\n/* harmony export */   \"getMap\": () => (/* binding */ getMap),\n/* harmony export */   \"initiateMap\": () => (/* binding */ initiateMap),\n/* harmony export */   \"zoomUpdate\": () => (/* binding */ zoomUpdate)\n/* harmony export */ });\n/* harmony import */ var honeycomb_grid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! honeycomb-grid */ \"./node_modules/honeycomb-grid/dist/honeycomb-grid.mjs\");\n//Imports\n //Public variables\n\nconst camera = {\n  x: 0,\n  y: 0,\n  zoom: 1\n};\nlet currentMap;\nconst Hex = (0,honeycomb_grid__WEBPACK_IMPORTED_MODULE_0__.defineHex)({\n  dimensions: 52,\n  orientation: 'FLAT',\n  origin: {\n    x: -500,\n    y: -400\n  }\n}); //Private variables\n\nconst mainCanvas = document.querySelector(\"#mainCanvas\");\nconst animCanvas = document.querySelector(\"#animationCanvas\");\nconst mainCtx = mainCanvas.getContext(\"2d\");\nconst animCtx = animCanvas.getContext(\"2d\");\nlet scales = 0;\nlet hexSize;\nlet a_full, b_full, c_full, a_hex, b_hex, c_hex;\nlet halfCanvasWidth, halfCanvasHeight;\nlet grid = new honeycomb_grid__WEBPACK_IMPORTED_MODULE_0__.Grid(Hex);\nlet PROVIDER;\nlet isdblclick = false;\n\nasync function sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction getMap(radius) {\n  let map = new honeycomb_grid__WEBPACK_IMPORTED_MODULE_0__.Grid(Hex, (0,honeycomb_grid__WEBPACK_IMPORTED_MODULE_0__.spiral)({\n    radius: 1 * radius\n  }));\n  console.log('getMap', map.size); //Basic water layer\n\n  for (let hex of map) {\n    hex.type = \"64, 128, 255\";\n    hex.highlight = false;\n  }\n\n  return map;\n} //Public functions\n\nasync function initiateMap(ever) {\n  currentMap = [];\n  PROVIDER = ever;\n  await PROVIDER.init(radius => {\n    currentMap = getMap(radius);\n    PROVIDER.setMap(currentMap);\n  });\n  mainCanvas.width = window.innerWidth;\n  mainCanvas.height = window.innerHeight;\n  animCanvas.width = window.innerWidth;\n  animCanvas.height = window.innerHeight;\n  calculateHexDimensions();\n  windowResizeUpdate();\n  zoomUpdate();\n  drawMap();\n  camera.x = halfCanvasWidth;\n  camera.y = halfCanvasHeight;\n  recalcEnergy();\n}\n\nfunction recalcEnergy() {\n  for (let hex of currentMap) {\n    if (!hex.details) continue;\n    calculateEnergy(hex);\n  }\n\n  setTimeout(recalcEnergy, 1000);\n}\n\nfunction calculateEnergy(hex) {\n  let dateNow = Math.round(Date.now() / 1000);\n\n  if (1 * hex.details.energy >= 1 * hex.details.energyMax || 1 * hex.details.lastCalcTime >= dateNow) {\n    return;\n  }\n\n  let energy = Math.min(1 * hex.details.energy + hex.details.energySec * hex.details.speed * (dateNow - hex.details.lastCalcTime), 1 * hex.details.energyMax);\n  hex.details.lastCalcTime = dateNow;\n  hex.details.energy = energy;\n}\n\nfunction zoomUpdate() {\n  const hex = grid.pointToHex({\n    x: camera.x,\n    y: camera.y\n  });\n  const x = hex.x;\n  const y = hex.y;\n  hexSize = scales;\n  calculateHexDimensions();\n  let replacementMap = new honeycomb_grid__WEBPACK_IMPORTED_MODULE_0__.Grid(Hex, (0,honeycomb_grid__WEBPACK_IMPORTED_MODULE_0__.spiral)({\n    radius: currentMap.radius\n  }));\n\n  for (let i = 0; i < currentMap.length; i++) {\n    currentMap[i].size = replacementMap[i].size;\n\n    if (currentMap[i].x === x && currentMap[i].y === y) {\n      camera.x = Math.round((0,honeycomb_grid__WEBPACK_IMPORTED_MODULE_0__.hexToPoint)(currentMap[i]).x + b_full + hexSize / 2);\n      camera.y = Math.round((0,honeycomb_grid__WEBPACK_IMPORTED_MODULE_0__.hexToPoint)(currentMap[i]).y + c_full);\n    }\n  }\n} //Private functions\n\nfunction drawMap() {\n  //Clearing\n  mainCtx.setTransform(1, 0, 0, 1, 0, 0);\n  mainCtx.fillStyle = \"black\";\n  mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height); //Positioning the camera\n\n  mainCtx.translate(-camera.x + halfCanvasWidth, -camera.y + halfCanvasHeight);\n\n  for (let hex of currentMap) {\n    //Hex is ignored if it wasn't seen yet\n    //if (hex.visibility === 'unseen') continue\n    // console.log('hex', hex)\n    // console.log('hexToPoint', hexToPoint(hex))\n    let x = (0,honeycomb_grid__WEBPACK_IMPORTED_MODULE_0__.hexToPoint)(hex).x,\n        y = (0,honeycomb_grid__WEBPACK_IMPORTED_MODULE_0__.hexToPoint)(hex).y; //Checking if hex is visible within canvas\n\n    if (Math.abs(x - camera.x) > halfCanvasWidth + hexSize || Math.abs(y - camera.y) > halfCanvasHeight + hexSize) continue; //Drawing highlight around hex\n\n    if (hex.highlight) {\n      mainCtx.strokeStyle = \"white\";\n      mainCtx.beginPath();\n      mainCtx.moveTo(x + a_full, y - c_full);\n      mainCtx.lineTo(x + b_full, y);\n      mainCtx.lineTo(x + a_full, y + c_full);\n      mainCtx.lineTo(x - a_full, y + c_full);\n      mainCtx.lineTo(x - b_full, y);\n      mainCtx.lineTo(x - a_full, y - c_full);\n      mainCtx.closePath();\n      mainCtx.stroke();\n    } //Drawing the hex\n\n\n    let color = hex.details ? `${hex.details.color.r}, ${hex.details.color.g}, ${hex.details.color.b}` : hex.type;\n    mainCtx.fillStyle = `rgba(${color},1)`;\n    mainCtx.beginPath();\n    mainCtx.moveTo(x + a_hex, y - c_hex);\n    mainCtx.lineTo(x + b_hex, y);\n    mainCtx.lineTo(x + a_hex, y + c_hex);\n    mainCtx.lineTo(x - a_hex, y + c_hex);\n    mainCtx.lineTo(x - b_hex, y);\n    mainCtx.lineTo(x - a_hex, y - c_hex);\n    mainCtx.closePath();\n    mainCtx.fill();\n    setText(mainCtx, x, y - hexSize / 2, `${hex.q};${hex.r}`);\n\n    if (hex.details) {\n      setText(mainCtx, x, y, `${hex.details.energy}`);\n      setText(mainCtx, x, y + hexSize / 2, `lvl: ${1 * hex.details.level + 1}`);\n    }\n  }\n\n  requestAnimationFrame(drawMap);\n}\n\nfunction setText(ctx, x, y, txt, fontSize = 10, style = \"white\", align = 'center') {\n  let _font = `${fontSize * (camera.zoom + 1)}px Georgia`;\n  ctx.font = _font;\n  ctx.fillStyle = style;\n  ctx.textAlign = align;\n  ctx.fillText(txt, x, y, hexSize);\n}\n\nfunction calculateHexDimensions() {\n  a_full = hexSize / 2;\n  b_full = hexSize;\n  c_full = hexSize / 2 * Math.sqrt(3);\n  a_hex = a_full * 0.95;\n  b_hex = b_full * 0.95;\n  c_hex = c_full * 0.95;\n}\n\nfunction windowResizeUpdate() {\n  mainCanvas.width = window.innerWidth;\n  mainCanvas.height = window.innerHeight;\n  animCanvas.width = window.innerWidth;\n  animCanvas.height = window.innerHeight;\n  halfCanvasWidth = mainCanvas.width / 2;\n  halfCanvasHeight = mainCanvas.height / 2;\n  const min = Math.min(halfCanvasWidth, halfCanvasHeight);\n  scales = min / 7;\n  console.log('halfCanvas', halfCanvasWidth, halfCanvasHeight);\n  console.log('scales', scales);\n} //Hex Highlighting\n\n\nanimCanvas.addEventListener('click', async ({\n  offsetX,\n  offsetY\n}) => {\n  console.log('click', isdblclick);\n  await sleep(500);\n  console.log('click', isdblclick);\n\n  if (isdblclick) {\n    return;\n  }\n\n  offsetX += camera.x - mainCanvas.width / 2;\n  offsetY += camera.y - mainCanvas.height / 2;\n  const hexCoordinates = grid.pointToHex({\n    x: offsetX,\n    y: offsetY\n  });\n\n  for (let hex of currentMap) {\n    if (hex.x == hexCoordinates.x && hex.y == hexCoordinates.y) {\n      hex.highlight = !hex.highlight;\n    } else {\n      hex.highlight = false;\n    }\n  }\n});\nanimCanvas.addEventListener('dblclick', async ({\n  offsetX,\n  offsetY\n}) => {\n  isdblclick = true;\n  console.log('dblclick', isdblclick);\n  await sleep(500);\n  isdblclick = false;\n  console.log('dblclick', isdblclick);\n  offsetX += camera.x - mainCanvas.width / 2;\n  offsetY += camera.y - mainCanvas.height / 2;\n  const hexCoordinates = grid.pointToHex({\n    x: offsetX,\n    y: offsetY\n  });\n  console.log(hexCoordinates);\n  let hHex;\n  let tHex;\n\n  for (let hex of currentMap) {\n    if (hex.highlight) {\n      hHex = hex;\n    }\n\n    if (hex.x == hexCoordinates.x && hex.y == hexCoordinates.y) {\n      tHex = hex;\n    }\n  }\n\n  if (!tHex) return;\n  if (hHex && !hHex.details) return;\n  console.log('hHex', hHex);\n  console.log('tHex', tHex);\n  let cellCoord = {\n    x: hexCoordinates.q,\n    y: hexCoordinates.r,\n    z: hexCoordinates.s\n  };\n\n  if (!hHex) {\n    if (!tHex.details) {\n      await PROVIDER.newGame(cellCoord);\n    }\n  } else if (hHex.address.toString() == tHex.address.toString()) {\n    await PROVIDER.upgradeCell(tHex.address);\n  } else {\n    if (!isNeighborHex(hHex, tHex)) return;\n    let energy = 1000;\n\n    if (!tHex.details) {\n      await PROVIDER.markCell(hHex.address, cellCoord, energy);\n    } else if (colorIsEqual(hHex.details.color, tHex.details.color)) {\n      //       \n      await PROVIDER.helpCell(hHex.address, cellCoord, energy);\n    } else {\n      await PROVIDER.attkCell(hHex.address, cellCoord, energy);\n    }\n  }\n});\n\nfunction colorIsEqual(color1, color2) {\n  return color1.r == color2.r && color1.g == color2.g && color1.b == color2.b;\n}\n\nfunction isNeighborHex(hex1, hex2) {\n  return cube_distance(hex1, hex2) == 1;\n}\n\nfunction cube_distance(hex1, hex2) {\n  return Math.max(Math.abs(hex1.q - hex2.q), Math.abs(hex1.r - hex2.r), Math.abs(hex1.s - hex2.s));\n}\n\nwindow.addEventListener('resize', () => {\n  windowResizeUpdate();\n  zoomUpdate();\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0cy9kaXNwbGF5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vc3JjL3NjcmlwdHMvZGlzcGxheS5qcz8zMjc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vSW1wb3J0c1xuaW1wb3J0IHsgZGVmaW5lSGV4LCBHcmlkLCBzcGlyYWwsIGhleFRvUG9pbnQgfSBmcm9tICdob25leWNvbWItZ3JpZCc7IC8vUHVibGljIHZhcmlhYmxlc1xuXG5leHBvcnQgY29uc3QgY2FtZXJhID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICB6b29tOiAxXG59O1xuZXhwb3J0IGxldCBjdXJyZW50TWFwO1xuY29uc3QgSGV4ID0gZGVmaW5lSGV4KHtcbiAgZGltZW5zaW9uczogNTIsXG4gIG9yaWVudGF0aW9uOiAnRkxBVCcsXG4gIG9yaWdpbjoge1xuICAgIHg6IC01MDAsXG4gICAgeTogLTQwMFxuICB9XG59KTsgLy9Qcml2YXRlIHZhcmlhYmxlc1xuXG5jb25zdCBtYWluQ2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNtYWluQ2FudmFzXCIpO1xuY29uc3QgYW5pbUNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjYW5pbWF0aW9uQ2FudmFzXCIpO1xuY29uc3QgbWFpbkN0eCA9IG1haW5DYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuY29uc3QgYW5pbUN0eCA9IGFuaW1DYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xubGV0IHNjYWxlcyA9IDA7XG5sZXQgaGV4U2l6ZTtcbmxldCBhX2Z1bGwsIGJfZnVsbCwgY19mdWxsLCBhX2hleCwgYl9oZXgsIGNfaGV4O1xubGV0IGhhbGZDYW52YXNXaWR0aCwgaGFsZkNhbnZhc0hlaWdodDtcbmxldCBncmlkID0gbmV3IEdyaWQoSGV4KTtcbmxldCBQUk9WSURFUjtcbmxldCBpc2RibGNsaWNrID0gZmFsc2U7XG5cbmFzeW5jIGZ1bmN0aW9uIHNsZWVwKG1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcChyYWRpdXMpIHtcbiAgbGV0IG1hcCA9IG5ldyBHcmlkKEhleCwgc3BpcmFsKHtcbiAgICByYWRpdXM6IDEgKiByYWRpdXNcbiAgfSkpO1xuICBjb25zb2xlLmxvZygnZ2V0TWFwJywgbWFwLnNpemUpOyAvL0Jhc2ljIHdhdGVyIGxheWVyXG5cbiAgZm9yIChsZXQgaGV4IG9mIG1hcCkge1xuICAgIGhleC50eXBlID0gXCI2NCwgMTI4LCAyNTVcIjtcbiAgICBoZXguaGlnaGxpZ2h0ID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbWFwO1xufSAvL1B1YmxpYyBmdW5jdGlvbnNcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRpYXRlTWFwKGV2ZXIpIHtcbiAgY3VycmVudE1hcCA9IFtdO1xuICBQUk9WSURFUiA9IGV2ZXI7XG4gIGF3YWl0IFBST1ZJREVSLmluaXQocmFkaXVzID0+IHtcbiAgICBjdXJyZW50TWFwID0gZ2V0TWFwKHJhZGl1cyk7XG4gICAgUFJPVklERVIuc2V0TWFwKGN1cnJlbnRNYXApO1xuICB9KTtcbiAgbWFpbkNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICBtYWluQ2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgYW5pbUNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICBhbmltQ2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgY2FsY3VsYXRlSGV4RGltZW5zaW9ucygpO1xuICB3aW5kb3dSZXNpemVVcGRhdGUoKTtcbiAgem9vbVVwZGF0ZSgpO1xuICBkcmF3TWFwKCk7XG4gIGNhbWVyYS54ID0gaGFsZkNhbnZhc1dpZHRoO1xuICBjYW1lcmEueSA9IGhhbGZDYW52YXNIZWlnaHQ7XG4gIHJlY2FsY0VuZXJneSgpO1xufVxuXG5mdW5jdGlvbiByZWNhbGNFbmVyZ3koKSB7XG4gIGZvciAobGV0IGhleCBvZiBjdXJyZW50TWFwKSB7XG4gICAgaWYgKCFoZXguZGV0YWlscykgY29udGludWU7XG4gICAgY2FsY3VsYXRlRW5lcmd5KGhleCk7XG4gIH1cblxuICBzZXRUaW1lb3V0KHJlY2FsY0VuZXJneSwgMTAwMCk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUVuZXJneShoZXgpIHtcbiAgbGV0IGRhdGVOb3cgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKTtcblxuICBpZiAoMSAqIGhleC5kZXRhaWxzLmVuZXJneSA+PSAxICogaGV4LmRldGFpbHMuZW5lcmd5TWF4IHx8IDEgKiBoZXguZGV0YWlscy5sYXN0Q2FsY1RpbWUgPj0gZGF0ZU5vdykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBlbmVyZ3kgPSBNYXRoLm1pbigxICogaGV4LmRldGFpbHMuZW5lcmd5ICsgaGV4LmRldGFpbHMuZW5lcmd5U2VjICogaGV4LmRldGFpbHMuc3BlZWQgKiAoZGF0ZU5vdyAtIGhleC5kZXRhaWxzLmxhc3RDYWxjVGltZSksIDEgKiBoZXguZGV0YWlscy5lbmVyZ3lNYXgpO1xuICBoZXguZGV0YWlscy5sYXN0Q2FsY1RpbWUgPSBkYXRlTm93O1xuICBoZXguZGV0YWlscy5lbmVyZ3kgPSBlbmVyZ3k7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB6b29tVXBkYXRlKCkge1xuICBjb25zdCBoZXggPSBncmlkLnBvaW50VG9IZXgoe1xuICAgIHg6IGNhbWVyYS54LFxuICAgIHk6IGNhbWVyYS55XG4gIH0pO1xuICBjb25zdCB4ID0gaGV4Lng7XG4gIGNvbnN0IHkgPSBoZXgueTtcbiAgaGV4U2l6ZSA9IHNjYWxlcztcbiAgY2FsY3VsYXRlSGV4RGltZW5zaW9ucygpO1xuICBsZXQgcmVwbGFjZW1lbnRNYXAgPSBuZXcgR3JpZChIZXgsIHNwaXJhbCh7XG4gICAgcmFkaXVzOiBjdXJyZW50TWFwLnJhZGl1c1xuICB9KSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50TWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgY3VycmVudE1hcFtpXS5zaXplID0gcmVwbGFjZW1lbnRNYXBbaV0uc2l6ZTtcblxuICAgIGlmIChjdXJyZW50TWFwW2ldLnggPT09IHggJiYgY3VycmVudE1hcFtpXS55ID09PSB5KSB7XG4gICAgICBjYW1lcmEueCA9IE1hdGgucm91bmQoaGV4VG9Qb2ludChjdXJyZW50TWFwW2ldKS54ICsgYl9mdWxsICsgaGV4U2l6ZSAvIDIpO1xuICAgICAgY2FtZXJhLnkgPSBNYXRoLnJvdW5kKGhleFRvUG9pbnQoY3VycmVudE1hcFtpXSkueSArIGNfZnVsbCk7XG4gICAgfVxuICB9XG59IC8vUHJpdmF0ZSBmdW5jdGlvbnNcblxuZnVuY3Rpb24gZHJhd01hcCgpIHtcbiAgLy9DbGVhcmluZ1xuICBtYWluQ3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgbWFpbkN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gIG1haW5DdHguZmlsbFJlY3QoMCwgMCwgbWFpbkNhbnZhcy53aWR0aCwgbWFpbkNhbnZhcy5oZWlnaHQpOyAvL1Bvc2l0aW9uaW5nIHRoZSBjYW1lcmFcblxuICBtYWluQ3R4LnRyYW5zbGF0ZSgtY2FtZXJhLnggKyBoYWxmQ2FudmFzV2lkdGgsIC1jYW1lcmEueSArIGhhbGZDYW52YXNIZWlnaHQpO1xuXG4gIGZvciAobGV0IGhleCBvZiBjdXJyZW50TWFwKSB7XG4gICAgLy9IZXggaXMgaWdub3JlZCBpZiBpdCB3YXNuJ3Qgc2VlbiB5ZXRcbiAgICAvL2lmIChoZXgudmlzaWJpbGl0eSA9PT0gJ3Vuc2VlbicpIGNvbnRpbnVlXG4gICAgLy8gY29uc29sZS5sb2coJ2hleCcsIGhleClcbiAgICAvLyBjb25zb2xlLmxvZygnaGV4VG9Qb2ludCcsIGhleFRvUG9pbnQoaGV4KSlcbiAgICBsZXQgeCA9IGhleFRvUG9pbnQoaGV4KS54LFxuICAgICAgICB5ID0gaGV4VG9Qb2ludChoZXgpLnk7IC8vQ2hlY2tpbmcgaWYgaGV4IGlzIHZpc2libGUgd2l0aGluIGNhbnZhc1xuXG4gICAgaWYgKE1hdGguYWJzKHggLSBjYW1lcmEueCkgPiBoYWxmQ2FudmFzV2lkdGggKyBoZXhTaXplIHx8IE1hdGguYWJzKHkgLSBjYW1lcmEueSkgPiBoYWxmQ2FudmFzSGVpZ2h0ICsgaGV4U2l6ZSkgY29udGludWU7IC8vRHJhd2luZyBoaWdobGlnaHQgYXJvdW5kIGhleFxuXG4gICAgaWYgKGhleC5oaWdobGlnaHQpIHtcbiAgICAgIG1haW5DdHguc3Ryb2tlU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICBtYWluQ3R4LmJlZ2luUGF0aCgpO1xuICAgICAgbWFpbkN0eC5tb3ZlVG8oeCArIGFfZnVsbCwgeSAtIGNfZnVsbCk7XG4gICAgICBtYWluQ3R4LmxpbmVUbyh4ICsgYl9mdWxsLCB5KTtcbiAgICAgIG1haW5DdHgubGluZVRvKHggKyBhX2Z1bGwsIHkgKyBjX2Z1bGwpO1xuICAgICAgbWFpbkN0eC5saW5lVG8oeCAtIGFfZnVsbCwgeSArIGNfZnVsbCk7XG4gICAgICBtYWluQ3R4LmxpbmVUbyh4IC0gYl9mdWxsLCB5KTtcbiAgICAgIG1haW5DdHgubGluZVRvKHggLSBhX2Z1bGwsIHkgLSBjX2Z1bGwpO1xuICAgICAgbWFpbkN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIG1haW5DdHguc3Ryb2tlKCk7XG4gICAgfSAvL0RyYXdpbmcgdGhlIGhleFxuXG5cbiAgICBsZXQgY29sb3IgPSBoZXguZGV0YWlscyA/IGAke2hleC5kZXRhaWxzLmNvbG9yLnJ9LCAke2hleC5kZXRhaWxzLmNvbG9yLmd9LCAke2hleC5kZXRhaWxzLmNvbG9yLmJ9YCA6IGhleC50eXBlO1xuICAgIG1haW5DdHguZmlsbFN0eWxlID0gYHJnYmEoJHtjb2xvcn0sMSlgO1xuICAgIG1haW5DdHguYmVnaW5QYXRoKCk7XG4gICAgbWFpbkN0eC5tb3ZlVG8oeCArIGFfaGV4LCB5IC0gY19oZXgpO1xuICAgIG1haW5DdHgubGluZVRvKHggKyBiX2hleCwgeSk7XG4gICAgbWFpbkN0eC5saW5lVG8oeCArIGFfaGV4LCB5ICsgY19oZXgpO1xuICAgIG1haW5DdHgubGluZVRvKHggLSBhX2hleCwgeSArIGNfaGV4KTtcbiAgICBtYWluQ3R4LmxpbmVUbyh4IC0gYl9oZXgsIHkpO1xuICAgIG1haW5DdHgubGluZVRvKHggLSBhX2hleCwgeSAtIGNfaGV4KTtcbiAgICBtYWluQ3R4LmNsb3NlUGF0aCgpO1xuICAgIG1haW5DdHguZmlsbCgpO1xuICAgIHNldFRleHQobWFpbkN0eCwgeCwgeSAtIGhleFNpemUgLyAyLCBgJHtoZXgucX07JHtoZXgucn1gKTtcblxuICAgIGlmIChoZXguZGV0YWlscykge1xuICAgICAgc2V0VGV4dChtYWluQ3R4LCB4LCB5LCBgJHtoZXguZGV0YWlscy5lbmVyZ3l9YCk7XG4gICAgICBzZXRUZXh0KG1haW5DdHgsIHgsIHkgKyBoZXhTaXplIC8gMiwgYGx2bDogJHsxICogaGV4LmRldGFpbHMubGV2ZWwgKyAxfWApO1xuICAgIH1cbiAgfVxuXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3TWFwKTtcbn1cblxuZnVuY3Rpb24gc2V0VGV4dChjdHgsIHgsIHksIHR4dCwgZm9udFNpemUgPSAxMCwgc3R5bGUgPSBcIndoaXRlXCIsIGFsaWduID0gJ2NlbnRlcicpIHtcbiAgbGV0IF9mb250ID0gYCR7Zm9udFNpemUgKiAoY2FtZXJhLnpvb20gKyAxKX1weCBHZW9yZ2lhYDtcbiAgY3R4LmZvbnQgPSBfZm9udDtcbiAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlO1xuICBjdHgudGV4dEFsaWduID0gYWxpZ247XG4gIGN0eC5maWxsVGV4dCh0eHQsIHgsIHksIGhleFNpemUpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVIZXhEaW1lbnNpb25zKCkge1xuICBhX2Z1bGwgPSBoZXhTaXplIC8gMjtcbiAgYl9mdWxsID0gaGV4U2l6ZTtcbiAgY19mdWxsID0gaGV4U2l6ZSAvIDIgKiBNYXRoLnNxcnQoMyk7XG4gIGFfaGV4ID0gYV9mdWxsICogMC45NTtcbiAgYl9oZXggPSBiX2Z1bGwgKiAwLjk1O1xuICBjX2hleCA9IGNfZnVsbCAqIDAuOTU7XG59XG5cbmZ1bmN0aW9uIHdpbmRvd1Jlc2l6ZVVwZGF0ZSgpIHtcbiAgbWFpbkNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICBtYWluQ2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgYW5pbUNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICBhbmltQ2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgaGFsZkNhbnZhc1dpZHRoID0gbWFpbkNhbnZhcy53aWR0aCAvIDI7XG4gIGhhbGZDYW52YXNIZWlnaHQgPSBtYWluQ2FudmFzLmhlaWdodCAvIDI7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKGhhbGZDYW52YXNXaWR0aCwgaGFsZkNhbnZhc0hlaWdodCk7XG4gIHNjYWxlcyA9IG1pbiAvIDc7XG4gIGNvbnNvbGUubG9nKCdoYWxmQ2FudmFzJywgaGFsZkNhbnZhc1dpZHRoLCBoYWxmQ2FudmFzSGVpZ2h0KTtcbiAgY29uc29sZS5sb2coJ3NjYWxlcycsIHNjYWxlcyk7XG59IC8vSGV4IEhpZ2hsaWdodGluZ1xuXG5cbmFuaW1DYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoe1xuICBvZmZzZXRYLFxuICBvZmZzZXRZXG59KSA9PiB7XG4gIGNvbnNvbGUubG9nKCdjbGljaycsIGlzZGJsY2xpY2spO1xuICBhd2FpdCBzbGVlcCg1MDApO1xuICBjb25zb2xlLmxvZygnY2xpY2snLCBpc2RibGNsaWNrKTtcblxuICBpZiAoaXNkYmxjbGljaykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9mZnNldFggKz0gY2FtZXJhLnggLSBtYWluQ2FudmFzLndpZHRoIC8gMjtcbiAgb2Zmc2V0WSArPSBjYW1lcmEueSAtIG1haW5DYW52YXMuaGVpZ2h0IC8gMjtcbiAgY29uc3QgaGV4Q29vcmRpbmF0ZXMgPSBncmlkLnBvaW50VG9IZXgoe1xuICAgIHg6IG9mZnNldFgsXG4gICAgeTogb2Zmc2V0WVxuICB9KTtcblxuICBmb3IgKGxldCBoZXggb2YgY3VycmVudE1hcCkge1xuICAgIGlmIChoZXgueCA9PSBoZXhDb29yZGluYXRlcy54ICYmIGhleC55ID09IGhleENvb3JkaW5hdGVzLnkpIHtcbiAgICAgIGhleC5oaWdobGlnaHQgPSAhaGV4LmhpZ2hsaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGV4LmhpZ2hsaWdodCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG5hbmltQ2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgYXN5bmMgKHtcbiAgb2Zmc2V0WCxcbiAgb2Zmc2V0WVxufSkgPT4ge1xuICBpc2RibGNsaWNrID0gdHJ1ZTtcbiAgY29uc29sZS5sb2coJ2RibGNsaWNrJywgaXNkYmxjbGljayk7XG4gIGF3YWl0IHNsZWVwKDUwMCk7XG4gIGlzZGJsY2xpY2sgPSBmYWxzZTtcbiAgY29uc29sZS5sb2coJ2RibGNsaWNrJywgaXNkYmxjbGljayk7XG4gIG9mZnNldFggKz0gY2FtZXJhLnggLSBtYWluQ2FudmFzLndpZHRoIC8gMjtcbiAgb2Zmc2V0WSArPSBjYW1lcmEueSAtIG1haW5DYW52YXMuaGVpZ2h0IC8gMjtcbiAgY29uc3QgaGV4Q29vcmRpbmF0ZXMgPSBncmlkLnBvaW50VG9IZXgoe1xuICAgIHg6IG9mZnNldFgsXG4gICAgeTogb2Zmc2V0WVxuICB9KTtcbiAgY29uc29sZS5sb2coaGV4Q29vcmRpbmF0ZXMpO1xuICBsZXQgaEhleDtcbiAgbGV0IHRIZXg7XG5cbiAgZm9yIChsZXQgaGV4IG9mIGN1cnJlbnRNYXApIHtcbiAgICBpZiAoaGV4LmhpZ2hsaWdodCkge1xuICAgICAgaEhleCA9IGhleDtcbiAgICB9XG5cbiAgICBpZiAoaGV4LnggPT0gaGV4Q29vcmRpbmF0ZXMueCAmJiBoZXgueSA9PSBoZXhDb29yZGluYXRlcy55KSB7XG4gICAgICB0SGV4ID0gaGV4O1xuICAgIH1cbiAgfVxuXG4gIGlmICghdEhleCkgcmV0dXJuO1xuICBpZiAoaEhleCAmJiAhaEhleC5kZXRhaWxzKSByZXR1cm47XG4gIGNvbnNvbGUubG9nKCdoSGV4JywgaEhleCk7XG4gIGNvbnNvbGUubG9nKCd0SGV4JywgdEhleCk7XG4gIGxldCBjZWxsQ29vcmQgPSB7XG4gICAgeDogaGV4Q29vcmRpbmF0ZXMucSxcbiAgICB5OiBoZXhDb29yZGluYXRlcy5yLFxuICAgIHo6IGhleENvb3JkaW5hdGVzLnNcbiAgfTtcblxuICBpZiAoIWhIZXgpIHtcbiAgICBpZiAoIXRIZXguZGV0YWlscykge1xuICAgICAgYXdhaXQgUFJPVklERVIubmV3R2FtZShjZWxsQ29vcmQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChoSGV4LmFkZHJlc3MudG9TdHJpbmcoKSA9PSB0SGV4LmFkZHJlc3MudG9TdHJpbmcoKSkge1xuICAgIGF3YWl0IFBST1ZJREVSLnVwZ3JhZGVDZWxsKHRIZXguYWRkcmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpc05laWdoYm9ySGV4KGhIZXgsIHRIZXgpKSByZXR1cm47XG4gICAgbGV0IGVuZXJneSA9IDEwMDA7XG5cbiAgICBpZiAoIXRIZXguZGV0YWlscykge1xuICAgICAgYXdhaXQgUFJPVklERVIubWFya0NlbGwoaEhleC5hZGRyZXNzLCBjZWxsQ29vcmQsIGVuZXJneSk7XG4gICAgfSBlbHNlIGlmIChjb2xvcklzRXF1YWwoaEhleC5kZXRhaWxzLmNvbG9yLCB0SGV4LmRldGFpbHMuY29sb3IpKSB7XG4gICAgICAvLyDQv9C10YDQtdC/0LjRgdCw0YLRjCDRg9GB0LvQvtCy0LjQtSDQv9C+INCy0LvQsNC00LXQu9GM0YbRgyDRj9GH0LXQudC60Lgg0Lgg0YbQstC10YLQsFxuICAgICAgYXdhaXQgUFJPVklERVIuaGVscENlbGwoaEhleC5hZGRyZXNzLCBjZWxsQ29vcmQsIGVuZXJneSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IFBST1ZJREVSLmF0dGtDZWxsKGhIZXguYWRkcmVzcywgY2VsbENvb3JkLCBlbmVyZ3kpO1xuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNvbG9ySXNFcXVhbChjb2xvcjEsIGNvbG9yMikge1xuICByZXR1cm4gY29sb3IxLnIgPT0gY29sb3IyLnIgJiYgY29sb3IxLmcgPT0gY29sb3IyLmcgJiYgY29sb3IxLmIgPT0gY29sb3IyLmI7XG59XG5cbmZ1bmN0aW9uIGlzTmVpZ2hib3JIZXgoaGV4MSwgaGV4Mikge1xuICByZXR1cm4gY3ViZV9kaXN0YW5jZShoZXgxLCBoZXgyKSA9PSAxO1xufVxuXG5mdW5jdGlvbiBjdWJlX2Rpc3RhbmNlKGhleDEsIGhleDIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGguYWJzKGhleDEucSAtIGhleDIucSksIE1hdGguYWJzKGhleDEuciAtIGhleDIuciksIE1hdGguYWJzKGhleDEucyAtIGhleDIucykpO1xufVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCkgPT4ge1xuICB3aW5kb3dSZXNpemVVcGRhdGUoKTtcbiAgem9vbVVwZGF0ZSgpO1xufSk7Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/scripts/display.js\n");

/***/ }),

/***/ "./src/scripts/ever.js":
/*!*****************************!*\
  !*** ./src/scripts/ever.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"setMap\": () => (/* binding */ setMap),\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"routerDetails\": () => (/* binding */ routerDetails),\n/* harmony export */   \"routerLiders\": () => (/* binding */ routerLiders),\n/* harmony export */   \"subscribeAllCellState\": () => (/* binding */ subscribeAllCellState),\n/* harmony export */   \"getAddressCells\": () => (/* binding */ getAddressCells),\n/* harmony export */   \"newGame\": () => (/* binding */ newGame),\n/* harmony export */   \"markCell\": () => (/* binding */ markCell),\n/* harmony export */   \"upgradeCell\": () => (/* binding */ upgradeCell),\n/* harmony export */   \"helpCell\": () => (/* binding */ helpCell),\n/* harmony export */   \"attkCell\": () => (/* binding */ attkCell),\n/* harmony export */   \"newRouter\": () => (/* binding */ newRouter),\n/* harmony export */   \"getDetailsCell\": () => (/* binding */ getDetailsCell),\n/* harmony export */   \"getDetailsRouter\": () => (/* binding */ getDetailsRouter),\n/* harmony export */   \"subscribePermissionsChanged\": () => (/* binding */ subscribePermissionsChanged)\n/* harmony export */ });\n/* harmony import */ var everscale_inpage_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! everscale-inpage-provider */ \"./node_modules/everscale-inpage-provider/dist/index.js\");\n/* harmony import */ var everscale_inpage_provider__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(everscale_inpage_provider__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var everscale_standalone_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! everscale-standalone-client */ \"./node_modules/everscale-standalone-client/index.js\");\n/* harmony import */ var everscale_standalone_client__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(everscale_standalone_client__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nconst {\n  TonClient,\n  signerKeys,\n  signerNone\n} = __webpack_require__(/*! @eversdk/core */ \"./node_modules/@eversdk/core/dist/index.js\"); //const { libNode } = require(\"@eversdk/lib-node\");\n\n\nconst {\n  libWeb\n} = __webpack_require__(/*! @eversdk/lib-web */ \"./node_modules/@eversdk/lib-web/index.js\");\n\nconst {\n  Account\n} = __webpack_require__(/*! @eversdk/appkit */ \"./node_modules/@eversdk/appkit/dist/index.js\");\n\nTonClient.useBinaryLibrary(libWeb);\n\nconst routerAbi = __webpack_require__(/*! ../../contracts/build/Router.abi.json */ \"./contracts/build/Router.abi.json\");\n\nconst cellAbi = __webpack_require__(/*! ../../contracts/build/Cell.abi.json */ \"./contracts/build/Cell.abi.json\");\n\nconst rootAbi = __webpack_require__(/*! ../../contracts/build/GameRoot.abi.json */ \"./contracts/build/GameRoot.abi.json\");\n\nconst Config = __webpack_require__(/*! ../../config.json */ \"./config.json\");\n\nlet currentMap = [];\nlet onRoumingChange;\nconst ever = new everscale_inpage_provider__WEBPACK_IMPORTED_MODULE_0__.ProviderRpcClient({});\nlet everClient;\nlet subscribeAcc;\n\nconst createClient = endpoint => {\n  let client = new TonClient({\n    network: {\n      endpoints: [endpoint],\n      message_retries_count: 3,\n      message_processing_timeout: 60000\n    }\n  });\n  return client;\n};\n\nconst getAccount = (abi, address = '', keys = null) => {\n  try {\n    return new Account({\n      abi\n    }, {\n      address: address,\n      signer: keys ? signerKeys(keys) : signerNone(),\n      client: everClient\n    });\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nconst getAccArr = async addreses => {\n  try {\n    const result = (await everClient.net.query_collection({\n      collection: \"accounts\",\n      filter: {\n        id: {\n          in: addreses\n        }\n      },\n      result: \"id acc_type balance boc\"\n    })).result;\n    return result;\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nconst runLocal = async (abi, address, functionName, input = {}, log = true, boc = null) => {\n  try {\n    const [account, message] = await Promise.all([boc || everClient.net.query_collection({\n      collection: \"accounts\",\n      filter: {\n        id: {\n          eq: address\n        }\n      },\n      result: \"boc\"\n    }).then(({\n      result\n    }) => result[0].boc).catch(() => {\n      return undefined;\n    }), everClient.abi.encode_message({\n      abi: {\n        type: 'Contract',\n        value: abi\n      },\n      address,\n      call_set: {\n        function_name: functionName,\n        input: input\n      },\n      signer: {\n        type: \"None\"\n      }\n    }).then(({\n      message\n    }) => message)]);\n    if (!account) return undefined;\n    let response = await everClient.tvm.run_tvm({\n      message: message,\n      account: account,\n      abi: {\n        type: 'Contract',\n        value: abi\n      }\n    });\n    if (log) console.log(\"output:\", response.decoded.output);\n    return response.decoded.output;\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nfunction behavior(name, fn) {\n  document.querySelectorAll(`[data-behavior=${name}]`).forEach(fn);\n}\n\nconst innerText = text => elem => {\n  elem.innerText = text;\n};\n\nfunction requestPermissions() {\n  return ever.requestPermissions({\n    permissions: ['basic', 'accountInteraction']\n  });\n}\n\nasync function disconnectAction() {\n  console.log('disconnectAction');\n  await ever.disconnect();\n}\n\nasync function getRoutersAction() {\n  clearTblRows('tblRouters', 3);\n  console.log('getRoutersAction');\n  const providerState = await ever.getProviderState();\n  let details = await ever.getAccountsByCodeHash({\n    codeHash: Config[providerState.selectedConnection].codeHash,\n    limit: 50\n  });\n  let addreses = details.accounts.map(el => el.toString());\n  console.log('routers', addreses);\n  let accs = await getAccArr(addreses);\n  console.log('routers', accs);\n\n  for (let i = 0; i < accs.length; i++) {\n    let details = await getDetailsRouter(accs[i].id, accs[i].boc);\n\n    if (details) {\n      let row, cell;\n      var date = new Date(1000 * details.endTime);\n      console.log('date', date);\n      row = addTblRow('tblRouters');\n      cell = row.insertCell(0);\n      cell.innerHTML = details.name;\n      cell = row.insertCell(1);\n      cell.innerHTML = details.radius;\n      cell = row.insertCell(2);\n      cell.innerHTML = details.speed;\n      cell = row.insertCell(3);\n      cell.innerHTML = date.customFormat(\"#DD#-#MM#-#YYYY# #hh#:#mm#:#ss#\");\n      cell = row.insertCell(4);\n      var btn = document.createElement('button');\n      btn.textContent = \"Set\";\n      btn.setAttribute('type', 'button');\n      btn.setAttribute(\"addr\", accs[i].id);\n      btn.onclick = setRouter;\n      cell.appendChild(btn);\n      cell = row.insertCell(5);\n      cell.innerHTML = accs[i].id;\n      cell.style = \"visibility: hidden\"; // cell.colSpan = \"4\"\n      // cell.style=\"text-align:left;\"\n    }\n  }\n}\n\nasync function getLiderBoard() {\n  clearTblRows('tblLiders', 1);\n  console.log('getLiderBoard');\n  const providerState = await ever.getProviderState();\n  let details = await routerLiders();\n  let users = details.users.map(el => el.toString());\n  console.log('users', users);\n\n  for (let i = 0; i < users.length; i++) {\n    let usr = users[i].split(',');\n    let row, cell;\n    row = addTblRow('tblLiders');\n    cell = row.insertCell(0);\n    cell.innerHTML = `${usr[0].substr(0, 6)}...${usr[0].substr(-4, 4)}`;\n    cell = row.insertCell(1);\n    cell.innerHTML = usr[1]; // cell.colSpan = \"4\"\n    // cell.style=\"text-align:left;\"\n  }\n}\n\nasync function setRouter(el) {\n  console.log('setRouter', el);\n  let address = el.target.attributes.addr.value;\n  console.log('address', address);\n  const providerState = await ever.getProviderState();\n  const network = providerState.selectedConnection;\n  Config[network].router = address;\n\n  for (let hex of currentMap) {\n    hex.highlight = false;\n    hex.details = undefined;\n  }\n\n  let details = await routerDetails();\n  console.log('details', details);\n  onRoumingChange(details.radius);\n  loadMap();\n  getLiderBoard();\n}\n\nasync function addRouterAction() {\n  let name = document.getElementById('router_name').value;\n  let radius = document.getElementById('router_radius').value;\n  let speed = document.getElementById('router_speed').value;\n  let time = document.getElementById('router_time').value;\n  console.log('addRouterAction', name, radius, speed, time);\n  const providerState = await newRouter(name, radius, speed, time);\n  await getRoutersAction();\n}\n\nasync function connect() {\n  await ever.requestPermissions({\n    permissions: ['basic', 'accountInteraction']\n  });\n}\n\nasync function checkConnect() {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  const network = providerState.selectedConnection;\n\n  if (!contractAddress(network) || !permissions.accountInteraction) {\n    behavior('connect', elem => elem.onclick = requestPermissions);\n    switchScreen(\"login\");\n\n    const connectText = elem => {\n      const disabled = !contractAddress(network);\n      elem.disabled = disabled;\n      elem.innerText = disabled ? `Contract not found` : `Connect with ${network}`;\n    };\n\n    behavior('connect', connectText);\n  } else {\n    // INFO for transactionsFound and contractStateChanged need permissions\n    const providerState = await ever.getProviderState();\n    (await ever.subscribe('transactionsFound', {\n      address: contractAddress(providerState.selectedConnection)\n    })).on('data', event => {\n      console.log(':', {\n        address: event.address,\n        transactions: event.transactions,\n        info: event.info\n      });\n    });\n    (await ever.subscribe('contractStateChanged', {\n      address: contractAddress(providerState.selectedConnection)\n    })).on('data', event => {\n      console.log('permissionsChanged:', {\n        address: event.address,\n        state: event.state\n      });\n    });\n    switchScreen(\"main\");\n    const account = permissions.accountInteraction;\n    let address = account.address.toString();\n    let pubkey = account.publicKey.toString();\n    behavior('address', innerText(`${address.substr(0, 6)}...${address.substr(-4, 4)}`));\n    behavior('publicKey', innerText(`${pubkey.substr(0, 6)}...${pubkey.substr(-4, 4)}`));\n    behavior('disconnectAction', elem => elem.onclick = disconnectAction);\n    behavior('getRoutersAction', elem => elem.onclick = getRoutersAction);\n    behavior('addRouterAction', elem => elem.onclick = addRouterAction);\n    console.log('endpoint:', Config[network].endpoint);\n    everClient = createClient(Config[network].endpoint);\n    subscribeAcc = getAccount({}); // loadMap();\n\n    await getRoutersAction();\n  }\n}\n\nasync function setNetworkChanged(network) {\n  const mod = network === 'mainnet' ? 'success' : 'secondary';\n  const out = `<span class=\"badge bg-${mod}\">${network}</span>`;\n  behavior('network', elem => elem.innerHTML = out);\n  await checkConnect();\n}\n\nfunction contractAddress(network, name = \"router\") {\n  if (Config[network] && Config[network][name]) {\n    return new everscale_inpage_provider__WEBPACK_IMPORTED_MODULE_0__.Address(Config[network][name]);\n  }\n\n  return null;\n}\n\nfunction switchScreen(to) {\n  console.log('switchScreen:', to);\n  [\"extension\", \"login\", \"main\"].forEach(screen => {\n    const switcher = elem => elem.style.display = to === screen ? 'table-row' : 'none';\n\n    behavior(screen, switcher);\n  });\n}\n\nasync function mainFlow() {\n  const providerState = await ever.getProviderState();\n  console.log('selectedConnection:', providerState.selectedConnection);\n  await setNetworkChanged(providerState.selectedConnection);\n  (await ever.subscribe('networkChanged')).on('data', event => {\n    console.log('networkChanged:', event.selectedConnection);\n    setNetworkChanged(event.selectedConnection);\n  });\n  (await ever.subscribe('permissionsChanged')).on('data', async event => {\n    console.log('permissionsChanged:', event.permissions);\n    await checkConnect();\n  });\n}\n\nasync function loadMap() {\n  let coords = [];\n\n  for (const hex of currentMap) {\n    coords.push({\n      x: hex.q,\n      y: hex.r,\n      z: hex.s\n    });\n  } // console.log('coords', coords);\n\n\n  let addreses = await getAddressCells(coords);\n  addreses = addreses.map(el => el.toString());\n  let i = 0;\n\n  for (const hex of currentMap) {\n    hex.address = addreses[i].toString();\n    i++;\n  } // console.log('addreses', addreses);\n\n\n  await subscribeAllCellState(addreses);\n  let accs = await getAccArr(addreses);\n  console.log('accs', accs);\n\n  for (let i = 0; i < accs.length; i++) {\n    let details = await getDetailsCell(accs[i].id, accs[i].boc);\n\n    if (details) {\n      let hex = findHex(accs[i].id);\n      console.log('hex', hex);\n\n      if (hex) {\n        hex.details = details;\n      }\n    }\n  }\n}\n\nfunction setMap(map) {\n  currentMap = map;\n}\nasync function init(_onRoumingChange) {\n  onRoumingChange = _onRoumingChange;\n\n  if (await ever.hasProvider()) {\n    try {\n      await ever.ensureInitialized();\n      await mainFlow();\n    } catch (error) {\n      throw error; // TODO handle it\n    }\n  } else {\n    switchScreen(\"extension\");\n  }\n}\n\nfunction findHex(address) {\n  let _hex;\n\n  for (const hex of currentMap) {\n    if (hex.address == address) {\n      _hex = hex;\n      break;\n    }\n  }\n\n  return _hex;\n}\n\nasync function routerDetails() {\n  const providerState = await ever.getProviderState();\n  const router = new ever.Contract(routerAbi, contractAddress(providerState.selectedConnection, 'router'));\n\n  try {\n    let details;\n    details = await router.methods.getDetails({}).call();\n    console.log('getDetails router', details);\n    return details;\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof everscale_inpage_provider__WEBPACK_IMPORTED_MODULE_0__.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function routerLiders() {\n  const providerState = await ever.getProviderState();\n  const router = new ever.Contract(routerAbi, contractAddress(providerState.selectedConnection, 'router'));\n\n  try {\n    let details;\n    details = await router.methods.getUsers({}).call();\n    console.log('getUsers router', details);\n    return details;\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof everscale_inpage_provider__WEBPACK_IMPORTED_MODULE_0__.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function subscribeAllCellState(arrAcc) {\n  try {\n    await subscribeAcc.free();\n    await subscribeAcc.subscribe(\"accounts\", {\n      id: {\n        in: arrAcc\n      }\n    }, \"id boc\", async msg => {\n      console.log(`onAcc:`, msg.id);\n      let hex = findHex(msg.id);\n      console.log('hex', hex);\n\n      if (hex) {\n        hex.details = await getDetailsCell(msg.id, msg.boc);\n      }\n\n      getLiderBoard();\n    }, async msg => {\n      console.log(`onError:`, msg);\n    });\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof everscale_inpage_provider__WEBPACK_IMPORTED_MODULE_0__.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function getAddressCells(coords) {\n  const providerState = await ever.getProviderState();\n  const router = new ever.Contract(routerAbi, contractAddress(providerState.selectedConnection, 'router'));\n\n  try {\n    let details;\n    details = await router.methods.getAddressCells({\n      coords\n    }).call();\n    console.log('getAddressCells router', details);\n    return details.addreses;\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof everscale_inpage_provider__WEBPACK_IMPORTED_MODULE_0__.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function newGame(cellCoord) {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  if (!permissions.accountInteraction) return;\n  const account = permissions.accountInteraction;\n  const router = new ever.Contract(routerAbi, contractAddress(providerState.selectedConnection, 'router'));\n\n  try {\n    console.log('newGame', 1);\n    let res = await router.methods.newGame({\n      baseCoord: cellCoord\n    }).send({\n      from: account.address.toString(),\n      amount: '2000000000'\n    });\n    console.log('newGame', res);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof everscale_inpage_provider__WEBPACK_IMPORTED_MODULE_0__.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function markCell(address, cellCoord, energy) {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  if (!permissions.accountInteraction) return;\n  const account = permissions.accountInteraction;\n  const cell = new ever.Contract(cellAbi, address);\n\n  try {\n    console.log('markCell', 1);\n    let res = await cell.methods.markCell({\n      targetCoord: cellCoord,\n      energy: energy\n    }).send({\n      from: account.address.toString(),\n      amount: '2000000000'\n    });\n    console.log('markCell', res);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof everscale_inpage_provider__WEBPACK_IMPORTED_MODULE_0__.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function upgradeCell(address) {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  if (!permissions.accountInteraction) return;\n  const account = permissions.accountInteraction;\n  const cell = new ever.Contract(cellAbi, address);\n\n  try {\n    console.log('upgradeCell', 1);\n    let res = await cell.methods.upgradeCell({// }).sendExternal({ publicKey: account.publicKey.toString() })\n    }).send({\n      from: account.address.toString(),\n      amount: '1000000000'\n    });\n    console.log('upgradeCell', res);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof everscale_inpage_provider__WEBPACK_IMPORTED_MODULE_0__.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function helpCell(address, cellCoord, energy) {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  if (!permissions.accountInteraction) return;\n  const account = permissions.accountInteraction;\n  const cell = new ever.Contract(cellAbi, address);\n\n  try {\n    console.log('helpCell', 1);\n    let res = await cell.methods.helpCell({\n      targetCoord: cellCoord,\n      energy: energy\n    }).send({\n      from: account.address.toString(),\n      amount: '1000000000'\n    });\n    console.log('helpCell', res);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof everscale_inpage_provider__WEBPACK_IMPORTED_MODULE_0__.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function attkCell(address, cellCoord, energy) {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  if (!permissions.accountInteraction) return;\n  const account = permissions.accountInteraction;\n  const cell = new ever.Contract(cellAbi, address);\n\n  try {\n    console.log('attkCell', 1);\n    let res = await cell.methods.attkCell({\n      targetCoord: cellCoord,\n      energy: energy\n    }).send({\n      from: account.address.toString(),\n      amount: '1000000000'\n    });\n    console.log('attkCell', res);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof everscale_inpage_provider__WEBPACK_IMPORTED_MODULE_0__.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function newRouter(name, radius, speed, time) {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  if (!permissions.accountInteraction) return;\n  const account = permissions.accountInteraction;\n  const gameroot = new ever.Contract(rootAbi, Config[providerState.selectedConnection].gameroot);\n\n  try {\n    console.log('newRouter', 1);\n    let res = await gameroot.methods.newRouter({\n      roundTime: time,\n      radius: radius,\n      speed: speed,\n      name: name,\n      nonce: '0'\n    }).send({\n      from: account.address.toString(),\n      amount: '2000000000'\n    });\n    console.log('newRouter', res);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof everscale_inpage_provider__WEBPACK_IMPORTED_MODULE_0__.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function getDetailsCell(address, boc = null) {\n  if (boc) {\n    try {\n      const output = await runLocal(cellAbi, address, \"getDetails\", {}, true, boc);\n      return output;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  const cell = new ever.Contract(cellAbi, address);\n\n  try {\n    const stateRes = await cell.getFullState();\n\n    if (stateRes.state == null || !stateRes.state.isDeployed) {\n      return null;\n    } //console.log('state', stateRes.state);\n\n\n    let details;\n    details = await cell.methods.getDetails({}).call();\n    console.log('getDetails cell', details);\n    return details;\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof everscale_inpage_provider__WEBPACK_IMPORTED_MODULE_0__.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function getDetailsRouter(address, boc = null) {\n  if (boc) {\n    try {\n      const output = await runLocal(routerAbi, address, \"getDetails\", {}, true, boc);\n      return output;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  const router = new ever.Contract(routerAbi, address);\n\n  try {\n    const stateRes = await router.getFullState();\n\n    if (stateRes.state == null || !stateRes.state.isDeployed) {\n      return null;\n    } //console.log('state', stateRes.state);\n\n\n    let details;\n    details = await router.methods.getDetails({}).call();\n    console.log('getDetails router', details);\n    return details;\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof everscale_inpage_provider__WEBPACK_IMPORTED_MODULE_0__.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function subscribePermissionsChanged() {\n  await ever.subscribe('permissionsChanged').on('data', permissions => {\n    console.log(permissions);\n  });\n}\n\nfunction addTblRow(tblName) {\n  var table = document.getElementById(tblName);\n  return table.insertRow(table.rows.length);\n}\n\nfunction clearTblRows(tblName, min = 1) {\n  var table = document.getElementById(tblName);\n\n  while (table.rows.length > min) table.deleteRow(table.rows.length - 1);\n}\n\nDate.prototype.customFormat = function (formatString) {\n  var YYYY, YY, MMMM, MMM, MM, M, DDDD, DDD, DD, D, hhhh, hhh, hh, h, mm, m, ss, s, ampm, AMPM, dMod, th;\n  var dateObject = this;\n  YY = ((YYYY = dateObject.getFullYear()) + \"\").slice(-2);\n  MM = (M = dateObject.getMonth() + 1) < 10 ? '0' + M : M;\n  MMM = (MMMM = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"][M - 1]).substring(0, 3);\n  DD = (D = dateObject.getDate()) < 10 ? '0' + D : D;\n  DDD = (DDDD = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"][dateObject.getDay()]).substring(0, 3);\n  th = D >= 10 && D <= 20 ? 'th' : (dMod = D % 10) == 1 ? 'st' : dMod == 2 ? 'nd' : dMod == 3 ? 'rd' : 'th';\n  formatString = formatString.replace(\"#YYYY#\", YYYY).replace(\"#YY#\", YY).replace(\"#MMMM#\", MMMM).replace(\"#MMM#\", MMM).replace(\"#MM#\", MM).replace(\"#M#\", M).replace(\"#DDDD#\", DDDD).replace(\"#DDD#\", DDD).replace(\"#DD#\", DD).replace(\"#D#\", D).replace(\"#th#\", th);\n  h = hhh = dateObject.getHours();\n  if (h == 0) h = 24;\n  if (h > 12) h -= 12;\n  hh = h < 10 ? '0' + h : h;\n  hhhh = hhh < 10 ? '0' + hhh : hhh;\n  AMPM = (ampm = hhh < 12 ? 'am' : 'pm').toUpperCase();\n  mm = (m = dateObject.getMinutes()) < 10 ? '0' + m : m;\n  ss = (s = dateObject.getSeconds()) < 10 ? '0' + s : s;\n  return formatString.replace(\"#hhhh#\", hhhh).replace(\"#hhh#\", hhh).replace(\"#hh#\", hh).replace(\"#h#\", h).replace(\"#mm#\", mm).replace(\"#m#\", m).replace(\"#ss#\", ss).replace(\"#s#\", s).replace(\"#ampm#\", ampm).replace(\"#AMPM#\", AMPM);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0cy9ldmVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vc3JjL3NjcmlwdHMvZXZlci5qcz8wOWQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFkZHJlc3MsIFByb3ZpZGVyUnBjQ2xpZW50LCBUdm1FeGNlcHRpb24gfSBmcm9tICdldmVyc2NhbGUtaW5wYWdlLXByb3ZpZGVyJztcbmltcG9ydCB7IEV2ZXJzY2FsZVN0YW5kYWxvbmVDbGllbnQsIFNpbXBsZUtleXN0b3JlLCBTaW1wbGVBY2NvdW50c1N0b3JhZ2UsIFdhbGxldFYzQWNjb3VudCB9IGZyb20gJ2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudCc7XG5cbmNvbnN0IHtcbiAgVG9uQ2xpZW50LFxuICBzaWduZXJLZXlzLFxuICBzaWduZXJOb25lXG59ID0gcmVxdWlyZShcIkBldmVyc2RrL2NvcmVcIik7IC8vY29uc3QgeyBsaWJOb2RlIH0gPSByZXF1aXJlKFwiQGV2ZXJzZGsvbGliLW5vZGVcIik7XG5cblxuY29uc3Qge1xuICBsaWJXZWJcbn0gPSByZXF1aXJlKFwiQGV2ZXJzZGsvbGliLXdlYlwiKTtcblxuY29uc3Qge1xuICBBY2NvdW50XG59ID0gcmVxdWlyZShcIkBldmVyc2RrL2FwcGtpdFwiKTtcblxuVG9uQ2xpZW50LnVzZUJpbmFyeUxpYnJhcnkobGliV2ViKTtcblxuY29uc3Qgcm91dGVyQWJpID0gcmVxdWlyZSgnLi4vLi4vY29udHJhY3RzL2J1aWxkL1JvdXRlci5hYmkuanNvbicpO1xuXG5jb25zdCBjZWxsQWJpID0gcmVxdWlyZSgnLi4vLi4vY29udHJhY3RzL2J1aWxkL0NlbGwuYWJpLmpzb24nKTtcblxuY29uc3Qgcm9vdEFiaSA9IHJlcXVpcmUoJy4uLy4uL2NvbnRyYWN0cy9idWlsZC9HYW1lUm9vdC5hYmkuanNvbicpO1xuXG5jb25zdCBDb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnLmpzb25cIik7XG5cbmxldCBjdXJyZW50TWFwID0gW107XG5sZXQgb25Sb3VtaW5nQ2hhbmdlO1xuY29uc3QgZXZlciA9IG5ldyBQcm92aWRlclJwY0NsaWVudCh7fSk7XG5sZXQgZXZlckNsaWVudDtcbmxldCBzdWJzY3JpYmVBY2M7XG5cbmNvbnN0IGNyZWF0ZUNsaWVudCA9IGVuZHBvaW50ID0+IHtcbiAgbGV0IGNsaWVudCA9IG5ldyBUb25DbGllbnQoe1xuICAgIG5ldHdvcms6IHtcbiAgICAgIGVuZHBvaW50czogW2VuZHBvaW50XSxcbiAgICAgIG1lc3NhZ2VfcmV0cmllc19jb3VudDogMyxcbiAgICAgIG1lc3NhZ2VfcHJvY2Vzc2luZ190aW1lb3V0OiA2MDAwMFxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjbGllbnQ7XG59O1xuXG5jb25zdCBnZXRBY2NvdW50ID0gKGFiaSwgYWRkcmVzcyA9ICcnLCBrZXlzID0gbnVsbCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgQWNjb3VudCh7XG4gICAgICBhYmlcbiAgICB9LCB7XG4gICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgc2lnbmVyOiBrZXlzID8gc2lnbmVyS2V5cyhrZXlzKSA6IHNpZ25lck5vbmUoKSxcbiAgICAgIGNsaWVudDogZXZlckNsaWVudFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5jb25zdCBnZXRBY2NBcnIgPSBhc3luYyBhZGRyZXNlcyA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gKGF3YWl0IGV2ZXJDbGllbnQubmV0LnF1ZXJ5X2NvbGxlY3Rpb24oe1xuICAgICAgY29sbGVjdGlvbjogXCJhY2NvdW50c1wiLFxuICAgICAgZmlsdGVyOiB7XG4gICAgICAgIGlkOiB7XG4gICAgICAgICAgaW46IGFkZHJlc2VzXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXN1bHQ6IFwiaWQgYWNjX3R5cGUgYmFsYW5jZSBib2NcIlxuICAgIH0pKS5yZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuY29uc3QgcnVuTG9jYWwgPSBhc3luYyAoYWJpLCBhZGRyZXNzLCBmdW5jdGlvbk5hbWUsIGlucHV0ID0ge30sIGxvZyA9IHRydWUsIGJvYyA9IG51bGwpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBbYWNjb3VudCwgbWVzc2FnZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbYm9jIHx8IGV2ZXJDbGllbnQubmV0LnF1ZXJ5X2NvbGxlY3Rpb24oe1xuICAgICAgY29sbGVjdGlvbjogXCJhY2NvdW50c1wiLFxuICAgICAgZmlsdGVyOiB7XG4gICAgICAgIGlkOiB7XG4gICAgICAgICAgZXE6IGFkZHJlc3NcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc3VsdDogXCJib2NcIlxuICAgIH0pLnRoZW4oKHtcbiAgICAgIHJlc3VsdFxuICAgIH0pID0+IHJlc3VsdFswXS5ib2MpLmNhdGNoKCgpID0+IHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSksIGV2ZXJDbGllbnQuYWJpLmVuY29kZV9tZXNzYWdlKHtcbiAgICAgIGFiaToge1xuICAgICAgICB0eXBlOiAnQ29udHJhY3QnLFxuICAgICAgICB2YWx1ZTogYWJpXG4gICAgICB9LFxuICAgICAgYWRkcmVzcyxcbiAgICAgIGNhbGxfc2V0OiB7XG4gICAgICAgIGZ1bmN0aW9uX25hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgaW5wdXQ6IGlucHV0XG4gICAgICB9LFxuICAgICAgc2lnbmVyOiB7XG4gICAgICAgIHR5cGU6IFwiTm9uZVwiXG4gICAgICB9XG4gICAgfSkudGhlbigoe1xuICAgICAgbWVzc2FnZVxuICAgIH0pID0+IG1lc3NhZ2UpXSk7XG4gICAgaWYgKCFhY2NvdW50KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGV2ZXJDbGllbnQudHZtLnJ1bl90dm0oe1xuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIGFjY291bnQ6IGFjY291bnQsXG4gICAgICBhYmk6IHtcbiAgICAgICAgdHlwZTogJ0NvbnRyYWN0JyxcbiAgICAgICAgdmFsdWU6IGFiaVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChsb2cpIGNvbnNvbGUubG9nKFwib3V0cHV0OlwiLCByZXNwb25zZS5kZWNvZGVkLm91dHB1dCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRlY29kZWQub3V0cHV0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBiZWhhdmlvcihuYW1lLCBmbikge1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS1iZWhhdmlvcj0ke25hbWV9XWApLmZvckVhY2goZm4pO1xufVxuXG5jb25zdCBpbm5lclRleHQgPSB0ZXh0ID0+IGVsZW0gPT4ge1xuICBlbGVtLmlubmVyVGV4dCA9IHRleHQ7XG59O1xuXG5mdW5jdGlvbiByZXF1ZXN0UGVybWlzc2lvbnMoKSB7XG4gIHJldHVybiBldmVyLnJlcXVlc3RQZXJtaXNzaW9ucyh7XG4gICAgcGVybWlzc2lvbnM6IFsnYmFzaWMnLCAnYWNjb3VudEludGVyYWN0aW9uJ11cbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRpc2Nvbm5lY3RBY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCdkaXNjb25uZWN0QWN0aW9uJyk7XG4gIGF3YWl0IGV2ZXIuZGlzY29ubmVjdCgpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRSb3V0ZXJzQWN0aW9uKCkge1xuICBjbGVhclRibFJvd3MoJ3RibFJvdXRlcnMnLCAzKTtcbiAgY29uc29sZS5sb2coJ2dldFJvdXRlcnNBY3Rpb24nKTtcbiAgY29uc3QgcHJvdmlkZXJTdGF0ZSA9IGF3YWl0IGV2ZXIuZ2V0UHJvdmlkZXJTdGF0ZSgpO1xuICBsZXQgZGV0YWlscyA9IGF3YWl0IGV2ZXIuZ2V0QWNjb3VudHNCeUNvZGVIYXNoKHtcbiAgICBjb2RlSGFzaDogQ29uZmlnW3Byb3ZpZGVyU3RhdGUuc2VsZWN0ZWRDb25uZWN0aW9uXS5jb2RlSGFzaCxcbiAgICBsaW1pdDogNTBcbiAgfSk7XG4gIGxldCBhZGRyZXNlcyA9IGRldGFpbHMuYWNjb3VudHMubWFwKGVsID0+IGVsLnRvU3RyaW5nKCkpO1xuICBjb25zb2xlLmxvZygncm91dGVycycsIGFkZHJlc2VzKTtcbiAgbGV0IGFjY3MgPSBhd2FpdCBnZXRBY2NBcnIoYWRkcmVzZXMpO1xuICBjb25zb2xlLmxvZygncm91dGVycycsIGFjY3MpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWNjcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBkZXRhaWxzID0gYXdhaXQgZ2V0RGV0YWlsc1JvdXRlcihhY2NzW2ldLmlkLCBhY2NzW2ldLmJvYyk7XG5cbiAgICBpZiAoZGV0YWlscykge1xuICAgICAgbGV0IHJvdywgY2VsbDtcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoMTAwMCAqIGRldGFpbHMuZW5kVGltZSk7XG4gICAgICBjb25zb2xlLmxvZygnZGF0ZScsIGRhdGUpO1xuICAgICAgcm93ID0gYWRkVGJsUm93KCd0YmxSb3V0ZXJzJyk7XG4gICAgICBjZWxsID0gcm93Lmluc2VydENlbGwoMCk7XG4gICAgICBjZWxsLmlubmVySFRNTCA9IGRldGFpbHMubmFtZTtcbiAgICAgIGNlbGwgPSByb3cuaW5zZXJ0Q2VsbCgxKTtcbiAgICAgIGNlbGwuaW5uZXJIVE1MID0gZGV0YWlscy5yYWRpdXM7XG4gICAgICBjZWxsID0gcm93Lmluc2VydENlbGwoMik7XG4gICAgICBjZWxsLmlubmVySFRNTCA9IGRldGFpbHMuc3BlZWQ7XG4gICAgICBjZWxsID0gcm93Lmluc2VydENlbGwoMyk7XG4gICAgICBjZWxsLmlubmVySFRNTCA9IGRhdGUuY3VzdG9tRm9ybWF0KFwiI0REIy0jTU0jLSNZWVlZIyAjaGgjOiNtbSM6I3NzI1wiKTtcbiAgICAgIGNlbGwgPSByb3cuaW5zZXJ0Q2VsbCg0KTtcbiAgICAgIHZhciBidG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgIGJ0bi50ZXh0Q29udGVudCA9IFwiU2V0XCI7XG4gICAgICBidG4uc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgICAgYnRuLnNldEF0dHJpYnV0ZShcImFkZHJcIiwgYWNjc1tpXS5pZCk7XG4gICAgICBidG4ub25jbGljayA9IHNldFJvdXRlcjtcbiAgICAgIGNlbGwuYXBwZW5kQ2hpbGQoYnRuKTtcbiAgICAgIGNlbGwgPSByb3cuaW5zZXJ0Q2VsbCg1KTtcbiAgICAgIGNlbGwuaW5uZXJIVE1MID0gYWNjc1tpXS5pZDtcbiAgICAgIGNlbGwuc3R5bGUgPSBcInZpc2liaWxpdHk6IGhpZGRlblwiOyAvLyBjZWxsLmNvbFNwYW4gPSBcIjRcIlxuICAgICAgLy8gY2VsbC5zdHlsZT1cInRleHQtYWxpZ246bGVmdDtcIlxuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRMaWRlckJvYXJkKCkge1xuICBjbGVhclRibFJvd3MoJ3RibExpZGVycycsIDEpO1xuICBjb25zb2xlLmxvZygnZ2V0TGlkZXJCb2FyZCcpO1xuICBjb25zdCBwcm92aWRlclN0YXRlID0gYXdhaXQgZXZlci5nZXRQcm92aWRlclN0YXRlKCk7XG4gIGxldCBkZXRhaWxzID0gYXdhaXQgcm91dGVyTGlkZXJzKCk7XG4gIGxldCB1c2VycyA9IGRldGFpbHMudXNlcnMubWFwKGVsID0+IGVsLnRvU3RyaW5nKCkpO1xuICBjb25zb2xlLmxvZygndXNlcnMnLCB1c2Vycyk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1c2Vycy5sZW5ndGg7IGkrKykge1xuICAgIGxldCB1c3IgPSB1c2Vyc1tpXS5zcGxpdCgnLCcpO1xuICAgIGxldCByb3csIGNlbGw7XG4gICAgcm93ID0gYWRkVGJsUm93KCd0YmxMaWRlcnMnKTtcbiAgICBjZWxsID0gcm93Lmluc2VydENlbGwoMCk7XG4gICAgY2VsbC5pbm5lckhUTUwgPSBgJHt1c3JbMF0uc3Vic3RyKDAsIDYpfS4uLiR7dXNyWzBdLnN1YnN0cigtNCwgNCl9YDtcbiAgICBjZWxsID0gcm93Lmluc2VydENlbGwoMSk7XG4gICAgY2VsbC5pbm5lckhUTUwgPSB1c3JbMV07IC8vIGNlbGwuY29sU3BhbiA9IFwiNFwiXG4gICAgLy8gY2VsbC5zdHlsZT1cInRleHQtYWxpZ246bGVmdDtcIlxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNldFJvdXRlcihlbCkge1xuICBjb25zb2xlLmxvZygnc2V0Um91dGVyJywgZWwpO1xuICBsZXQgYWRkcmVzcyA9IGVsLnRhcmdldC5hdHRyaWJ1dGVzLmFkZHIudmFsdWU7XG4gIGNvbnNvbGUubG9nKCdhZGRyZXNzJywgYWRkcmVzcyk7XG4gIGNvbnN0IHByb3ZpZGVyU3RhdGUgPSBhd2FpdCBldmVyLmdldFByb3ZpZGVyU3RhdGUoKTtcbiAgY29uc3QgbmV0d29yayA9IHByb3ZpZGVyU3RhdGUuc2VsZWN0ZWRDb25uZWN0aW9uO1xuICBDb25maWdbbmV0d29ya10ucm91dGVyID0gYWRkcmVzcztcblxuICBmb3IgKGxldCBoZXggb2YgY3VycmVudE1hcCkge1xuICAgIGhleC5oaWdobGlnaHQgPSBmYWxzZTtcbiAgICBoZXguZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxldCBkZXRhaWxzID0gYXdhaXQgcm91dGVyRGV0YWlscygpO1xuICBjb25zb2xlLmxvZygnZGV0YWlscycsIGRldGFpbHMpO1xuICBvblJvdW1pbmdDaGFuZ2UoZGV0YWlscy5yYWRpdXMpO1xuICBsb2FkTWFwKCk7XG4gIGdldExpZGVyQm9hcmQoKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYWRkUm91dGVyQWN0aW9uKCkge1xuICBsZXQgbmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb3V0ZXJfbmFtZScpLnZhbHVlO1xuICBsZXQgcmFkaXVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JvdXRlcl9yYWRpdXMnKS52YWx1ZTtcbiAgbGV0IHNwZWVkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JvdXRlcl9zcGVlZCcpLnZhbHVlO1xuICBsZXQgdGltZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb3V0ZXJfdGltZScpLnZhbHVlO1xuICBjb25zb2xlLmxvZygnYWRkUm91dGVyQWN0aW9uJywgbmFtZSwgcmFkaXVzLCBzcGVlZCwgdGltZSk7XG4gIGNvbnN0IHByb3ZpZGVyU3RhdGUgPSBhd2FpdCBuZXdSb3V0ZXIobmFtZSwgcmFkaXVzLCBzcGVlZCwgdGltZSk7XG4gIGF3YWl0IGdldFJvdXRlcnNBY3Rpb24oKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgYXdhaXQgZXZlci5yZXF1ZXN0UGVybWlzc2lvbnMoe1xuICAgIHBlcm1pc3Npb25zOiBbJ2Jhc2ljJywgJ2FjY291bnRJbnRlcmFjdGlvbiddXG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjaGVja0Nvbm5lY3QoKSB7XG4gIGNvbnN0IHByb3ZpZGVyU3RhdGUgPSBhd2FpdCBldmVyLmdldFByb3ZpZGVyU3RhdGUoKTtcbiAgY29uc3QgcGVybWlzc2lvbnMgPSBwcm92aWRlclN0YXRlLnBlcm1pc3Npb25zO1xuICBjb25zdCBuZXR3b3JrID0gcHJvdmlkZXJTdGF0ZS5zZWxlY3RlZENvbm5lY3Rpb247XG5cbiAgaWYgKCFjb250cmFjdEFkZHJlc3MobmV0d29yaykgfHwgIXBlcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbikge1xuICAgIGJlaGF2aW9yKCdjb25uZWN0JywgZWxlbSA9PiBlbGVtLm9uY2xpY2sgPSByZXF1ZXN0UGVybWlzc2lvbnMpO1xuICAgIHN3aXRjaFNjcmVlbihcImxvZ2luXCIpO1xuXG4gICAgY29uc3QgY29ubmVjdFRleHQgPSBlbGVtID0+IHtcbiAgICAgIGNvbnN0IGRpc2FibGVkID0gIWNvbnRyYWN0QWRkcmVzcyhuZXR3b3JrKTtcbiAgICAgIGVsZW0uZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICAgIGVsZW0uaW5uZXJUZXh0ID0gZGlzYWJsZWQgPyBgQ29udHJhY3Qgbm90IGZvdW5kYCA6IGBDb25uZWN0IHdpdGggJHtuZXR3b3JrfWA7XG4gICAgfTtcblxuICAgIGJlaGF2aW9yKCdjb25uZWN0JywgY29ubmVjdFRleHQpO1xuICB9IGVsc2Uge1xuICAgIC8vIElORk8gZm9yIHRyYW5zYWN0aW9uc0ZvdW5kIGFuZCBjb250cmFjdFN0YXRlQ2hhbmdlZCBuZWVkIHBlcm1pc3Npb25zXG4gICAgY29uc3QgcHJvdmlkZXJTdGF0ZSA9IGF3YWl0IGV2ZXIuZ2V0UHJvdmlkZXJTdGF0ZSgpO1xuICAgIChhd2FpdCBldmVyLnN1YnNjcmliZSgndHJhbnNhY3Rpb25zRm91bmQnLCB7XG4gICAgICBhZGRyZXNzOiBjb250cmFjdEFkZHJlc3MocHJvdmlkZXJTdGF0ZS5zZWxlY3RlZENvbm5lY3Rpb24pXG4gICAgfSkpLm9uKCdkYXRhJywgZXZlbnQgPT4ge1xuICAgICAgY29uc29sZS5sb2coJzonLCB7XG4gICAgICAgIGFkZHJlc3M6IGV2ZW50LmFkZHJlc3MsXG4gICAgICAgIHRyYW5zYWN0aW9uczogZXZlbnQudHJhbnNhY3Rpb25zLFxuICAgICAgICBpbmZvOiBldmVudC5pbmZvXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAoYXdhaXQgZXZlci5zdWJzY3JpYmUoJ2NvbnRyYWN0U3RhdGVDaGFuZ2VkJywge1xuICAgICAgYWRkcmVzczogY29udHJhY3RBZGRyZXNzKHByb3ZpZGVyU3RhdGUuc2VsZWN0ZWRDb25uZWN0aW9uKVxuICAgIH0pKS5vbignZGF0YScsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdwZXJtaXNzaW9uc0NoYW5nZWQ6Jywge1xuICAgICAgICBhZGRyZXNzOiBldmVudC5hZGRyZXNzLFxuICAgICAgICBzdGF0ZTogZXZlbnQuc3RhdGVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHN3aXRjaFNjcmVlbihcIm1haW5cIik7XG4gICAgY29uc3QgYWNjb3VudCA9IHBlcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbjtcbiAgICBsZXQgYWRkcmVzcyA9IGFjY291bnQuYWRkcmVzcy50b1N0cmluZygpO1xuICAgIGxldCBwdWJrZXkgPSBhY2NvdW50LnB1YmxpY0tleS50b1N0cmluZygpO1xuICAgIGJlaGF2aW9yKCdhZGRyZXNzJywgaW5uZXJUZXh0KGAke2FkZHJlc3Muc3Vic3RyKDAsIDYpfS4uLiR7YWRkcmVzcy5zdWJzdHIoLTQsIDQpfWApKTtcbiAgICBiZWhhdmlvcigncHVibGljS2V5JywgaW5uZXJUZXh0KGAke3B1YmtleS5zdWJzdHIoMCwgNil9Li4uJHtwdWJrZXkuc3Vic3RyKC00LCA0KX1gKSk7XG4gICAgYmVoYXZpb3IoJ2Rpc2Nvbm5lY3RBY3Rpb24nLCBlbGVtID0+IGVsZW0ub25jbGljayA9IGRpc2Nvbm5lY3RBY3Rpb24pO1xuICAgIGJlaGF2aW9yKCdnZXRSb3V0ZXJzQWN0aW9uJywgZWxlbSA9PiBlbGVtLm9uY2xpY2sgPSBnZXRSb3V0ZXJzQWN0aW9uKTtcbiAgICBiZWhhdmlvcignYWRkUm91dGVyQWN0aW9uJywgZWxlbSA9PiBlbGVtLm9uY2xpY2sgPSBhZGRSb3V0ZXJBY3Rpb24pO1xuICAgIGNvbnNvbGUubG9nKCdlbmRwb2ludDonLCBDb25maWdbbmV0d29ya10uZW5kcG9pbnQpO1xuICAgIGV2ZXJDbGllbnQgPSBjcmVhdGVDbGllbnQoQ29uZmlnW25ldHdvcmtdLmVuZHBvaW50KTtcbiAgICBzdWJzY3JpYmVBY2MgPSBnZXRBY2NvdW50KHt9KTsgLy8gbG9hZE1hcCgpO1xuXG4gICAgYXdhaXQgZ2V0Um91dGVyc0FjdGlvbigpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNldE5ldHdvcmtDaGFuZ2VkKG5ldHdvcmspIHtcbiAgY29uc3QgbW9kID0gbmV0d29yayA9PT0gJ21haW5uZXQnID8gJ3N1Y2Nlc3MnIDogJ3NlY29uZGFyeSc7XG4gIGNvbnN0IG91dCA9IGA8c3BhbiBjbGFzcz1cImJhZGdlIGJnLSR7bW9kfVwiPiR7bmV0d29ya308L3NwYW4+YDtcbiAgYmVoYXZpb3IoJ25ldHdvcmsnLCBlbGVtID0+IGVsZW0uaW5uZXJIVE1MID0gb3V0KTtcbiAgYXdhaXQgY2hlY2tDb25uZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGNvbnRyYWN0QWRkcmVzcyhuZXR3b3JrLCBuYW1lID0gXCJyb3V0ZXJcIikge1xuICBpZiAoQ29uZmlnW25ldHdvcmtdICYmIENvbmZpZ1tuZXR3b3JrXVtuYW1lXSkge1xuICAgIHJldHVybiBuZXcgQWRkcmVzcyhDb25maWdbbmV0d29ya11bbmFtZV0pO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHN3aXRjaFNjcmVlbih0bykge1xuICBjb25zb2xlLmxvZygnc3dpdGNoU2NyZWVuOicsIHRvKTtcbiAgW1wiZXh0ZW5zaW9uXCIsIFwibG9naW5cIiwgXCJtYWluXCJdLmZvckVhY2goc2NyZWVuID0+IHtcbiAgICBjb25zdCBzd2l0Y2hlciA9IGVsZW0gPT4gZWxlbS5zdHlsZS5kaXNwbGF5ID0gdG8gPT09IHNjcmVlbiA/ICd0YWJsZS1yb3cnIDogJ25vbmUnO1xuXG4gICAgYmVoYXZpb3Ioc2NyZWVuLCBzd2l0Y2hlcik7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBtYWluRmxvdygpIHtcbiAgY29uc3QgcHJvdmlkZXJTdGF0ZSA9IGF3YWl0IGV2ZXIuZ2V0UHJvdmlkZXJTdGF0ZSgpO1xuICBjb25zb2xlLmxvZygnc2VsZWN0ZWRDb25uZWN0aW9uOicsIHByb3ZpZGVyU3RhdGUuc2VsZWN0ZWRDb25uZWN0aW9uKTtcbiAgYXdhaXQgc2V0TmV0d29ya0NoYW5nZWQocHJvdmlkZXJTdGF0ZS5zZWxlY3RlZENvbm5lY3Rpb24pO1xuICAoYXdhaXQgZXZlci5zdWJzY3JpYmUoJ25ldHdvcmtDaGFuZ2VkJykpLm9uKCdkYXRhJywgZXZlbnQgPT4ge1xuICAgIGNvbnNvbGUubG9nKCduZXR3b3JrQ2hhbmdlZDonLCBldmVudC5zZWxlY3RlZENvbm5lY3Rpb24pO1xuICAgIHNldE5ldHdvcmtDaGFuZ2VkKGV2ZW50LnNlbGVjdGVkQ29ubmVjdGlvbik7XG4gIH0pO1xuICAoYXdhaXQgZXZlci5zdWJzY3JpYmUoJ3Blcm1pc3Npb25zQ2hhbmdlZCcpKS5vbignZGF0YScsIGFzeW5jIGV2ZW50ID0+IHtcbiAgICBjb25zb2xlLmxvZygncGVybWlzc2lvbnNDaGFuZ2VkOicsIGV2ZW50LnBlcm1pc3Npb25zKTtcbiAgICBhd2FpdCBjaGVja0Nvbm5lY3QoKTtcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRNYXAoKSB7XG4gIGxldCBjb29yZHMgPSBbXTtcblxuICBmb3IgKGNvbnN0IGhleCBvZiBjdXJyZW50TWFwKSB7XG4gICAgY29vcmRzLnB1c2goe1xuICAgICAgeDogaGV4LnEsXG4gICAgICB5OiBoZXgucixcbiAgICAgIHo6IGhleC5zXG4gICAgfSk7XG4gIH0gLy8gY29uc29sZS5sb2coJ2Nvb3JkcycsIGNvb3Jkcyk7XG5cblxuICBsZXQgYWRkcmVzZXMgPSBhd2FpdCBnZXRBZGRyZXNzQ2VsbHMoY29vcmRzKTtcbiAgYWRkcmVzZXMgPSBhZGRyZXNlcy5tYXAoZWwgPT4gZWwudG9TdHJpbmcoKSk7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGNvbnN0IGhleCBvZiBjdXJyZW50TWFwKSB7XG4gICAgaGV4LmFkZHJlc3MgPSBhZGRyZXNlc1tpXS50b1N0cmluZygpO1xuICAgIGkrKztcbiAgfSAvLyBjb25zb2xlLmxvZygnYWRkcmVzZXMnLCBhZGRyZXNlcyk7XG5cblxuICBhd2FpdCBzdWJzY3JpYmVBbGxDZWxsU3RhdGUoYWRkcmVzZXMpO1xuICBsZXQgYWNjcyA9IGF3YWl0IGdldEFjY0FycihhZGRyZXNlcyk7XG4gIGNvbnNvbGUubG9nKCdhY2NzJywgYWNjcyk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY2NzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGRldGFpbHMgPSBhd2FpdCBnZXREZXRhaWxzQ2VsbChhY2NzW2ldLmlkLCBhY2NzW2ldLmJvYyk7XG5cbiAgICBpZiAoZGV0YWlscykge1xuICAgICAgbGV0IGhleCA9IGZpbmRIZXgoYWNjc1tpXS5pZCk7XG4gICAgICBjb25zb2xlLmxvZygnaGV4JywgaGV4KTtcblxuICAgICAgaWYgKGhleCkge1xuICAgICAgICBoZXguZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRNYXAobWFwKSB7XG4gIGN1cnJlbnRNYXAgPSBtYXA7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdChfb25Sb3VtaW5nQ2hhbmdlKSB7XG4gIG9uUm91bWluZ0NoYW5nZSA9IF9vblJvdW1pbmdDaGFuZ2U7XG5cbiAgaWYgKGF3YWl0IGV2ZXIuaGFzUHJvdmlkZXIoKSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBldmVyLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICBhd2FpdCBtYWluRmxvdygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjsgLy8gVE9ETyBoYW5kbGUgaXRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoU2NyZWVuKFwiZXh0ZW5zaW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRIZXgoYWRkcmVzcykge1xuICBsZXQgX2hleDtcblxuICBmb3IgKGNvbnN0IGhleCBvZiBjdXJyZW50TWFwKSB7XG4gICAgaWYgKGhleC5hZGRyZXNzID09IGFkZHJlc3MpIHtcbiAgICAgIF9oZXggPSBoZXg7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2hleDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJvdXRlckRldGFpbHMoKSB7XG4gIGNvbnN0IHByb3ZpZGVyU3RhdGUgPSBhd2FpdCBldmVyLmdldFByb3ZpZGVyU3RhdGUoKTtcbiAgY29uc3Qgcm91dGVyID0gbmV3IGV2ZXIuQ29udHJhY3Qocm91dGVyQWJpLCBjb250cmFjdEFkZHJlc3MocHJvdmlkZXJTdGF0ZS5zZWxlY3RlZENvbm5lY3Rpb24sICdyb3V0ZXInKSk7XG5cbiAgdHJ5IHtcbiAgICBsZXQgZGV0YWlscztcbiAgICBkZXRhaWxzID0gYXdhaXQgcm91dGVyLm1ldGhvZHMuZ2V0RGV0YWlscyh7fSkuY2FsbCgpO1xuICAgIGNvbnNvbGUubG9nKCdnZXREZXRhaWxzIHJvdXRlcicsIGRldGFpbHMpO1xuICAgIHJldHVybiBkZXRhaWxzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcblxuICAgIGlmIChlIGluc3RhbmNlb2YgVHZtRXhjZXB0aW9uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUuY29kZSk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcm91dGVyTGlkZXJzKCkge1xuICBjb25zdCBwcm92aWRlclN0YXRlID0gYXdhaXQgZXZlci5nZXRQcm92aWRlclN0YXRlKCk7XG4gIGNvbnN0IHJvdXRlciA9IG5ldyBldmVyLkNvbnRyYWN0KHJvdXRlckFiaSwgY29udHJhY3RBZGRyZXNzKHByb3ZpZGVyU3RhdGUuc2VsZWN0ZWRDb25uZWN0aW9uLCAncm91dGVyJykpO1xuXG4gIHRyeSB7XG4gICAgbGV0IGRldGFpbHM7XG4gICAgZGV0YWlscyA9IGF3YWl0IHJvdXRlci5tZXRob2RzLmdldFVzZXJzKHt9KS5jYWxsKCk7XG4gICAgY29uc29sZS5sb2coJ2dldFVzZXJzIHJvdXRlcicsIGRldGFpbHMpO1xuICAgIHJldHVybiBkZXRhaWxzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcblxuICAgIGlmIChlIGluc3RhbmNlb2YgVHZtRXhjZXB0aW9uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUuY29kZSk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3Vic2NyaWJlQWxsQ2VsbFN0YXRlKGFyckFjYykge1xuICB0cnkge1xuICAgIGF3YWl0IHN1YnNjcmliZUFjYy5mcmVlKCk7XG4gICAgYXdhaXQgc3Vic2NyaWJlQWNjLnN1YnNjcmliZShcImFjY291bnRzXCIsIHtcbiAgICAgIGlkOiB7XG4gICAgICAgIGluOiBhcnJBY2NcbiAgICAgIH1cbiAgICB9LCBcImlkIGJvY1wiLCBhc3luYyBtc2cgPT4ge1xuICAgICAgY29uc29sZS5sb2coYG9uQWNjOmAsIG1zZy5pZCk7XG4gICAgICBsZXQgaGV4ID0gZmluZEhleChtc2cuaWQpO1xuICAgICAgY29uc29sZS5sb2coJ2hleCcsIGhleCk7XG5cbiAgICAgIGlmIChoZXgpIHtcbiAgICAgICAgaGV4LmRldGFpbHMgPSBhd2FpdCBnZXREZXRhaWxzQ2VsbChtc2cuaWQsIG1zZy5ib2MpO1xuICAgICAgfVxuXG4gICAgICBnZXRMaWRlckJvYXJkKCk7XG4gICAgfSwgYXN5bmMgbXNnID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGBvbkVycm9yOmAsIG1zZyk7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBUdm1FeGNlcHRpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZS5jb2RlKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBZGRyZXNzQ2VsbHMoY29vcmRzKSB7XG4gIGNvbnN0IHByb3ZpZGVyU3RhdGUgPSBhd2FpdCBldmVyLmdldFByb3ZpZGVyU3RhdGUoKTtcbiAgY29uc3Qgcm91dGVyID0gbmV3IGV2ZXIuQ29udHJhY3Qocm91dGVyQWJpLCBjb250cmFjdEFkZHJlc3MocHJvdmlkZXJTdGF0ZS5zZWxlY3RlZENvbm5lY3Rpb24sICdyb3V0ZXInKSk7XG5cbiAgdHJ5IHtcbiAgICBsZXQgZGV0YWlscztcbiAgICBkZXRhaWxzID0gYXdhaXQgcm91dGVyLm1ldGhvZHMuZ2V0QWRkcmVzc0NlbGxzKHtcbiAgICAgIGNvb3Jkc1xuICAgIH0pLmNhbGwoKTtcbiAgICBjb25zb2xlLmxvZygnZ2V0QWRkcmVzc0NlbGxzIHJvdXRlcicsIGRldGFpbHMpO1xuICAgIHJldHVybiBkZXRhaWxzLmFkZHJlc2VzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcblxuICAgIGlmIChlIGluc3RhbmNlb2YgVHZtRXhjZXB0aW9uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUuY29kZSk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbmV3R2FtZShjZWxsQ29vcmQpIHtcbiAgY29uc3QgcHJvdmlkZXJTdGF0ZSA9IGF3YWl0IGV2ZXIuZ2V0UHJvdmlkZXJTdGF0ZSgpO1xuICBjb25zdCBwZXJtaXNzaW9ucyA9IHByb3ZpZGVyU3RhdGUucGVybWlzc2lvbnM7XG4gIGlmICghcGVybWlzc2lvbnMuYWNjb3VudEludGVyYWN0aW9uKSByZXR1cm47XG4gIGNvbnN0IGFjY291bnQgPSBwZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb247XG4gIGNvbnN0IHJvdXRlciA9IG5ldyBldmVyLkNvbnRyYWN0KHJvdXRlckFiaSwgY29udHJhY3RBZGRyZXNzKHByb3ZpZGVyU3RhdGUuc2VsZWN0ZWRDb25uZWN0aW9uLCAncm91dGVyJykpO1xuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ25ld0dhbWUnLCAxKTtcbiAgICBsZXQgcmVzID0gYXdhaXQgcm91dGVyLm1ldGhvZHMubmV3R2FtZSh7XG4gICAgICBiYXNlQ29vcmQ6IGNlbGxDb29yZFxuICAgIH0pLnNlbmQoe1xuICAgICAgZnJvbTogYWNjb3VudC5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICBhbW91bnQ6ICcyMDAwMDAwMDAwJ1xuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKCduZXdHYW1lJywgcmVzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoZSk7XG5cbiAgICBpZiAoZSBpbnN0YW5jZW9mIFR2bUV4Y2VwdGlvbikge1xuICAgICAgY29uc29sZS5lcnJvcihlLmNvZGUpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1hcmtDZWxsKGFkZHJlc3MsIGNlbGxDb29yZCwgZW5lcmd5KSB7XG4gIGNvbnN0IHByb3ZpZGVyU3RhdGUgPSBhd2FpdCBldmVyLmdldFByb3ZpZGVyU3RhdGUoKTtcbiAgY29uc3QgcGVybWlzc2lvbnMgPSBwcm92aWRlclN0YXRlLnBlcm1pc3Npb25zO1xuICBpZiAoIXBlcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbikgcmV0dXJuO1xuICBjb25zdCBhY2NvdW50ID0gcGVybWlzc2lvbnMuYWNjb3VudEludGVyYWN0aW9uO1xuICBjb25zdCBjZWxsID0gbmV3IGV2ZXIuQ29udHJhY3QoY2VsbEFiaSwgYWRkcmVzcyk7XG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnbWFya0NlbGwnLCAxKTtcbiAgICBsZXQgcmVzID0gYXdhaXQgY2VsbC5tZXRob2RzLm1hcmtDZWxsKHtcbiAgICAgIHRhcmdldENvb3JkOiBjZWxsQ29vcmQsXG4gICAgICBlbmVyZ3k6IGVuZXJneVxuICAgIH0pLnNlbmQoe1xuICAgICAgZnJvbTogYWNjb3VudC5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICBhbW91bnQ6ICcyMDAwMDAwMDAwJ1xuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKCdtYXJrQ2VsbCcsIHJlcyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBUdm1FeGNlcHRpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZS5jb2RlKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGdyYWRlQ2VsbChhZGRyZXNzKSB7XG4gIGNvbnN0IHByb3ZpZGVyU3RhdGUgPSBhd2FpdCBldmVyLmdldFByb3ZpZGVyU3RhdGUoKTtcbiAgY29uc3QgcGVybWlzc2lvbnMgPSBwcm92aWRlclN0YXRlLnBlcm1pc3Npb25zO1xuICBpZiAoIXBlcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbikgcmV0dXJuO1xuICBjb25zdCBhY2NvdW50ID0gcGVybWlzc2lvbnMuYWNjb3VudEludGVyYWN0aW9uO1xuICBjb25zdCBjZWxsID0gbmV3IGV2ZXIuQ29udHJhY3QoY2VsbEFiaSwgYWRkcmVzcyk7XG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygndXBncmFkZUNlbGwnLCAxKTtcbiAgICBsZXQgcmVzID0gYXdhaXQgY2VsbC5tZXRob2RzLnVwZ3JhZGVDZWxsKHsvLyB9KS5zZW5kRXh0ZXJuYWwoeyBwdWJsaWNLZXk6IGFjY291bnQucHVibGljS2V5LnRvU3RyaW5nKCkgfSlcbiAgICB9KS5zZW5kKHtcbiAgICAgIGZyb206IGFjY291bnQuYWRkcmVzcy50b1N0cmluZygpLFxuICAgICAgYW1vdW50OiAnMTAwMDAwMDAwMCdcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZygndXBncmFkZUNlbGwnLCByZXMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcblxuICAgIGlmIChlIGluc3RhbmNlb2YgVHZtRXhjZXB0aW9uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUuY29kZSk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGVscENlbGwoYWRkcmVzcywgY2VsbENvb3JkLCBlbmVyZ3kpIHtcbiAgY29uc3QgcHJvdmlkZXJTdGF0ZSA9IGF3YWl0IGV2ZXIuZ2V0UHJvdmlkZXJTdGF0ZSgpO1xuICBjb25zdCBwZXJtaXNzaW9ucyA9IHByb3ZpZGVyU3RhdGUucGVybWlzc2lvbnM7XG4gIGlmICghcGVybWlzc2lvbnMuYWNjb3VudEludGVyYWN0aW9uKSByZXR1cm47XG4gIGNvbnN0IGFjY291bnQgPSBwZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb247XG4gIGNvbnN0IGNlbGwgPSBuZXcgZXZlci5Db250cmFjdChjZWxsQWJpLCBhZGRyZXNzKTtcblxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdoZWxwQ2VsbCcsIDEpO1xuICAgIGxldCByZXMgPSBhd2FpdCBjZWxsLm1ldGhvZHMuaGVscENlbGwoe1xuICAgICAgdGFyZ2V0Q29vcmQ6IGNlbGxDb29yZCxcbiAgICAgIGVuZXJneTogZW5lcmd5XG4gICAgfSkuc2VuZCh7XG4gICAgICBmcm9tOiBhY2NvdW50LmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgIGFtb3VudDogJzEwMDAwMDAwMDAnXG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coJ2hlbHBDZWxsJywgcmVzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoZSk7XG5cbiAgICBpZiAoZSBpbnN0YW5jZW9mIFR2bUV4Y2VwdGlvbikge1xuICAgICAgY29uc29sZS5lcnJvcihlLmNvZGUpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF0dGtDZWxsKGFkZHJlc3MsIGNlbGxDb29yZCwgZW5lcmd5KSB7XG4gIGNvbnN0IHByb3ZpZGVyU3RhdGUgPSBhd2FpdCBldmVyLmdldFByb3ZpZGVyU3RhdGUoKTtcbiAgY29uc3QgcGVybWlzc2lvbnMgPSBwcm92aWRlclN0YXRlLnBlcm1pc3Npb25zO1xuICBpZiAoIXBlcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbikgcmV0dXJuO1xuICBjb25zdCBhY2NvdW50ID0gcGVybWlzc2lvbnMuYWNjb3VudEludGVyYWN0aW9uO1xuICBjb25zdCBjZWxsID0gbmV3IGV2ZXIuQ29udHJhY3QoY2VsbEFiaSwgYWRkcmVzcyk7XG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnYXR0a0NlbGwnLCAxKTtcbiAgICBsZXQgcmVzID0gYXdhaXQgY2VsbC5tZXRob2RzLmF0dGtDZWxsKHtcbiAgICAgIHRhcmdldENvb3JkOiBjZWxsQ29vcmQsXG4gICAgICBlbmVyZ3k6IGVuZXJneVxuICAgIH0pLnNlbmQoe1xuICAgICAgZnJvbTogYWNjb3VudC5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICBhbW91bnQ6ICcxMDAwMDAwMDAwJ1xuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKCdhdHRrQ2VsbCcsIHJlcyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBUdm1FeGNlcHRpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZS5jb2RlKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBuZXdSb3V0ZXIobmFtZSwgcmFkaXVzLCBzcGVlZCwgdGltZSkge1xuICBjb25zdCBwcm92aWRlclN0YXRlID0gYXdhaXQgZXZlci5nZXRQcm92aWRlclN0YXRlKCk7XG4gIGNvbnN0IHBlcm1pc3Npb25zID0gcHJvdmlkZXJTdGF0ZS5wZXJtaXNzaW9ucztcbiAgaWYgKCFwZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb24pIHJldHVybjtcbiAgY29uc3QgYWNjb3VudCA9IHBlcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbjtcbiAgY29uc3QgZ2FtZXJvb3QgPSBuZXcgZXZlci5Db250cmFjdChyb290QWJpLCBDb25maWdbcHJvdmlkZXJTdGF0ZS5zZWxlY3RlZENvbm5lY3Rpb25dLmdhbWVyb290KTtcblxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCduZXdSb3V0ZXInLCAxKTtcbiAgICBsZXQgcmVzID0gYXdhaXQgZ2FtZXJvb3QubWV0aG9kcy5uZXdSb3V0ZXIoe1xuICAgICAgcm91bmRUaW1lOiB0aW1lLFxuICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICBzcGVlZDogc3BlZWQsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgbm9uY2U6ICcwJ1xuICAgIH0pLnNlbmQoe1xuICAgICAgZnJvbTogYWNjb3VudC5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICBhbW91bnQ6ICcyMDAwMDAwMDAwJ1xuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKCduZXdSb3V0ZXInLCByZXMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcblxuICAgIGlmIChlIGluc3RhbmNlb2YgVHZtRXhjZXB0aW9uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUuY29kZSk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGV0YWlsc0NlbGwoYWRkcmVzcywgYm9jID0gbnVsbCkge1xuICBpZiAoYm9jKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJ1bkxvY2FsKGNlbGxBYmksIGFkZHJlc3MsIFwiZ2V0RGV0YWlsc1wiLCB7fSwgdHJ1ZSwgYm9jKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNlbGwgPSBuZXcgZXZlci5Db250cmFjdChjZWxsQWJpLCBhZGRyZXNzKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHN0YXRlUmVzID0gYXdhaXQgY2VsbC5nZXRGdWxsU3RhdGUoKTtcblxuICAgIGlmIChzdGF0ZVJlcy5zdGF0ZSA9PSBudWxsIHx8ICFzdGF0ZVJlcy5zdGF0ZS5pc0RlcGxveWVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vY29uc29sZS5sb2coJ3N0YXRlJywgc3RhdGVSZXMuc3RhdGUpO1xuXG5cbiAgICBsZXQgZGV0YWlscztcbiAgICBkZXRhaWxzID0gYXdhaXQgY2VsbC5tZXRob2RzLmdldERldGFpbHMoe30pLmNhbGwoKTtcbiAgICBjb25zb2xlLmxvZygnZ2V0RGV0YWlscyBjZWxsJywgZGV0YWlscyk7XG4gICAgcmV0dXJuIGRldGFpbHM7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBUdm1FeGNlcHRpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZS5jb2RlKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREZXRhaWxzUm91dGVyKGFkZHJlc3MsIGJvYyA9IG51bGwpIHtcbiAgaWYgKGJvYykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBydW5Mb2NhbChyb3V0ZXJBYmksIGFkZHJlc3MsIFwiZ2V0RGV0YWlsc1wiLCB7fSwgdHJ1ZSwgYm9jKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJvdXRlciA9IG5ldyBldmVyLkNvbnRyYWN0KHJvdXRlckFiaSwgYWRkcmVzcyk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzdGF0ZVJlcyA9IGF3YWl0IHJvdXRlci5nZXRGdWxsU3RhdGUoKTtcblxuICAgIGlmIChzdGF0ZVJlcy5zdGF0ZSA9PSBudWxsIHx8ICFzdGF0ZVJlcy5zdGF0ZS5pc0RlcGxveWVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vY29uc29sZS5sb2coJ3N0YXRlJywgc3RhdGVSZXMuc3RhdGUpO1xuXG5cbiAgICBsZXQgZGV0YWlscztcbiAgICBkZXRhaWxzID0gYXdhaXQgcm91dGVyLm1ldGhvZHMuZ2V0RGV0YWlscyh7fSkuY2FsbCgpO1xuICAgIGNvbnNvbGUubG9nKCdnZXREZXRhaWxzIHJvdXRlcicsIGRldGFpbHMpO1xuICAgIHJldHVybiBkZXRhaWxzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcblxuICAgIGlmIChlIGluc3RhbmNlb2YgVHZtRXhjZXB0aW9uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUuY29kZSk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3Vic2NyaWJlUGVybWlzc2lvbnNDaGFuZ2VkKCkge1xuICBhd2FpdCBldmVyLnN1YnNjcmliZSgncGVybWlzc2lvbnNDaGFuZ2VkJykub24oJ2RhdGEnLCBwZXJtaXNzaW9ucyA9PiB7XG4gICAgY29uc29sZS5sb2cocGVybWlzc2lvbnMpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVGJsUm93KHRibE5hbWUpIHtcbiAgdmFyIHRhYmxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGJsTmFtZSk7XG4gIHJldHVybiB0YWJsZS5pbnNlcnRSb3codGFibGUucm93cy5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBjbGVhclRibFJvd3ModGJsTmFtZSwgbWluID0gMSkge1xuICB2YXIgdGFibGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YmxOYW1lKTtcblxuICB3aGlsZSAodGFibGUucm93cy5sZW5ndGggPiBtaW4pIHRhYmxlLmRlbGV0ZVJvdyh0YWJsZS5yb3dzLmxlbmd0aCAtIDEpO1xufVxuXG5EYXRlLnByb3RvdHlwZS5jdXN0b21Gb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0U3RyaW5nKSB7XG4gIHZhciBZWVlZLCBZWSwgTU1NTSwgTU1NLCBNTSwgTSwgRERERCwgRERELCBERCwgRCwgaGhoaCwgaGhoLCBoaCwgaCwgbW0sIG0sIHNzLCBzLCBhbXBtLCBBTVBNLCBkTW9kLCB0aDtcbiAgdmFyIGRhdGVPYmplY3QgPSB0aGlzO1xuICBZWSA9ICgoWVlZWSA9IGRhdGVPYmplY3QuZ2V0RnVsbFllYXIoKSkgKyBcIlwiKS5zbGljZSgtMik7XG4gIE1NID0gKE0gPSBkYXRlT2JqZWN0LmdldE1vbnRoKCkgKyAxKSA8IDEwID8gJzAnICsgTSA6IE07XG4gIE1NTSA9IChNTU1NID0gW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl1bTSAtIDFdKS5zdWJzdHJpbmcoMCwgMyk7XG4gIEREID0gKEQgPSBkYXRlT2JqZWN0LmdldERhdGUoKSkgPCAxMCA/ICcwJyArIEQgOiBEO1xuICBEREQgPSAoRERERCA9IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdW2RhdGVPYmplY3QuZ2V0RGF5KCldKS5zdWJzdHJpbmcoMCwgMyk7XG4gIHRoID0gRCA+PSAxMCAmJiBEIDw9IDIwID8gJ3RoJyA6IChkTW9kID0gRCAlIDEwKSA9PSAxID8gJ3N0JyA6IGRNb2QgPT0gMiA/ICduZCcgOiBkTW9kID09IDMgPyAncmQnIDogJ3RoJztcbiAgZm9ybWF0U3RyaW5nID0gZm9ybWF0U3RyaW5nLnJlcGxhY2UoXCIjWVlZWSNcIiwgWVlZWSkucmVwbGFjZShcIiNZWSNcIiwgWVkpLnJlcGxhY2UoXCIjTU1NTSNcIiwgTU1NTSkucmVwbGFjZShcIiNNTU0jXCIsIE1NTSkucmVwbGFjZShcIiNNTSNcIiwgTU0pLnJlcGxhY2UoXCIjTSNcIiwgTSkucmVwbGFjZShcIiNEREREI1wiLCBEREREKS5yZXBsYWNlKFwiI0RERCNcIiwgREREKS5yZXBsYWNlKFwiI0REI1wiLCBERCkucmVwbGFjZShcIiNEI1wiLCBEKS5yZXBsYWNlKFwiI3RoI1wiLCB0aCk7XG4gIGggPSBoaGggPSBkYXRlT2JqZWN0LmdldEhvdXJzKCk7XG4gIGlmIChoID09IDApIGggPSAyNDtcbiAgaWYgKGggPiAxMikgaCAtPSAxMjtcbiAgaGggPSBoIDwgMTAgPyAnMCcgKyBoIDogaDtcbiAgaGhoaCA9IGhoaCA8IDEwID8gJzAnICsgaGhoIDogaGhoO1xuICBBTVBNID0gKGFtcG0gPSBoaGggPCAxMiA/ICdhbScgOiAncG0nKS50b1VwcGVyQ2FzZSgpO1xuICBtbSA9IChtID0gZGF0ZU9iamVjdC5nZXRNaW51dGVzKCkpIDwgMTAgPyAnMCcgKyBtIDogbTtcbiAgc3MgPSAocyA9IGRhdGVPYmplY3QuZ2V0U2Vjb25kcygpKSA8IDEwID8gJzAnICsgcyA6IHM7XG4gIHJldHVybiBmb3JtYXRTdHJpbmcucmVwbGFjZShcIiNoaGhoI1wiLCBoaGhoKS5yZXBsYWNlKFwiI2hoaCNcIiwgaGhoKS5yZXBsYWNlKFwiI2hoI1wiLCBoaCkucmVwbGFjZShcIiNoI1wiLCBoKS5yZXBsYWNlKFwiI21tI1wiLCBtbSkucmVwbGFjZShcIiNtI1wiLCBtKS5yZXBsYWNlKFwiI3NzI1wiLCBzcykucmVwbGFjZShcIiNzI1wiLCBzKS5yZXBsYWNlKFwiI2FtcG0jXCIsIGFtcG0pLnJlcGxhY2UoXCIjQU1QTSNcIiwgQU1QTSk7XG59OyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/scripts/ever.js\n");

/***/ }),

/***/ "./node_modules/bignumber.js/bignumber.js":
/*!************************************************!*\
  !*** ./node_modules/bignumber.js/bignumber.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;;(function (globalObject) {\r\n  'use strict';\r\n\r\n/*\r\n *      bignumber.js v9.1.0\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\n  var BigNumber,\r\n    isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n    mathceil = Math.ceil,\r\n    mathfloor = Math.floor,\r\n\r\n    bignumberError = '[BigNumber Error] ',\r\n    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n    BASE = 1e14,\r\n    LOG_BASE = 14,\r\n    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n    SQRT_BASE = 1e7,\r\n\r\n    // EDITABLE\r\n    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n    // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n    MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n  /*\r\n   * Create and return a BigNumber constructor.\r\n   */\r\n  function clone(configObject) {\r\n    var div, convertBase, parseNumeric,\r\n      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n      ONE = new BigNumber(1),\r\n\r\n\r\n      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n      // The default values below must be integers within the inclusive ranges stated.\r\n      // The values can also be changed at run-time using BigNumber.set.\r\n\r\n      // The maximum number of decimal places for operations involving division.\r\n      DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n      // The rounding mode used when rounding to the above decimal places, and when using\r\n      // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n      // UP         0 Away from zero.\r\n      // DOWN       1 Towards zero.\r\n      // CEIL       2 Towards +Infinity.\r\n      // FLOOR      3 Towards -Infinity.\r\n      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n      // The exponent value at and beneath which toString returns exponential notation.\r\n      // Number type: -7\r\n      TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n      // The exponent value at and above which toString returns exponential notation.\r\n      // Number type: 21\r\n      TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n      // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // Number type: -324  (5e-324)\r\n      MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // Number type:  308  (1.7976931348623157e+308)\r\n      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n      MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      CRYPTO = false,                          // true or false\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN      1 The remainder has the same sign as the dividend.\r\n      //             This modulo mode is commonly known as 'truncated division' and is\r\n      //             equivalent to (a % n) in JavaScript.\r\n      // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n      //             The remainder is always positive.\r\n      //\r\n      // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n      // modes are commonly used for the modulus operation.\r\n      // Although the other rounding modes can also be used, they may not give useful results.\r\n      MODULO_MODE = 1,                         // 0 to 9\r\n\r\n      // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n      // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n      POW_PRECISION = 0,                       // 0 to MAX\r\n\r\n      // The format specification used by the BigNumber.prototype.toFormat method.\r\n      FORMAT = {\r\n        prefix: '',\r\n        groupSize: 3,\r\n        secondaryGroupSize: 0,\r\n        groupSeparator: ',',\r\n        decimalSeparator: '.',\r\n        fractionGroupSize: 0,\r\n        fractionGroupSeparator: '\\xA0',        // non-breaking space\r\n        suffix: ''\r\n      },\r\n\r\n      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n      // '-', '.', whitespace, or repeated character.\r\n      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',\r\n      alphabetHasNormalDecimalDigits = true;\r\n\r\n\r\n    //------------------------------------------------------------------------------------------\r\n\r\n\r\n    // CONSTRUCTOR\r\n\r\n\r\n    /*\r\n     * The BigNumber constructor and exported function.\r\n     * Create and return a new instance of a BigNumber object.\r\n     *\r\n     * v {number|string|BigNumber} A numeric value.\r\n     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n     */\r\n    function BigNumber(v, b) {\r\n      var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n        x = this;\r\n\r\n      // Enable constructor call without `new`.\r\n      if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n      if (b == null) {\r\n\r\n        if (v && v._isBigNumber === true) {\r\n          x.s = v.s;\r\n\r\n          if (!v.c || v.e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else if (v.e < MIN_EXP) {\r\n            x.c = [x.e = 0];\r\n          } else {\r\n            x.e = v.e;\r\n            x.c = v.c.slice();\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n          // Use `1 / n` to handle minus zero also.\r\n          x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n          // Fast path for integers, where n < 2147483648 (2**31).\r\n          if (v === ~~v) {\r\n            for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n            if (e > MAX_EXP) {\r\n              x.c = x.e = null;\r\n            } else {\r\n              x.e = e;\r\n              x.c = [v];\r\n            }\r\n\r\n            return;\r\n          }\r\n\r\n          str = String(v);\r\n        } else {\r\n\r\n          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n        // Exponential form?\r\n        if ((i = str.search(/e/i)) > 0) {\r\n\r\n          // Determine exponent.\r\n          if (e < 0) e = i;\r\n          e += +str.slice(i + 1);\r\n          str = str.substring(0, i);\r\n        } else if (e < 0) {\r\n\r\n          // Integer.\r\n          e = str.length;\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n        // Allow exponential notation to be used with base 10 argument, while\r\n        // also rounding to DECIMAL_PLACES as with other bases.\r\n        if (b == 10 && alphabetHasNormalDecimalDigits) {\r\n          x = new BigNumber(v);\r\n          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n        }\r\n\r\n        str = String(v);\r\n\r\n        if (isNum = typeof v == 'number') {\r\n\r\n          // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n          if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n            throw Error\r\n             (tooManyDigits + v);\r\n          }\r\n        } else {\r\n          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        alphabet = ALPHABET.slice(0, b);\r\n        e = i = 0;\r\n\r\n        // Check that str is a valid base b number.\r\n        // Don't use RegExp, so alphabet can contain special characters.\r\n        for (len = str.length; i < len; i++) {\r\n          if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n            if (c == '.') {\r\n\r\n              // If '.' is not the first character and it has not be found before.\r\n              if (i > e) {\r\n                e = len;\r\n                continue;\r\n              }\r\n            } else if (!caseChanged) {\r\n\r\n              // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                  str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n                caseChanged = true;\r\n                i = -1;\r\n                e = 0;\r\n                continue;\r\n              }\r\n            }\r\n\r\n            return parseNumeric(x, String(v), isNum, b);\r\n          }\r\n        }\r\n\r\n        // Prevent later check for length on converted number.\r\n        isNum = false;\r\n        str = convertBase(str, b, 10, x.s);\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n        else e = str.length;\r\n      }\r\n\r\n      // Determine leading zeros.\r\n      for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n      // Determine trailing zeros.\r\n      for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n      if (str = str.slice(i, ++len)) {\r\n        len -= i;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (isNum && BigNumber.DEBUG &&\r\n          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n            throw Error\r\n             (tooManyDigits + (x.s * v));\r\n        }\r\n\r\n         // Overflow?\r\n        if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n          // Infinity.\r\n          x.c = x.e = null;\r\n\r\n        // Underflow?\r\n        } else if (e < MIN_EXP) {\r\n\r\n          // Zero.\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = e;\r\n          x.c = [];\r\n\r\n          // Transform base\r\n\r\n          // e is the base 10 exponent.\r\n          // i is where to slice str to get the first element of the coefficient array.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n          if (i < len) {\r\n            if (i) x.c.push(+str.slice(0, i));\r\n\r\n            for (len -= LOG_BASE; i < len;) {\r\n              x.c.push(+str.slice(i, i += LOG_BASE));\r\n            }\r\n\r\n            i = LOG_BASE - (str = str.slice(i)).length;\r\n          } else {\r\n            i -= len;\r\n          }\r\n\r\n          for (; i--; str += '0');\r\n          x.c.push(+str);\r\n        }\r\n      } else {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n\r\n    // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n    BigNumber.clone = clone;\r\n\r\n    BigNumber.ROUND_UP = 0;\r\n    BigNumber.ROUND_DOWN = 1;\r\n    BigNumber.ROUND_CEIL = 2;\r\n    BigNumber.ROUND_FLOOR = 3;\r\n    BigNumber.ROUND_HALF_UP = 4;\r\n    BigNumber.ROUND_HALF_DOWN = 5;\r\n    BigNumber.ROUND_HALF_EVEN = 6;\r\n    BigNumber.ROUND_HALF_CEIL = 7;\r\n    BigNumber.ROUND_HALF_FLOOR = 8;\r\n    BigNumber.EUCLID = 9;\r\n\r\n\r\n    /*\r\n     * Configure infrequently-changing library-wide settings.\r\n     *\r\n     * Accept an object with the following optional properties (if the value of a property is\r\n     * a number, it must be an integer within the inclusive range stated):\r\n     *\r\n     *   DECIMAL_PLACES   {number}           0 to MAX\r\n     *   ROUNDING_MODE    {number}           0 to 8\r\n     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n     *   CRYPTO           {boolean}          true or false\r\n     *   MODULO_MODE      {number}           0 to 9\r\n     *   POW_PRECISION       {number}           0 to MAX\r\n     *   ALPHABET         {string}           A string of two or more unique characters which does\r\n     *                                       not contain '.'.\r\n     *   FORMAT           {object}           An object with some of the following properties:\r\n     *     prefix                 {string}\r\n     *     groupSize              {number}\r\n     *     secondaryGroupSize     {number}\r\n     *     groupSeparator         {string}\r\n     *     decimalSeparator       {string}\r\n     *     fractionGroupSize      {number}\r\n     *     fractionGroupSeparator {string}\r\n     *     suffix                 {string}\r\n     *\r\n     * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n     *\r\n     * E.g.\r\n     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n     *\r\n     * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n     *\r\n     * Return an object with the properties current values.\r\n     */\r\n    BigNumber.config = BigNumber.set = function (obj) {\r\n      var p, v;\r\n\r\n      if (obj != null) {\r\n\r\n        if (typeof obj == 'object') {\r\n\r\n          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            DECIMAL_PLACES = v;\r\n          }\r\n\r\n          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 8, p);\r\n            ROUNDING_MODE = v;\r\n          }\r\n\r\n          // EXPONENTIAL_AT {number|number[]}\r\n          // Integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, 0, p);\r\n              intCheck(v[1], 0, MAX, p);\r\n              TO_EXP_NEG = v[0];\r\n              TO_EXP_POS = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n            }\r\n          }\r\n\r\n          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n          if (obj.hasOwnProperty(p = 'RANGE')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, -1, p);\r\n              intCheck(v[1], 1, MAX, p);\r\n              MIN_EXP = v[0];\r\n              MAX_EXP = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              if (v) {\r\n                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n              } else {\r\n                throw Error\r\n                 (bignumberError + p + ' cannot be zero: ' + v);\r\n              }\r\n            }\r\n          }\r\n\r\n          // CRYPTO {boolean} true or false.\r\n          // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n          // '[BigNumber Error] crypto unavailable'\r\n          if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n            v = obj[p];\r\n            if (v === !!v) {\r\n              if (v) {\r\n                if (typeof crypto != 'undefined' && crypto &&\r\n                 (crypto.getRandomValues || crypto.randomBytes)) {\r\n                  CRYPTO = v;\r\n                } else {\r\n                  CRYPTO = !v;\r\n                  throw Error\r\n                   (bignumberError + 'crypto unavailable');\r\n                }\r\n              } else {\r\n                CRYPTO = v;\r\n              }\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' not true or false: ' + v);\r\n            }\r\n          }\r\n\r\n          // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 9, p);\r\n            MODULO_MODE = v;\r\n          }\r\n\r\n          // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            POW_PRECISION = v;\r\n          }\r\n\r\n          // FORMAT {object}\r\n          // '[BigNumber Error] FORMAT not an object: {v}'\r\n          if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n            v = obj[p];\r\n            if (typeof v == 'object') FORMAT = v;\r\n            else throw Error\r\n             (bignumberError + p + ' not an object: ' + v);\r\n          }\r\n\r\n          // ALPHABET {string}\r\n          // '[BigNumber Error] ALPHABET invalid: {v}'\r\n          if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n            v = obj[p];\r\n\r\n            // Disallow if less than two characters,\r\n            // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n            if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';\r\n              ALPHABET = v;\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' invalid: ' + v);\r\n            }\r\n          }\r\n\r\n        } else {\r\n\r\n          // '[BigNumber Error] Object expected: {v}'\r\n          throw Error\r\n           (bignumberError + 'Object expected: ' + obj);\r\n        }\r\n      }\r\n\r\n      return {\r\n        DECIMAL_PLACES: DECIMAL_PLACES,\r\n        ROUNDING_MODE: ROUNDING_MODE,\r\n        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n        RANGE: [MIN_EXP, MAX_EXP],\r\n        CRYPTO: CRYPTO,\r\n        MODULO_MODE: MODULO_MODE,\r\n        POW_PRECISION: POW_PRECISION,\r\n        FORMAT: FORMAT,\r\n        ALPHABET: ALPHABET\r\n      };\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if v is a BigNumber instance, otherwise return false.\r\n     *\r\n     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n     *\r\n     * v {any}\r\n     *\r\n     * '[BigNumber Error] Invalid BigNumber: {v}'\r\n     */\r\n    BigNumber.isBigNumber = function (v) {\r\n      if (!v || v._isBigNumber !== true) return false;\r\n      if (!BigNumber.DEBUG) return true;\r\n\r\n      var i, n,\r\n        c = v.c,\r\n        e = v.e,\r\n        s = v.s;\r\n\r\n      out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n          // If the first element is zero, the BigNumber value must be zero.\r\n          if (c[0] === 0) {\r\n            if (e === 0 && c.length === 1) return true;\r\n            break out;\r\n          }\r\n\r\n          // Calculate number of digits that c[0] should have, based on the exponent.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (i < 1) i += LOG_BASE;\r\n\r\n          // Calculate number of digits of c[0].\r\n          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n          if (String(c[0]).length == i) {\r\n\r\n            for (i = 0; i < c.length; i++) {\r\n              n = c[i];\r\n              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n            }\r\n\r\n            // Last element cannot be zero, unless it is the only element.\r\n            if (n !== 0) return true;\r\n          }\r\n        }\r\n\r\n      // Infinity/NaN\r\n      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n        return true;\r\n      }\r\n\r\n      throw Error\r\n        (bignumberError + 'Invalid BigNumber: ' + v);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the maximum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.maximum = BigNumber.max = function () {\r\n      return maxOrMin(arguments, P.lt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the minimum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.minimum = BigNumber.min = function () {\r\n      return maxOrMin(arguments, P.gt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n     * zeros are produced).\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n     * '[BigNumber Error] crypto unavailable'\r\n     */\r\n    BigNumber.random = (function () {\r\n      var pow2_53 = 0x20000000000000;\r\n\r\n      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n      // Check if Math.random() produces more than 32 bits of randomness.\r\n      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n       ? function () { return mathfloor(Math.random() * pow2_53); }\r\n       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n         (Math.random() * 0x800000 | 0); };\r\n\r\n      return function (dp) {\r\n        var a, b, e, k, v,\r\n          i = 0,\r\n          c = [],\r\n          rand = new BigNumber(ONE);\r\n\r\n        if (dp == null) dp = DECIMAL_PLACES;\r\n        else intCheck(dp, 0, MAX);\r\n\r\n        k = mathceil(dp / LOG_BASE);\r\n\r\n        if (CRYPTO) {\r\n\r\n          // Browsers supporting crypto.getRandomValues.\r\n          if (crypto.getRandomValues) {\r\n\r\n            a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n            for (; i < k;) {\r\n\r\n              // 53 bits:\r\n              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n              // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n              //                                     11111 11111111 11111111\r\n              // 0x20000 is 2^21.\r\n              v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n              // Rejection sampling:\r\n              // 0 <= v < 9007199254740992\r\n              // Probability that v >= 9e15, is\r\n              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n              if (v >= 9e15) {\r\n                b = crypto.getRandomValues(new Uint32Array(2));\r\n                a[i] = b[0];\r\n                a[i + 1] = b[1];\r\n              } else {\r\n\r\n                // 0 <= v <= 8999999999999999\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 2;\r\n              }\r\n            }\r\n            i = k / 2;\r\n\r\n          // Node.js supporting crypto.randomBytes.\r\n          } else if (crypto.randomBytes) {\r\n\r\n            // buffer\r\n            a = crypto.randomBytes(k *= 7);\r\n\r\n            for (; i < k;) {\r\n\r\n              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n              // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n              // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n              // 0 <= v < 9007199254740992\r\n              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n              if (v >= 9e15) {\r\n                crypto.randomBytes(7).copy(a, i);\r\n              } else {\r\n\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 7;\r\n              }\r\n            }\r\n            i = k / 7;\r\n          } else {\r\n            CRYPTO = false;\r\n            throw Error\r\n             (bignumberError + 'crypto unavailable');\r\n          }\r\n        }\r\n\r\n        // Use Math.random.\r\n        if (!CRYPTO) {\r\n\r\n          for (; i < k;) {\r\n            v = random53bitInt();\r\n            if (v < 9e15) c[i++] = v % 1e14;\r\n          }\r\n        }\r\n\r\n        k = c[--i];\r\n        dp %= LOG_BASE;\r\n\r\n        // Convert trailing digits to zeros according to dp.\r\n        if (k && dp) {\r\n          v = POWS_TEN[LOG_BASE - dp];\r\n          c[i] = mathfloor(k / v) * v;\r\n        }\r\n\r\n        // Remove trailing elements which are zero.\r\n        for (; c[i] === 0; c.pop(), i--);\r\n\r\n        // Zero?\r\n        if (i < 0) {\r\n          c = [e = 0];\r\n        } else {\r\n\r\n          // Remove leading elements which are zero and adjust exponent accordingly.\r\n          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n          // Count the digits of the first element of c to determine leading zeros, and...\r\n          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n          // adjust the exponent accordingly.\r\n          if (i < LOG_BASE) e -= LOG_BASE - i;\r\n        }\r\n\r\n        rand.e = e;\r\n        rand.c = c;\r\n        return rand;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the sum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.sum = function () {\r\n      var i = 1,\r\n        args = arguments,\r\n        sum = new BigNumber(args[0]);\r\n      for (; i < args.length;) sum = sum.plus(args[i++]);\r\n      return sum;\r\n    };\r\n\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n\r\n    // Called by BigNumber and BigNumber.prototype.toString.\r\n    convertBase = (function () {\r\n      var decimal = '0123456789';\r\n\r\n      /*\r\n       * Convert string of baseIn to an array of numbers of baseOut.\r\n       * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n       */\r\n      function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n        var j,\r\n          arr = [0],\r\n          arrL,\r\n          i = 0,\r\n          len = str.length;\r\n\r\n        for (; i < len;) {\r\n          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n          arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n          for (j = 0; j < arr.length; j++) {\r\n\r\n            if (arr[j] > baseOut - 1) {\r\n              if (arr[j + 1] == null) arr[j + 1] = 0;\r\n              arr[j + 1] += arr[j] / baseOut | 0;\r\n              arr[j] %= baseOut;\r\n            }\r\n          }\r\n        }\r\n\r\n        return arr.reverse();\r\n      }\r\n\r\n      // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n      // If the caller is toString, we are converting from base 10 to baseOut.\r\n      // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n      return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n        var alphabet, d, e, k, r, x, xc, y,\r\n          i = str.indexOf('.'),\r\n          dp = DECIMAL_PLACES,\r\n          rm = ROUNDING_MODE;\r\n\r\n        // Non-integer.\r\n        if (i >= 0) {\r\n          k = POW_PRECISION;\r\n\r\n          // Unlimited precision.\r\n          POW_PRECISION = 0;\r\n          str = str.replace('.', '');\r\n          y = new BigNumber(baseIn);\r\n          x = y.pow(str.length - i);\r\n          POW_PRECISION = k;\r\n\r\n          // Convert str as if an integer, then restore the fraction part by dividing the\r\n          // result by its base raised to a power.\r\n\r\n          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n           10, baseOut, decimal);\r\n          y.e = y.c.length;\r\n        }\r\n\r\n        // Convert the number as integer.\r\n\r\n        xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n         ? (alphabet = ALPHABET, decimal)\r\n         : (alphabet = decimal, ALPHABET));\r\n\r\n        // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n        e = k = xc.length;\r\n\r\n        // Remove trailing zeros.\r\n        for (; xc[--k] == 0; xc.pop());\r\n\r\n        // Zero?\r\n        if (!xc[0]) return alphabet.charAt(0);\r\n\r\n        // Does str represent an integer? If so, no need for the division.\r\n        if (i < 0) {\r\n          --e;\r\n        } else {\r\n          x.c = xc;\r\n          x.e = e;\r\n\r\n          // The sign is needed for correct rounding.\r\n          x.s = sign;\r\n          x = div(x, y, dp, rm, baseOut);\r\n          xc = x.c;\r\n          r = x.r;\r\n          e = x.e;\r\n        }\r\n\r\n        // xc now represents str converted to baseOut.\r\n\r\n        // THe index of the rounding digit.\r\n        d = e + dp + 1;\r\n\r\n        // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n        i = xc[d];\r\n\r\n        // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n        k = baseOut / 2;\r\n        r = r || d < 0 || xc[d + 1] != null;\r\n\r\n        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n               rm == (x.s < 0 ? 8 : 7));\r\n\r\n        // If the index of the rounding digit is not greater than zero, or xc represents\r\n        // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n        // such as 0.00001.\r\n        if (d < 1 || !xc[0]) {\r\n\r\n          // 1^-dp or 0\r\n          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n        } else {\r\n\r\n          // Truncate xc to the required number of decimal places.\r\n          xc.length = d;\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            // Rounding up may mean the previous digit has to be rounded up and so on.\r\n            for (--baseOut; ++xc[--d] > baseOut;) {\r\n              xc[d] = 0;\r\n\r\n              if (!d) {\r\n                ++e;\r\n                xc = [1].concat(xc);\r\n              }\r\n            }\r\n          }\r\n\r\n          // Determine trailing zeros.\r\n          for (k = xc.length; !xc[--k];);\r\n\r\n          // E.g. [4, 11, 15] becomes 4bf.\r\n          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n          // Add leading zeros, decimal point and trailing zeros as required.\r\n          str = toFixedPoint(str, e, alphabet.charAt(0));\r\n        }\r\n\r\n        // The caller will add the sign.\r\n        return str;\r\n      };\r\n    })();\r\n\r\n\r\n    // Perform division in the specified base. Called by div and convertBase.\r\n    div = (function () {\r\n\r\n      // Assume non-zero x and k.\r\n      function multiply(x, k, base) {\r\n        var m, temp, xlo, xhi,\r\n          carry = 0,\r\n          i = x.length,\r\n          klo = k % SQRT_BASE,\r\n          khi = k / SQRT_BASE | 0;\r\n\r\n        for (x = x.slice(); i--;) {\r\n          xlo = x[i] % SQRT_BASE;\r\n          xhi = x[i] / SQRT_BASE | 0;\r\n          m = khi * xlo + xhi * klo;\r\n          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n          x[i] = temp % base;\r\n        }\r\n\r\n        if (carry) x = [carry].concat(x);\r\n\r\n        return x;\r\n      }\r\n\r\n      function compare(a, b, aL, bL) {\r\n        var i, cmp;\r\n\r\n        if (aL != bL) {\r\n          cmp = aL > bL ? 1 : -1;\r\n        } else {\r\n\r\n          for (i = cmp = 0; i < aL; i++) {\r\n\r\n            if (a[i] != b[i]) {\r\n              cmp = a[i] > b[i] ? 1 : -1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        return cmp;\r\n      }\r\n\r\n      function subtract(a, b, aL, base) {\r\n        var i = 0;\r\n\r\n        // Subtract b from a.\r\n        for (; aL--;) {\r\n          a[aL] -= i;\r\n          i = a[aL] < b[aL] ? 1 : 0;\r\n          a[aL] = i * base + a[aL] - b[aL];\r\n        }\r\n\r\n        // Remove leading zeros.\r\n        for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n      }\r\n\r\n      // x: dividend, y: divisor.\r\n      return function (x, y, dp, rm, base) {\r\n        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n          yL, yz,\r\n          s = x.s == y.s ? 1 : -1,\r\n          xc = x.c,\r\n          yc = y.c;\r\n\r\n        // Either NaN, Infinity or 0?\r\n        if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n          return new BigNumber(\r\n\r\n           // Return NaN if either NaN, or both Infinity or 0.\r\n           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\r\n            xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n         );\r\n        }\r\n\r\n        q = new BigNumber(s);\r\n        qc = q.c = [];\r\n        e = x.e - y.e;\r\n        s = dp + e + 1;\r\n\r\n        if (!base) {\r\n          base = BASE;\r\n          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n          s = s / LOG_BASE | 0;\r\n        }\r\n\r\n        // Result exponent may be one less then the current value of e.\r\n        // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n        for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n        if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n        if (s < 0) {\r\n          qc.push(1);\r\n          more = true;\r\n        } else {\r\n          xL = xc.length;\r\n          yL = yc.length;\r\n          i = 0;\r\n          s += 2;\r\n\r\n          // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n          n = mathfloor(base / (yc[0] + 1));\r\n\r\n          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n          if (n > 1) {\r\n            yc = multiply(yc, n, base);\r\n            xc = multiply(xc, n, base);\r\n            yL = yc.length;\r\n            xL = xc.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xc.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL; rem[remL++] = 0);\r\n          yz = yc.slice();\r\n          yz = [0].concat(yz);\r\n          yc0 = yc[0];\r\n          if (yc[1] >= base / 2) yc0++;\r\n          // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n          do {\r\n            n = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yc, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, n.\r\n\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // n is how many times the divisor goes into the current remainder.\r\n              n = mathfloor(rem0 / yc0);\r\n\r\n              //  Algorithm:\r\n              //  product = divisor multiplied by trial digit (n).\r\n              //  Compare product and remainder.\r\n              //  If product is greater than remainder:\r\n              //    Subtract divisor from product, decrement trial digit.\r\n              //  Subtract product from remainder.\r\n              //  If product was less than remainder at the last compare:\r\n              //    Compare new remainder and divisor.\r\n              //    If remainder is greater than divisor:\r\n              //      Subtract divisor from remainder, increment trial digit.\r\n\r\n              if (n > 1) {\r\n\r\n                // n may be > base only when base is 3.\r\n                if (n >= base) n = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiply(yc, n, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                // If product > remainder then trial digit n too high.\r\n                // n is 1 too high about 5% of the time, and is not known to have\r\n                // ever been more than 1 too high.\r\n                while (compare(prod, rem, prodL, remL) == 1) {\r\n                  n--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                  prodL = prod.length;\r\n                  cmp = 1;\r\n                }\r\n              } else {\r\n\r\n                // n is 0 or 1, cmp is -1.\r\n                // If n is 0, there is no need to compare yc and rem again below,\r\n                // so change cmp to 1 to avoid it.\r\n                // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n                if (n == 0) {\r\n\r\n                  // divisor < remainder, so n must be at least 1.\r\n                  cmp = n = 1;\r\n                }\r\n\r\n                // product = divisor\r\n                prod = yc.slice();\r\n                prodL = prod.length;\r\n              }\r\n\r\n              if (prodL < remL) prod = [0].concat(prod);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n              remL = rem.length;\r\n\r\n               // If product was < remainder.\r\n              if (cmp == -1) {\r\n\r\n                // Compare divisor and new remainder.\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                // Trial digit n too low.\r\n                // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n                while (compare(yc, rem, yL, remL) < 1) {\r\n                  n++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                  remL = rem.length;\r\n                }\r\n              }\r\n            } else if (cmp === 0) {\r\n              n++;\r\n              rem = [0];\r\n            } // else cmp === 1 and n will be 0\r\n\r\n            // Add the next digit, n, to the result array.\r\n            qc[i++] = n;\r\n\r\n            // Update the remainder.\r\n            if (rem[0]) {\r\n              rem[remL++] = xc[xi] || 0;\r\n            } else {\r\n              rem = [xc[xi]];\r\n              remL = 1;\r\n            }\r\n          } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n          more = rem[0] != null;\r\n\r\n          // Leading zero?\r\n          if (!qc[0]) qc.splice(0, 1);\r\n        }\r\n\r\n        if (base == BASE) {\r\n\r\n          // To calculate q.e, first get the number of digits of qc[0].\r\n          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n        // Caller is convertBase.\r\n        } else {\r\n          q.e = e;\r\n          q.r = +more;\r\n        }\r\n\r\n        return q;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n     * notation rounded to the specified decimal places or significant digits.\r\n     *\r\n     * n: a BigNumber.\r\n     * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n     * rm: the rounding mode.\r\n     * id: 1 (toExponential) or 2 (toPrecision).\r\n     */\r\n    function format(n, i, rm, id) {\r\n      var c0, e, ne, len, str;\r\n\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      if (!n.c) return n.toString();\r\n\r\n      c0 = n.c[0];\r\n      ne = n.e;\r\n\r\n      if (i == null) {\r\n        str = coeffToString(n.c);\r\n        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n         ? toExponential(str, ne)\r\n         : toFixedPoint(str, ne, '0');\r\n      } else {\r\n        n = round(new BigNumber(n), i, rm);\r\n\r\n        // n.e may have changed if the value was rounded up.\r\n        e = n.e;\r\n\r\n        str = coeffToString(n.c);\r\n        len = str.length;\r\n\r\n        // toPrecision returns exponential notation if the number of significant digits\r\n        // specified is less than the number of digits necessary to represent the integer\r\n        // part of the value in fixed-point notation.\r\n\r\n        // Exponential notation.\r\n        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n          // Append zeros?\r\n          for (; len < i; str += '0', len++);\r\n          str = toExponential(str, e);\r\n\r\n        // Fixed-point notation.\r\n        } else {\r\n          i -= ne;\r\n          str = toFixedPoint(str, e, '0');\r\n\r\n          // Append zeros?\r\n          if (e + 1 > len) {\r\n            if (--i > 0) for (str += '.'; i--; str += '0');\r\n          } else {\r\n            i += e - len;\r\n            if (i > 0) {\r\n              if (e + 1 == len) str += '.';\r\n              for (; i--; str += '0');\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return n.s < 0 && c0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // Handle BigNumber.max and BigNumber.min.\r\n    function maxOrMin(args, method) {\r\n      var n,\r\n        i = 1,\r\n        m = new BigNumber(args[0]);\r\n\r\n      for (; i < args.length; i++) {\r\n        n = new BigNumber(args[i]);\r\n\r\n        // If any number is NaN, return NaN.\r\n        if (!n.s) {\r\n          m = n;\r\n          break;\r\n        } else if (method.call(m, n)) {\r\n          m = n;\r\n        }\r\n      }\r\n\r\n      return m;\r\n    }\r\n\r\n\r\n    /*\r\n     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n     * Called by minus, plus and times.\r\n     */\r\n    function normalise(n, c, e) {\r\n      var i = 1,\r\n        j = c.length;\r\n\r\n       // Remove trailing zeros.\r\n      for (; !c[--j]; c.pop());\r\n\r\n      // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n      for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n      // Overflow?\r\n      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        n.c = n.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        n.c = [n.e = 0];\r\n      } else {\r\n        n.e = e;\r\n        n.c = c;\r\n      }\r\n\r\n      return n;\r\n    }\r\n\r\n\r\n    // Handle values that fail the validity test in BigNumber.\r\n    parseNumeric = (function () {\r\n      var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n        dotAfter = /^([^.]+)\\.$/,\r\n        dotBefore = /^\\.([^.]+)$/,\r\n        isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n        whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n      return function (x, str, isNum, b) {\r\n        var base,\r\n          s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n        // No exception on Infinity or NaN.\r\n        if (isInfinityOrNaN.test(s)) {\r\n          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n        } else {\r\n          if (!isNum) {\r\n\r\n            // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n            s = s.replace(basePrefix, function (m, p1, p2) {\r\n              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n              return !b || b == base ? p1 : m;\r\n            });\r\n\r\n            if (b) {\r\n              base = b;\r\n\r\n              // E.g. '1.' to '1', '.1' to '0.1'\r\n              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n            }\r\n\r\n            if (str != s) return new BigNumber(s, base);\r\n          }\r\n\r\n          // '[BigNumber Error] Not a number: {n}'\r\n          // '[BigNumber Error] Not a base {b} number: {n}'\r\n          if (BigNumber.DEBUG) {\r\n            throw Error\r\n              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n          }\r\n\r\n          // NaN\r\n          x.s = null;\r\n        }\r\n\r\n        x.c = x.e = null;\r\n      }\r\n    })();\r\n\r\n\r\n    /*\r\n     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n     * If r is truthy, it is known that there are more digits after the rounding digit.\r\n     */\r\n    function round(x, sd, rm, r) {\r\n      var d, i, j, k, n, ni, rd,\r\n        xc = x.c,\r\n        pows10 = POWS_TEN;\r\n\r\n      // if x is not Infinity or NaN...\r\n      if (xc) {\r\n\r\n        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n        // ni is the index of n within x.c.\r\n        // d is the number of digits of n.\r\n        // i is the index of rd within n including leading zeros.\r\n        // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n        out: {\r\n\r\n          // Get the number of digits of the first element of xc.\r\n          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n          i = sd - d;\r\n\r\n          // If the rounding digit is in the first element of xc...\r\n          if (i < 0) {\r\n            i += LOG_BASE;\r\n            j = sd;\r\n            n = xc[ni = 0];\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = n / pows10[d - j - 1] % 10 | 0;\r\n          } else {\r\n            ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n            if (ni >= xc.length) {\r\n\r\n              if (r) {\r\n\r\n                // Needed by sqrt.\r\n                for (; xc.length <= ni; xc.push(0));\r\n                n = rd = 0;\r\n                d = 1;\r\n                i %= LOG_BASE;\r\n                j = i - LOG_BASE + 1;\r\n              } else {\r\n                break out;\r\n              }\r\n            } else {\r\n              n = k = xc[ni];\r\n\r\n              // Get the number of digits of n.\r\n              for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n              // Get the index of rd within n.\r\n              i %= LOG_BASE;\r\n\r\n              // Get the index of rd within n, adjusted for leading zeros.\r\n              // The number of leading zeros of n is given by LOG_BASE - d.\r\n              j = i - LOG_BASE + d;\r\n\r\n              // Get the rounding digit at index j of n.\r\n              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;\r\n            }\r\n          }\r\n\r\n          r = r || sd < 0 ||\r\n\r\n          // Are there any non-zero digits after the rounding digit?\r\n          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n          r = rm < 4\r\n           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n            // Check whether the digit to the left of the rounding digit is odd.\r\n            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n          if (sd < 1 || !xc[0]) {\r\n            xc.length = 0;\r\n\r\n            if (r) {\r\n\r\n              // Convert sd to decimal places.\r\n              sd -= x.e + 1;\r\n\r\n              // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n              x.e = -sd || 0;\r\n            } else {\r\n\r\n              // Zero.\r\n              xc[0] = x.e = 0;\r\n            }\r\n\r\n            return x;\r\n          }\r\n\r\n          // Remove excess digits.\r\n          if (i == 0) {\r\n            xc.length = ni;\r\n            k = 1;\r\n            ni--;\r\n          } else {\r\n            xc.length = ni + 1;\r\n            k = pows10[LOG_BASE - i];\r\n\r\n            // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n            // j > 0 means i > number of leading zeros of n.\r\n            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n          }\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            for (; ;) {\r\n\r\n              // If the digit to be rounded up is in the first element of xc...\r\n              if (ni == 0) {\r\n\r\n                // i will be the length of xc[0] before k is added.\r\n                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n                j = xc[0] += k;\r\n                for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n                // if i != k the length has increased.\r\n                if (i != k) {\r\n                  x.e++;\r\n                  if (xc[0] == BASE) xc[0] = 1;\r\n                }\r\n\r\n                break;\r\n              } else {\r\n                xc[ni] += k;\r\n                if (xc[ni] != BASE) break;\r\n                xc[ni--] = 0;\r\n                k = 1;\r\n              }\r\n            }\r\n          }\r\n\r\n          // Remove trailing zeros.\r\n          for (i = xc.length; xc[--i] === 0; xc.pop());\r\n        }\r\n\r\n        // Overflow? Infinity.\r\n        if (x.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n\r\n        // Underflow? Zero.\r\n        } else if (x.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        }\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n\r\n    function valueOf(n) {\r\n      var str,\r\n        e = n.e;\r\n\r\n      if (e === null) return n.toString();\r\n\r\n      str = coeffToString(n.c);\r\n\r\n      str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n        ? toExponential(str, e)\r\n        : toFixedPoint(str, e, '0');\r\n\r\n      return n.s < 0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n     */\r\n    P.absoluteValue = P.abs = function () {\r\n      var x = new BigNumber(this);\r\n      if (x.s < 0) x.s = 1;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return\r\n     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     *   0 if they have the same value,\r\n     *   or null if the value of either is NaN.\r\n     */\r\n    P.comparedTo = function (y, b) {\r\n      return compare(this, new BigNumber(y, b));\r\n    };\r\n\r\n\r\n    /*\r\n     * If dp is undefined or null or true or false, return the number of decimal places of the\r\n     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n     *\r\n     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.decimalPlaces = P.dp = function (dp, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), dp + x.e + 1, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last number.\r\n      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n      if (n < 0) n = 0;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n / 0 = I\r\n     *  n / N = N\r\n     *  n / I = 0\r\n     *  0 / n = 0\r\n     *  0 / 0 = N\r\n     *  0 / N = N\r\n     *  0 / I = 0\r\n     *  N / n = N\r\n     *  N / 0 = N\r\n     *  N / N = N\r\n     *  N / I = N\r\n     *  I / n = I\r\n     *  I / 0 = I\r\n     *  I / N = N\r\n     *  I / I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.dividedBy = P.div = function (y, b) {\r\n      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n     * BigNumber by the value of BigNumber(y, b).\r\n     */\r\n    P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n      return div(this, new BigNumber(y, b), 0, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n     *\r\n     * If m is present, return the result modulo m.\r\n     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n     *\r\n     * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n     *\r\n     * n {number|string|BigNumber} The exponent. An integer.\r\n     * [m] {number|string|BigNumber} The modulus.\r\n     *\r\n     * '[BigNumber Error] Exponent not an integer: {n}'\r\n     */\r\n    P.exponentiatedBy = P.pow = function (n, m) {\r\n      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n        x = this;\r\n\r\n      n = new BigNumber(n);\r\n\r\n      // Allow NaN and Infinity, but not other non-integers.\r\n      if (n.c && !n.isInteger()) {\r\n        throw Error\r\n          (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n      }\r\n\r\n      if (m != null) m = new BigNumber(m);\r\n\r\n      // Exponent of MAX_SAFE_INTEGER is 15.\r\n      nIsBig = n.e > 14;\r\n\r\n      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.\r\n      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n        // The sign of the result of pow when x is negative depends on the evenness of n.\r\n        // If +n overflows to Infinity, the evenness of n would be not be known.\r\n        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));\r\n        return m ? y.mod(m) : y;\r\n      }\r\n\r\n      nIsNeg = n.s < 0;\r\n\r\n      if (m) {\r\n\r\n        // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n        isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n        if (isModExp) x = x.mod(m);\r\n\r\n      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.\r\n      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n        // [1, 240000000]\r\n        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n        // [80000000000000]  [99999750000000]\r\n        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n        // If x is negative and n is odd, k = -0, else k = 0.\r\n        k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n        // If x >= 1, k = Infinity.\r\n        if (x.e > -1) k = 1 / k;\r\n\r\n        // If n is negative return 0, else return Infinity.\r\n        return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n      } else if (POW_PRECISION) {\r\n\r\n        // Truncating each coefficient array to a length of k after each multiplication\r\n        // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n        // i.e. there will be a minimum of 28 guard digits retained.\r\n        k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n      }\r\n\r\n      if (nIsBig) {\r\n        half = new BigNumber(0.5);\r\n        if (nIsNeg) n.s = 1;\r\n        nIsOdd = isOdd(n);\r\n      } else {\r\n        i = Math.abs(+valueOf(n));\r\n        nIsOdd = i % 2;\r\n      }\r\n\r\n      y = new BigNumber(ONE);\r\n\r\n      // Performs 54 loop iterations for n of 9007199254740991.\r\n      for (; ;) {\r\n\r\n        if (nIsOdd) {\r\n          y = y.times(x);\r\n          if (!y.c) break;\r\n\r\n          if (k) {\r\n            if (y.c.length > k) y.c.length = k;\r\n          } else if (isModExp) {\r\n            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n          }\r\n        }\r\n\r\n        if (i) {\r\n          i = mathfloor(i / 2);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        } else {\r\n          n = n.times(half);\r\n          round(n, n.e + 1, 1);\r\n\r\n          if (n.e > 14) {\r\n            nIsOdd = isOdd(n);\r\n          } else {\r\n            i = +valueOf(n);\r\n            if (i === 0) break;\r\n            nIsOdd = i % 2;\r\n          }\r\n        }\r\n\r\n        x = x.times(x);\r\n\r\n        if (k) {\r\n          if (x.c && x.c.length > k) x.c.length = k;\r\n        } else if (isModExp) {\r\n          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (isModExp) return y;\r\n      if (nIsNeg) y = ONE.div(y);\r\n\r\n      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n     */\r\n    P.integerValue = function (rm) {\r\n      var n = new BigNumber(this);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n      return round(n, n.e + 1, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isEqualTo = P.eq = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n     */\r\n    P.isFinite = function () {\r\n      return !!this.c;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isGreaterThan = P.gt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n     */\r\n    P.isInteger = function () {\r\n      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isLessThan = P.lt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n     */\r\n    P.isNaN = function () {\r\n      return !this.s;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is negative, otherwise return false.\r\n     */\r\n    P.isNegative = function () {\r\n      return this.s < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is positive, otherwise return false.\r\n     */\r\n    P.isPositive = function () {\r\n      return this.s > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n     */\r\n    P.isZero = function () {\r\n      return !!this.c && this.c[0] == 0;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n - 0 = n\r\n     *  n - N = N\r\n     *  n - I = -I\r\n     *  0 - n = -n\r\n     *  0 - 0 = 0\r\n     *  0 - N = N\r\n     *  0 - I = -I\r\n     *  N - n = N\r\n     *  N - 0 = N\r\n     *  N - N = N\r\n     *  N - I = N\r\n     *  I - n = I\r\n     *  I - 0 = I\r\n     *  I - N = N\r\n     *  I - I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.minus = function (y, b) {\r\n      var i, j, t, xLTy,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n      if (a != b) {\r\n        y.s = -b;\r\n        return x.plus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Either Infinity?\r\n        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n        // Either zero?\r\n        if (!xc[0] || !yc[0]) {\r\n\r\n          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n           ROUNDING_MODE == 3 ? -0 : 0);\r\n        }\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Determine which is the bigger number.\r\n      if (a = xe - ye) {\r\n\r\n        if (xLTy = a < 0) {\r\n          a = -a;\r\n          t = xc;\r\n        } else {\r\n          ye = xe;\r\n          t = yc;\r\n        }\r\n\r\n        t.reverse();\r\n\r\n        // Prepend zeros to equalise exponents.\r\n        for (b = a; b--; t.push(0));\r\n        t.reverse();\r\n      } else {\r\n\r\n        // Exponents equal. Check digit by digit.\r\n        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n        for (a = b = 0; b < j; b++) {\r\n\r\n          if (xc[b] != yc[b]) {\r\n            xLTy = xc[b] < yc[b];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // x < y? Point xc to the array of the bigger number.\r\n      if (xLTy) {\r\n        t = xc;\r\n        xc = yc;\r\n        yc = t;\r\n        y.s = -y.s;\r\n      }  \r\n\r\n      b = (j = yc.length) - (i = xc.length);\r\n\r\n      // Append zeros to xc if shorter.\r\n      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n      if (b > 0) for (; b--; xc[i++] = 0);\r\n      b = BASE - 1;\r\n\r\n      // Subtract yc from xc.\r\n      for (; j > a;) {\r\n\r\n        if (xc[--j] < yc[j]) {\r\n          for (i = j; i && !xc[--i]; xc[i] = b);\r\n          --xc[i];\r\n          xc[j] += BASE;\r\n        }\r\n\r\n        xc[j] -= yc[j];\r\n      }\r\n\r\n      // Remove leading zeros and adjust exponent accordingly.\r\n      for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n      // Zero?\r\n      if (!xc[0]) {\r\n\r\n        // Following IEEE 754 (2008) 6.3,\r\n        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n        y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n        y.c = [y.e = 0];\r\n        return y;\r\n      }\r\n\r\n      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n      // for finite x and y.\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     *   n % 0 =  N\r\n     *   n % N =  N\r\n     *   n % I =  n\r\n     *   0 % n =  0\r\n     *  -0 % n = -0\r\n     *   0 % 0 =  N\r\n     *   0 % N =  N\r\n     *   0 % I =  0\r\n     *   N % n =  N\r\n     *   N % 0 =  N\r\n     *   N % N =  N\r\n     *   N % I =  N\r\n     *   I % n =  N\r\n     *   I % 0 =  N\r\n     *   I % N =  N\r\n     *   I % I =  N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n     * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n     */\r\n    P.modulo = P.mod = function (y, b) {\r\n      var q, s,\r\n        x = this;\r\n\r\n      y = new BigNumber(y, b);\r\n\r\n      // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n      if (!x.c || !y.s || y.c && !y.c[0]) {\r\n        return new BigNumber(NaN);\r\n\r\n      // Return x if y is Infinity or x is zero.\r\n      } else if (!y.c || x.c && !x.c[0]) {\r\n        return new BigNumber(x);\r\n      }\r\n\r\n      if (MODULO_MODE == 9) {\r\n\r\n        // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n        // r = x - qy    where  0 <= r < abs(y)\r\n        s = y.s;\r\n        y.s = 1;\r\n        q = div(x, y, 0, 3);\r\n        y.s = s;\r\n        q.s *= s;\r\n      } else {\r\n        q = div(x, y, 0, MODULO_MODE);\r\n      }\r\n\r\n      y = x.minus(q.times(y));\r\n\r\n      // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n      return y;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n * 0 = 0\r\n     *  n * N = N\r\n     *  n * I = I\r\n     *  0 * n = 0\r\n     *  0 * 0 = 0\r\n     *  0 * N = N\r\n     *  0 * I = N\r\n     *  N * n = N\r\n     *  N * 0 = N\r\n     *  N * N = N\r\n     *  N * I = N\r\n     *  I * n = I\r\n     *  I * 0 = N\r\n     *  I * N = N\r\n     *  I * I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n     * of BigNumber(y, b).\r\n     */\r\n    P.multipliedBy = P.times = function (y, b) {\r\n      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n        base, sqrtBase,\r\n        x = this,\r\n        xc = x.c,\r\n        yc = (y = new BigNumber(y, b)).c;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n        // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n          y.c = y.e = y.s = null;\r\n        } else {\r\n          y.s *= x.s;\r\n\r\n          // Return Infinity if either is Infinity.\r\n          if (!xc || !yc) {\r\n            y.c = y.e = null;\r\n\r\n          // Return 0 if either is 0.\r\n          } else {\r\n            y.c = [0];\r\n            y.e = 0;\r\n          }\r\n        }\r\n\r\n        return y;\r\n      }\r\n\r\n      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n      y.s *= x.s;\r\n      xcL = xc.length;\r\n      ycL = yc.length;\r\n\r\n      // Ensure xc points to longer array and xcL to its length.\r\n      if (xcL < ycL) {\r\n        zc = xc;\r\n        xc = yc;\r\n        yc = zc;\r\n        i = xcL;\r\n        xcL = ycL;\r\n        ycL = i;\r\n      }  \r\n\r\n      // Initialise the result array with zeros.\r\n      for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n      base = BASE;\r\n      sqrtBase = SQRT_BASE;\r\n\r\n      for (i = ycL; --i >= 0;) {\r\n        c = 0;\r\n        ylo = yc[i] % sqrtBase;\r\n        yhi = yc[i] / sqrtBase | 0;\r\n\r\n        for (k = xcL, j = i + k; j > i;) {\r\n          xlo = xc[--k] % sqrtBase;\r\n          xhi = xc[k] / sqrtBase | 0;\r\n          m = yhi * xlo + xhi * ylo;\r\n          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n          zc[j--] = xlo % base;\r\n        }\r\n\r\n        zc[j] = c;\r\n      }\r\n\r\n      if (c) {\r\n        ++e;\r\n      } else {\r\n        zc.splice(0, 1);\r\n      }\r\n\r\n      return normalise(y, zc, e);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n     * i.e. multiplied by -1.\r\n     */\r\n    P.negated = function () {\r\n      var x = new BigNumber(this);\r\n      x.s = -x.s || null;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n + 0 = n\r\n     *  n + N = N\r\n     *  n + I = I\r\n     *  0 + n = n\r\n     *  0 + 0 = 0\r\n     *  0 + N = N\r\n     *  0 + I = I\r\n     *  N + n = N\r\n     *  N + 0 = N\r\n     *  N + N = N\r\n     *  N + I = N\r\n     *  I + n = I\r\n     *  I + 0 = I\r\n     *  I + N = N\r\n     *  I + I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.plus = function (y, b) {\r\n      var t,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n       if (a != b) {\r\n        y.s = -b;\r\n        return x.minus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Return Infinity if either Infinity.\r\n        if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n        // Either zero?\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n      if (a = xe - ye) {\r\n        if (a > 0) {\r\n          ye = xe;\r\n          t = yc;\r\n        } else {\r\n          a = -a;\r\n          t = xc;\r\n        }\r\n\r\n        t.reverse();\r\n        for (; a--; t.push(0));\r\n        t.reverse();\r\n      }\r\n\r\n      a = xc.length;\r\n      b = yc.length;\r\n\r\n      // Point xc to the longer array, and b to the shorter length.\r\n      if (a - b < 0) {\r\n        t = yc;\r\n        yc = xc;\r\n        xc = t;\r\n        b = a;\r\n      }  \r\n\r\n      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n      for (a = 0; b;) {\r\n        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n      }\r\n\r\n      if (a) {\r\n        xc = [a].concat(xc);\r\n        ++ye;\r\n      }\r\n\r\n      // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n      // ye = MAX_EXP + 1 possible\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     * If sd is undefined or null or true or false, return the number of significant digits of\r\n     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n     * If sd is true include integer-part trailing zeros in the count.\r\n     *\r\n     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n     *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.precision = P.sd = function (sd, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (sd != null && sd !== !!sd) {\r\n        intCheck(sd, 1, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), sd, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      v = c.length - 1;\r\n      n = v * LOG_BASE + 1;\r\n\r\n      if (v = c[v]) {\r\n\r\n        // Subtract the number of trailing zeros of the last element.\r\n        for (; v % 10 == 0; v /= 10, n--);\r\n\r\n        // Add the number of digits of the first element.\r\n        for (v = c[0]; v >= 10; v /= 10, n++);\r\n      }\r\n\r\n      if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n     *\r\n     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n     */\r\n    P.shiftedBy = function (k) {\r\n      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n      return this.times('1e' + k);\r\n    };\r\n\r\n\r\n    /*\r\n     *  sqrt(-n) =  N\r\n     *  sqrt(N) =  N\r\n     *  sqrt(-I) =  N\r\n     *  sqrt(I) =  I\r\n     *  sqrt(0) =  0\r\n     *  sqrt(-0) = -0\r\n     *\r\n     * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.squareRoot = P.sqrt = function () {\r\n      var m, n, r, rep, t,\r\n        x = this,\r\n        c = x.c,\r\n        s = x.s,\r\n        e = x.e,\r\n        dp = DECIMAL_PLACES + 4,\r\n        half = new BigNumber('0.5');\r\n\r\n      // Negative/NaN/Infinity/zero?\r\n      if (s !== 1 || !c || !c[0]) {\r\n        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n      }\r\n\r\n      // Initial estimate.\r\n      s = Math.sqrt(+valueOf(x));\r\n\r\n      // Math.sqrt underflow/overflow?\r\n      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n      if (s == 0 || s == 1 / 0) {\r\n        n = coeffToString(c);\r\n        if ((n.length + e) % 2 == 0) n += '0';\r\n        s = Math.sqrt(+n);\r\n        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n        if (s == 1 / 0) {\r\n          n = '5e' + e;\r\n        } else {\r\n          n = s.toExponential();\r\n          n = n.slice(0, n.indexOf('e') + 1) + e;\r\n        }\r\n\r\n        r = new BigNumber(n);\r\n      } else {\r\n        r = new BigNumber(s + '');\r\n      }\r\n\r\n      // Check for zero.\r\n      // r could be zero if MIN_EXP is changed after the this value was created.\r\n      // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n      // coeffToString to throw.\r\n      if (r.c[0]) {\r\n        e = r.e;\r\n        s = e + dp;\r\n        if (s < 3) s = 0;\r\n\r\n        // Newton-Raphson iteration.\r\n        for (; ;) {\r\n          t = r;\r\n          r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n            // The exponent of r may here be one less than the final result exponent,\r\n            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n            // are indexed correctly.\r\n            if (r.e < e) --s;\r\n            n = n.slice(s - 3, s + 1);\r\n\r\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n            // iteration.\r\n            if (n == '9999' || !rep && n == '4999') {\r\n\r\n              // On the first iteration only, check to see if rounding up gives the\r\n              // exact result as the nines may infinitely repeat.\r\n              if (!rep) {\r\n                round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n                if (t.times(t).eq(x)) {\r\n                  r = t;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              dp += 4;\r\n              s += 4;\r\n              rep = 1;\r\n            } else {\r\n\r\n              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n              // result. If not, then there are further digits and m will be truthy.\r\n              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n                // Truncate to the first rounding digit.\r\n                round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n                m = !r.times(r).eq(x);\r\n              }\r\n\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in exponential notation and\r\n     * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toExponential = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp++;\r\n      }\r\n      return format(this, dp, rm, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n     * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toFixed = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp = dp + this.e + 1;\r\n      }\r\n      return format(this, dp, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n     * of the format or FORMAT object (see BigNumber.set).\r\n     *\r\n     * The formatting object may contain some or all of the properties shown below.\r\n     *\r\n     * FORMAT = {\r\n     *   prefix: '',\r\n     *   groupSize: 3,\r\n     *   secondaryGroupSize: 0,\r\n     *   groupSeparator: ',',\r\n     *   decimalSeparator: '.',\r\n     *   fractionGroupSize: 0,\r\n     *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n     *   suffix: ''\r\n     * };\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     * [format] {object} Formatting options. See FORMAT pbject above.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     * '[BigNumber Error] Argument not an object: {format}'\r\n     */\r\n    P.toFormat = function (dp, rm, format) {\r\n      var str,\r\n        x = this;\r\n\r\n      if (format == null) {\r\n        if (dp != null && rm && typeof rm == 'object') {\r\n          format = rm;\r\n          rm = null;\r\n        } else if (dp && typeof dp == 'object') {\r\n          format = dp;\r\n          dp = rm = null;\r\n        } else {\r\n          format = FORMAT;\r\n        }\r\n      } else if (typeof format != 'object') {\r\n        throw Error\r\n          (bignumberError + 'Argument not an object: ' + format);\r\n      }\r\n\r\n      str = x.toFixed(dp, rm);\r\n\r\n      if (x.c) {\r\n        var i,\r\n          arr = str.split('.'),\r\n          g1 = +format.groupSize,\r\n          g2 = +format.secondaryGroupSize,\r\n          groupSeparator = format.groupSeparator || '',\r\n          intPart = arr[0],\r\n          fractionPart = arr[1],\r\n          isNeg = x.s < 0,\r\n          intDigits = isNeg ? intPart.slice(1) : intPart,\r\n          len = intDigits.length;\r\n\r\n        if (g2) {\r\n          i = g1;\r\n          g1 = g2;\r\n          g2 = i;\r\n          len -= i;\r\n        }  \r\n\r\n        if (g1 > 0 && len > 0) {\r\n          i = len % g1 || g1;\r\n          intPart = intDigits.substr(0, i);\r\n          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n          if (isNeg) intPart = '-' + intPart;\r\n        }\r\n\r\n        str = fractionPart\r\n         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n          ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n           '$&' + (format.fractionGroupSeparator || ''))\r\n          : fractionPart)\r\n         : intPart;\r\n      }\r\n\r\n      return (format.prefix || '') + str + (format.suffix || '');\r\n    };\r\n\r\n\r\n    /*\r\n     * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n     * fraction with an integer numerator and an integer denominator.\r\n     * The denominator will be a positive non-zero value less than or equal to the specified\r\n     * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n     * the lowest value necessary to represent the number exactly.\r\n     *\r\n     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n     *\r\n     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n     */\r\n    P.toFraction = function (md) {\r\n      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n        x = this,\r\n        xc = x.c;\r\n\r\n      if (md != null) {\r\n        n = new BigNumber(md);\r\n\r\n        // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n          throw Error\r\n            (bignumberError + 'Argument ' +\r\n              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n        }\r\n      }\r\n\r\n      if (!xc) return new BigNumber(x);\r\n\r\n      d = new BigNumber(ONE);\r\n      n1 = d0 = new BigNumber(ONE);\r\n      d1 = n0 = new BigNumber(ONE);\r\n      s = coeffToString(xc);\r\n\r\n      // Determine initial denominator.\r\n      // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n      e = d.e = s.length - x.e - 1;\r\n      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n      exp = MAX_EXP;\r\n      MAX_EXP = 1 / 0;\r\n      n = new BigNumber(s);\r\n\r\n      // n0 = d1 = 0\r\n      n0.c[0] = 0;\r\n\r\n      for (; ;)  {\r\n        q = div(n, d, 0, 1);\r\n        d2 = d0.plus(q.times(d1));\r\n        if (d2.comparedTo(md) == 1) break;\r\n        d0 = d1;\r\n        d1 = d2;\r\n        n1 = n0.plus(q.times(d2 = n1));\r\n        n0 = d2;\r\n        d = n.minus(q.times(d2 = d));\r\n        n = d2;\r\n      }\r\n\r\n      d2 = div(md.minus(d0), d1, 0, 1);\r\n      n0 = n0.plus(d2.times(n1));\r\n      d0 = d0.plus(d2.times(d1));\r\n      n0.s = n1.s = x.s;\r\n      e = e * 2;\r\n\r\n      // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n      MAX_EXP = exp;\r\n\r\n      return r;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return the value of this BigNumber converted to a number primitive.\r\n     */\r\n    P.toNumber = function () {\r\n      return +valueOf(this);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n     * necessary to represent the integer part of the value in fixed-point notation, then use\r\n     * exponential notation.\r\n     *\r\n     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.toPrecision = function (sd, rm) {\r\n      if (sd != null) intCheck(sd, 1, MAX);\r\n      return format(this, sd, rm, 2);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n     * TO_EXP_NEG, return exponential notation.\r\n     *\r\n     * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n     *\r\n     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n     */\r\n    P.toString = function (b) {\r\n      var str,\r\n        n = this,\r\n        s = n.s,\r\n        e = n.e;\r\n\r\n      // Infinity or NaN?\r\n      if (e === null) {\r\n        if (s) {\r\n          str = 'Infinity';\r\n          if (s < 0) str = '-' + str;\r\n        } else {\r\n          str = 'NaN';\r\n        }\r\n      } else {\r\n        if (b == null) {\r\n          str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n           ? toExponential(coeffToString(n.c), e)\r\n           : toFixedPoint(coeffToString(n.c), e, '0');\r\n        } else if (b === 10 && alphabetHasNormalDecimalDigits) {\r\n          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n          str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n        } else {\r\n          intCheck(b, 2, ALPHABET.length, 'Base');\r\n          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n        }\r\n\r\n        if (s < 0 && n.c[0]) str = '-' + str;\r\n      }\r\n\r\n      return str;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return as toString, but do not accept a base argument, and include the minus sign for\r\n     * negative zero.\r\n     */\r\n    P.valueOf = P.toJSON = function () {\r\n      return valueOf(this);\r\n    };\r\n\r\n\r\n    P._isBigNumber = true;\r\n\r\n    if (configObject != null) BigNumber.set(configObject);\r\n\r\n    return BigNumber;\r\n  }\r\n\r\n\r\n  // PRIVATE HELPER FUNCTIONS\r\n\r\n  // These functions don't need access to variables,\r\n  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\n  function bitFloor(n) {\r\n    var i = n | 0;\r\n    return n > 0 || n === i ? i : i - 1;\r\n  }\r\n\r\n\r\n  // Return a coefficient array as a string of base 10 digits.\r\n  function coeffToString(a) {\r\n    var s, z,\r\n      i = 1,\r\n      j = a.length,\r\n      r = a[0] + '';\r\n\r\n    for (; i < j;) {\r\n      s = a[i++] + '';\r\n      z = LOG_BASE - s.length;\r\n      for (; z--; s = '0' + s);\r\n      r += s;\r\n    }\r\n\r\n    // Determine trailing zeros.\r\n    for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n    return r.slice(0, j + 1 || 1);\r\n  }\r\n\r\n\r\n  // Compare the value of BigNumbers x and y.\r\n  function compare(x, y) {\r\n    var a, b,\r\n      xc = x.c,\r\n      yc = y.c,\r\n      i = x.s,\r\n      j = y.s,\r\n      k = x.e,\r\n      l = y.e;\r\n\r\n    // Either NaN?\r\n    if (!i || !j) return null;\r\n\r\n    a = xc && !xc[0];\r\n    b = yc && !yc[0];\r\n\r\n    // Either zero?\r\n    if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n    // Signs differ?\r\n    if (i != j) return i;\r\n\r\n    a = i < 0;\r\n    b = k == l;\r\n\r\n    // Either Infinity?\r\n    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n    // Compare exponents.\r\n    if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n    j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n    // Compare lengths.\r\n    return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n   */\r\n  function intCheck(n, min, max, name) {\r\n    if (n < min || n > max || n !== mathfloor(n)) {\r\n      throw Error\r\n       (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n         ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n         : ' not a primitive number: ') + String(n));\r\n    }\r\n  }\r\n\r\n\r\n  // Assumes finite n.\r\n  function isOdd(n) {\r\n    var k = n.c.length - 1;\r\n    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n  }\r\n\r\n\r\n  function toExponential(str, e) {\r\n    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n     (e < 0 ? 'e' : 'e+') + e;\r\n  }\r\n\r\n\r\n  function toFixedPoint(str, e, z) {\r\n    var len, zs;\r\n\r\n    // Negative exponent?\r\n    if (e < 0) {\r\n\r\n      // Prepend zeros.\r\n      for (zs = z + '.'; ++e; zs += z);\r\n      str = zs + str;\r\n\r\n    // Positive exponent\r\n    } else {\r\n      len = str.length;\r\n\r\n      // Append zeros.\r\n      if (++e > len) {\r\n        for (zs = z, e -= len; --e; zs += z);\r\n        str += zs;\r\n      } else if (e < len) {\r\n        str = str.slice(0, e) + '.' + str.slice(e);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // EXPORT\r\n\r\n\r\n  BigNumber = clone();\r\n  BigNumber['default'] = BigNumber.BigNumber = BigNumber;\r\n\r\n  // AMD.\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n  // Node.js and other environments that support module.exports.\r\n  } else {}\r\n})(this);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLmpzP2NjZWQiXSwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbiAoZ2xvYmFsT2JqZWN0KSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuLypcclxuICogICAgICBiaWdudW1iZXIuanMgdjkuMS4wXHJcbiAqICAgICAgQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGFyYml0cmFyeS1wcmVjaXNpb24gYXJpdGhtZXRpYy5cclxuICogICAgICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWdudW1iZXIuanNcclxuICogICAgICBDb3B5cmlnaHQgKGMpIDIwMjIgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICogICAgICBNSVQgTGljZW5zZWQuXHJcbiAqXHJcbiAqICAgICAgQmlnTnVtYmVyLnByb3RvdHlwZSBtZXRob2RzICAgICB8ICBCaWdOdW1iZXIgbWV0aG9kc1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGFic29sdXRlVmFsdWUgICAgICAgICAgICBhYnMgICAgfCAgY2xvbmVcclxuICogICAgICBjb21wYXJlZFRvICAgICAgICAgICAgICAgICAgICAgIHwgIGNvbmZpZyAgICAgICAgICAgICAgIHNldFxyXG4gKiAgICAgIGRlY2ltYWxQbGFjZXMgICAgICAgICAgICBkcCAgICAgfCAgICAgIERFQ0lNQUxfUExBQ0VTXHJcbiAqICAgICAgZGl2aWRlZEJ5ICAgICAgICAgICAgICAgIGRpdiAgICB8ICAgICAgUk9VTkRJTkdfTU9ERVxyXG4gKiAgICAgIGRpdmlkZWRUb0ludGVnZXJCeSAgICAgICBpZGl2ICAgfCAgICAgIEVYUE9ORU5USUFMX0FUXHJcbiAqICAgICAgZXhwb25lbnRpYXRlZEJ5ICAgICAgICAgIHBvdyAgICB8ICAgICAgUkFOR0VcclxuICogICAgICBpbnRlZ2VyVmFsdWUgICAgICAgICAgICAgICAgICAgIHwgICAgICBDUllQVE9cclxuICogICAgICBpc0VxdWFsVG8gICAgICAgICAgICAgICAgZXEgICAgIHwgICAgICBNT0RVTE9fTU9ERVxyXG4gKiAgICAgIGlzRmluaXRlICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgIFBPV19QUkVDSVNJT05cclxuICogICAgICBpc0dyZWF0ZXJUaGFuICAgICAgICAgICAgZ3QgICAgIHwgICAgICBGT1JNQVRcclxuICogICAgICBpc0dyZWF0ZXJUaGFuT3JFcXVhbFRvICAgZ3RlICAgIHwgICAgICBBTFBIQUJFVFxyXG4gKiAgICAgIGlzSW50ZWdlciAgICAgICAgICAgICAgICAgICAgICAgfCAgaXNCaWdOdW1iZXJcclxuICogICAgICBpc0xlc3NUaGFuICAgICAgICAgICAgICAgbHQgICAgIHwgIG1heGltdW0gICAgICAgICAgICAgIG1heFxyXG4gKiAgICAgIGlzTGVzc1RoYW5PckVxdWFsVG8gICAgICBsdGUgICAgfCAgbWluaW11bSAgICAgICAgICAgICAgbWluXHJcbiAqICAgICAgaXNOYU4gICAgICAgICAgICAgICAgICAgICAgICAgICB8ICByYW5kb21cclxuICogICAgICBpc05lZ2F0aXZlICAgICAgICAgICAgICAgICAgICAgIHwgIHN1bVxyXG4gKiAgICAgIGlzUG9zaXRpdmUgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGlzWmVybyAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1pbnVzICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1vZHVsbyAgICAgICAgICAgICAgICAgICBtb2QgICAgfFxyXG4gKiAgICAgIG11bHRpcGxpZWRCeSAgICAgICAgICAgICB0aW1lcyAgfFxyXG4gKiAgICAgIG5lZ2F0ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHBsdXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHByZWNpc2lvbiAgICAgICAgICAgICAgICBzZCAgICAgfFxyXG4gKiAgICAgIHNoaWZ0ZWRCeSAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHNxdWFyZVJvb3QgICAgICAgICAgICAgICBzcXJ0ICAgfFxyXG4gKiAgICAgIHRvRXhwb25lbnRpYWwgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRml4ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRm9ybWF0ICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRnJhY3Rpb24gICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvSlNPTiAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvTnVtYmVyICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvUHJlY2lzaW9uICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvU3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHZhbHVlT2YgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKlxyXG4gKi9cclxuXHJcblxyXG4gIHZhciBCaWdOdW1iZXIsXHJcbiAgICBpc051bWVyaWMgPSAvXi0/KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspPyQvaSxcclxuICAgIG1hdGhjZWlsID0gTWF0aC5jZWlsLFxyXG4gICAgbWF0aGZsb29yID0gTWF0aC5mbG9vcixcclxuXHJcbiAgICBiaWdudW1iZXJFcnJvciA9ICdbQmlnTnVtYmVyIEVycm9yXSAnLFxyXG4gICAgdG9vTWFueURpZ2l0cyA9IGJpZ251bWJlckVycm9yICsgJ051bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6ICcsXHJcblxyXG4gICAgQkFTRSA9IDFlMTQsXHJcbiAgICBMT0dfQkFTRSA9IDE0LFxyXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmYsICAgICAgICAgLy8gMl41MyAtIDFcclxuICAgIC8vIE1BWF9JTlQzMiA9IDB4N2ZmZmZmZmYsICAgICAgICAgICAgICAgICAgIC8vIDJeMzEgLSAxXHJcbiAgICBQT1dTX1RFTiA9IFsxLCAxMCwgMTAwLCAxZTMsIDFlNCwgMWU1LCAxZTYsIDFlNywgMWU4LCAxZTksIDFlMTAsIDFlMTEsIDFlMTIsIDFlMTNdLFxyXG4gICAgU1FSVF9CQVNFID0gMWU3LFxyXG5cclxuICAgIC8vIEVESVRBQkxFXHJcbiAgICAvLyBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIERFQ0lNQUxfUExBQ0VTLCBUT19FWFBfTkVHLCBUT19FWFBfUE9TLCBNSU5fRVhQLCBNQVhfRVhQLCBhbmRcclxuICAgIC8vIHRoZSBhcmd1bWVudHMgdG8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQsIGFuZCB0b1ByZWNpc2lvbi5cclxuICAgIE1BWCA9IDFFOTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYX0lOVDMyXHJcblxyXG5cclxuICAvKlxyXG4gICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgQmlnTnVtYmVyIGNvbnN0cnVjdG9yLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNsb25lKGNvbmZpZ09iamVjdCkge1xyXG4gICAgdmFyIGRpdiwgY29udmVydEJhc2UsIHBhcnNlTnVtZXJpYyxcclxuICAgICAgUCA9IEJpZ051bWJlci5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBCaWdOdW1iZXIsIHRvU3RyaW5nOiBudWxsLCB2YWx1ZU9mOiBudWxsIH0sXHJcbiAgICAgIE9ORSA9IG5ldyBCaWdOdW1iZXIoMSksXHJcblxyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFRElUQUJMRSBDT05GSUcgREVGQVVMVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlcyBiZWxvdyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlcyBzdGF0ZWQuXHJcbiAgICAgIC8vIFRoZSB2YWx1ZXMgY2FuIGFsc28gYmUgY2hhbmdlZCBhdCBydW4tdGltZSB1c2luZyBCaWdOdW1iZXIuc2V0LlxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBvcGVyYXRpb25zIGludm9sdmluZyBkaXZpc2lvbi5cclxuICAgICAgREVDSU1BTF9QTEFDRVMgPSAyMCwgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIHJvdW5kaW5nIG1vZGUgdXNlZCB3aGVuIHJvdW5kaW5nIHRvIHRoZSBhYm92ZSBkZWNpbWFsIHBsYWNlcywgYW5kIHdoZW4gdXNpbmdcclxuICAgICAgLy8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQgYW5kIHRvUHJlY2lzaW9uLCBhbmQgcm91bmQgKGRlZmF1bHQgdmFsdWUpLlxyXG4gICAgICAvLyBVUCAgICAgICAgIDAgQXdheSBmcm9tIHplcm8uXHJcbiAgICAgIC8vIERPV04gICAgICAgMSBUb3dhcmRzIHplcm8uXHJcbiAgICAgIC8vIENFSUwgICAgICAgMiBUb3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gRkxPT1IgICAgICAzIFRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX1VQICAgIDQgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHVwLlxyXG4gICAgICAvLyBIQUxGX0RPV04gIDUgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIGRvd24uXHJcbiAgICAgIC8vIEhBTEZfRVZFTiAgNiBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyBldmVuIG5laWdoYm91ci5cclxuICAgICAgLy8gSEFMRl9DRUlMICA3IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9GTE9PUiA4IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgUk9VTkRJTkdfTU9ERSA9IDQsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDhcclxuXHJcbiAgICAgIC8vIEVYUE9ORU5USUFMX0FUIDogW1RPX0VYUF9ORUcgLCBUT19FWFBfUE9TXVxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtN1xyXG4gICAgICBUT19FWFBfTkVHID0gLTcsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gLU1BWFxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBhYm92ZSB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogMjFcclxuICAgICAgVE9fRVhQX1BPUyA9IDIxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gUkFOR0UgOiBbTUlOX0VYUCwgTUFYX0VYUF1cclxuXHJcbiAgICAgIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC0zMjQgICg1ZS0zMjQpXHJcbiAgICAgIE1JTl9FWFAgPSAtMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLTEgdG8gLU1BWFxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgdmFsdWUsIGFib3ZlIHdoaWNoIG92ZXJmbG93IHRvIEluZmluaXR5IG9jY3Vycy5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6ICAzMDggICgxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOClcclxuICAgICAgLy8gRm9yIE1BWF9FWFAgPiAxZTcsIGUuZy4gbmV3IEJpZ051bWJlcignMWUxMDAwMDAwMDAnKS5wbHVzKDEpIG1heSBiZSBzbG93LlxyXG4gICAgICBNQVhfRVhQID0gMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gTUFYXHJcblxyXG4gICAgICAvLyBXaGV0aGVyIHRvIHVzZSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uLCBpZiBhdmFpbGFibGUuXHJcbiAgICAgIENSWVBUTyA9IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZVxyXG5cclxuICAgICAgLy8gVGhlIG1vZHVsbyBtb2RlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgbW9kdWx1czogYSBtb2Qgbi5cclxuICAgICAgLy8gVGhlIHF1b3RpZW50IChxID0gYSAvIG4pIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgIC8vIFRoZSByZW1haW5kZXIgKHIpIGlzIGNhbGN1bGF0ZWQgYXM6IHIgPSBhIC0gbiAqIHEuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFVQICAgICAgICAwIFRoZSByZW1haW5kZXIgaXMgcG9zaXRpdmUgaWYgdGhlIGRpdmlkZW5kIGlzIG5lZ2F0aXZlLCBlbHNlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAvLyBET1dOICAgICAgMSBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpZGVuZC5cclxuICAgICAgLy8gICAgICAgICAgICAgVGhpcyBtb2R1bG8gbW9kZSBpcyBjb21tb25seSBrbm93biBhcyAndHJ1bmNhdGVkIGRpdmlzaW9uJyBhbmQgaXNcclxuICAgICAgLy8gICAgICAgICAgICAgZXF1aXZhbGVudCB0byAoYSAlIG4pIGluIEphdmFTY3JpcHQuXHJcbiAgICAgIC8vIEZMT09SICAgICAzIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlzb3IgKFB5dGhvbiAlKS5cclxuICAgICAgLy8gSEFMRl9FVkVOIDYgVGhpcyBtb2R1bG8gbW9kZSBpbXBsZW1lbnRzIHRoZSBJRUVFIDc1NCByZW1haW5kZXIgZnVuY3Rpb24uXHJcbiAgICAgIC8vIEVVQ0xJRCAgICA5IEV1Y2xpZGlhbiBkaXZpc2lvbi4gcSA9IHNpZ24obikgKiBmbG9vcihhIC8gYWJzKG4pKS5cclxuICAgICAgLy8gICAgICAgICAgICAgVGhlIHJlbWFpbmRlciBpcyBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFRoZSB0cnVuY2F0ZWQgZGl2aXNpb24sIGZsb29yZWQgZGl2aXNpb24sIEV1Y2xpZGlhbiBkaXZpc2lvbiBhbmQgSUVFRSA3NTQgcmVtYWluZGVyXHJcbiAgICAgIC8vIG1vZGVzIGFyZSBjb21tb25seSB1c2VkIGZvciB0aGUgbW9kdWx1cyBvcGVyYXRpb24uXHJcbiAgICAgIC8vIEFsdGhvdWdoIHRoZSBvdGhlciByb3VuZGluZyBtb2RlcyBjYW4gYWxzbyBiZSB1c2VkLCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cclxuICAgICAgTU9EVUxPX01PREUgPSAxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDlcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHJlc3VsdCBvZiB0aGUgZXhwb25lbnRpYXRlZEJ5IG9wZXJhdGlvbi5cclxuICAgICAgLy8gSWYgUE9XX1BSRUNJU0lPTiBpcyAwLCB0aGVyZSB3aWxsIGJlIHVubGltaXRlZCBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgIFBPV19QUkVDSVNJT04gPSAwLCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSBmb3JtYXQgc3BlY2lmaWNhdGlvbiB1c2VkIGJ5IHRoZSBCaWdOdW1iZXIucHJvdG90eXBlLnRvRm9ybWF0IG1ldGhvZC5cclxuICAgICAgRk9STUFUID0ge1xyXG4gICAgICAgIHByZWZpeDogJycsXHJcbiAgICAgICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAgICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAgICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgICAgc3VmZml4OiAnJ1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gVGhlIGFscGhhYmV0IHVzZWQgZm9yIGJhc2UgY29udmVyc2lvbi4gSXQgbXVzdCBiZSBhdCBsZWFzdCAyIGNoYXJhY3RlcnMgbG9uZywgd2l0aCBubyAnKycsXHJcbiAgICAgIC8vICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgIC8vICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfJ1xyXG4gICAgICBBTFBIQUJFVCA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLFxyXG4gICAgICBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMgPSB0cnVlO1xyXG5cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAvLyBDT05TVFJVQ1RPUlxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhlIEJpZ051bWJlciBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIEJpZ051bWJlciBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogdiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgICAqIFtiXSB7bnVtYmVyfSBUaGUgYmFzZSBvZiB2LiBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJpZ051bWJlcih2LCBiKSB7XHJcbiAgICAgIHZhciBhbHBoYWJldCwgYywgY2FzZUNoYW5nZWQsIGUsIGksIGlzTnVtLCBsZW4sIHN0cixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIC8vIEVuYWJsZSBjb25zdHJ1Y3RvciBjYWxsIHdpdGhvdXQgYG5ld2AuXHJcbiAgICAgIGlmICghKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpKSByZXR1cm4gbmV3IEJpZ051bWJlcih2LCBiKTtcclxuXHJcbiAgICAgIGlmIChiID09IG51bGwpIHtcclxuXHJcbiAgICAgICAgaWYgKHYgJiYgdi5faXNCaWdOdW1iZXIgPT09IHRydWUpIHtcclxuICAgICAgICAgIHgucyA9IHYucztcclxuXHJcbiAgICAgICAgICBpZiAoIXYuYyB8fCB2LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHYuZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeC5lID0gdi5lO1xyXG4gICAgICAgICAgICB4LmMgPSB2LmMuc2xpY2UoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpICYmIHYgKiAwID09IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBVc2UgYDEgLyBuYCB0byBoYW5kbGUgbWludXMgemVybyBhbHNvLlxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHYgPSAtdiwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGludGVnZXJzLCB3aGVyZSBuIDwgMjE0NzQ4MzY0OCAoMioqMzEpLlxyXG4gICAgICAgICAgaWYgKHYgPT09IH5+dikge1xyXG4gICAgICAgICAgICBmb3IgKGUgPSAwLCBpID0gdjsgaSA+PSAxMDsgaSAvPSAxMCwgZSsrKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgICAgICB4LmMgPSBbdl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBpZiAoIWlzTnVtZXJpYy50ZXN0KHN0ciA9IFN0cmluZyh2KSkpIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSk7XHJcblxyXG4gICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICAgICAgICBpZiAoKGkgPSBzdHIuc2VhcmNoKC9lL2kpKSA+IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXHJcbiAgICAgICAgICBpZiAoZSA8IDApIGUgPSBpO1xyXG4gICAgICAgICAgZSArPSArc3RyLnNsaWNlKGkgKyAxKTtcclxuICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgICAgIC8vIEludGVnZXIuXHJcbiAgICAgICAgICBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG5cclxuICAgICAgICAvLyBBbGxvdyBleHBvbmVudGlhbCBub3RhdGlvbiB0byBiZSB1c2VkIHdpdGggYmFzZSAxMCBhcmd1bWVudCwgd2hpbGVcclxuICAgICAgICAvLyBhbHNvIHJvdW5kaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFzIHdpdGggb3RoZXIgYmFzZXMuXHJcbiAgICAgICAgaWYgKGIgPT0gMTAgJiYgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzKSB7XHJcbiAgICAgICAgICB4ID0gbmV3IEJpZ051bWJlcih2KTtcclxuICAgICAgICAgIHJldHVybiByb3VuZCh4LCBERUNJTUFMX1BMQUNFUyArIHguZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG5cclxuICAgICAgICBpZiAoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykge1xyXG5cclxuICAgICAgICAgIC8vIEF2b2lkIHBvdGVudGlhbCBpbnRlcnByZXRhdGlvbiBvZiBJbmZpbml0eSBhbmQgTmFOIGFzIGJhc2UgNDQrIHZhbHVlcy5cclxuICAgICAgICAgIGlmICh2ICogMCAhPSAwKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0sIGIpO1xyXG5cclxuICAgICAgICAgIHgucyA9IDEgLyB2IDwgMCA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcgJiYgc3RyLnJlcGxhY2UoL14wXFwuMCp8XFwuLywgJycpLmxlbmd0aCA+IDE1KSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAodG9vTWFueURpZ2l0cyArIHYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWxwaGFiZXQgPSBBTFBIQUJFVC5zbGljZSgwLCBiKTtcclxuICAgICAgICBlID0gaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgc3RyIGlzIGEgdmFsaWQgYmFzZSBiIG51bWJlci5cclxuICAgICAgICAvLyBEb24ndCB1c2UgUmVnRXhwLCBzbyBhbHBoYWJldCBjYW4gY29udGFpbiBzcGVjaWFsIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgIGlmIChhbHBoYWJldC5pbmRleE9mKGMgPSBzdHIuY2hhckF0KGkpKSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKGMgPT0gJy4nKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmICcuJyBpcyBub3QgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXQgaGFzIG5vdCBiZSBmb3VuZCBiZWZvcmUuXHJcbiAgICAgICAgICAgICAgaWYgKGkgPiBlKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gbGVuO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjYXNlQ2hhbmdlZCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBBbGxvdyBlLmcuIGhleGFkZWNpbWFsICdGRicgYXMgd2VsbCBhcyAnZmYnLlxyXG4gICAgICAgICAgICAgIGlmIChzdHIgPT0gc3RyLnRvVXBwZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpKSB8fFxyXG4gICAgICAgICAgICAgICAgICBzdHIgPT0gc3RyLnRvTG93ZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWMoeCwgU3RyaW5nKHYpLCBpc051bSwgYik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcmV2ZW50IGxhdGVyIGNoZWNrIGZvciBsZW5ndGggb24gY29udmVydGVkIG51bWJlci5cclxuICAgICAgICBpc051bSA9IGZhbHNlO1xyXG4gICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHN0ciwgYiwgMTAsIHgucyk7XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgZWxzZSBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdCgtLWxlbikgPT09IDQ4Oyk7XHJcblxyXG4gICAgICBpZiAoc3RyID0gc3RyLnNsaWNlKGksICsrbGVuKSkge1xyXG4gICAgICAgIGxlbiAtPSBpO1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgIGlmIChpc051bSAmJiBCaWdOdW1iZXIuREVCVUcgJiZcclxuICAgICAgICAgIGxlbiA+IDE1ICYmICh2ID4gTUFYX1NBRkVfSU5URUdFUiB8fCB2ICE9PSBtYXRoZmxvb3IodikpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAodG9vTWFueURpZ2l0cyArICh4LnMgKiB2KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgICAgaWYgKChlID0gZSAtIGkgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgIHguYyA9IFtdO1xyXG5cclxuICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYXNlXHJcblxyXG4gICAgICAgICAgLy8gZSBpcyB0aGUgYmFzZSAxMCBleHBvbmVudC5cclxuICAgICAgICAgIC8vIGkgaXMgd2hlcmUgdG8gc2xpY2Ugc3RyIHRvIGdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgY29lZmZpY2llbnQgYXJyYXkuXHJcbiAgICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgaWYgKGUgPCAwKSBpICs9IExPR19CQVNFOyAgLy8gaSA8IDFcclxuXHJcbiAgICAgICAgICBpZiAoaSA8IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoaSkgeC5jLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjspIHtcclxuICAgICAgICAgICAgICB4LmMucHVzaCgrc3RyLnNsaWNlKGksIGkgKz0gTE9HX0JBU0UpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaSA9IExPR19CQVNFIC0gKHN0ciA9IHN0ci5zbGljZShpKSkubGVuZ3RoO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSAtPSBsZW47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB4LmMucHVzaCgrc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SIFBST1BFUlRJRVNcclxuXHJcblxyXG4gICAgQmlnTnVtYmVyLmNsb25lID0gY2xvbmU7XHJcblxyXG4gICAgQmlnTnVtYmVyLlJPVU5EX1VQID0gMDtcclxuICAgIEJpZ051bWJlci5ST1VORF9ET1dOID0gMTtcclxuICAgIEJpZ051bWJlci5ST1VORF9DRUlMID0gMjtcclxuICAgIEJpZ051bWJlci5ST1VORF9GTE9PUiA9IDM7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9VUCA9IDQ7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOID0gNTtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0VWRU4gPSA2O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfQ0VJTCA9IDc7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XHJcbiAgICBCaWdOdW1iZXIuRVVDTElEID0gOTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIENvbmZpZ3VyZSBpbmZyZXF1ZW50bHktY2hhbmdpbmcgbGlicmFyeS13aWRlIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEFjY2VwdCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbmFsIHByb3BlcnRpZXMgKGlmIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGlzXHJcbiAgICAgKiBhIG51bWJlciwgaXQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIHN0YXRlZCk6XHJcbiAgICAgKlxyXG4gICAgICogICBERUNJTUFMX1BMQUNFUyAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBST1VORElOR19NT0RFICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDhcclxuICAgICAqICAgRVhQT05FTlRJQUxfQVQgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggIG9yICBbLU1BWCB0byAwLCAwIHRvIE1BWF1cclxuICAgICAqICAgUkFOR0UgICAgICAgICAgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggKG5vdCB6ZXJvKSAgb3IgIFstTUFYIHRvIC0xLCAxIHRvIE1BWF1cclxuICAgICAqICAgQ1JZUFRPICAgICAgICAgICB7Ym9vbGVhbn0gICAgICAgICAgdHJ1ZSBvciBmYWxzZVxyXG4gICAgICogICBNT0RVTE9fTU9ERSAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDlcclxuICAgICAqICAgUE9XX1BSRUNJU0lPTiAgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgQUxQSEFCRVQgICAgICAgICB7c3RyaW5nfSAgICAgICAgICAgQSBzdHJpbmcgb2YgdHdvIG9yIG1vcmUgdW5pcXVlIGNoYXJhY3RlcnMgd2hpY2ggZG9lc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgY29udGFpbiAnLicuXHJcbiAgICAgKiAgIEZPUk1BVCAgICAgICAgICAge29iamVjdH0gICAgICAgICAgIEFuIG9iamVjdCB3aXRoIHNvbWUgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICogICAgIHByZWZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBncm91cFNpemUgICAgICAgICAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgc2Vjb25kYXJ5R3JvdXBTaXplICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGdyb3VwU2VwYXJhdG9yICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBkZWNpbWFsU2VwYXJhdG9yICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNpemUgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3Ige3N0cmluZ31cclxuICAgICAqICAgICBzdWZmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKlxyXG4gICAgICogKFRoZSB2YWx1ZXMgYXNzaWduZWQgdG8gdGhlIGFib3ZlIEZPUk1BVCBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90IGNoZWNrZWQgZm9yIHZhbGlkaXR5LilcclxuICAgICAqXHJcbiAgICAgKiBFLmcuXHJcbiAgICAgKiBCaWdOdW1iZXIuY29uZmlnKHsgREVDSU1BTF9QTEFDRVMgOiAyMCwgUk9VTkRJTkdfTU9ERSA6IDQgfSlcclxuICAgICAqXHJcbiAgICAgKiBJZ25vcmUgcHJvcGVydGllcy9wYXJhbWV0ZXJzIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZCwgZXhjZXB0IGZvciBBTFBIQUJFVC5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgY3VycmVudCB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5jb25maWcgPSBCaWdOdW1iZXIuc2V0ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICB2YXIgcCwgdjtcclxuXHJcbiAgICAgIGlmIChvYmogIT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICAgIC8vIERFQ0lNQUxfUExBQ0VTIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBERUNJTUFMX1BMQUNFUyB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnREVDSU1BTF9QTEFDRVMnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUk9VTkRJTkdfTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJPVU5ESU5HX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JPVU5ESU5HX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA4LCBwKTtcclxuICAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRVhQT05FTlRJQUxfQVQge251bWJlcnxudW1iZXJbXX1cclxuICAgICAgICAgIC8vIEludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAwIGluY2x1c2l2ZSwgMCB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBFWFBPTkVOVElBTF9BVCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRVhQT05FTlRJQUxfQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIDAsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IHZbMF07XHJcbiAgICAgICAgICAgICAgVE9fRVhQX1BPUyA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gLShUT19FWFBfUE9TID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUkFOR0Uge251bWJlcnxudW1iZXJbXX0gTm9uLXplcm8gaW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIC0xIGluY2x1c2l2ZSwgaW50ZWdlciAxIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJBTkdFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZXxjYW5ub3QgYmUgemVyb306IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdSQU5HRScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgLTEsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDEsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgTUlOX0VYUCA9IHZbMF07XHJcbiAgICAgICAgICAgICAgTUFYX0VYUCA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgTUlOX0VYUCA9IC0oTUFYX0VYUCA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBjYW5ub3QgYmUgemVybzogJyArIHYpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENSWVBUTyB7Ym9vbGVhbn0gdHJ1ZSBvciBmYWxzZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBDUllQVE8gbm90IHRydWUgb3IgZmFsc2U6IHt2fSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQ1JZUFRPJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgPT09ICEhdikge1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8gJiZcclxuICAgICAgICAgICAgICAgICAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB8fCBjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSAhdjtcclxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IHRydWUgb3IgZmFsc2U6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE1PRFVMT19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOSBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTU9EVUxPX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ01PRFVMT19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOSwgcCk7XHJcbiAgICAgICAgICAgIE1PRFVMT19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBQT1dfUFJFQ0lTSU9OIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBQT1dfUFJFQ0lTSU9OIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdQT1dfUFJFQ0lTSU9OJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRk9STUFUIHtvYmplY3R9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRk9STUFUIG5vdCBhbiBvYmplY3Q6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdGT1JNQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ29iamVjdCcpIEZPUk1BVCA9IHY7XHJcbiAgICAgICAgICAgIGVsc2UgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCBhbiBvYmplY3Q6ICcgKyB2KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBBTFBIQUJFVCB7c3RyaW5nfVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEFMUEhBQkVUIGludmFsaWQ6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdBTFBIQUJFVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcblxyXG4gICAgICAgICAgICAvLyBEaXNhbGxvdyBpZiBsZXNzIHRoYW4gdHdvIGNoYXJhY3RlcnMsXHJcbiAgICAgICAgICAgIC8vIG9yIGlmIGl0IGNvbnRhaW5zICcrJywgJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIGEgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ3N0cmluZycgJiYgIS9eLj8kfFsrXFwtLlxcc118KC4pLipcXDEvLnRlc3QodikpIHtcclxuICAgICAgICAgICAgICBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMgPSB2LnNsaWNlKDAsIDEwKSA9PSAnMDEyMzQ1Njc4OSc7XHJcbiAgICAgICAgICAgICAgQUxQSEFCRVQgPSB2O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGludmFsaWQ6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBPYmplY3QgZXhwZWN0ZWQ6IHt2fSdcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ09iamVjdCBleHBlY3RlZDogJyArIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIERFQ0lNQUxfUExBQ0VTOiBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICBST1VORElOR19NT0RFOiBST1VORElOR19NT0RFLFxyXG4gICAgICAgIEVYUE9ORU5USUFMX0FUOiBbVE9fRVhQX05FRywgVE9fRVhQX1BPU10sXHJcbiAgICAgICAgUkFOR0U6IFtNSU5fRVhQLCBNQVhfRVhQXSxcclxuICAgICAgICBDUllQVE86IENSWVBUTyxcclxuICAgICAgICBNT0RVTE9fTU9ERTogTU9EVUxPX01PREUsXHJcbiAgICAgICAgUE9XX1BSRUNJU0lPTjogUE9XX1BSRUNJU0lPTixcclxuICAgICAgICBGT1JNQVQ6IEZPUk1BVCxcclxuICAgICAgICBBTFBIQUJFVDogQUxQSEFCRVRcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB2IGlzIGEgQmlnTnVtYmVyIGluc3RhbmNlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqIElmIEJpZ051bWJlci5ERUJVRyBpcyB0cnVlLCB0aHJvdyBpZiBhIEJpZ051bWJlciBpbnN0YW5jZSBpcyBub3Qgd2VsbC1mb3JtZWQuXHJcbiAgICAgKlxyXG4gICAgICogdiB7YW55fVxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBJbnZhbGlkIEJpZ051bWJlcjoge3Z9J1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuaXNCaWdOdW1iZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICBpZiAoIXYgfHwgdi5faXNCaWdOdW1iZXIgIT09IHRydWUpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKCFCaWdOdW1iZXIuREVCVUcpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgdmFyIGksIG4sXHJcbiAgICAgICAgYyA9IHYuYyxcclxuICAgICAgICBlID0gdi5lLFxyXG4gICAgICAgIHMgPSB2LnM7XHJcblxyXG4gICAgICBvdXQ6IGlmICh7fS50b1N0cmluZy5jYWxsKGMpID09ICdbb2JqZWN0IEFycmF5XScpIHtcclxuXHJcbiAgICAgICAgaWYgKChzID09PSAxIHx8IHMgPT09IC0xKSAmJiBlID49IC1NQVggJiYgZSA8PSBNQVggJiYgZSA9PT0gbWF0aGZsb29yKGUpKSB7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGVsZW1lbnQgaXMgemVybywgdGhlIEJpZ051bWJlciB2YWx1ZSBtdXN0IGJlIHplcm8uXHJcbiAgICAgICAgICBpZiAoY1swXSA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoZSA9PT0gMCAmJiBjLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyB0aGF0IGNbMF0gc2hvdWxkIGhhdmUsIGJhc2VkIG9uIHRoZSBleHBvbmVudC5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoaSA8IDEpIGkgKz0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgICAgIC8vaWYgKE1hdGguY2VpbChNYXRoLmxvZyhjWzBdICsgMSkgLyBNYXRoLkxOMTApID09IGkpIHtcclxuICAgICAgICAgIGlmIChTdHJpbmcoY1swXSkubGVuZ3RoID09IGkpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgbiA9IGNbaV07XHJcbiAgICAgICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gQkFTRSB8fCBuICE9PSBtYXRoZmxvb3IobikpIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTGFzdCBlbGVtZW50IGNhbm5vdCBiZSB6ZXJvLCB1bmxlc3MgaXQgaXMgdGhlIG9ubHkgZWxlbWVudC5cclxuICAgICAgICAgICAgaWYgKG4gIT09IDApIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluZmluaXR5L05hTlxyXG4gICAgICB9IGVsc2UgaWYgKGMgPT09IG51bGwgJiYgZSA9PT0gbnVsbCAmJiAocyA9PT0gbnVsbCB8fCBzID09PSAxIHx8IHMgPT09IC0xKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgIChiaWdudW1iZXJFcnJvciArICdJbnZhbGlkIEJpZ051bWJlcjogJyArIHYpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWF4aW11bSA9IEJpZ051bWJlci5tYXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAubHQpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1pbmltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWluaW11bSA9IEJpZ051bWJlci5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAuZ3QpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2l0aCBhIHJhbmRvbSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDEsXHJcbiAgICAgKiBhbmQgd2l0aCBkcCwgb3IgREVDSU1BTF9QTEFDRVMgaWYgZHAgaXMgb21pdHRlZCwgZGVjaW1hbCBwbGFjZXMgKG9yIGxlc3MgaWYgdHJhaWxpbmdcclxuICAgICAqIHplcm9zIGFyZSBwcm9kdWNlZCkuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB9J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnJhbmRvbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBwb3cyXzUzID0gMHgyMDAwMDAwMDAwMDAwMDtcclxuXHJcbiAgICAgIC8vIFJldHVybiBhIDUzIGJpdCBpbnRlZ2VyIG4sIHdoZXJlIDAgPD0gbiA8IDkwMDcxOTkyNTQ3NDA5OTIuXHJcbiAgICAgIC8vIENoZWNrIGlmIE1hdGgucmFuZG9tKCkgcHJvZHVjZXMgbW9yZSB0aGFuIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cclxuICAgICAgLy8gSWYgaXQgZG9lcywgYXNzdW1lIGF0IGxlYXN0IDUzIGJpdHMgYXJlIHByb2R1Y2VkLCBvdGhlcndpc2UgYXNzdW1lIGF0IGxlYXN0IDMwIGJpdHMuXHJcbiAgICAgIC8vIDB4NDAwMDAwMDAgaXMgMl4zMCwgMHg4MDAwMDAgaXMgMl4yMywgMHgxZmZmZmYgaXMgMl4yMSAtIDEuXHJcbiAgICAgIHZhciByYW5kb201M2JpdEludCA9IChNYXRoLnJhbmRvbSgpICogcG93Ml81MykgJiAweDFmZmZmZlxyXG4gICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpOyB9XHJcbiAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgoTWF0aC5yYW5kb20oKSAqIDB4NDAwMDAwMDAgfCAwKSAqIDB4ODAwMDAwKSArXHJcbiAgICAgICAgIChNYXRoLnJhbmRvbSgpICogMHg4MDAwMDAgfCAwKTsgfTtcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZHApIHtcclxuICAgICAgICB2YXIgYSwgYiwgZSwgaywgdixcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgYyA9IFtdLFxyXG4gICAgICAgICAgcmFuZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgICAgaWYgKGRwID09IG51bGwpIGRwID0gREVDSU1BTF9QTEFDRVM7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKGRwIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICBpZiAoQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc3VwcG9ydGluZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLlxyXG4gICAgICAgICAgaWYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrICo9IDIpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gNTMgYml0czpcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpICogTWF0aC5wb3coMiwgMjEpKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwXHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSA+Pj4gMTEpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAweDIwMDAwIGlzIDJeMjEuXHJcbiAgICAgICAgICAgICAgdiA9IGFbaV0gKiAweDIwMDAwICsgKGFbaSArIDFdID4+PiAxMSk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFJlamVjdGlvbiBzYW1wbGluZzpcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgLy8gUHJvYmFiaWxpdHkgdGhhdCB2ID49IDllMTUsIGlzXHJcbiAgICAgICAgICAgICAgLy8gNzE5OTI1NDc0MDk5MiAvIDkwMDcxOTkyNTQ3NDA5OTIgfj0gMC4wMDA4LCBpLmUuIDEgaW4gMTI1MVxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgyKSk7XHJcbiAgICAgICAgICAgICAgICBhW2ldID0gYlswXTtcclxuICAgICAgICAgICAgICAgIGFbaSArIDFdID0gYlsxXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8PSA4OTk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gICAgICAgICAgfSBlbHNlIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJ1ZmZlclxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwMDAwMCBpcyAyXjQ4LCAweDEwMDAwMDAwMDAwIGlzIDJeNDBcclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMCBpcyAyXjMyLCAweDEwMDAwMDAgaXMgMl4yNFxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIHYgPSAoKGFbaV0gJiAzMSkgKiAweDEwMDAwMDAwMDAwMDApICsgKGFbaSArIDFdICogMHgxMDAwMDAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyAyXSAqIDB4MTAwMDAwMDAwKSArIChhW2kgKyAzXSAqIDB4MTAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyA0XSA8PCAxNikgKyAoYVtpICsgNV0gPDwgOCkgKyBhW2kgKyA2XTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgY3J5cHRvLnJhbmRvbUJ5dGVzKDcpLmNvcHkoYSwgaSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDc7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gNztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIENSWVBUTyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXNlIE1hdGgucmFuZG9tLlxyXG4gICAgICAgIGlmICghQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG4gICAgICAgICAgICB2ID0gcmFuZG9tNTNiaXRJbnQoKTtcclxuICAgICAgICAgICAgaWYgKHYgPCA5ZTE1KSBjW2krK10gPSB2ICUgMWUxNDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGsgPSBjWy0taV07XHJcbiAgICAgICAgZHAgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdHJhaWxpbmcgZGlnaXRzIHRvIHplcm9zIGFjY29yZGluZyB0byBkcC5cclxuICAgICAgICBpZiAoayAmJiBkcCkge1xyXG4gICAgICAgICAgdiA9IFBPV1NfVEVOW0xPR19CQVNFIC0gZHBdO1xyXG4gICAgICAgICAgY1tpXSA9IG1hdGhmbG9vcihrIC8gdikgKiB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGZvciAoOyBjW2ldID09PSAwOyBjLnBvcCgpLCBpLS0pO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgYyA9IFtlID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgZm9yIChlID0gLTEgOyBjWzBdID09PSAwOyBjLnNwbGljZSgwLCAxKSwgZSAtPSBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgLy8gQ291bnQgdGhlIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiBjIHRvIGRldGVybWluZSBsZWFkaW5nIHplcm9zLCBhbmQuLi5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIC8vIGFkanVzdCB0aGUgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBpZiAoaSA8IExPR19CQVNFKSBlIC09IExPR19CQVNFIC0gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJhbmQuZSA9IGU7XHJcbiAgICAgICAgcmFuZC5jID0gYztcclxuICAgICAgICByZXR1cm4gcmFuZDtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHN1bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5zdW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxyXG4gICAgICAgIHN1bSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7KSBzdW0gPSBzdW0ucGx1cyhhcmdzW2krK10pO1xyXG4gICAgICByZXR1cm4gc3VtO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLy8gUFJJVkFURSBGVU5DVElPTlNcclxuXHJcblxyXG4gICAgLy8gQ2FsbGVkIGJ5IEJpZ051bWJlciBhbmQgQmlnTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZy5cclxuICAgIGNvbnZlcnRCYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGRlY2ltYWwgPSAnMDEyMzQ1Njc4OSc7XHJcblxyXG4gICAgICAvKlxyXG4gICAgICAgKiBDb252ZXJ0IHN0cmluZyBvZiBiYXNlSW4gdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBiYXNlT3V0LlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJ2ZmJywgMTYsIDEwKSByZXR1cm5zIFsyLCA1LCA1XS5cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgYWxwaGFiZXQpIHtcclxuICAgICAgICB2YXIgaixcclxuICAgICAgICAgIGFyciA9IFswXSxcclxuICAgICAgICAgIGFyckwsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgZm9yIChhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOyBhcnJbYXJyTF0gKj0gYmFzZUluKTtcclxuXHJcbiAgICAgICAgICBhcnJbMF0gKz0gYWxwaGFiZXQuaW5kZXhPZihzdHIuY2hhckF0KGkrKykpO1xyXG5cclxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPiBiYXNlT3V0IC0gMSkge1xyXG4gICAgICAgICAgICAgIGlmIChhcnJbaiArIDFdID09IG51bGwpIGFycltqICsgMV0gPSAwO1xyXG4gICAgICAgICAgICAgIGFycltqICsgMV0gKz0gYXJyW2pdIC8gYmFzZU91dCB8IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2pdICU9IGJhc2VPdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnIucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZUluIHRvIGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyB0b1N0cmluZywgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlIDEwIHRvIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgQmlnTnVtYmVyLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2VJbiB0byBiYXNlIDEwLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0ciwgYmFzZUluLCBiYXNlT3V0LCBzaWduLCBjYWxsZXJJc1RvU3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIGFscGhhYmV0LCBkLCBlLCBrLCByLCB4LCB4YywgeSxcclxuICAgICAgICAgIGkgPSBzdHIuaW5kZXhPZignLicpLFxyXG4gICAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICAgIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuXHJcbiAgICAgICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICAgICAgaWYgKGkgPj0gMCkge1xyXG4gICAgICAgICAgayA9IFBPV19QUkVDSVNJT047XHJcblxyXG4gICAgICAgICAgLy8gVW5saW1pdGVkIHByZWNpc2lvbi5cclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSAwO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihiYXNlSW4pO1xyXG4gICAgICAgICAgeCA9IHkucG93KHN0ci5sZW5ndGggLSBpKTtcclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSBrO1xyXG5cclxuICAgICAgICAgIC8vIENvbnZlcnQgc3RyIGFzIGlmIGFuIGludGVnZXIsIHRoZW4gcmVzdG9yZSB0aGUgZnJhY3Rpb24gcGFydCBieSBkaXZpZGluZyB0aGVcclxuICAgICAgICAgIC8vIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlci5cclxuXHJcbiAgICAgICAgICB5LmMgPSB0b0Jhc2VPdXQodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcoeC5jKSwgeC5lLCAnMCcpLFxyXG4gICAgICAgICAgIDEwLCBiYXNlT3V0LCBkZWNpbWFsKTtcclxuICAgICAgICAgIHkuZSA9IHkuYy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgaW50ZWdlci5cclxuXHJcbiAgICAgICAgeGMgPSB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGNhbGxlcklzVG9TdHJpbmdcclxuICAgICAgICAgPyAoYWxwaGFiZXQgPSBBTFBIQUJFVCwgZGVjaW1hbClcclxuICAgICAgICAgOiAoYWxwaGFiZXQgPSBkZWNpbWFsLCBBTFBIQUJFVCkpO1xyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgYXMgYW4gaW50ZWdlciBhbmQgY29udmVydGVkIHRvIGJhc2VPdXQuIGUgaXMgdGhlIGV4cG9uZW50LlxyXG4gICAgICAgIGUgPSBrID0geGMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7IHhjWy0ta10gPT0gMDsgeGMucG9wKCkpO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0pIHJldHVybiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcblxyXG4gICAgICAgIC8vIERvZXMgc3RyIHJlcHJlc2VudCBhbiBpbnRlZ2VyPyBJZiBzbywgbm8gbmVlZCBmb3IgdGhlIGRpdmlzaW9uLlxyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgLS1lO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmMgPSB4YztcclxuICAgICAgICAgIHguZSA9IGU7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIHNpZ24gaXMgbmVlZGVkIGZvciBjb3JyZWN0IHJvdW5kaW5nLlxyXG4gICAgICAgICAgeC5zID0gc2lnbjtcclxuICAgICAgICAgIHggPSBkaXYoeCwgeSwgZHAsIHJtLCBiYXNlT3V0KTtcclxuICAgICAgICAgIHhjID0geC5jO1xyXG4gICAgICAgICAgciA9IHgucjtcclxuICAgICAgICAgIGUgPSB4LmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgY29udmVydGVkIHRvIGJhc2VPdXQuXHJcblxyXG4gICAgICAgIC8vIFRIZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgZCA9IGUgKyBkcCArIDE7XHJcblxyXG4gICAgICAgIC8vIFRoZSByb3VuZGluZyBkaWdpdDogdGhlIGRpZ2l0IHRvIHRoZSByaWdodCBvZiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICBpID0geGNbZF07XHJcblxyXG4gICAgICAgIC8vIExvb2sgYXQgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhbmQgbW9kZSB0byBkZXRlcm1pbmUgd2hldGhlciB0byByb3VuZCB1cC5cclxuXHJcbiAgICAgICAgayA9IGJhc2VPdXQgLyAyO1xyXG4gICAgICAgIHIgPSByIHx8IGQgPCAwIHx8IHhjW2QgKyAxXSAhPSBudWxsO1xyXG5cclxuICAgICAgICByID0gcm0gPCA0ID8gKGkgIT0gbnVsbCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICAgICA6IGkgPiBrIHx8IGkgPT0gayAmJihybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJiB4Y1tkIC0gMV0gJiAxIHx8XHJcbiAgICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBub3QgZ3JlYXRlciB0aGFuIHplcm8sIG9yIHhjIHJlcHJlc2VudHNcclxuICAgICAgICAvLyB6ZXJvLCB0aGVuIHRoZSByZXN1bHQgb2YgdGhlIGJhc2UgY29udmVyc2lvbiBpcyB6ZXJvIG9yLCBpZiByb3VuZGluZyB1cCwgYSB2YWx1ZVxyXG4gICAgICAgIC8vIHN1Y2ggYXMgMC4wMDAwMS5cclxuICAgICAgICBpZiAoZCA8IDEgfHwgIXhjWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gMV4tZHAgb3IgMFxyXG4gICAgICAgICAgc3RyID0gciA/IHRvRml4ZWRQb2ludChhbHBoYWJldC5jaGFyQXQoMSksIC1kcCwgYWxwaGFiZXQuY2hhckF0KDApKSA6IGFscGhhYmV0LmNoYXJBdCgwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFRydW5jYXRlIHhjIHRvIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSBkO1xyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cCBhbmQgc28gb24uXHJcbiAgICAgICAgICAgIGZvciAoLS1iYXNlT3V0OyArK3hjWy0tZF0gPiBiYXNlT3V0Oykge1xyXG4gICAgICAgICAgICAgIHhjW2RdID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKCFkKSB7XHJcbiAgICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgICAgICB4YyA9IFsxXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoayA9IHhjLmxlbmd0aDsgIXhjWy0ta107KTtcclxuXHJcbiAgICAgICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICAgICAgZm9yIChpID0gMCwgc3RyID0gJyc7IGkgPD0gazsgc3RyICs9IGFscGhhYmV0LmNoYXJBdCh4Y1tpKytdKSk7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVyb3MsIGRlY2ltYWwgcG9pbnQgYW5kIHRyYWlsaW5nIHplcm9zIGFzIHJlcXVpcmVkLlxyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgYWxwaGFiZXQuY2hhckF0KDApKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBjYWxsZXIgd2lsbCBhZGQgdGhlIHNpZ24uXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8vIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLiBDYWxsZWQgYnkgZGl2IGFuZCBjb252ZXJ0QmFzZS5cclxuICAgIGRpdiA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAvLyBBc3N1bWUgbm9uLXplcm8geCBhbmQgay5cclxuICAgICAgZnVuY3Rpb24gbXVsdGlwbHkoeCwgaywgYmFzZSkge1xyXG4gICAgICAgIHZhciBtLCB0ZW1wLCB4bG8sIHhoaSxcclxuICAgICAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgICAgIGkgPSB4Lmxlbmd0aCxcclxuICAgICAgICAgIGtsbyA9IGsgJSBTUVJUX0JBU0UsXHJcbiAgICAgICAgICBraGkgPSBrIC8gU1FSVF9CQVNFIHwgMDtcclxuXHJcbiAgICAgICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07KSB7XHJcbiAgICAgICAgICB4bG8gPSB4W2ldICUgU1FSVF9CQVNFO1xyXG4gICAgICAgICAgeGhpID0geFtpXSAvIFNRUlRfQkFTRSB8IDA7XHJcbiAgICAgICAgICBtID0ga2hpICogeGxvICsgeGhpICoga2xvO1xyXG4gICAgICAgICAgdGVtcCA9IGtsbyAqIHhsbyArICgobSAlIFNRUlRfQkFTRSkgKiBTUVJUX0JBU0UpICsgY2Fycnk7XHJcbiAgICAgICAgICBjYXJyeSA9ICh0ZW1wIC8gYmFzZSB8IDApICsgKG0gLyBTUVJUX0JBU0UgfCAwKSArIGtoaSAqIHhoaTtcclxuICAgICAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjYXJyeSkgeCA9IFtjYXJyeV0uY29uY2F0KHgpO1xyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY29tcGFyZShhLCBiLCBhTCwgYkwpIHtcclxuICAgICAgICB2YXIgaSwgY21wO1xyXG5cclxuICAgICAgICBpZiAoYUwgIT0gYkwpIHtcclxuICAgICAgICAgIGNtcCA9IGFMID4gYkwgPyAxIDogLTE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBmb3IgKGkgPSBjbXAgPSAwOyBpIDwgYUw7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xyXG4gICAgICAgICAgICAgIGNtcCA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBhTCwgYmFzZSkge1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICAgICAgZm9yICg7IGFMLS07KSB7XHJcbiAgICAgICAgICBhW2FMXSAtPSBpO1xyXG4gICAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTsgYS5zcGxpY2UoMCwgMSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4OiBkaXZpZGVuZCwgeTogZGl2aXNvci5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5LCBkcCwgcm0sIGJhc2UpIHtcclxuICAgICAgICB2YXIgY21wLCBlLCBpLCBtb3JlLCBuLCBwcm9kLCBwcm9kTCwgcSwgcWMsIHJlbSwgcmVtTCwgcmVtMCwgeGksIHhMLCB5YzAsXHJcbiAgICAgICAgICB5TCwgeXosXHJcbiAgICAgICAgICBzID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBOYU4sIEluZmluaXR5IG9yIDA/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheGNbMF0gfHwgIXljIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKFxyXG5cclxuICAgICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBOYU4sIG9yIGJvdGggSW5maW5pdHkgb3IgMC5cclxuICAgICAgICAgICAheC5zIHx8ICF5LnMgfHwgKHhjID8geWMgJiYgeGNbMF0gPT0geWNbMF0gOiAheWMpID8gTmFOIDpcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyDCsTAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIMKxMC5cclxuICAgICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcclxuICAgICAgICBxYyA9IHEuYyA9IFtdO1xyXG4gICAgICAgIGUgPSB4LmUgLSB5LmU7XHJcbiAgICAgICAgcyA9IGRwICsgZSArIDE7XHJcblxyXG4gICAgICAgIGlmICghYmFzZSkge1xyXG4gICAgICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpIC0gYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICAgICAgcyA9IHMgLyBMT0dfQkFTRSB8IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgZS5cclxuICAgICAgICAvLyBUaGUgY29lZmZpY2llbnRzIG9mIHRoZSBCaWdOdW1iZXJzIGZyb20gY29udmVydEJhc2UgbWF5IGhhdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yIChpID0gMDsgeWNbaV0gPT0gKHhjW2ldIHx8IDApOyBpKyspO1xyXG5cclxuICAgICAgICBpZiAoeWNbaV0gPiAoeGNbaV0gfHwgMCkpIGUtLTtcclxuXHJcbiAgICAgICAgaWYgKHMgPCAwKSB7XHJcbiAgICAgICAgICBxYy5wdXNoKDEpO1xyXG4gICAgICAgICAgbW9yZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgIHMgKz0gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb3JtYWxpc2UgeGMgYW5kIHljIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWMgaXMgPj0gYmFzZSAvIDIuXHJcblxyXG4gICAgICAgICAgbiA9IG1hdGhmbG9vcihiYXNlIC8gKHljWzBdICsgMSkpO1xyXG5cclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBoYW5kbGUgb2RkIGJhc2VzIHdoZXJlIHljWzBdID09IChiYXNlIC8gMikgLSAxLlxyXG4gICAgICAgICAgLy8gaWYgKG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIpIHtcclxuICAgICAgICAgIGlmIChuID4gMSkge1xyXG4gICAgICAgICAgICB5YyA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeGMgPSBtdWx0aXBseSh4YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB4aSA9IHlMO1xyXG4gICAgICAgICAgcmVtID0geGMuc2xpY2UoMCwgeUwpO1xyXG4gICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICAgICAgICAgIGZvciAoOyByZW1MIDwgeUw7IHJlbVtyZW1MKytdID0gMCk7XHJcbiAgICAgICAgICB5eiA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICB5eiA9IFswXS5jb25jYXQoeXopO1xyXG4gICAgICAgICAgeWMwID0geWNbMF07XHJcbiAgICAgICAgICBpZiAoeWNbMV0gPj0gYmFzZSAvIDIpIHljMCsrO1xyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIHByZXZlbnQgdHJpYWwgZGlnaXQgbiA+IGJhc2UsIHdoZW4gdXNpbmcgYmFzZSAzLlxyXG4gICAgICAgICAgLy8gZWxzZSBpZiAoYmFzZSA9PSAzICYmIHljMCA9PSAxKSB5YzAgPSAxICsgMWUtMTU7XHJcblxyXG4gICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBuID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBjbXAgPSBjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgbi5cclxuXHJcbiAgICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcclxuICAgICAgICAgICAgICBpZiAoeUwgIT0gcmVtTCkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIG4gPSBtYXRoZmxvb3IocmVtMCAvIHljMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgICAgLy8gIHByb2R1Y3QgPSBkaXZpc29yIG11bHRpcGxpZWQgYnkgdHJpYWwgZGlnaXQgKG4pLlxyXG4gICAgICAgICAgICAgIC8vICBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCBpcyBncmVhdGVyIHRoYW4gcmVtYWluZGVyOlxyXG4gICAgICAgICAgICAgIC8vICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LCBkZWNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgLy8gIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3Qgd2FzIGxlc3MgdGhhbiByZW1haW5kZXIgYXQgdGhlIGxhc3QgY29tcGFyZTpcclxuICAgICAgICAgICAgICAvLyAgICBDb21wYXJlIG5ldyByZW1haW5kZXIgYW5kIGRpdmlzb3IuXHJcbiAgICAgICAgICAgICAgLy8gICAgSWYgcmVtYWluZGVyIGlzIGdyZWF0ZXIgdGhhbiBkaXZpc29yOlxyXG4gICAgICAgICAgICAgIC8vICAgICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlciwgaW5jcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG5cclxuICAgICAgICAgICAgICBpZiAobiA+IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIG1heSBiZSA+IGJhc2Ugb25seSB3aGVuIGJhc2UgaXMgMy5cclxuICAgICAgICAgICAgICAgIGlmIChuID49IGJhc2UpIG4gPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3QgPiByZW1haW5kZXIgdGhlbiB0cmlhbCBkaWdpdCBuIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBoaWdoIGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgaXMgbm90IGtub3duIHRvIGhhdmVcclxuICAgICAgICAgICAgICAgIC8vIGV2ZXIgYmVlbiBtb3JlIHRoYW4gMSB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbi0tO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHljLCBwcm9kTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDAgb3IgMSwgY21wIGlzIC0xLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbXBhcmUgeWMgYW5kIHJlbSBhZ2FpbiBiZWxvdyxcclxuICAgICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMSwgbGVhdmUgY21wIGFzIC0xLCBzbyB5YyBhbmQgcmVtIGFyZSBjb21wYXJlZCBhZ2Fpbi5cclxuICAgICAgICAgICAgICAgIGlmIChuID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIGRpdmlzb3IgPCByZW1haW5kZXIsIHNvIG4gbXVzdCBiZSBhdCBsZWFzdCAxLlxyXG4gICAgICAgICAgICAgICAgICBjbXAgPSBuID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKHByb2RMIDwgcmVtTCkgcHJvZCA9IFswXS5jb25jYXQocHJvZCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIG5ldyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgbmV3IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIFRyaWFsIGRpZ2l0IG4gdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gbG93IGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgdmVyeSByYXJlbHkgMiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICBuKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHlMIDwgcmVtTCA/IHl6IDogeWMsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgbisrO1xyXG4gICAgICAgICAgICAgIHJlbSA9IFswXTtcclxuICAgICAgICAgICAgfSAvLyBlbHNlIGNtcCA9PT0gMSBhbmQgbiB3aWxsIGJlIDBcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV4dCBkaWdpdCwgbiwgdG8gdGhlIHJlc3VsdCBhcnJheS5cclxuICAgICAgICAgICAgcWNbaSsrXSA9IG47XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKHJlbVswXSkge1xyXG4gICAgICAgICAgICAgIHJlbVtyZW1MKytdID0geGNbeGldIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVtID0gW3hjW3hpXV07XHJcbiAgICAgICAgICAgICAgcmVtTCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gd2hpbGUgKCh4aSsrIDwgeEwgfHwgcmVtWzBdICE9IG51bGwpICYmIHMtLSk7XHJcblxyXG4gICAgICAgICAgbW9yZSA9IHJlbVswXSAhPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICAgIGlmICghcWNbMF0pIHFjLnNwbGljZSgwLCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChiYXNlID09IEJBU0UpIHtcclxuXHJcbiAgICAgICAgICAvLyBUbyBjYWxjdWxhdGUgcS5lLCBmaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgcWNbMF0uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCBzID0gcWNbMF07IHMgPj0gMTA7IHMgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgcm91bmQocSwgZHAgKyAocS5lID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpICsgMSwgcm0sIG1vcmUpO1xyXG5cclxuICAgICAgICAvLyBDYWxsZXIgaXMgY29udmVydEJhc2UuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHEuZSA9IGU7XHJcbiAgICAgICAgICBxLnIgPSArbW9yZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBxO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIEJpZ051bWJlciBuIGluIGZpeGVkLXBvaW50IG9yIGV4cG9uZW50aWFsXHJcbiAgICAgKiBub3RhdGlvbiByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXMgb3Igc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICpcclxuICAgICAqIG46IGEgQmlnTnVtYmVyLlxyXG4gICAgICogaTogdGhlIGluZGV4IG9mIHRoZSBsYXN0IGRpZ2l0IHJlcXVpcmVkIChpLmUuIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwKS5cclxuICAgICAqIHJtOiB0aGUgcm91bmRpbmcgbW9kZS5cclxuICAgICAqIGlkOiAxICh0b0V4cG9uZW50aWFsKSBvciAyICh0b1ByZWNpc2lvbikuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvcm1hdChuLCBpLCBybSwgaWQpIHtcclxuICAgICAgdmFyIGMwLCBlLCBuZSwgbGVuLCBzdHI7XHJcblxyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIGlmICghbi5jKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgYzAgPSBuLmNbMF07XHJcbiAgICAgIG5lID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGkgPT0gbnVsbCkge1xyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBzdHIgPSBpZCA9PSAxIHx8IGlkID09IDIgJiYgKG5lIDw9IFRPX0VYUF9ORUcgfHwgbmUgPj0gVE9fRVhQX1BPUylcclxuICAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgbmUpXHJcbiAgICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgbmUsICcwJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIGksIHJtKTtcclxuXHJcbiAgICAgICAgLy8gbi5lIG1heSBoYXZlIGNoYW5nZWQgaWYgdGhlIHZhbHVlIHdhcyByb3VuZGVkIHVwLlxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyB0b1ByZWNpc2lvbiByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgICAgLy8gc3BlY2lmaWVkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyXHJcbiAgICAgICAgLy8gcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24uXHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgIGlmIChpZCA9PSAxIHx8IGlkID09IDIgJiYgKGkgPD0gZSB8fCBlIDw9IFRPX0VYUF9ORUcpKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgZm9yICg7IGxlbiA8IGk7IHN0ciArPSAnMCcsIGxlbisrKTtcclxuICAgICAgICAgIHN0ciA9IHRvRXhwb25lbnRpYWwoc3RyLCBlKTtcclxuXHJcbiAgICAgICAgLy8gRml4ZWQtcG9pbnQgbm90YXRpb24uXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGkgLT0gbmU7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGlmIChlICsgMSA+IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoLS1pID4gMCkgZm9yIChzdHIgKz0gJy4nOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSArPSBlIC0gbGVuO1xyXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICBpZiAoZSArIDEgPT0gbGVuKSBzdHIgKz0gJy4nO1xyXG4gICAgICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCAmJiBjMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIEJpZ051bWJlci5tYXggYW5kIEJpZ051bWJlci5taW4uXHJcbiAgICBmdW5jdGlvbiBtYXhPck1pbihhcmdzLCBtZXRob2QpIHtcclxuICAgICAgdmFyIG4sXHJcbiAgICAgICAgaSA9IDEsXHJcbiAgICAgICAgbSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcblxyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihhcmdzW2ldKTtcclxuXHJcbiAgICAgICAgLy8gSWYgYW55IG51bWJlciBpcyBOYU4sIHJldHVybiBOYU4uXHJcbiAgICAgICAgaWYgKCFuLnMpIHtcclxuICAgICAgICAgIG0gPSBuO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QuY2FsbChtLCBuKSkge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFN0cmlwIHRyYWlsaW5nIHplcm9zLCBjYWxjdWxhdGUgYmFzZSAxMCBleHBvbmVudCBhbmQgY2hlY2sgYWdhaW5zdCBNSU5fRVhQIGFuZCBNQVhfRVhQLlxyXG4gICAgICogQ2FsbGVkIGJ5IG1pbnVzLCBwbHVzIGFuZCB0aW1lcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXNlKG4sIGMsIGUpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGogPSBjLmxlbmd0aDtcclxuXHJcbiAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoOyAhY1stLWpdOyBjLnBvcCgpKTtcclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYmFzZSAxMCBleHBvbmVudC4gRmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgIGZvciAoaiA9IGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgaWYgKChlID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICBuLmMgPSBuLmUgPSBudWxsO1xyXG5cclxuICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgbi5jID0gW24uZSA9IDBdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4uZSA9IGU7XHJcbiAgICAgICAgbi5jID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSB2YWx1ZXMgdGhhdCBmYWlsIHRoZSB2YWxpZGl0eSB0ZXN0IGluIEJpZ051bWJlci5cclxuICAgIHBhcnNlTnVtZXJpYyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaSxcclxuICAgICAgICBkb3RBZnRlciA9IC9eKFteLl0rKVxcLiQvLFxyXG4gICAgICAgIGRvdEJlZm9yZSA9IC9eXFwuKFteLl0rKSQvLFxyXG4gICAgICAgIGlzSW5maW5pdHlPck5hTiA9IC9eLT8oSW5maW5pdHl8TmFOKSQvLFxyXG4gICAgICAgIHdoaXRlc3BhY2VPclBsdXMgPSAvXlxccypcXCsoPz1bXFx3Ll0pfF5cXHMrfFxccyskL2c7XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHN0ciwgaXNOdW0sIGIpIHtcclxuICAgICAgICB2YXIgYmFzZSxcclxuICAgICAgICAgIHMgPSBpc051bSA/IHN0ciA6IHN0ci5yZXBsYWNlKHdoaXRlc3BhY2VPclBsdXMsICcnKTtcclxuXHJcbiAgICAgICAgLy8gTm8gZXhjZXB0aW9uIG9uIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICAgIGlmIChpc0luZmluaXR5T3JOYU4udGVzdChzKSkge1xyXG4gICAgICAgICAgeC5zID0gaXNOYU4ocykgPyBudWxsIDogcyA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICghaXNOdW0pIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pXHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYmFzZVByZWZpeCwgZnVuY3Rpb24gKG0sIHAxLCBwMikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSAocDIgPSBwMi50b0xvd2VyQ2FzZSgpKSA9PSAneCcgPyAxNiA6IHAyID09ICdiJyA/IDIgOiA4O1xyXG4gICAgICAgICAgICAgIHJldHVybiAhYiB8fCBiID09IGJhc2UgPyBwMSA6IG07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gYjtcclxuXHJcbiAgICAgICAgICAgICAgLy8gRS5nLiAnMS4nIHRvICcxJywgJy4xJyB0byAnMC4xJ1xyXG4gICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoZG90QWZ0ZXIsICckMScpLnJlcGxhY2UoZG90QmVmb3JlLCAnMC4kMScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RyICE9IHMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHMsIGJhc2UpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBiYXNlIHtifSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnTm90IGEnICsgKGIgPyAnIGJhc2UgJyArIGIgOiAnJykgKyAnIG51bWJlcjogJyArIHN0cik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTmFOXHJcbiAgICAgICAgICB4LnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJvdW5kIHggdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAgICAgKiBJZiByIGlzIHRydXRoeSwgaXQgaXMga25vd24gdGhhdCB0aGVyZSBhcmUgbW9yZSBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByb3VuZCh4LCBzZCwgcm0sIHIpIHtcclxuICAgICAgdmFyIGQsIGksIGosIGssIG4sIG5pLCByZCxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICBwb3dzMTAgPSBQT1dTX1RFTjtcclxuXHJcbiAgICAgIC8vIGlmIHggaXMgbm90IEluZmluaXR5IG9yIE5hTi4uLlxyXG4gICAgICBpZiAoeGMpIHtcclxuXHJcbiAgICAgICAgLy8gcmQgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICAvLyBuIGlzIGEgYmFzZSAxZTE0IG51bWJlciwgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IG9mIGFycmF5IHguYyBjb250YWluaW5nIHJkLlxyXG4gICAgICAgIC8vIG5pIGlzIHRoZSBpbmRleCBvZiBuIHdpdGhpbiB4LmMuXHJcbiAgICAgICAgLy8gZCBpcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgIC8vIGkgaXMgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuIGluY2x1ZGluZyBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIC8vIGogaXMgdGhlIGFjdHVhbCBpbmRleCBvZiByZCB3aXRoaW4gbiAoaWYgPCAwLCByZCBpcyBhIGxlYWRpbmcgemVybykuXHJcbiAgICAgICAgb3V0OiB7XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLlxyXG4gICAgICAgICAgZm9yIChkID0gMSwgayA9IHhjWzBdOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG4gICAgICAgICAgaSA9IHNkIC0gZDtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICAgICAgICBqID0gc2Q7XHJcbiAgICAgICAgICAgIG4gPSB4Y1tuaSA9IDBdO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgIHJkID0gbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmkgPSBtYXRoY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5pID49IHhjLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5lZWRlZCBieSBzcXJ0LlxyXG4gICAgICAgICAgICAgICAgZm9yICg7IHhjLmxlbmd0aCA8PSBuaTsgeGMucHVzaCgwKSk7XHJcbiAgICAgICAgICAgICAgICBuID0gcmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZCA9IDE7XHJcbiAgICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG4gICAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbiA9IGsgPSB4Y1tuaV07XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICAgIGZvciAoZCA9IDE7IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4uXHJcbiAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiwgYWRqdXN0ZWQgZm9yIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4gaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkLlxyXG4gICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgICByZCA9IGogPCAwID8gMCA6IG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwIHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHIgPSByIHx8IHNkIDwgMCB8fFxyXG5cclxuICAgICAgICAgIC8vIEFyZSB0aGVyZSBhbnkgbm9uLXplcm8gZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdD9cclxuICAgICAgICAgIC8vIFRoZSBleHByZXNzaW9uICBuICUgcG93czEwW2QgLSBqIC0gMV0gIHJldHVybnMgYWxsIGRpZ2l0cyBvZiBuIHRvIHRoZSByaWdodFxyXG4gICAgICAgICAgLy8gb2YgdGhlIGRpZ2l0IGF0IGosIGUuZy4gaWYgbiBpcyA5MDg3MTQgYW5kIGogaXMgMiwgdGhlIGV4cHJlc3Npb24gZ2l2ZXMgNzE0LlxyXG4gICAgICAgICAgIHhjW25pICsgMV0gIT0gbnVsbCB8fCAoaiA8IDAgPyBuIDogbiAlIHBvd3MxMFtkIC0gaiAtIDFdKTtcclxuXHJcbiAgICAgICAgICByID0gcm0gPCA0XHJcbiAgICAgICAgICAgPyAocmQgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgOiByZCA+IDUgfHwgcmQgPT0gNSAmJiAocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiZcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBvZGQuXHJcbiAgICAgICAgICAgICgoaSA+IDAgPyBqID4gMCA/IG4gLyBwb3dzMTBbZCAtIGpdIDogMCA6IHhjW25pIC0gMV0pICUgMTApICYgMSB8fFxyXG4gICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAgIGlmIChzZCA8IDEgfHwgIXhjWzBdKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHNkIHRvIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICAgIHNkIC09IHguZSArIDE7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSBwb3dzMTBbKExPR19CQVNFIC0gc2QgJSBMT0dfQkFTRSkgJSBMT0dfQkFTRV07XHJcbiAgICAgICAgICAgICAgeC5lID0gLXNkIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSB4LmUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cclxuICAgICAgICAgIGlmIChpID09IDApIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmk7XHJcbiAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICBuaS0tO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmkgKyAxO1xyXG4gICAgICAgICAgICBrID0gcG93czEwW0xPR19CQVNFIC0gaV07XHJcblxyXG4gICAgICAgICAgICAvLyBFLmcuIDU2NzAwIGJlY29tZXMgNTYwMDAgaWYgNyBpcyB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgIC8vIGogPiAwIG1lYW5zIGkgPiBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuLlxyXG4gICAgICAgICAgICB4Y1tuaV0gPSBqID4gMCA/IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqXSAlIHBvd3MxMFtqXSkgKiBrIDogMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiB0aGUgZGlnaXQgdG8gYmUgcm91bmRlZCB1cCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgICAgIGlmIChuaSA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaSB3aWxsIGJlIHRoZSBsZW5ndGggb2YgeGNbMF0gYmVmb3JlIGsgaXMgYWRkZWQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBqID0geGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcbiAgICAgICAgICAgICAgICBqID0geGNbMF0gKz0gaztcclxuICAgICAgICAgICAgICAgIGZvciAoayA9IDE7IGogPj0gMTA7IGogLz0gMTAsIGsrKyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgaSAhPSBrIHRoZSBsZW5ndGggaGFzIGluY3JlYXNlZC5cclxuICAgICAgICAgICAgICAgIGlmIChpICE9IGspIHtcclxuICAgICAgICAgICAgICAgICAgeC5lKys7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh4Y1swXSA9PSBCQVNFKSB4Y1swXSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHhjW25pXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhjW25pXSAhPSBCQVNFKSBicmVhaztcclxuICAgICAgICAgICAgICAgIHhjW25pLS1dID0gMDtcclxuICAgICAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoaSA9IHhjLmxlbmd0aDsgeGNbLS1pXSA9PT0gMDsgeGMucG9wKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3ZlcmZsb3c/IEluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/IFplcm8uXHJcbiAgICAgICAgfSBlbHNlIGlmICh4LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdmFsdWVPZihuKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChlID09PSBudWxsKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG5cclxuICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIGUpXHJcbiAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFBST1RPVFlQRS9JTlNUQU5DRSBNRVRIT0RTXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlci5cclxuICAgICAqL1xyXG4gICAgUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHgucyA8IDApIHgucyA9IDE7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVyblxyXG4gICAgICogICAxIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgLTEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAwIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZSxcclxuICAgICAqICAgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIGlzIE5hTi5cclxuICAgICAqL1xyXG4gICAgUC5jb21wYXJlZFRvID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgZHAgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlXHJcbiAgICAgKiB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBkcCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGRwIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlczogaW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLmRlY2ltYWxQbGFjZXMgPSBQLmRwID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIGRwICsgeC5lICsgMSwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIG4gPSAoKHYgPSBjLmxlbmd0aCAtIDEpIC0gYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBudW1iZXIuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG4gICAgICBpZiAobiA8IDApIG4gPSAwO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLyAwID0gSVxyXG4gICAgICogIG4gLyBOID0gTlxyXG4gICAgICogIG4gLyBJID0gMFxyXG4gICAgICogIDAgLyBuID0gMFxyXG4gICAgICogIDAgLyAwID0gTlxyXG4gICAgICogIDAgLyBOID0gTlxyXG4gICAgICogIDAgLyBJID0gMFxyXG4gICAgICogIE4gLyBuID0gTlxyXG4gICAgICogIE4gLyAwID0gTlxyXG4gICAgICogIE4gLyBOID0gTlxyXG4gICAgICogIE4gLyBJID0gTlxyXG4gICAgICogIEkgLyBuID0gSVxyXG4gICAgICogIEkgLyAwID0gSVxyXG4gICAgICogIEkgLyBOID0gTlxyXG4gICAgICogIEkgLyBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGRpdmlkZWQgYnkgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRCeSA9IFAuZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCBERUNJTUFMX1BMQUNFUywgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgaW50ZWdlciBwYXJ0IG9mIGRpdmlkaW5nIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgYnkgdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmlkaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIDAsIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZXhwb25lbnRpYXRlZCBieSBuLlxyXG4gICAgICpcclxuICAgICAqIElmIG0gaXMgcHJlc2VudCwgcmV0dXJuIHRoZSByZXN1bHQgbW9kdWxvIG0uXHJcbiAgICAgKiBJZiBuIGlzIG5lZ2F0aXZlIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqIElmIFBPV19QUkVDSVNJT04gaXMgbm9uLXplcm8gYW5kIG0gaXMgbm90IHByZXNlbnQsIHJvdW5kIHRvIFBPV19QUkVDSVNJT04gdXNpbmcgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbW9kdWxhciBwb3dlciBvcGVyYXRpb24gd29ya3MgZWZmaWNpZW50bHkgd2hlbiB4LCBuLCBhbmQgbSBhcmUgaW50ZWdlcnMsIG90aGVyd2lzZSBpdFxyXG4gICAgICogaXMgZXF1aXZhbGVudCB0byBjYWxjdWxhdGluZyB4LmV4cG9uZW50aWF0ZWRCeShuKS5tb2R1bG8obSkgd2l0aCBhIFBPV19QUkVDSVNJT04gb2YgMC5cclxuICAgICAqXHJcbiAgICAgKiBuIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIGV4cG9uZW50LiBBbiBpbnRlZ2VyLlxyXG4gICAgICogW21dIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIG1vZHVsdXMuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEV4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiB7bn0nXHJcbiAgICAgKi9cclxuICAgIFAuZXhwb25lbnRpYXRlZEJ5ID0gUC5wb3cgPSBmdW5jdGlvbiAobiwgbSkge1xyXG4gICAgICB2YXIgaGFsZiwgaXNNb2RFeHAsIGksIGssIG1vcmUsIG5Jc0JpZywgbklzTmVnLCBuSXNPZGQsIHksXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihuKTtcclxuXHJcbiAgICAgIC8vIEFsbG93IE5hTiBhbmQgwrFJbmZpbml0eSwgYnV0IG5vdCBvdGhlciBub24taW50ZWdlcnMuXHJcbiAgICAgIGlmIChuLmMgJiYgIW4uaXNJbnRlZ2VyKCkpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0V4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiAnICsgdmFsdWVPZihuKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChtICE9IG51bGwpIG0gPSBuZXcgQmlnTnVtYmVyKG0pO1xyXG5cclxuICAgICAgLy8gRXhwb25lbnQgb2YgTUFYX1NBRkVfSU5URUdFUiBpcyAxNS5cclxuICAgICAgbklzQmlnID0gbi5lID4gMTQ7XHJcblxyXG4gICAgICAvLyBJZiB4IGlzIE5hTiwgwrFJbmZpbml0eSwgwrEwIG9yIMKxMSwgb3IgbiBpcyDCsUluZmluaXR5LCBOYU4gb3IgwrEwLlxyXG4gICAgICBpZiAoIXguYyB8fCAheC5jWzBdIHx8IHguY1swXSA9PSAxICYmICF4LmUgJiYgeC5jLmxlbmd0aCA9PSAxIHx8ICFuLmMgfHwgIW4uY1swXSkge1xyXG5cclxuICAgICAgICAvLyBUaGUgc2lnbiBvZiB0aGUgcmVzdWx0IG9mIHBvdyB3aGVuIHggaXMgbmVnYXRpdmUgZGVwZW5kcyBvbiB0aGUgZXZlbm5lc3Mgb2Ygbi5cclxuICAgICAgICAvLyBJZiArbiBvdmVyZmxvd3MgdG8gwrFJbmZpbml0eSwgdGhlIGV2ZW5uZXNzIG9mIG4gd291bGQgYmUgbm90IGJlIGtub3duLlxyXG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE1hdGgucG93KCt2YWx1ZU9mKHgpLCBuSXNCaWcgPyAyIC0gaXNPZGQobikgOiArdmFsdWVPZihuKSkpO1xyXG4gICAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuSXNOZWcgPSBuLnMgPCAwO1xyXG5cclxuICAgICAgaWYgKG0pIHtcclxuXHJcbiAgICAgICAgLy8geCAlIG0gcmV0dXJucyBOYU4gaWYgYWJzKG0pIGlzIHplcm8sIG9yIG0gaXMgTmFOLlxyXG4gICAgICAgIGlmIChtLmMgPyAhbS5jWzBdIDogIW0ucykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgICAgaXNNb2RFeHAgPSAhbklzTmVnICYmIHguaXNJbnRlZ2VyKCkgJiYgbS5pc0ludGVnZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKGlzTW9kRXhwKSB4ID0geC5tb2QobSk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdyB0byDCsUluZmluaXR5OiA+PTIqKjFlMTAgb3IgPj0xLjAwMDAwMjQqKjFlMTUuXHJcbiAgICAgIC8vIFVuZGVyZmxvdyB0byDCsTA6IDw9MC43OSoqMWUxMCBvciA8PTAuOTk5OTk3NSoqMWUxNS5cclxuICAgICAgfSBlbHNlIGlmIChuLmUgPiA5ICYmICh4LmUgPiAwIHx8IHguZSA8IC0xIHx8ICh4LmUgPT0gMFxyXG4gICAgICAgIC8vIFsxLCAyNDAwMDAwMDBdXHJcbiAgICAgICAgPyB4LmNbMF0gPiAxIHx8IG5Jc0JpZyAmJiB4LmNbMV0gPj0gMjRlN1xyXG4gICAgICAgIC8vIFs4MDAwMDAwMDAwMDAwMF0gIFs5OTk5OTc1MDAwMDAwMF1cclxuICAgICAgICA6IHguY1swXSA8IDhlMTMgfHwgbklzQmlnICYmIHguY1swXSA8PSA5OTk5OTc1ZTcpKSkge1xyXG5cclxuICAgICAgICAvLyBJZiB4IGlzIG5lZ2F0aXZlIGFuZCBuIGlzIG9kZCwgayA9IC0wLCBlbHNlIGsgPSAwLlxyXG4gICAgICAgIGsgPSB4LnMgPCAwICYmIGlzT2RkKG4pID8gLTAgOiAwO1xyXG5cclxuICAgICAgICAvLyBJZiB4ID49IDEsIGsgPSDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiAtMSkgayA9IDEgLyBrO1xyXG5cclxuICAgICAgICAvLyBJZiBuIGlzIG5lZ2F0aXZlIHJldHVybiDCsTAsIGVsc2UgcmV0dXJuIMKxSW5maW5pdHkuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIobklzTmVnID8gMSAvIGsgOiBrKTtcclxuXHJcbiAgICAgIH0gZWxzZSBpZiAoUE9XX1BSRUNJU0lPTikge1xyXG5cclxuICAgICAgICAvLyBUcnVuY2F0aW5nIGVhY2ggY29lZmZpY2llbnQgYXJyYXkgdG8gYSBsZW5ndGggb2YgayBhZnRlciBlYWNoIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgLy8gZXF1YXRlcyB0byB0cnVuY2F0aW5nIHNpZ25pZmljYW50IGRpZ2l0cyB0byBQT1dfUFJFQ0lTSU9OICsgWzI4LCA0MV0sXHJcbiAgICAgICAgLy8gaS5lLiB0aGVyZSB3aWxsIGJlIGEgbWluaW11bSBvZiAyOCBndWFyZCBkaWdpdHMgcmV0YWluZWQuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKFBPV19QUkVDSVNJT04gLyBMT0dfQkFTRSArIDIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobklzQmlnKSB7XHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoMC41KTtcclxuICAgICAgICBpZiAobklzTmVnKSBuLnMgPSAxO1xyXG4gICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkgPSBNYXRoLmFicygrdmFsdWVPZihuKSk7XHJcbiAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAvLyBQZXJmb3JtcyA1NCBsb29wIGl0ZXJhdGlvbnMgZm9yIG4gb2YgOTAwNzE5OTI1NDc0MDk5MS5cclxuICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgaWYgKG5Jc09kZCkge1xyXG4gICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICBpZiAoIXkuYykgYnJlYWs7XHJcblxyXG4gICAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgICAgaWYgKHkuYy5sZW5ndGggPiBrKSB5LmMubGVuZ3RoID0gaztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgICAgeSA9IHkubW9kKG0pOyAgICAvL3kgPSB5Lm1pbnVzKGRpdih5LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGkpIHtcclxuICAgICAgICAgIGkgPSBtYXRoZmxvb3IoaSAvIDIpO1xyXG4gICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBuLnRpbWVzKGhhbGYpO1xyXG4gICAgICAgICAgcm91bmQobiwgbi5lICsgMSwgMSk7XHJcblxyXG4gICAgICAgICAgaWYgKG4uZSA+IDE0KSB7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSA9ICt2YWx1ZU9mKG4pO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeCA9IHgudGltZXMoeCk7XHJcblxyXG4gICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICBpZiAoeC5jICYmIHguYy5sZW5ndGggPiBrKSB4LmMubGVuZ3RoID0gaztcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICB4ID0geC5tb2QobSk7ICAgIC8veCA9IHgubWludXMoZGl2KHgsIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNNb2RFeHApIHJldHVybiB5O1xyXG4gICAgICBpZiAobklzTmVnKSB5ID0gT05FLmRpdih5KTtcclxuXHJcbiAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiBrID8gcm91bmQoeSwgUE9XX1BSRUNJU0lPTiwgUk9VTkRJTkdfTU9ERSwgbW9yZSkgOiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYW4gaW50ZWdlclxyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3JtfSdcclxuICAgICAqL1xyXG4gICAgUC5pbnRlZ2VyVmFsdWUgPSBmdW5jdGlvbiAocm0pIHtcclxuICAgICAgdmFyIG4gPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuICAgICAgcmV0dXJuIHJvdW5kKG4sIG4uZSArIDEsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNFcXVhbFRvID0gUC5lcSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNGaW5pdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IDEgfHwgYiA9PT0gMDtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5jLmxlbmd0aCAtIDI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW5PckVxdWFsVG8gPSBQLmx0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAtMSB8fCBiID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhdGhpcy5zO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgcG9zaXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIDAgb3IgLTAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgdGhpcy5jWzBdID09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLSAwID0gblxyXG4gICAgICogIG4gLSBOID0gTlxyXG4gICAgICogIG4gLSBJID0gLUlcclxuICAgICAqICAwIC0gbiA9IC1uXHJcbiAgICAgKiAgMCAtIDAgPSAwXHJcbiAgICAgKiAgMCAtIE4gPSBOXHJcbiAgICAgKiAgMCAtIEkgPSAtSVxyXG4gICAgICogIE4gLSBuID0gTlxyXG4gICAgICogIE4gLSAwID0gTlxyXG4gICAgICogIE4gLSBOID0gTlxyXG4gICAgICogIE4gLSBJID0gTlxyXG4gICAgICogIEkgLSBuID0gSVxyXG4gICAgICogIEkgLSAwID0gSVxyXG4gICAgICogIEkgLSBOID0gTlxyXG4gICAgICogIEkgLSBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1pbnVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm1pbnVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGksIGosIHQsIHhMVHksXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIHhjID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeWMgPyB4IDogTmFOKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICAgIHJldHVybiB5Y1swXSA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6XHJcblxyXG4gICAgICAgICAgIC8vIElFRUUgNzU0ICgyMDA4KSA2LjM6IG4gLSBuID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHlcclxuICAgICAgICAgICBST1VORElOR19NT0RFID09IDMgPyAtMCA6IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG5cclxuICAgICAgICBpZiAoeExUeSA9IGEgPCAwKSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgICAgZm9yIChiID0gYTsgYi0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgIGogPSAoeExUeSA9IChhID0geGMubGVuZ3RoKSA8IChiID0geWMubGVuZ3RoKSkgPyBhIDogYjtcclxuXHJcbiAgICAgICAgZm9yIChhID0gYiA9IDA7IGIgPCBqOyBiKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAoeGNbYl0gIT0geWNbYl0pIHtcclxuICAgICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKHhMVHkpIHtcclxuICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgeGMgPSB5YztcclxuICAgICAgICB5YyA9IHQ7XHJcbiAgICAgICAgeS5zID0gLXkucztcclxuICAgICAgfSAgXHJcblxyXG4gICAgICBiID0gKGogPSB5Yy5sZW5ndGgpIC0gKGkgPSB4Yy5sZW5ndGgpO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zIHRvIHhjIGlmIHNob3J0ZXIuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gYWRkIHplcm9zIHRvIHljIGlmIHNob3J0ZXIgYXMgc3VidHJhY3Qgb25seSBuZWVkcyB0byBzdGFydCBhdCB5Yy5sZW5ndGguXHJcbiAgICAgIGlmIChiID4gMCkgZm9yICg7IGItLTsgeGNbaSsrXSA9IDApO1xyXG4gICAgICBiID0gQkFTRSAtIDE7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB5YyBmcm9tIHhjLlxyXG4gICAgICBmb3IgKDsgaiA+IGE7KSB7XHJcblxyXG4gICAgICAgIGlmICh4Y1stLWpdIDwgeWNbal0pIHtcclxuICAgICAgICAgIGZvciAoaSA9IGo7IGkgJiYgIXhjWy0taV07IHhjW2ldID0gYik7XHJcbiAgICAgICAgICAtLXhjW2ldO1xyXG4gICAgICAgICAgeGNbal0gKz0gQkFTRTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHhjW2pdIC09IHljW2pdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICBmb3IgKDsgeGNbMF0gPT0gMDsgeGMuc3BsaWNlKDAsIDEpLCAtLXllKTtcclxuXHJcbiAgICAgIC8vIFplcm8/XHJcbiAgICAgIGlmICgheGNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gRm9sbG93aW5nIElFRUUgNzU0ICgyMDA4KSA2LjMsXHJcbiAgICAgICAgLy8gbiAtIG4gPSArMCAgYnV0ICBuIC0gbiA9IC0wICB3aGVuIHJvdW5kaW5nIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAgIHkucyA9IFJPVU5ESU5HX01PREUgPT0gMyA/IC0xIDogMTtcclxuICAgICAgICB5LmMgPSBbeS5lID0gMF07XHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIEluZmluaXR5IGFzICt4IC0gK3kgIT0gSW5maW5pdHkgJiYgLXggLSAteSAhPSBJbmZpbml0eVxyXG4gICAgICAvLyBmb3IgZmluaXRlIHggYW5kIHkuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgIG4gJSAwID0gIE5cclxuICAgICAqICAgbiAlIE4gPSAgTlxyXG4gICAgICogICBuICUgSSA9ICBuXHJcbiAgICAgKiAgIDAgJSBuID0gIDBcclxuICAgICAqICAtMCAlIG4gPSAtMFxyXG4gICAgICogICAwICUgMCA9ICBOXHJcbiAgICAgKiAgIDAgJSBOID0gIE5cclxuICAgICAqICAgMCAlIEkgPSAgMFxyXG4gICAgICogICBOICUgbiA9ICBOXHJcbiAgICAgKiAgIE4gJSAwID0gIE5cclxuICAgICAqICAgTiAlIE4gPSAgTlxyXG4gICAgICogICBOICUgSSA9ICBOXHJcbiAgICAgKiAgIEkgJSBuID0gIE5cclxuICAgICAqICAgSSAlIDAgPSAgTlxyXG4gICAgICogICBJICUgTiA9ICBOXHJcbiAgICAgKiAgIEkgJSBJID0gIE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtb2R1bG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuIFRoZSByZXN1bHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUgb2YgTU9EVUxPX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAubW9kdWxvID0gUC5tb2QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgcSwgcyxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIE5hTiBpZiB4IGlzIEluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgemVyby5cclxuICAgICAgaWYgKCF4LmMgfHwgIXkucyB8fCB5LmMgJiYgIXkuY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4geCBpZiB5IGlzIEluZmluaXR5IG9yIHggaXMgemVyby5cclxuICAgICAgfSBlbHNlIGlmICgheS5jIHx8IHguYyAmJiAheC5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChNT0RVTE9fTU9ERSA9PSA5KSB7XHJcblxyXG4gICAgICAgIC8vIEV1Y2xpZGlhbiBkaXZpc2lvbjogcSA9IHNpZ24oeSkgKiBmbG9vcih4IC8gYWJzKHkpKVxyXG4gICAgICAgIC8vIHIgPSB4IC0gcXkgICAgd2hlcmUgIDAgPD0gciA8IGFicyh5KVxyXG4gICAgICAgIHMgPSB5LnM7XHJcbiAgICAgICAgeS5zID0gMTtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIDMpO1xyXG4gICAgICAgIHkucyA9IHM7XHJcbiAgICAgICAgcS5zICo9IHM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCBNT0RVTE9fTU9ERSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSB4Lm1pbnVzKHEudGltZXMoeSkpO1xyXG5cclxuICAgICAgLy8gVG8gbWF0Y2ggSmF2YVNjcmlwdCAlLCBlbnN1cmUgc2lnbiBvZiB6ZXJvIGlzIHNpZ24gb2YgZGl2aWRlbmQuXHJcbiAgICAgIGlmICgheS5jWzBdICYmIE1PRFVMT19NT0RFID09IDEpIHkucyA9IHgucztcclxuXHJcbiAgICAgIHJldHVybiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICogMCA9IDBcclxuICAgICAqICBuICogTiA9IE5cclxuICAgICAqICBuICogSSA9IElcclxuICAgICAqICAwICogbiA9IDBcclxuICAgICAqICAwICogMCA9IDBcclxuICAgICAqICAwICogTiA9IE5cclxuICAgICAqICAwICogSSA9IE5cclxuICAgICAqICBOICogbiA9IE5cclxuICAgICAqICBOICogMCA9IE5cclxuICAgICAqICBOICogTiA9IE5cclxuICAgICAqICBOICogSSA9IE5cclxuICAgICAqICBJICogbiA9IElcclxuICAgICAqICBJICogMCA9IE5cclxuICAgICAqICBJICogTiA9IE5cclxuICAgICAqICBJICogSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZVxyXG4gICAgICogb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm11bHRpcGxpZWRCeSA9IFAudGltZXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgYywgZSwgaSwgaiwgaywgbSwgeGNMLCB4bG8sIHhoaSwgeWNMLCB5bG8sIHloaSwgemMsXHJcbiAgICAgICAgYmFzZSwgc3FydEJhc2UsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSAoeSA9IG5ldyBCaWdOdW1iZXIoeSwgYikpLmM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOLCDCsUluZmluaXR5IG9yIMKxMD9cclxuICAgICAgaWYgKCF4YyB8fCAheWMgfHwgIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBpcyBOYU4sIG9yIG9uZSBpcyAwIGFuZCB0aGUgb3RoZXIgaXMgSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4LnMgfHwgIXkucyB8fCB4YyAmJiAheGNbMF0gJiYgIXljIHx8IHljICYmICF5Y1swXSAmJiAheGMpIHtcclxuICAgICAgICAgIHkuYyA9IHkuZSA9IHkucyA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHkucyAqPSB4LnM7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIGlzIMKxSW5maW5pdHkuXHJcbiAgICAgICAgICBpZiAoIXhjIHx8ICF5Yykge1xyXG4gICAgICAgICAgICB5LmMgPSB5LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgZWl0aGVyIGlzIMKxMC5cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHkuYyA9IFswXTtcclxuICAgICAgICAgICAgeS5lID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICB5LnMgKj0geC5zO1xyXG4gICAgICB4Y0wgPSB4Yy5sZW5ndGg7XHJcbiAgICAgIHljTCA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEVuc3VyZSB4YyBwb2ludHMgdG8gbG9uZ2VyIGFycmF5IGFuZCB4Y0wgdG8gaXRzIGxlbmd0aC5cclxuICAgICAgaWYgKHhjTCA8IHljTCkge1xyXG4gICAgICAgIHpjID0geGM7XHJcbiAgICAgICAgeGMgPSB5YztcclxuICAgICAgICB5YyA9IHpjO1xyXG4gICAgICAgIGkgPSB4Y0w7XHJcbiAgICAgICAgeGNMID0geWNMO1xyXG4gICAgICAgIHljTCA9IGk7XHJcbiAgICAgIH0gIFxyXG5cclxuICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IHhjTCArIHljTCwgemMgPSBbXTsgaS0tOyB6Yy5wdXNoKDApKTtcclxuXHJcbiAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICBzcXJ0QmFzZSA9IFNRUlRfQkFTRTtcclxuXHJcbiAgICAgIGZvciAoaSA9IHljTDsgLS1pID49IDA7KSB7XHJcbiAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgeWxvID0geWNbaV0gJSBzcXJ0QmFzZTtcclxuICAgICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcclxuXHJcbiAgICAgICAgZm9yIChrID0geGNMLCBqID0gaSArIGs7IGogPiBpOykge1xyXG4gICAgICAgICAgeGxvID0geGNbLS1rXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgICAgeGhpID0geGNba10gLyBzcXJ0QmFzZSB8IDA7XHJcbiAgICAgICAgICBtID0geWhpICogeGxvICsgeGhpICogeWxvO1xyXG4gICAgICAgICAgeGxvID0geWxvICogeGxvICsgKChtICUgc3FydEJhc2UpICogc3FydEJhc2UpICsgemNbal0gKyBjO1xyXG4gICAgICAgICAgYyA9ICh4bG8gLyBiYXNlIHwgMCkgKyAobSAvIHNxcnRCYXNlIHwgMCkgKyB5aGkgKiB4aGk7XHJcbiAgICAgICAgICB6Y1tqLS1dID0geGxvICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHpjW2pdID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGMpIHtcclxuICAgICAgICArK2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgemMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHpjLCBlKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBuZWdhdGVkLFxyXG4gICAgICogaS5lLiBtdWx0aXBsaWVkIGJ5IC0xLlxyXG4gICAgICovXHJcbiAgICBQLm5lZ2F0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgeC5zID0gLXgucyB8fCBudWxsO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiArIDAgPSBuXHJcbiAgICAgKiAgbiArIE4gPSBOXHJcbiAgICAgKiAgbiArIEkgPSBJXHJcbiAgICAgKiAgMCArIG4gPSBuXHJcbiAgICAgKiAgMCArIDAgPSAwXHJcbiAgICAgKiAgMCArIE4gPSBOXHJcbiAgICAgKiAgMCArIEkgPSBJXHJcbiAgICAgKiAgTiArIG4gPSBOXHJcbiAgICAgKiAgTiArIDAgPSBOXHJcbiAgICAgKiAgTiArIE4gPSBOXHJcbiAgICAgKiAgTiArIEkgPSBOXHJcbiAgICAgKiAgSSArIG4gPSBJXHJcbiAgICAgKiAgSSArIDAgPSBJXHJcbiAgICAgKiAgSSArIE4gPSBOXHJcbiAgICAgKiAgSSArIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcGx1cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5wbHVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4Lm1pbnVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBuZXcgQmlnTnVtYmVyKGEgLyAwKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHJldHVybiB5Y1swXSA/IHkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6IGEgKiAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG4gICAgICAgIGlmIChhID4gMCkge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgZm9yICg7IGEtLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYSA9IHhjLmxlbmd0aDtcclxuICAgICAgYiA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXksIGFuZCBiIHRvIHRoZSBzaG9ydGVyIGxlbmd0aC5cclxuICAgICAgaWYgKGEgLSBiIDwgMCkge1xyXG4gICAgICAgIHQgPSB5YztcclxuICAgICAgICB5YyA9IHhjO1xyXG4gICAgICAgIHhjID0gdDtcclxuICAgICAgICBiID0gYTtcclxuICAgICAgfSAgXHJcblxyXG4gICAgICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgaWdub3JlZC5cclxuICAgICAgZm9yIChhID0gMDsgYjspIHtcclxuICAgICAgICBhID0gKHhjWy0tYl0gPSB4Y1tiXSArIHljW2JdICsgYSkgLyBCQVNFIHwgMDtcclxuICAgICAgICB4Y1tiXSA9IEJBU0UgPT09IHhjW2JdID8gMCA6IHhjW2JdICUgQkFTRTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGEpIHtcclxuICAgICAgICB4YyA9IFthXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICsreWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcclxuICAgICAgLy8geWUgPSBNQVhfRVhQICsgMSBwb3NzaWJsZVxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgc2QgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mXHJcbiAgICAgKiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICogSWYgc2QgaXMgdHJ1ZSBpbmNsdWRlIGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgY291bnQuXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBzZCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIHNkIHtudW1iZXJ8Ym9vbGVhbn0gbnVtYmVyOiBzaWduaWZpY2FudCBkaWdpdHM6IGludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogd2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoc2QgIT0gbnVsbCAmJiBzZCAhPT0gISFzZCkge1xyXG4gICAgICAgIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBzZCwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIHYgPSBjLmxlbmd0aCAtIDE7XHJcbiAgICAgIG4gPSB2ICogTE9HX0JBU0UgKyAxO1xyXG5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSB7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBuKyspO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2QgJiYgeC5lICsgMSA+IG4pIG4gPSB4LmUgKyAxO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgc2hpZnRlZCBieSBrIHBsYWNlc1xyXG4gICAgICogKHBvd2VycyBvZiAxMCkuIFNoaWZ0IHRvIHRoZSByaWdodCBpZiBuID4gMCwgYW5kIHRvIHRoZSBsZWZ0IGlmIG4gPCAwLlxyXG4gICAgICpcclxuICAgICAqIGsge251bWJlcn0gSW50ZWdlciwgLU1BWF9TQUZFX0lOVEVHRVIgdG8gTUFYX1NBRkVfSU5URUdFUiBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtrfSdcclxuICAgICAqL1xyXG4gICAgUC5zaGlmdGVkQnkgPSBmdW5jdGlvbiAoaykge1xyXG4gICAgICBpbnRDaGVjayhrLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUik7XHJcbiAgICAgIHJldHVybiB0aGlzLnRpbWVzKCcxZScgKyBrKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgc3FydCgtbikgPSAgTlxyXG4gICAgICogIHNxcnQoTikgPSAgTlxyXG4gICAgICogIHNxcnQoLUkpID0gIE5cclxuICAgICAqICBzcXJ0KEkpID0gIElcclxuICAgICAqICBzcXJ0KDApID0gIDBcclxuICAgICAqICBzcXJ0KC0wKSA9IC0wXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLFxyXG4gICAgICogcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG0sIG4sIHIsIHJlcCwgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBjID0geC5jLFxyXG4gICAgICAgIHMgPSB4LnMsXHJcbiAgICAgICAgZSA9IHguZSxcclxuICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTICsgNCxcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcignMC41Jyk7XHJcblxyXG4gICAgICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cclxuICAgICAgaWYgKHMgIT09IDEgfHwgIWMgfHwgIWNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcighcyB8fCBzIDwgMCAmJiAoIWMgfHwgY1swXSkgPyBOYU4gOiBjID8geCA6IDEgLyAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICAgICAgcyA9IE1hdGguc3FydCgrdmFsdWVPZih4KSk7XHJcblxyXG4gICAgICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gICAgICAvLyBQYXNzIHggdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gICAgICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcclxuICAgICAgICBuID0gY29lZmZUb1N0cmluZyhjKTtcclxuICAgICAgICBpZiAoKG4ubGVuZ3RoICsgZSkgJSAyID09IDApIG4gKz0gJzAnO1xyXG4gICAgICAgIHMgPSBNYXRoLnNxcnQoK24pO1xyXG4gICAgICAgIGUgPSBiaXRGbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xyXG5cclxuICAgICAgICBpZiAocyA9PSAxIC8gMCkge1xyXG4gICAgICAgICAgbiA9ICc1ZScgKyBlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoJ2UnKSArIDEpICsgZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKHMgKyAnJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciB6ZXJvLlxyXG4gICAgICAvLyByIGNvdWxkIGJlIHplcm8gaWYgTUlOX0VYUCBpcyBjaGFuZ2VkIGFmdGVyIHRoZSB0aGlzIHZhbHVlIHdhcyBjcmVhdGVkLlxyXG4gICAgICAvLyBUaGlzIHdvdWxkIGNhdXNlIGEgZGl2aXNpb24gYnkgemVybyAoeC90KSBhbmQgaGVuY2UgSW5maW5pdHkgYmVsb3csIHdoaWNoIHdvdWxkIGNhdXNlXHJcbiAgICAgIC8vIGNvZWZmVG9TdHJpbmcgdG8gdGhyb3cuXHJcbiAgICAgIGlmIChyLmNbMF0pIHtcclxuICAgICAgICBlID0gci5lO1xyXG4gICAgICAgIHMgPSBlICsgZHA7XHJcbiAgICAgICAgaWYgKHMgPCAzKSBzID0gMDtcclxuXHJcbiAgICAgICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gICAgICAgIGZvciAoOyA7KSB7XHJcbiAgICAgICAgICB0ID0gcjtcclxuICAgICAgICAgIHIgPSBoYWxmLnRpbWVzKHQucGx1cyhkaXYoeCwgdCwgZHAsIDEpKSk7XHJcblxyXG4gICAgICAgICAgaWYgKGNvZWZmVG9TdHJpbmcodC5jKS5zbGljZSgwLCBzKSA9PT0gKG4gPSBjb2VmZlRvU3RyaW5nKHIuYykpLnNsaWNlKDAsIHMpKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgb2YgciBtYXkgaGVyZSBiZSBvbmUgbGVzcyB0aGFuIHRoZSBmaW5hbCByZXN1bHQgZXhwb25lbnQsXHJcbiAgICAgICAgICAgIC8vIGUuZyAwLjAwMDk5OTkgKGUtNCkgLS0+IDAuMDAxIChlLTMpLCBzbyBhZGp1c3QgcyBzbyB0aGUgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSBpbmRleGVkIGNvcnJlY3RseS5cclxuICAgICAgICAgICAgaWYgKHIuZSA8IGUpIC0tcztcclxuICAgICAgICAgICAgbiA9IG4uc2xpY2UocyAtIDMsIHMgKyAxKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgOTk5OSBvciA0OTk5IChpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnkpIGNvbnRpbnVlIHRoZVxyXG4gICAgICAgICAgICAvLyBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgIGlmIChuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIE9uIHRoZSBmaXJzdCBpdGVyYXRpb24gb25seSwgY2hlY2sgdG8gc2VlIGlmIHJvdW5kaW5nIHVwIGdpdmVzIHRoZVxyXG4gICAgICAgICAgICAgIC8vIGV4YWN0IHJlc3VsdCBhcyB0aGUgbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgICAgICAgIGlmICghcmVwKSB7XHJcbiAgICAgICAgICAgICAgICByb3VuZCh0LCB0LmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0LnRpbWVzKHQpLmVxKHgpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHIgPSB0O1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGRwICs9IDQ7XHJcbiAgICAgICAgICAgICAgcyArPSA0O1xyXG4gICAgICAgICAgICAgIHJlcCA9IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBleGFjdFxyXG4gICAgICAgICAgICAgIC8vIHJlc3VsdC4gSWYgbm90LCB0aGVuIHRoZXJlIGFyZSBmdXJ0aGVyIGRpZ2l0cyBhbmQgbSB3aWxsIGJlIHRydXRoeS5cclxuICAgICAgICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSAnNScpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDEpO1xyXG4gICAgICAgICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLmVxKHgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDEsIFJPVU5ESU5HX01PREUsIG0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIGFuZFxyXG4gICAgICogcm91bmRlZCB1c2luZyBST1VORElOR19NT0RFIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwKys7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0sIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kaW5nXHJcbiAgICAgKiB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogYXMgd2l0aCBKYXZhU2NyaXB0J3MgbnVtYmVyIHR5cGUsICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsXHJcbiAgICAgKiBidXQgZS5nLiAoLTAuMDAwMDEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9GaXhlZCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCA9IGRwICsgdGhpcy5lICsgMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRlZFxyXG4gICAgICogdXNpbmcgcm0gb3IgUk9VTkRJTkdfTU9ERSB0byBkcCBkZWNpbWFsIHBsYWNlcywgYW5kIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHByb3BlcnRpZXNcclxuICAgICAqIG9mIHRoZSBmb3JtYXQgb3IgRk9STUFUIG9iamVjdCAoc2VlIEJpZ051bWJlci5zZXQpLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBmb3JtYXR0aW5nIG9iamVjdCBtYXkgY29udGFpbiBzb21lIG9yIGFsbCBvZiB0aGUgcHJvcGVydGllcyBzaG93biBiZWxvdy5cclxuICAgICAqXHJcbiAgICAgKiBGT1JNQVQgPSB7XHJcbiAgICAgKiAgIHByZWZpeDogJycsXHJcbiAgICAgKiAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAqICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICogICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICogICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICogICBzdWZmaXg6ICcnXHJcbiAgICAgKiB9O1xyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqIFtmb3JtYXRdIHtvYmplY3R9IEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlIEZPUk1BVCBwYmplY3QgYWJvdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQgbm90IGFuIG9iamVjdDoge2Zvcm1hdH0nXHJcbiAgICAgKi9cclxuICAgIFAudG9Gb3JtYXQgPSBmdW5jdGlvbiAoZHAsIHJtLCBmb3JtYXQpIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChkcCAhPSBudWxsICYmIHJtICYmIHR5cGVvZiBybSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gcm07XHJcbiAgICAgICAgICBybSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkcCAmJiB0eXBlb2YgZHAgPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IGRwO1xyXG4gICAgICAgICAgZHAgPSBybSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZvcm1hdCA9IEZPUk1BVDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdCAhPSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgbm90IGFuIG9iamVjdDogJyArIGZvcm1hdCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0ciA9IHgudG9GaXhlZChkcCwgcm0pO1xyXG5cclxuICAgICAgaWYgKHguYykge1xyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcuJyksXHJcbiAgICAgICAgICBnMSA9ICtmb3JtYXQuZ3JvdXBTaXplLFxyXG4gICAgICAgICAgZzIgPSArZm9ybWF0LnNlY29uZGFyeUdyb3VwU2l6ZSxcclxuICAgICAgICAgIGdyb3VwU2VwYXJhdG9yID0gZm9ybWF0Lmdyb3VwU2VwYXJhdG9yIHx8ICcnLFxyXG4gICAgICAgICAgaW50UGFydCA9IGFyclswXSxcclxuICAgICAgICAgIGZyYWN0aW9uUGFydCA9IGFyclsxXSxcclxuICAgICAgICAgIGlzTmVnID0geC5zIDwgMCxcclxuICAgICAgICAgIGludERpZ2l0cyA9IGlzTmVnID8gaW50UGFydC5zbGljZSgxKSA6IGludFBhcnQsXHJcbiAgICAgICAgICBsZW4gPSBpbnREaWdpdHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoZzIpIHtcclxuICAgICAgICAgIGkgPSBnMTtcclxuICAgICAgICAgIGcxID0gZzI7XHJcbiAgICAgICAgICBnMiA9IGk7XHJcbiAgICAgICAgICBsZW4gLT0gaTtcclxuICAgICAgICB9ICBcclxuXHJcbiAgICAgICAgaWYgKGcxID4gMCAmJiBsZW4gPiAwKSB7XHJcbiAgICAgICAgICBpID0gbGVuICUgZzEgfHwgZzE7XHJcbiAgICAgICAgICBpbnRQYXJ0ID0gaW50RGlnaXRzLnN1YnN0cigwLCBpKTtcclxuICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IGcxKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnN1YnN0cihpLCBnMSk7XHJcbiAgICAgICAgICBpZiAoZzIgPiAwKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnNsaWNlKGkpO1xyXG4gICAgICAgICAgaWYgKGlzTmVnKSBpbnRQYXJ0ID0gJy0nICsgaW50UGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IGZyYWN0aW9uUGFydFxyXG4gICAgICAgICA/IGludFBhcnQgKyAoZm9ybWF0LmRlY2ltYWxTZXBhcmF0b3IgfHwgJycpICsgKChnMiA9ICtmb3JtYXQuZnJhY3Rpb25Hcm91cFNpemUpXHJcbiAgICAgICAgICA/IGZyYWN0aW9uUGFydC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxkeycgKyBnMiArICd9XFxcXEInLCAnZycpLFxyXG4gICAgICAgICAgICckJicgKyAoZm9ybWF0LmZyYWN0aW9uR3JvdXBTZXBhcmF0b3IgfHwgJycpKVxyXG4gICAgICAgICAgOiBmcmFjdGlvblBhcnQpXHJcbiAgICAgICAgIDogaW50UGFydDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIChmb3JtYXQucHJlZml4IHx8ICcnKSArIHN0ciArIChmb3JtYXQuc3VmZml4IHx8ICcnKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgdHdvIEJpZ051bWJlcnMgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBhcyBhIHNpbXBsZVxyXG4gICAgICogZnJhY3Rpb24gd2l0aCBhbiBpbnRlZ2VyIG51bWVyYXRvciBhbmQgYW4gaW50ZWdlciBkZW5vbWluYXRvci5cclxuICAgICAqIFRoZSBkZW5vbWluYXRvciB3aWxsIGJlIGEgcG9zaXRpdmUgbm9uLXplcm8gdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWRcclxuICAgICAqIG1heGltdW0gZGVub21pbmF0b3IuIElmIGEgbWF4aW11bSBkZW5vbWluYXRvciBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgZGVub21pbmF0b3Igd2lsbCBiZVxyXG4gICAgICogdGhlIGxvd2VzdCB2YWx1ZSBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBudW1iZXIgZXhhY3RseS5cclxuICAgICAqXHJcbiAgICAgKiBbbWRdIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gSW50ZWdlciA+PSAxLCBvciBJbmZpbml0eS4gVGhlIG1heGltdW0gZGVub21pbmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9IDoge21kfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1kKSB7XHJcbiAgICAgIHZhciBkLCBkMCwgZDEsIGQyLCBlLCBleHAsIG4sIG4wLCBuMSwgcSwgciwgcyxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYztcclxuXHJcbiAgICAgIGlmIChtZCAhPSBudWxsKSB7XHJcbiAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobWQpO1xyXG5cclxuICAgICAgICAvLyBUaHJvdyBpZiBtZCBpcyBsZXNzIHRoYW4gb25lIG9yIGlzIG5vdCBhbiBpbnRlZ2VyLCB1bmxlc3MgaXQgaXMgSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCFuLmlzSW50ZWdlcigpICYmIChuLmMgfHwgbi5zICE9PSAxKSB8fCBuLmx0KE9ORSkpIHtcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCAnICtcclxuICAgICAgICAgICAgICAobi5pc0ludGVnZXIoKSA/ICdvdXQgb2YgcmFuZ2U6ICcgOiAnbm90IGFuIGludGVnZXI6ICcpICsgdmFsdWVPZihuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXhjKSByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuXHJcbiAgICAgIGQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIG4xID0gZDAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIGQxID0gbjAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIHMgPSBjb2VmZlRvU3RyaW5nKHhjKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSBpbml0aWFsIGRlbm9taW5hdG9yLlxyXG4gICAgICAvLyBkIGlzIGEgcG93ZXIgb2YgMTAgYW5kIHRoZSBtaW5pbXVtIG1heCBkZW5vbWluYXRvciB0aGF0IHNwZWNpZmllcyB0aGUgdmFsdWUgZXhhY3RseS5cclxuICAgICAgZSA9IGQuZSA9IHMubGVuZ3RoIC0geC5lIC0gMTtcclxuICAgICAgZC5jWzBdID0gUE9XU19URU5bKGV4cCA9IGUgJSBMT0dfQkFTRSkgPCAwID8gTE9HX0JBU0UgKyBleHAgOiBleHBdO1xyXG4gICAgICBtZCA9ICFtZCB8fCBuLmNvbXBhcmVkVG8oZCkgPiAwID8gKGUgPiAwID8gZCA6IG4xKSA6IG47XHJcblxyXG4gICAgICBleHAgPSBNQVhfRVhQO1xyXG4gICAgICBNQVhfRVhQID0gMSAvIDA7XHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG5cclxuICAgICAgLy8gbjAgPSBkMSA9IDBcclxuICAgICAgbjAuY1swXSA9IDA7XHJcblxyXG4gICAgICBmb3IgKDsgOykgIHtcclxuICAgICAgICBxID0gZGl2KG4sIGQsIDAsIDEpO1xyXG4gICAgICAgIGQyID0gZDAucGx1cyhxLnRpbWVzKGQxKSk7XHJcbiAgICAgICAgaWYgKGQyLmNvbXBhcmVkVG8obWQpID09IDEpIGJyZWFrO1xyXG4gICAgICAgIGQwID0gZDE7XHJcbiAgICAgICAgZDEgPSBkMjtcclxuICAgICAgICBuMSA9IG4wLnBsdXMocS50aW1lcyhkMiA9IG4xKSk7XHJcbiAgICAgICAgbjAgPSBkMjtcclxuICAgICAgICBkID0gbi5taW51cyhxLnRpbWVzKGQyID0gZCkpO1xyXG4gICAgICAgIG4gPSBkMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZDIgPSBkaXYobWQubWludXMoZDApLCBkMSwgMCwgMSk7XHJcbiAgICAgIG4wID0gbjAucGx1cyhkMi50aW1lcyhuMSkpO1xyXG4gICAgICBkMCA9IGQwLnBsdXMoZDIudGltZXMoZDEpKTtcclxuICAgICAgbjAucyA9IG4xLnMgPSB4LnM7XHJcbiAgICAgIGUgPSBlICogMjtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBmcmFjdGlvbiBpcyBjbG9zZXIgdG8geCwgbjAvZDAgb3IgbjEvZDFcclxuICAgICAgciA9IGRpdihuMSwgZDEsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpLmNvbXBhcmVkVG8oXHJcbiAgICAgICAgICBkaXYobjAsIGQwLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKSkgPCAxID8gW24xLCBkMV0gOiBbbjAsIGQwXTtcclxuXHJcbiAgICAgIE1BWF9FWFAgPSBleHA7XHJcblxyXG4gICAgICByZXR1cm4gcjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGNvbnZlcnRlZCB0byBhIG51bWJlciBwcmltaXRpdmUuXHJcbiAgICAgKi9cclxuICAgIFAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiArdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSBvciBST1VORElOR19NT0RFLiBJZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHNcclxuICAgICAqIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXIgcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24sIHRoZW4gdXNlXHJcbiAgICAgKiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICBpZiAoc2QgIT0gbnVsbCkgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgc2QsIHJtLCAyKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBiYXNlIGIsIG9yIGJhc2UgMTAgaWYgYiBpc1xyXG4gICAgICogb21pdHRlZC4gSWYgYSBiYXNlIGlzIHNwZWNpZmllZCwgaW5jbHVkaW5nIGJhc2UgMTAsIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmRcclxuICAgICAqIFJPVU5ESU5HX01PREUuIElmIGEgYmFzZSBpcyBub3Qgc3BlY2lmaWVkLCBhbmQgdGhpcyBCaWdOdW1iZXIgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnRcclxuICAgICAqIHRoYXQgaXMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIFRPX0VYUF9QT1MsIG9yIGEgbmVnYXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXHJcbiAgICAgKiBUT19FWFBfTkVHLCByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW2JdIHtudW1iZXJ9IEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgKi9cclxuICAgIFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIG4gPSB0aGlzLFxyXG4gICAgICAgIHMgPSBuLnMsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIC8vIEluZmluaXR5IG9yIE5hTj9cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHtcclxuICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgc3RyID0gJ0luZmluaXR5JztcclxuICAgICAgICAgIGlmIChzIDwgMCkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdHIgPSAnTmFOJztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgICAgID8gdG9FeHBvbmVudGlhbChjb2VmZlRvU3RyaW5nKG4uYyksIGUpXHJcbiAgICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMTAgJiYgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzKSB7XHJcbiAgICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgREVDSU1BTF9QTEFDRVMgKyBlICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBuLmUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuICAgICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyksIDEwLCBiLCBzLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCAmJiBuLmNbMF0pIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYXMgdG9TdHJpbmcsIGJ1dCBkbyBub3QgYWNjZXB0IGEgYmFzZSBhcmd1bWVudCwgYW5kIGluY2x1ZGUgdGhlIG1pbnVzIHNpZ24gZm9yXHJcbiAgICAgKiBuZWdhdGl2ZSB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBQLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBQLl9pc0JpZ051bWJlciA9IHRydWU7XHJcblxyXG4gICAgaWYgKGNvbmZpZ09iamVjdCAhPSBudWxsKSBCaWdOdW1iZXIuc2V0KGNvbmZpZ09iamVjdCk7XHJcblxyXG4gICAgcmV0dXJuIEJpZ051bWJlcjtcclxuICB9XHJcblxyXG5cclxuICAvLyBQUklWQVRFIEhFTFBFUiBGVU5DVElPTlNcclxuXHJcbiAgLy8gVGhlc2UgZnVuY3Rpb25zIGRvbid0IG5lZWQgYWNjZXNzIHRvIHZhcmlhYmxlcyxcclxuICAvLyBlLmcuIERFQ0lNQUxfUExBQ0VTLCBpbiB0aGUgc2NvcGUgb2YgdGhlIGBjbG9uZWAgZnVuY3Rpb24gYWJvdmUuXHJcblxyXG5cclxuICBmdW5jdGlvbiBiaXRGbG9vcihuKSB7XHJcbiAgICB2YXIgaSA9IG4gfCAwO1xyXG4gICAgcmV0dXJuIG4gPiAwIHx8IG4gPT09IGkgPyBpIDogaSAtIDE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUmV0dXJuIGEgY29lZmZpY2llbnQgYXJyYXkgYXMgYSBzdHJpbmcgb2YgYmFzZSAxMCBkaWdpdHMuXHJcbiAgZnVuY3Rpb24gY29lZmZUb1N0cmluZyhhKSB7XHJcbiAgICB2YXIgcywgeixcclxuICAgICAgaSA9IDEsXHJcbiAgICAgIGogPSBhLmxlbmd0aCxcclxuICAgICAgciA9IGFbMF0gKyAnJztcclxuXHJcbiAgICBmb3IgKDsgaSA8IGo7KSB7XHJcbiAgICAgIHMgPSBhW2krK10gKyAnJztcclxuICAgICAgeiA9IExPR19CQVNFIC0gcy5sZW5ndGg7XHJcbiAgICAgIGZvciAoOyB6LS07IHMgPSAnMCcgKyBzKTtcclxuICAgICAgciArPSBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoaiA9IHIubGVuZ3RoOyByLmNoYXJDb2RlQXQoLS1qKSA9PT0gNDg7KTtcclxuXHJcbiAgICByZXR1cm4gci5zbGljZSgwLCBqICsgMSB8fCAxKTtcclxuICB9XHJcblxyXG5cclxuICAvLyBDb21wYXJlIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXJzIHggYW5kIHkuXHJcbiAgZnVuY3Rpb24gY29tcGFyZSh4LCB5KSB7XHJcbiAgICB2YXIgYSwgYixcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHljID0geS5jLFxyXG4gICAgICBpID0geC5zLFxyXG4gICAgICBqID0geS5zLFxyXG4gICAgICBrID0geC5lLFxyXG4gICAgICBsID0geS5lO1xyXG5cclxuICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICBpZiAoIWkgfHwgIWopIHJldHVybiBudWxsO1xyXG5cclxuICAgIGEgPSB4YyAmJiAheGNbMF07XHJcbiAgICBiID0geWMgJiYgIXljWzBdO1xyXG5cclxuICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgaWYgKGEgfHwgYikgcmV0dXJuIGEgPyBiID8gMCA6IC1qIDogaTtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICBpZiAoaSAhPSBqKSByZXR1cm4gaTtcclxuXHJcbiAgICBhID0gaSA8IDA7XHJcbiAgICBiID0gayA9PSBsO1xyXG5cclxuICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gYiA/IDAgOiAheGMgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZXhwb25lbnRzLlxyXG4gICAgaWYgKCFiKSByZXR1cm4gayA+IGwgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIGogPSAoayA9IHhjLmxlbmd0aCkgPCAobCA9IHljLmxlbmd0aCkgPyBrIDogbDtcclxuXHJcbiAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgZm9yIChpID0gMDsgaSA8IGo7IGkrKykgaWYgKHhjW2ldICE9IHljW2ldKSByZXR1cm4geGNbaV0gPiB5Y1tpXSBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gICAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGEgPyAxIDogLTE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDaGVjayB0aGF0IG4gaXMgYSBwcmltaXRpdmUgbnVtYmVyLCBhbiBpbnRlZ2VyLCBhbmQgaW4gcmFuZ2UsIG90aGVyd2lzZSB0aHJvdy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBpbnRDaGVjayhuLCBtaW4sIG1heCwgbmFtZSkge1xyXG4gICAgaWYgKG4gPCBtaW4gfHwgbiA+IG1heCB8fCBuICE9PSBtYXRoZmxvb3IobikpIHtcclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgIChiaWdudW1iZXJFcnJvciArIChuYW1lIHx8ICdBcmd1bWVudCcpICsgKHR5cGVvZiBuID09ICdudW1iZXInXHJcbiAgICAgICAgID8gbiA8IG1pbiB8fCBuID4gbWF4ID8gJyBvdXQgb2YgcmFuZ2U6ICcgOiAnIG5vdCBhbiBpbnRlZ2VyOiAnXHJcbiAgICAgICAgIDogJyBub3QgYSBwcmltaXRpdmUgbnVtYmVyOiAnKSArIFN0cmluZyhuKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQXNzdW1lcyBmaW5pdGUgbi5cclxuICBmdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgICB2YXIgayA9IG4uYy5sZW5ndGggLSAxO1xyXG4gICAgcmV0dXJuIGJpdEZsb29yKG4uZSAvIExPR19CQVNFKSA9PSBrICYmIG4uY1trXSAlIDIgIT0gMDtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0V4cG9uZW50aWFsKHN0ciwgZSkge1xyXG4gICAgcmV0dXJuIChzdHIubGVuZ3RoID4gMSA/IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSkgOiBzdHIpICtcclxuICAgICAoZSA8IDAgPyAnZScgOiAnZSsnKSArIGU7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9GaXhlZFBvaW50KHN0ciwgZSwgeikge1xyXG4gICAgdmFyIGxlbiwgenM7XHJcblxyXG4gICAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XHJcbiAgICBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MuXHJcbiAgICAgIGZvciAoenMgPSB6ICsgJy4nOyArK2U7IHpzICs9IHopO1xyXG4gICAgICBzdHIgPSB6cyArIHN0cjtcclxuXHJcbiAgICAvLyBQb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgICAgaWYgKCsrZSA+IGxlbikge1xyXG4gICAgICAgIGZvciAoenMgPSB6LCBlIC09IGxlbjsgLS1lOyB6cyArPSB6KTtcclxuICAgICAgICBzdHIgKz0genM7XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IGxlbikge1xyXG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gRVhQT1JUXHJcblxyXG5cclxuICBCaWdOdW1iZXIgPSBjbG9uZSgpO1xyXG4gIEJpZ051bWJlclsnZGVmYXVsdCddID0gQmlnTnVtYmVyLkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQU1ELlxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpZ051bWJlcjsgfSk7XHJcblxyXG4gIC8vIE5vZGUuanMgYW5kIG90aGVyIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMuXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQnJvd3Nlci5cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKCFnbG9iYWxPYmplY3QpIHtcclxuICAgICAgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiA/IHNlbGYgOiB3aW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgZ2xvYmFsT2JqZWN0LkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuICB9XHJcbn0pKHRoaXMpO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQSxXQVVBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bignumber.js/bignumber.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/styles/main.scss":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/styles/main.scss ***!
  \***********************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"html,\\nbody {\\n  background-color: #414141;\\n  user-select: none;\\n  text-align: center;\\n  overflow: hidden;\\n  margin: 0px;\\n  width: 100%;\\n  height: 100%;\\n}\\n\\ntable {\\n  margin: auto;\\n  z-index: 1;\\n}\\n\\ncanvas {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n}\\n\\ntr td {\\n  color: lawngreen;\\n  font-size: 20px;\\n}\\n\\ntr td div p {\\n  margin-top: 0px;\\n  margin-bottom: 0px;\\n}\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9zdHlsZXMvbWFpbi5zY3NzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vc3JjL3N0eWxlcy9tYWluLnNjc3M/YTNlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZnVuY3Rpb24oaSl7cmV0dXJuIGlbMV19KTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcImh0bWwsXFxuYm9keSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDE0MTQxO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgbWFyZ2luOiAwcHg7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxuXFxudGFibGUge1xcbiAgbWFyZ2luOiBhdXRvO1xcbiAgei1pbmRleDogMTtcXG59XFxuXFxuY2FudmFzIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxufVxcblxcbnRyIHRkIHtcXG4gIGNvbG9yOiBsYXduZ3JlZW47XFxuICBmb250LXNpemU6IDIwcHg7XFxufVxcblxcbnRyIHRkIGRpdiBwIHtcXG4gIG1hcmdpbi10b3A6IDBweDtcXG4gIG1hcmdpbi1ib3R0b206IDBweDtcXG59XCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/styles/main.scss\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcz8wZTMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzPzA5NTYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/events/events.js\n");

/***/ }),

/***/ "./node_modules/everscale-inpage-provider/dist/api.js":
/*!************************************************************!*\
  !*** ./node_modules/everscale-inpage-provider/dist/api.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLWlucGFnZS1wcm92aWRlci9kaXN0L2FwaS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9ldmVyc2NhbGUtaW5wYWdlLXByb3ZpZGVyL2Rpc3QvYXBpLmpzPzI4YjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/everscale-inpage-provider/dist/api.js\n");

/***/ }),

/***/ "./node_modules/everscale-inpage-provider/dist/contract.js":
/*!*****************************************************************!*\
  !*** ./node_modules/everscale-inpage-provider/dist/contract.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TvmException = exports.Contract = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/everscale-inpage-provider/dist/utils.js\");\nconst models_1 = __webpack_require__(/*! ./models */ \"./node_modules/everscale-inpage-provider/dist/models.js\");\n/**\n * @category Contract\n */\nclass Contract {\n    constructor(provider, abi, address) {\n        if (!Array.isArray(abi.functions)) {\n            throw new Error('Invalid abi. Functions array required');\n        }\n        if (!Array.isArray(abi.events)) {\n            throw new Error('Invalid abi. Events array required');\n        }\n        this._provider = provider;\n        this._abi = JSON.stringify(abi);\n        this._functions = abi.functions.reduce((functions, item) => {\n            functions[item.name] = { inputs: item.inputs || [], outputs: item.outputs || [] };\n            return functions;\n        }, {});\n        this._events = abi.events.reduce((events, item) => {\n            events[item.name] = { inputs: item.inputs || [] };\n            return events;\n        }, {});\n        this._address = address;\n        this._methods = new Proxy({}, {\n            get: (_object, method) => {\n                const rawAbi = this._functions[method];\n                return (params = {}) => new ContractMethodImpl(this._provider, rawAbi, this._abi, this._address, method, params);\n            },\n        });\n    }\n    get methods() {\n        return this._methods;\n    }\n    get address() {\n        return this._address;\n    }\n    get abi() {\n        return this._abi;\n    }\n    /**\n     * Requests contract data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getFullState() {\n        await this._provider.ensureInitialized();\n        return await this._provider.rawApi.getFullContractState({\n            address: this.address.toString(),\n        });\n    }\n    /**\n     * Creates new contract transactions stream\n     *\n     * @param subscriber\n     */\n    transactions(subscriber) {\n        return subscriber.transactions(this._address)\n            .flatMap(({ transactions }) => transactions);\n    }\n    /**\n     * Creates new contract events stream\n     *\n     * @param subscriber\n     */\n    events(subscriber) {\n        return subscriber.transactions(this._address)\n            .flatMap(({ transactions }) => transactions)\n            .flatMap((tx) => this.decodeTransactionEvents({ transaction: tx }).then((events) => {\n            events.forEach((event) => event.transaction = tx);\n            return events;\n        }));\n    }\n    async waitForEvent(args = {}) {\n        const { range, filter } = args;\n        const filterFn = typeof filter === 'string'\n            ? ({ event }) => event === filter\n            : filter;\n        let subscriber = args.subscriber;\n        const hasTempSubscriber = subscriber == null;\n        if (subscriber == null) {\n            subscriber = new this._provider.Subscriber();\n        }\n        const event = await (((range === null || range === void 0 ? void 0 : range.fromLt) != null || (range === null || range === void 0 ? void 0 : range.fromUtime) != null)\n            ? subscriber.oldTransactions(this._address, range)\n                .merge(subscriber.transactions(this._address))\n            : subscriber.transactions(this.address)).flatMap(item => item.transactions)\n            .takeWhile(item => range == null ||\n            (range.fromLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.fromLt) > 0) &&\n                (range.fromUtime == null || item.createdAt > range.fromUtime) &&\n                (range.toLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.toLt) < 0) &&\n                (range.toUtime == null || item.createdAt < range.toUtime))\n            .flatMap(tx => this.decodeTransactionEvents({ transaction: tx })\n            .then((events) => {\n            events.forEach((event) => event.transaction = tx);\n            return events;\n        }))\n            .filterMap(async (event) => {\n            if (filterFn == null || (await filterFn(event))) {\n                return event;\n            }\n            else {\n                return undefined;\n            }\n        })\n            .first();\n        hasTempSubscriber && (await subscriber.unsubscribe());\n        return event;\n    }\n    async getPastEvents(args) {\n        const { range, filter, limit } = args;\n        const filterFn = typeof filter === 'string'\n            ? ({ event }) => event === filter\n            : filter;\n        const result = [];\n        let currentContinuation = args === null || args === void 0 ? void 0 : args.continuation;\n        outer: while (true) {\n            const { transactions, continuation } = await this._provider.getTransactions({\n                address: this._address,\n                continuation: currentContinuation,\n            });\n            if (transactions.length === null) {\n                break;\n            }\n            const filteredTransactions = transactions.filter((item) => (((range === null || range === void 0 ? void 0 : range.fromLt) == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.fromLt) > 0) &&\n                ((range === null || range === void 0 ? void 0 : range.fromUtime) == null || item.createdAt > range.fromUtime) &&\n                ((range === null || range === void 0 ? void 0 : range.toLt) == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.toLt) < 0) &&\n                ((range === null || range === void 0 ? void 0 : range.toUtime) == null || item.createdAt < range.toUtime)));\n            if (filteredTransactions.length > 0) {\n                const parsedEvents = await Promise.all(filteredTransactions.map(async (tx) => {\n                    return {\n                        tx, events: await this.decodeTransactionEvents({ transaction: tx }).then((events) => {\n                            events.forEach((event) => event.transaction = tx);\n                            return events;\n                        }),\n                    };\n                }));\n                for (let { tx, events } of parsedEvents) {\n                    if (filterFn != null) {\n                        events = await Promise.all(events.map(async (event) => (await filterFn(event)) ? event : undefined)).then(events => events.filter((event) => event != null));\n                    }\n                    currentContinuation = tx.id; // update continuation in case of early break\n                    for (const event of events) {\n                        if (limit != null && result.length >= limit) {\n                            break outer;\n                        }\n                        result.push(event);\n                    }\n                    if (limit != null && result.length >= limit) {\n                        break outer;\n                    }\n                }\n            }\n            currentContinuation = continuation;\n            if (currentContinuation == null) {\n                break;\n            }\n        }\n        return { events: result, continuation: currentContinuation };\n    }\n    async decodeTransaction(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeTransaction({\n                transaction: (0, models_1.serializeTransaction)(args.transaction),\n                abi: this._abi,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            const { method, input, output } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},\n                output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeTransactionEvents(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const { events } = await this._provider.rawApi.decodeTransactionEvents({\n                transaction: (0, models_1.serializeTransaction)(args.transaction),\n                abi: this._abi,\n            });\n            const result = [];\n            for (const { event, data } of events) {\n                const rawAbi = this._events[event];\n                result.push({\n                    event,\n                    data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {},\n                });\n            }\n            return result;\n        }\n        catch (_) {\n            return [];\n        }\n    }\n    async decodeInputMessage(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeInput({\n                abi: this._abi,\n                body: args.body,\n                internal: args.internal,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            const { method, input } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeOutputMessage(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeOutput({\n                abi: this._abi,\n                body: args.body,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            const { method, output } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeEvent(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeEvent({\n                abi: this.abi,\n                body: args.body,\n                event: args.events,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            const { event, data } = result;\n            const rawAbi = this._events[event];\n            return {\n                event,\n                data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n}\nexports.Contract = Contract;\n/**\n * @category Contract\n */\nclass TvmException extends Error {\n    constructor(code) {\n        super(`TvmException: ${code}`);\n        this.code = code;\n    }\n}\nexports.TvmException = TvmException;\nclass ContractMethodImpl {\n    constructor(provider, functionAbi, abi, address, method, params) {\n        this.provider = provider;\n        this.functionAbi = functionAbi;\n        this.abi = abi;\n        this.address = address;\n        this.method = method;\n        this.params = (0, models_1.serializeTokensObject)(params);\n    }\n    async send(args) {\n        await this.provider.ensureInitialized();\n        const { transaction } = await this.provider.rawApi.sendMessage({\n            sender: args.from.toString(),\n            recipient: this.address.toString(),\n            amount: args.amount,\n            bounce: args.bounce == null ? true : args.bounce,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n        });\n        return (0, models_1.parseTransaction)(transaction);\n    }\n    async sendDelayed(args) {\n        await this.provider.ensureInitialized();\n        const transactions = new utils_1.DelayedTransactions;\n        const subscription = await this.provider.subscribe('messageStatusUpdated');\n        subscription.on('data', (data) => {\n            if (!data.address.equals(args.from)) {\n                return;\n            }\n            transactions.fillTransaction(data.hash, data.transaction);\n        });\n        const { message } = await this.provider.rawApi.sendMessageDelayed({\n            sender: args.from.toString(),\n            recipient: this.address.toString(),\n            amount: args.amount,\n            bounce: args.bounce == null ? true : args.bounce,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n        }).catch(e => {\n            subscription.unsubscribe().catch(console.error);\n            throw e;\n        });\n        const transaction = transactions\n            .waitTransaction(this.address, message.hash)\n            .finally(() => subscription.unsubscribe().catch(console.error));\n        return {\n            messageHash: message.hash,\n            expireAt: message.expireAt,\n            transaction,\n        };\n    }\n    async sendWithResult(args) {\n        await this.provider.ensureInitialized();\n        let subscriber = args.subscriber;\n        const hasTempSubscriber = subscriber == null;\n        if (subscriber == null) {\n            subscriber = new this.provider.Subscriber();\n        }\n        try {\n            // Parent transaction from wallet\n            let parentTransaction = undefined;\n            // Child transaction promise\n            let resolveChildTransactionPromise;\n            const childTransactionPromise = new Promise((resolve) => {\n                resolveChildTransactionPromise = (tx) => resolve(tx);\n            });\n            // Array for collecting transactions on target before parent transaction promise resolution\n            const possibleChildren = [];\n            // Subscribe to this account\n            subscriber.transactions(this.address)\n                .flatMap(batch => batch.transactions)\n                // Listen only messages from sender\n                .filter(item => { var _a; return ((_a = item.inMessage.src) === null || _a === void 0 ? void 0 : _a.equals(args.from)) || false; })\n                .on((tx) => {\n                if (parentTransaction == null) {\n                    // If we don't known whether the message was sent just collect all transactions from the sender\n                    possibleChildren.push(tx);\n                }\n                else if (parentTransaction.possibleMessages.findIndex((msg) => msg.hash == tx.inMessage.hash) >= 0) {\n                    // Resolve promise if transaction was found\n                    resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(tx);\n                }\n            });\n            // Send message\n            const transaction = await this.send(args);\n            // Extract all outgoing messages from the parent transaction to this contract\n            const possibleMessages = transaction.outMessages.filter(msg => { var _a; return ((_a = msg.dst) === null || _a === void 0 ? void 0 : _a.equals(this.address)) || false; });\n            // Update stream state\n            parentTransaction = {\n                transaction,\n                possibleMessages,\n            };\n            // Check whether child transaction was already found\n            const alreadyReceived = possibleChildren.find((tx) => {\n                return possibleMessages.findIndex((msg) => msg.hash == tx.inMessage.hash) >= 0;\n            });\n            if (alreadyReceived != null) {\n                resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(alreadyReceived);\n            }\n            const childTransaction = await childTransactionPromise;\n            // Parse output\n            let output = undefined;\n            try {\n                const result = await this.provider.rawApi.decodeTransaction({\n                    transaction: (0, models_1.serializeTransaction)(childTransaction),\n                    abi: this.abi,\n                    method: this.method,\n                });\n                if (result != null) {\n                    output = this.functionAbi.outputs != null\n                        ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, result.output)\n                        : {};\n                }\n            }\n            catch (e) {\n                console.error(e);\n            }\n            // Done\n            return {\n                parentTransaction: parentTransaction.transaction,\n                childTransaction,\n                output,\n            };\n        }\n        finally {\n            hasTempSubscriber && (await subscriber.unsubscribe());\n        }\n    }\n    async estimateFees(args) {\n        await this.provider.ensureInitialized();\n        const { fees } = await this.provider.rawApi.estimateFees({\n            sender: args.from.toString(),\n            recipient: this.address.toString(),\n            amount: args.amount,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n        });\n        return fees;\n    }\n    async sendExternal(args) {\n        await this.provider.ensureInitialized();\n        const method = args.withoutSignature === true\n            ? this.provider.rawApi.sendUnsignedExternalMessage\n            : this.provider.rawApi.sendExternalMessage;\n        const { transaction, output } = await method({\n            publicKey: args.publicKey,\n            recipient: this.address.toString(),\n            stateInit: args.stateInit,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n            local: args.local,\n        });\n        return {\n            transaction: (0, models_1.parseTransaction)(transaction),\n            output: output != null ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, output) : undefined,\n        };\n    }\n    async sendExternalDelayed(args) {\n        await this.provider.ensureInitialized();\n        const transactions = new utils_1.DelayedTransactions;\n        const subscription = await this.provider.subscribe('messageStatusUpdated');\n        subscription.on('data', (data) => {\n            if (!data.address.equals(this.address)) {\n                return;\n            }\n            transactions.fillTransaction(data.hash, data.transaction);\n        });\n        const { message } = await this.provider.rawApi.sendExternalMessageDelayed({\n            publicKey: args.publicKey,\n            recipient: this.address.toString(),\n            stateInit: args.stateInit,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n        }).catch(e => {\n            subscription.unsubscribe().catch(console.error);\n            throw e;\n        });\n        const transaction = transactions\n            .waitTransaction(this.address, message.hash)\n            .finally(() => subscription.unsubscribe().catch(console.error));\n        return {\n            messageHash: message.hash,\n            expireAt: message.expireAt,\n            transaction,\n        };\n    }\n    async call(args = {}) {\n        await this.provider.ensureInitialized();\n        const { output, code } = await this.provider.rawApi.runLocal({\n            address: this.address.toString(),\n            cachedState: args.cachedState,\n            responsible: args.responsible,\n            functionCall: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n        });\n        if (output == null || code != 0) {\n            throw new TvmException(code);\n        }\n        else {\n            return (0, models_1.parseTokensObject)(this.functionAbi.outputs, output);\n        }\n    }\n    async encodeInternal() {\n        await this.provider.ensureInitialized();\n        const { boc } = await this.provider.rawApi.encodeInternalInput({\n            abi: this.abi,\n            method: this.method,\n            params: this.params,\n        });\n        return boc;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLWlucGFnZS1wcm92aWRlci9kaXN0L2NvbnRyYWN0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXIvZGlzdC9jb250cmFjdC5qcz9jODBkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Udm1FeGNlcHRpb24gPSBleHBvcnRzLkNvbnRyYWN0ID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgbW9kZWxzXzEgPSByZXF1aXJlKFwiLi9tb2RlbHNcIik7XG4vKipcbiAqIEBjYXRlZ29yeSBDb250cmFjdFxuICovXG5jbGFzcyBDb250cmFjdCB7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFiaSwgYWRkcmVzcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWJpLmZ1bmN0aW9ucykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhYmkuIEZ1bmN0aW9ucyBhcnJheSByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhYmkuZXZlbnRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFiaS4gRXZlbnRzIGFycmF5IHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5fYWJpID0gSlNPTi5zdHJpbmdpZnkoYWJpKTtcbiAgICAgICAgdGhpcy5fZnVuY3Rpb25zID0gYWJpLmZ1bmN0aW9ucy5yZWR1Y2UoKGZ1bmN0aW9ucywgaXRlbSkgPT4ge1xuICAgICAgICAgICAgZnVuY3Rpb25zW2l0ZW0ubmFtZV0gPSB7IGlucHV0czogaXRlbS5pbnB1dHMgfHwgW10sIG91dHB1dHM6IGl0ZW0ub3V0cHV0cyB8fCBbXSB9O1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9ucztcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBhYmkuZXZlbnRzLnJlZHVjZSgoZXZlbnRzLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICBldmVudHNbaXRlbS5uYW1lXSA9IHsgaW5wdXRzOiBpdGVtLmlucHV0cyB8fCBbXSB9O1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLl9hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5fbWV0aG9kcyA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgZ2V0OiAoX29iamVjdCwgbWV0aG9kKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3QWJpID0gdGhpcy5fZnVuY3Rpb25zW21ldGhvZF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwYXJhbXMgPSB7fSkgPT4gbmV3IENvbnRyYWN0TWV0aG9kSW1wbCh0aGlzLl9wcm92aWRlciwgcmF3QWJpLCB0aGlzLl9hYmksIHRoaXMuX2FkZHJlc3MsIG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWV0aG9kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGhvZHM7XG4gICAgfVxuICAgIGdldCBhZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkcmVzcztcbiAgICB9XG4gICAgZ2V0IGFiaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FiaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgY29udHJhY3QgZGF0YVxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBnZXRGdWxsU3RhdGUoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3Byb3ZpZGVyLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9wcm92aWRlci5yYXdBcGkuZ2V0RnVsbENvbnRyYWN0U3RhdGUoe1xuICAgICAgICAgICAgYWRkcmVzczogdGhpcy5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG5ldyBjb250cmFjdCB0cmFuc2FjdGlvbnMgc3RyZWFtXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3Vic2NyaWJlclxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9ucyhzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyLnRyYW5zYWN0aW9ucyh0aGlzLl9hZGRyZXNzKVxuICAgICAgICAgICAgLmZsYXRNYXAoKHsgdHJhbnNhY3Rpb25zIH0pID0+IHRyYW5zYWN0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IGNvbnRyYWN0IGV2ZW50cyBzdHJlYW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJzY3JpYmVyXG4gICAgICovXG4gICAgZXZlbnRzKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXIudHJhbnNhY3Rpb25zKHRoaXMuX2FkZHJlc3MpXG4gICAgICAgICAgICAuZmxhdE1hcCgoeyB0cmFuc2FjdGlvbnMgfSkgPT4gdHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgLmZsYXRNYXAoKHR4KSA9PiB0aGlzLmRlY29kZVRyYW5zYWN0aW9uRXZlbnRzKHsgdHJhbnNhY3Rpb246IHR4IH0pLnRoZW4oKGV2ZW50cykgPT4ge1xuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiBldmVudC50cmFuc2FjdGlvbiA9IHR4KTtcbiAgICAgICAgICAgIHJldHVybiBldmVudHM7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgd2FpdEZvckV2ZW50KGFyZ3MgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHJhbmdlLCBmaWx0ZXIgfSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IGZpbHRlckZuID0gdHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gKHsgZXZlbnQgfSkgPT4gZXZlbnQgPT09IGZpbHRlclxuICAgICAgICAgICAgOiBmaWx0ZXI7XG4gICAgICAgIGxldCBzdWJzY3JpYmVyID0gYXJncy5zdWJzY3JpYmVyO1xuICAgICAgICBjb25zdCBoYXNUZW1wU3Vic2NyaWJlciA9IHN1YnNjcmliZXIgPT0gbnVsbDtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlciA9IG5ldyB0aGlzLl9wcm92aWRlci5TdWJzY3JpYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnQgPSBhd2FpdCAoKChyYW5nZSA9PT0gbnVsbCB8fCByYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFuZ2UuZnJvbUx0KSAhPSBudWxsIHx8IChyYW5nZSA9PT0gbnVsbCB8fCByYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFuZ2UuZnJvbVV0aW1lKSAhPSBudWxsKVxuICAgICAgICAgICAgPyBzdWJzY3JpYmVyLm9sZFRyYW5zYWN0aW9ucyh0aGlzLl9hZGRyZXNzLCByYW5nZSlcbiAgICAgICAgICAgICAgICAubWVyZ2Uoc3Vic2NyaWJlci50cmFuc2FjdGlvbnModGhpcy5fYWRkcmVzcykpXG4gICAgICAgICAgICA6IHN1YnNjcmliZXIudHJhbnNhY3Rpb25zKHRoaXMuYWRkcmVzcykpLmZsYXRNYXAoaXRlbSA9PiBpdGVtLnRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIC50YWtlV2hpbGUoaXRlbSA9PiByYW5nZSA9PSBudWxsIHx8XG4gICAgICAgICAgICAocmFuZ2UuZnJvbUx0ID09IG51bGwgfHwgdXRpbHNfMS5MVF9DT0xMQVRPUi5jb21wYXJlKGl0ZW0uaWQubHQsIHJhbmdlLmZyb21MdCkgPiAwKSAmJlxuICAgICAgICAgICAgICAgIChyYW5nZS5mcm9tVXRpbWUgPT0gbnVsbCB8fCBpdGVtLmNyZWF0ZWRBdCA+IHJhbmdlLmZyb21VdGltZSkgJiZcbiAgICAgICAgICAgICAgICAocmFuZ2UudG9MdCA9PSBudWxsIHx8IHV0aWxzXzEuTFRfQ09MTEFUT1IuY29tcGFyZShpdGVtLmlkLmx0LCByYW5nZS50b0x0KSA8IDApICYmXG4gICAgICAgICAgICAgICAgKHJhbmdlLnRvVXRpbWUgPT0gbnVsbCB8fCBpdGVtLmNyZWF0ZWRBdCA8IHJhbmdlLnRvVXRpbWUpKVxuICAgICAgICAgICAgLmZsYXRNYXAodHggPT4gdGhpcy5kZWNvZGVUcmFuc2FjdGlvbkV2ZW50cyh7IHRyYW5zYWN0aW9uOiB0eCB9KVxuICAgICAgICAgICAgLnRoZW4oKGV2ZW50cykgPT4ge1xuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiBldmVudC50cmFuc2FjdGlvbiA9IHR4KTtcbiAgICAgICAgICAgIHJldHVybiBldmVudHM7XG4gICAgICAgIH0pKVxuICAgICAgICAgICAgLmZpbHRlck1hcChhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJGbiA9PSBudWxsIHx8IChhd2FpdCBmaWx0ZXJGbihldmVudCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maXJzdCgpO1xuICAgICAgICBoYXNUZW1wU3Vic2NyaWJlciAmJiAoYXdhaXQgc3Vic2NyaWJlci51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgICBhc3luYyBnZXRQYXN0RXZlbnRzKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgeyByYW5nZSwgZmlsdGVyLCBsaW1pdCB9ID0gYXJncztcbiAgICAgICAgY29uc3QgZmlsdGVyRm4gPSB0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyAoeyBldmVudCB9KSA9PiBldmVudCA9PT0gZmlsdGVyXG4gICAgICAgICAgICA6IGZpbHRlcjtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBjdXJyZW50Q29udGludWF0aW9uID0gYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLmNvbnRpbnVhdGlvbjtcbiAgICAgICAgb3V0ZXI6IHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9ucywgY29udGludWF0aW9uIH0gPSBhd2FpdCB0aGlzLl9wcm92aWRlci5nZXRUcmFuc2FjdGlvbnMoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuX2FkZHJlc3MsXG4gICAgICAgICAgICAgICAgY29udGludWF0aW9uOiBjdXJyZW50Q29udGludWF0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRUcmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMuZmlsdGVyKChpdGVtKSA9PiAoKChyYW5nZSA9PT0gbnVsbCB8fCByYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFuZ2UuZnJvbUx0KSA9PSBudWxsIHx8IHV0aWxzXzEuTFRfQ09MTEFUT1IuY29tcGFyZShpdGVtLmlkLmx0LCByYW5nZS5mcm9tTHQpID4gMCkgJiZcbiAgICAgICAgICAgICAgICAoKHJhbmdlID09PSBudWxsIHx8IHJhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByYW5nZS5mcm9tVXRpbWUpID09IG51bGwgfHwgaXRlbS5jcmVhdGVkQXQgPiByYW5nZS5mcm9tVXRpbWUpICYmXG4gICAgICAgICAgICAgICAgKChyYW5nZSA9PT0gbnVsbCB8fCByYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFuZ2UudG9MdCkgPT0gbnVsbCB8fCB1dGlsc18xLkxUX0NPTExBVE9SLmNvbXBhcmUoaXRlbS5pZC5sdCwgcmFuZ2UudG9MdCkgPCAwKSAmJlxuICAgICAgICAgICAgICAgICgocmFuZ2UgPT09IG51bGwgfHwgcmFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhbmdlLnRvVXRpbWUpID09IG51bGwgfHwgaXRlbS5jcmVhdGVkQXQgPCByYW5nZS50b1V0aW1lKSkpO1xuICAgICAgICAgICAgaWYgKGZpbHRlcmVkVHJhbnNhY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRFdmVudHMgPSBhd2FpdCBQcm9taXNlLmFsbChmaWx0ZXJlZFRyYW5zYWN0aW9ucy5tYXAoYXN5bmMgKHR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eCwgZXZlbnRzOiBhd2FpdCB0aGlzLmRlY29kZVRyYW5zYWN0aW9uRXZlbnRzKHsgdHJhbnNhY3Rpb246IHR4IH0pLnRoZW4oKGV2ZW50cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4gZXZlbnQudHJhbnNhY3Rpb24gPSB0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB7IHR4LCBldmVudHMgfSBvZiBwYXJzZWRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlckZuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cyA9IGF3YWl0IFByb21pc2UuYWxsKGV2ZW50cy5tYXAoYXN5bmMgKGV2ZW50KSA9PiAoYXdhaXQgZmlsdGVyRm4oZXZlbnQpKSA/IGV2ZW50IDogdW5kZWZpbmVkKSkudGhlbihldmVudHMgPT4gZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IGV2ZW50ICE9IG51bGwpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGludWF0aW9uID0gdHguaWQ7IC8vIHVwZGF0ZSBjb250aW51YXRpb24gaW4gY2FzZSBvZiBlYXJseSBicmVha1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbWl0ICE9IG51bGwgJiYgcmVzdWx0Lmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCAhPSBudWxsICYmIHJlc3VsdC5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudENvbnRpbnVhdGlvbiA9IGNvbnRpbnVhdGlvbjtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29udGludWF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBldmVudHM6IHJlc3VsdCwgY29udGludWF0aW9uOiBjdXJyZW50Q29udGludWF0aW9uIH07XG4gICAgfVxuICAgIGFzeW5jIGRlY29kZVRyYW5zYWN0aW9uKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fcHJvdmlkZXIuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3Byb3ZpZGVyLnJhd0FwaS5kZWNvZGVUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246ICgwLCBtb2RlbHNfMS5zZXJpYWxpemVUcmFuc2FjdGlvbikoYXJncy50cmFuc2FjdGlvbiksXG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLl9hYmksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBhcmdzLm1ldGhvZHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IG1ldGhvZCwgaW5wdXQsIG91dHB1dCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgcmF3QWJpID0gdGhpcy5fZnVuY3Rpb25zW21ldGhvZF07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBpbnB1dDogcmF3QWJpLmlucHV0cyAhPSBudWxsID8gKDAsIG1vZGVsc18xLnBhcnNlVG9rZW5zT2JqZWN0KShyYXdBYmkuaW5wdXRzLCBpbnB1dCkgOiB7fSxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHJhd0FiaS5vdXRwdXRzICE9IG51bGwgPyAoMCwgbW9kZWxzXzEucGFyc2VUb2tlbnNPYmplY3QpKHJhd0FiaS5vdXRwdXRzLCBvdXRwdXQpIDoge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlY29kZVRyYW5zYWN0aW9uRXZlbnRzKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fcHJvdmlkZXIuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXZlbnRzIH0gPSBhd2FpdCB0aGlzLl9wcm92aWRlci5yYXdBcGkuZGVjb2RlVHJhbnNhY3Rpb25FdmVudHMoe1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiAoMCwgbW9kZWxzXzEuc2VyaWFsaXplVHJhbnNhY3Rpb24pKGFyZ3MudHJhbnNhY3Rpb24pLFxuICAgICAgICAgICAgICAgIGFiaTogdGhpcy5fYWJpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBldmVudCwgZGF0YSB9IG9mIGV2ZW50cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhd0FiaSA9IHRoaXMuX2V2ZW50c1tldmVudF07XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogcmF3QWJpLmlucHV0cyAhPSBudWxsID8gKDAsIG1vZGVsc18xLnBhcnNlVG9rZW5zT2JqZWN0KShyYXdBYmkuaW5wdXRzLCBkYXRhKSA6IHt9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlY29kZUlucHV0TWVzc2FnZShhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3Byb3ZpZGVyLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9wcm92aWRlci5yYXdBcGkuZGVjb2RlSW5wdXQoe1xuICAgICAgICAgICAgICAgIGFiaTogdGhpcy5fYWJpLFxuICAgICAgICAgICAgICAgIGJvZHk6IGFyZ3MuYm9keSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbDogYXJncy5pbnRlcm5hbCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGFyZ3MubWV0aG9kcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgbWV0aG9kLCBpbnB1dCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgcmF3QWJpID0gdGhpcy5fZnVuY3Rpb25zW21ldGhvZF07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBpbnB1dDogcmF3QWJpLmlucHV0cyAhPSBudWxsID8gKDAsIG1vZGVsc18xLnBhcnNlVG9rZW5zT2JqZWN0KShyYXdBYmkuaW5wdXRzLCBpbnB1dCkgOiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVjb2RlT3V0cHV0TWVzc2FnZShhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3Byb3ZpZGVyLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9wcm92aWRlci5yYXdBcGkuZGVjb2RlT3V0cHV0KHtcbiAgICAgICAgICAgICAgICBhYmk6IHRoaXMuX2FiaSxcbiAgICAgICAgICAgICAgICBib2R5OiBhcmdzLmJvZHksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBhcmdzLm1ldGhvZHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IG1ldGhvZCwgb3V0cHV0IH0gPSByZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCByYXdBYmkgPSB0aGlzLl9mdW5jdGlvbnNbbWV0aG9kXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgIG91dHB1dDogcmF3QWJpLm91dHB1dHMgIT0gbnVsbCA/ICgwLCBtb2RlbHNfMS5wYXJzZVRva2Vuc09iamVjdCkocmF3QWJpLm91dHB1dHMsIG91dHB1dCkgOiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVjb2RlRXZlbnQoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLl9wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fcHJvdmlkZXIucmF3QXBpLmRlY29kZUV2ZW50KHtcbiAgICAgICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgICAgIGJvZHk6IGFyZ3MuYm9keSxcbiAgICAgICAgICAgICAgICBldmVudDogYXJncy5ldmVudHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGV2ZW50LCBkYXRhIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCByYXdBYmkgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBkYXRhOiByYXdBYmkuaW5wdXRzICE9IG51bGwgPyAoMCwgbW9kZWxzXzEucGFyc2VUb2tlbnNPYmplY3QpKHJhd0FiaS5pbnB1dHMsIGRhdGEpIDoge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Db250cmFjdCA9IENvbnRyYWN0O1xuLyoqXG4gKiBAY2F0ZWdvcnkgQ29udHJhY3RcbiAqL1xuY2xhc3MgVHZtRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICAgICAgc3VwZXIoYFR2bUV4Y2VwdGlvbjogJHtjb2RlfWApO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuVHZtRXhjZXB0aW9uID0gVHZtRXhjZXB0aW9uO1xuY2xhc3MgQ29udHJhY3RNZXRob2RJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZnVuY3Rpb25BYmksIGFiaSwgYWRkcmVzcywgbWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uQWJpID0gZnVuY3Rpb25BYmk7XG4gICAgICAgIHRoaXMuYWJpID0gYWJpO1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSAoMCwgbW9kZWxzXzEuc2VyaWFsaXplVG9rZW5zT2JqZWN0KShwYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJhd0FwaS5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICBzZW5kZXI6IGFyZ3MuZnJvbS50b1N0cmluZygpLFxuICAgICAgICAgICAgcmVjaXBpZW50OiB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGFtb3VudDogYXJncy5hbW91bnQsXG4gICAgICAgICAgICBib3VuY2U6IGFyZ3MuYm91bmNlID09IG51bGwgPyB0cnVlIDogYXJncy5ib3VuY2UsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogdGhpcy5wYXJhbXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgwLCBtb2RlbHNfMS5wYXJzZVRyYW5zYWN0aW9uKSh0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIHNlbmREZWxheWVkKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBuZXcgdXRpbHNfMS5EZWxheWVkVHJhbnNhY3Rpb25zO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnN1YnNjcmliZSgnbWVzc2FnZVN0YXR1c1VwZGF0ZWQnKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmICghZGF0YS5hZGRyZXNzLmVxdWFscyhhcmdzLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNhY3Rpb25zLmZpbGxUcmFuc2FjdGlvbihkYXRhLmhhc2gsIGRhdGEudHJhbnNhY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJhd0FwaS5zZW5kTWVzc2FnZURlbGF5ZWQoe1xuICAgICAgICAgICAgc2VuZGVyOiBhcmdzLmZyb20udG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHJlY2lwaWVudDogdGhpcy5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBhbW91bnQ6IGFyZ3MuYW1vdW50LFxuICAgICAgICAgICAgYm91bmNlOiBhcmdzLmJvdW5jZSA9PSBudWxsID8gdHJ1ZSA6IGFyZ3MuYm91bmNlLFxuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgIGFiaTogdGhpcy5hYmksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHRoaXMucGFyYW1zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgLndhaXRUcmFuc2FjdGlvbih0aGlzLmFkZHJlc3MsIG1lc3NhZ2UuaGFzaClcbiAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpLmNhdGNoKGNvbnNvbGUuZXJyb3IpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2VIYXNoOiBtZXNzYWdlLmhhc2gsXG4gICAgICAgICAgICBleHBpcmVBdDogbWVzc2FnZS5leHBpcmVBdCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzZW5kV2l0aFJlc3VsdChhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXIuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgbGV0IHN1YnNjcmliZXIgPSBhcmdzLnN1YnNjcmliZXI7XG4gICAgICAgIGNvbnN0IGhhc1RlbXBTdWJzY3JpYmVyID0gc3Vic2NyaWJlciA9PSBudWxsO1xuICAgICAgICBpZiAoc3Vic2NyaWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyID0gbmV3IHRoaXMucHJvdmlkZXIuU3Vic2NyaWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBQYXJlbnQgdHJhbnNhY3Rpb24gZnJvbSB3YWxsZXRcbiAgICAgICAgICAgIGxldCBwYXJlbnRUcmFuc2FjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIENoaWxkIHRyYW5zYWN0aW9uIHByb21pc2VcbiAgICAgICAgICAgIGxldCByZXNvbHZlQ2hpbGRUcmFuc2FjdGlvblByb21pc2U7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFRyYW5zYWN0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNoaWxkVHJhbnNhY3Rpb25Qcm9taXNlID0gKHR4KSA9PiByZXNvbHZlKHR4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQXJyYXkgZm9yIGNvbGxlY3RpbmcgdHJhbnNhY3Rpb25zIG9uIHRhcmdldCBiZWZvcmUgcGFyZW50IHRyYW5zYWN0aW9uIHByb21pc2UgcmVzb2x1dGlvblxuICAgICAgICAgICAgY29uc3QgcG9zc2libGVDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoaXMgYWNjb3VudFxuICAgICAgICAgICAgc3Vic2NyaWJlci50cmFuc2FjdGlvbnModGhpcy5hZGRyZXNzKVxuICAgICAgICAgICAgICAgIC5mbGF0TWFwKGJhdGNoID0+IGJhdGNoLnRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgICAgICAvLyBMaXN0ZW4gb25seSBtZXNzYWdlcyBmcm9tIHNlbmRlclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSBpdGVtLmluTWVzc2FnZS5zcmMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lcXVhbHMoYXJncy5mcm9tKSkgfHwgZmFsc2U7IH0pXG4gICAgICAgICAgICAgICAgLm9uKCh0eCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGtub3duIHdoZXRoZXIgdGhlIG1lc3NhZ2Ugd2FzIHNlbnQganVzdCBjb2xsZWN0IGFsbCB0cmFuc2FjdGlvbnMgZnJvbSB0aGUgc2VuZGVyXG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2hpbGRyZW4ucHVzaCh0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudFRyYW5zYWN0aW9uLnBvc3NpYmxlTWVzc2FnZXMuZmluZEluZGV4KChtc2cpID0+IG1zZy5oYXNoID09IHR4LmluTWVzc2FnZS5oYXNoKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgcHJvbWlzZSBpZiB0cmFuc2FjdGlvbiB3YXMgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNoaWxkVHJhbnNhY3Rpb25Qcm9taXNlID09PSBudWxsIHx8IHJlc29sdmVDaGlsZFRyYW5zYWN0aW9uUHJvbWlzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzb2x2ZUNoaWxkVHJhbnNhY3Rpb25Qcm9taXNlKHR4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFNlbmQgbWVzc2FnZVxuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLnNlbmQoYXJncyk7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IGFsbCBvdXRnb2luZyBtZXNzYWdlcyBmcm9tIHRoZSBwYXJlbnQgdHJhbnNhY3Rpb24gdG8gdGhpcyBjb250cmFjdFxuICAgICAgICAgICAgY29uc3QgcG9zc2libGVNZXNzYWdlcyA9IHRyYW5zYWN0aW9uLm91dE1lc3NhZ2VzLmZpbHRlcihtc2cgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gbXNnLmRzdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVxdWFscyh0aGlzLmFkZHJlc3MpKSB8fCBmYWxzZTsgfSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgc3RyZWFtIHN0YXRlXG4gICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBwb3NzaWJsZU1lc3NhZ2VzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgY2hpbGQgdHJhbnNhY3Rpb24gd2FzIGFscmVhZHkgZm91bmRcbiAgICAgICAgICAgIGNvbnN0IGFscmVhZHlSZWNlaXZlZCA9IHBvc3NpYmxlQ2hpbGRyZW4uZmluZCgodHgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zc2libGVNZXNzYWdlcy5maW5kSW5kZXgoKG1zZykgPT4gbXNnLmhhc2ggPT0gdHguaW5NZXNzYWdlLmhhc2gpID49IDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhbHJlYWR5UmVjZWl2ZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVDaGlsZFRyYW5zYWN0aW9uUHJvbWlzZSA9PT0gbnVsbCB8fCByZXNvbHZlQ2hpbGRUcmFuc2FjdGlvblByb21pc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc29sdmVDaGlsZFRyYW5zYWN0aW9uUHJvbWlzZShhbHJlYWR5UmVjZWl2ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hpbGRUcmFuc2FjdGlvbiA9IGF3YWl0IGNoaWxkVHJhbnNhY3Rpb25Qcm9taXNlO1xuICAgICAgICAgICAgLy8gUGFyc2Ugb3V0cHV0XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJhd0FwaS5kZWNvZGVUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiAoMCwgbW9kZWxzXzEuc2VyaWFsaXplVHJhbnNhY3Rpb24pKGNoaWxkVHJhbnNhY3Rpb24pLFxuICAgICAgICAgICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLmZ1bmN0aW9uQWJpLm91dHB1dHMgIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoMCwgbW9kZWxzXzEucGFyc2VUb2tlbnNPYmplY3QpKHRoaXMuZnVuY3Rpb25BYmkub3V0cHV0cywgcmVzdWx0Lm91dHB1dClcbiAgICAgICAgICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG9uZVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbjogcGFyZW50VHJhbnNhY3Rpb24udHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgY2hpbGRUcmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaGFzVGVtcFN1YnNjcmliZXIgJiYgKGF3YWl0IHN1YnNjcmliZXIudW5zdWJzY3JpYmUoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZXN0aW1hdGVGZWVzKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IGZlZXMgfSA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmF3QXBpLmVzdGltYXRlRmVlcyh7XG4gICAgICAgICAgICBzZW5kZXI6IGFyZ3MuZnJvbS50b1N0cmluZygpLFxuICAgICAgICAgICAgcmVjaXBpZW50OiB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGFtb3VudDogYXJncy5hbW91bnQsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogdGhpcy5wYXJhbXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZlZXM7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRFeHRlcm5hbChhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXIuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gYXJncy53aXRob3V0U2lnbmF0dXJlID09PSB0cnVlXG4gICAgICAgICAgICA/IHRoaXMucHJvdmlkZXIucmF3QXBpLnNlbmRVbnNpZ25lZEV4dGVybmFsTWVzc2FnZVxuICAgICAgICAgICAgOiB0aGlzLnByb3ZpZGVyLnJhd0FwaS5zZW5kRXh0ZXJuYWxNZXNzYWdlO1xuICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9uLCBvdXRwdXQgfSA9IGF3YWl0IG1ldGhvZCh7XG4gICAgICAgICAgICBwdWJsaWNLZXk6IGFyZ3MucHVibGljS2V5LFxuICAgICAgICAgICAgcmVjaXBpZW50OiB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHN0YXRlSW5pdDogYXJncy5zdGF0ZUluaXQsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogdGhpcy5wYXJhbXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9jYWw6IGFyZ3MubG9jYWwsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246ICgwLCBtb2RlbHNfMS5wYXJzZVRyYW5zYWN0aW9uKSh0cmFuc2FjdGlvbiksXG4gICAgICAgICAgICBvdXRwdXQ6IG91dHB1dCAhPSBudWxsID8gKDAsIG1vZGVsc18xLnBhcnNlVG9rZW5zT2JqZWN0KSh0aGlzLmZ1bmN0aW9uQWJpLm91dHB1dHMsIG91dHB1dCkgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHNlbmRFeHRlcm5hbERlbGF5ZWQoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLnByb3ZpZGVyLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IG5ldyB1dGlsc18xLkRlbGF5ZWRUcmFuc2FjdGlvbnM7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IHRoaXMucHJvdmlkZXIuc3Vic2NyaWJlKCdtZXNzYWdlU3RhdHVzVXBkYXRlZCcpO1xuICAgICAgICBzdWJzY3JpcHRpb24ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkYXRhLmFkZHJlc3MuZXF1YWxzKHRoaXMuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2FjdGlvbnMuZmlsbFRyYW5zYWN0aW9uKGRhdGEuaGFzaCwgZGF0YS50cmFuc2FjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmF3QXBpLnNlbmRFeHRlcm5hbE1lc3NhZ2VEZWxheWVkKHtcbiAgICAgICAgICAgIHB1YmxpY0tleTogYXJncy5wdWJsaWNLZXksXG4gICAgICAgICAgICByZWNpcGllbnQ6IHRoaXMuYWRkcmVzcy50b1N0cmluZygpLFxuICAgICAgICAgICAgc3RhdGVJbml0OiBhcmdzLnN0YXRlSW5pdCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB0aGlzLnBhcmFtcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgIC53YWl0VHJhbnNhY3Rpb24odGhpcy5hZGRyZXNzLCBtZXNzYWdlLmhhc2gpXG4gICAgICAgICAgICAuZmluYWxseSgoKSA9PiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKS5jYXRjaChjb25zb2xlLmVycm9yKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlSGFzaDogbWVzc2FnZS5oYXNoLFxuICAgICAgICAgICAgZXhwaXJlQXQ6IG1lc3NhZ2UuZXhwaXJlQXQsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbChhcmdzID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IG91dHB1dCwgY29kZSB9ID0gYXdhaXQgdGhpcy5wcm92aWRlci5yYXdBcGkucnVuTG9jYWwoe1xuICAgICAgICAgICAgYWRkcmVzczogdGhpcy5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBjYWNoZWRTdGF0ZTogYXJncy5jYWNoZWRTdGF0ZSxcbiAgICAgICAgICAgIHJlc3BvbnNpYmxlOiBhcmdzLnJlc3BvbnNpYmxlLFxuICAgICAgICAgICAgZnVuY3Rpb25DYWxsOiB7XG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogdGhpcy5wYXJhbXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dHB1dCA9PSBudWxsIHx8IGNvZGUgIT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR2bUV4Y2VwdGlvbihjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgbW9kZWxzXzEucGFyc2VUb2tlbnNPYmplY3QpKHRoaXMuZnVuY3Rpb25BYmkub3V0cHV0cywgb3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBlbmNvZGVJbnRlcm5hbCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IGJvYyB9ID0gYXdhaXQgdGhpcy5wcm92aWRlci5yYXdBcGkuZW5jb2RlSW50ZXJuYWxJbnB1dCh7XG4gICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy5wYXJhbXMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYm9jO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/everscale-inpage-provider/dist/contract.js\n");

/***/ }),

/***/ "./node_modules/everscale-inpage-provider/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/everscale-inpage-provider/dist/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ProviderNotInitializedException = exports.ProviderNotFoundException = exports.ProviderRpcClient = exports.hasEverscaleProvider = exports.LT_COLLATOR = exports.mergeTransactions = exports.MessageExpiredException = exports.AddressLiteral = exports.Address = exports.Subscriber = void 0;\nconst models_1 = __webpack_require__(/*! ./models */ \"./node_modules/everscale-inpage-provider/dist/models.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/everscale-inpage-provider/dist/utils.js\");\nconst subscriber = __importStar(__webpack_require__(/*! ./stream */ \"./node_modules/everscale-inpage-provider/dist/stream.js\"));\nconst contract = __importStar(__webpack_require__(/*! ./contract */ \"./node_modules/everscale-inpage-provider/dist/contract.js\"));\n__exportStar(__webpack_require__(/*! ./api */ \"./node_modules/everscale-inpage-provider/dist/api.js\"), exports);\n__exportStar(__webpack_require__(/*! ./models */ \"./node_modules/everscale-inpage-provider/dist/models.js\"), exports);\n__exportStar(__webpack_require__(/*! ./contract */ \"./node_modules/everscale-inpage-provider/dist/contract.js\"), exports);\nvar stream_1 = __webpack_require__(/*! ./stream */ \"./node_modules/everscale-inpage-provider/dist/stream.js\");\nObject.defineProperty(exports, \"Subscriber\", ({ enumerable: true, get: function () { return stream_1.Subscriber; } }));\nvar utils_2 = __webpack_require__(/*! ./utils */ \"./node_modules/everscale-inpage-provider/dist/utils.js\");\nObject.defineProperty(exports, \"Address\", ({ enumerable: true, get: function () { return utils_2.Address; } }));\nObject.defineProperty(exports, \"AddressLiteral\", ({ enumerable: true, get: function () { return utils_2.AddressLiteral; } }));\nObject.defineProperty(exports, \"MessageExpiredException\", ({ enumerable: true, get: function () { return utils_2.MessageExpiredException; } }));\nObject.defineProperty(exports, \"mergeTransactions\", ({ enumerable: true, get: function () { return utils_2.mergeTransactions; } }));\nObject.defineProperty(exports, \"LT_COLLATOR\", ({ enumerable: true, get: function () { return utils_2.LT_COLLATOR; } }));\nconst isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\nlet ensurePageLoaded;\nif (!isBrowser || document.readyState === 'complete') {\n    ensurePageLoaded = Promise.resolve();\n}\nelse {\n    ensurePageLoaded = new Promise((resolve) => {\n        window.addEventListener('load', () => {\n            resolve();\n        });\n    });\n}\nconst getProvider = () => isBrowser ? window.__ever || window.ton : undefined;\n/**\n * @category Provider\n */\nasync function hasEverscaleProvider() {\n    if (!isBrowser) {\n        return false;\n    }\n    await ensurePageLoaded;\n    return window.__hasEverscaleProvider === true || window.hasTonProvider === true;\n}\nexports.hasEverscaleProvider = hasEverscaleProvider;\n/**\n * @category Provider\n */\nclass ProviderRpcClient {\n    constructor(properties = {}) {\n        this._subscriptions = {\n            connected: new Map(),\n            disconnected: new Map(),\n            transactionsFound: new Map(),\n            contractStateChanged: new Map(),\n            messageStatusUpdated: new Map(),\n            networkChanged: new Map(),\n            permissionsChanged: new Map(),\n            loggedOut: new Map(),\n        };\n        this._contractSubscriptions = new Map();\n        this._properties = properties;\n        const self = this;\n        // Create contract proxy type\n        class ProviderContract extends contract.Contract {\n            constructor(abi, address) {\n                super(self, abi, address);\n            }\n        }\n        this.Contract = ProviderContract;\n        // Create subscriber proxy type\n        class ProviderSubscriber extends subscriber.Subscriber {\n            constructor() {\n                super(self);\n            }\n        }\n        this.Subscriber = ProviderSubscriber;\n        // Wrap provider requests\n        this._api = new Proxy({}, {\n            get: (_object, method) => (params) => {\n                if (this._provider != null) {\n                    return this._provider.request({ method, params });\n                }\n                else {\n                    throw new ProviderNotInitializedException();\n                }\n            },\n        });\n        if (properties.forceUseFallback === true) {\n            this._initializationPromise = properties.fallback != null\n                ? properties.fallback()\n                    .then((provider) => {\n                    this._provider = provider;\n                })\n                : Promise.resolve();\n        }\n        else {\n            // Initialize provider with injected object by default\n            this._provider = getProvider();\n            if (this._provider != null) {\n                // Provider as already injected\n                this._initializationPromise = Promise.resolve();\n            }\n            else {\n                // Wait until page is loaded and initialization complete\n                this._initializationPromise = hasEverscaleProvider()\n                    .then((hasProvider) => new Promise((resolve) => {\n                    if (!hasProvider) {\n                        // Fully loaded page doesn't even contain provider flag\n                        return resolve();\n                    }\n                    // Wait injected provider initialization otherwise\n                    this._provider = getProvider();\n                    if (this._provider != null) {\n                        resolve();\n                    }\n                    else {\n                        const eventName = window.__hasEverscaleProvider === true ? 'ever#initialized' : 'ton#initialized';\n                        window.addEventListener(eventName, (_) => {\n                            this._provider = getProvider();\n                            resolve();\n                        });\n                    }\n                }))\n                    .then(async () => {\n                    if (this._provider == null && properties.fallback != null) {\n                        this._provider = await properties.fallback();\n                    }\n                });\n            }\n        }\n        // Will only register handlers for successfully loaded injected provider\n        this._initializationPromise.then(() => {\n            if (this._provider != null) {\n                this._registerEventHandlers(this._provider);\n            }\n        });\n    }\n    /**\n     * Checks whether this page has injected Everscale provider or\n     * there is a fallback provider.\n     */\n    async hasProvider() {\n        if (this._properties.fallback != null) {\n            return true;\n        }\n        return hasEverscaleProvider();\n    }\n    /**\n     * Waits until provider api will be available. Calls `fallback` if no provider was found\n     *\n     * @throws ProviderNotFoundException when no provider found\n     */\n    async ensureInitialized() {\n        await this._initializationPromise;\n        if (this._provider == null) {\n            throw new ProviderNotFoundException();\n        }\n    }\n    /**\n     * Whether provider api is ready\n     */\n    get isInitialized() {\n        return this._provider != null;\n    }\n    /**\n     * Raw provider\n     */\n    get raw() {\n        if (this._provider != null) {\n            return this._provider;\n        }\n        else {\n            throw new ProviderNotInitializedException();\n        }\n    }\n    /**\n     * Raw provider api\n     */\n    get rawApi() {\n        return this._api;\n    }\n    /**\n     * Creates typed contract wrapper.\n     *\n     * @param abi Readonly object (must be declared with `as const`)\n     * @param address Default contract address\n     *\n     * @deprecated `new ever.Contract(abi, address)` should be used instead\n     */\n    createContract(abi, address) {\n        return new this.Contract(abi, address);\n    }\n    /**\n     * Creates subscriptions group\n     *\n     * @deprecated `new ever.Subscriber()` should be used instead\n     */\n    createSubscriber() {\n        return new this.Subscriber();\n    }\n    /**\n     * Requests new permissions for current origin.\n     * Shows an approval window to the user.\n     * Will overwrite already existing permissions\n     *\n     * ---\n     * Required permissions: none\n     */\n    async requestPermissions(args) {\n        await this.ensureInitialized();\n        const result = await this._api.requestPermissions({\n            permissions: args.permissions,\n        });\n        return (0, models_1.parsePermissions)(result);\n    }\n    /**\n     * Updates `accountInteraction` permission value\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async changeAccount() {\n        await this.ensureInitialized();\n        await this._api.changeAccount();\n    }\n    /**\n     * Removes all permissions for current origin and stops all subscriptions\n     */\n    async disconnect() {\n        await this.ensureInitialized();\n        await this._api.disconnect();\n    }\n    async subscribe(eventName, params) {\n        class SubscriptionImpl {\n            constructor(_subscribe, _unsubscribe) {\n                this._subscribe = _subscribe;\n                this._unsubscribe = _unsubscribe;\n                this._listeners = {\n                    data: [],\n                    subscribed: [],\n                    unsubscribed: [],\n                };\n                this._subscribed = false;\n                this.subscribe = async () => {\n                    if (this._subscribed) {\n                        return;\n                    }\n                    this._subscribed = true;\n                    await this._subscribe(this);\n                    for (const handler of this._listeners['subscribed']) {\n                        handler();\n                    }\n                };\n                this.unsubscribe = async () => {\n                    if (!this._subscribed) {\n                        return;\n                    }\n                    this._subscribed = false;\n                    await this._unsubscribe();\n                    for (const handler of this._listeners['unsubscribed']) {\n                        handler();\n                    }\n                };\n            }\n            on(eventName, listener) {\n                this._listeners[eventName].push(listener);\n                return this;\n            }\n            notify(data) {\n                for (const handler of this._listeners['data']) {\n                    handler(data);\n                }\n            }\n        }\n        const existingSubscriptions = this._subscriptions[eventName];\n        const id = (0, utils_1.getUniqueId)();\n        switch (eventName) {\n            case 'connected':\n            case 'disconnected':\n            case 'messageStatusUpdated':\n            case 'networkChanged':\n            case 'permissionsChanged':\n            case 'loggedOut': {\n                const subscription = new SubscriptionImpl(async (subscription) => {\n                    if (existingSubscriptions.has(id)) {\n                        return;\n                    }\n                    existingSubscriptions.set(id, (data) => {\n                        subscription.notify(data);\n                    });\n                }, async () => {\n                    existingSubscriptions.delete(id);\n                });\n                await subscription.subscribe();\n                return subscription;\n            }\n            case 'transactionsFound':\n            case 'contractStateChanged': {\n                if (params == null) {\n                    throw new Error('Address must be specified for the subscription');\n                }\n                await this.ensureInitialized();\n                const address = params.address.toString();\n                const subscription = new SubscriptionImpl(async (subscription) => {\n                    if (existingSubscriptions.has(id)) {\n                        return;\n                    }\n                    existingSubscriptions.set(id, ((data) => {\n                        if (data.address.toString() === address) {\n                            subscription.notify(data);\n                        }\n                    }));\n                    let contractSubscriptions = this._contractSubscriptions.get(address);\n                    if (contractSubscriptions == null) {\n                        contractSubscriptions = new Map();\n                        this._contractSubscriptions.set(address, contractSubscriptions);\n                    }\n                    const subscriptionState = {\n                        state: eventName === 'contractStateChanged',\n                        transactions: eventName === 'transactionsFound',\n                    };\n                    contractSubscriptions.set(id, subscriptionState);\n                    const { total, withoutExcluded, } = foldSubscriptions(contractSubscriptions.values(), subscriptionState);\n                    try {\n                        if (total.transactions !== withoutExcluded.transactions || total.state !== withoutExcluded.state) {\n                            await this.rawApi.subscribe({ address, subscriptions: total });\n                        }\n                    }\n                    catch (e) {\n                        existingSubscriptions.delete(id);\n                        contractSubscriptions.delete(id);\n                        throw e;\n                    }\n                }, async () => {\n                    existingSubscriptions.delete(id);\n                    const contractSubscriptions = this._contractSubscriptions.get(address);\n                    if (contractSubscriptions == null) {\n                        return;\n                    }\n                    const updates = contractSubscriptions.get(id);\n                    const { total, withoutExcluded } = foldSubscriptions(contractSubscriptions.values(), updates);\n                    contractSubscriptions.delete(id);\n                    if (!withoutExcluded.transactions && !withoutExcluded.state) {\n                        await this.rawApi.unsubscribe({ address });\n                    }\n                    else if (total.transactions !== withoutExcluded.transactions || total.state !== withoutExcluded.state) {\n                        await this.rawApi.subscribe({ address, subscriptions: withoutExcluded });\n                    }\n                });\n                await subscription.subscribe();\n                return subscription;\n            }\n            default: {\n                throw new Error(`Unknown event ${eventName}`);\n            }\n        }\n    }\n    /**\n     * Returns provider api state\n     *\n     * ---\n     * Required permissions: none\n     */\n    async getProviderState() {\n        await this.ensureInitialized();\n        const state = await this._api.getProviderState();\n        return {\n            ...state,\n            permissions: (0, models_1.parsePermissions)(state.permissions),\n        };\n    }\n    /**\n     * Requests contract balance\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getBalance(address) {\n        const { state } = await this.getFullContractState({\n            address,\n        });\n        return state == null ? '0' : state === null || state === void 0 ? void 0 : state.balance;\n    }\n    /**\n     * Requests contract data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getFullContractState(args) {\n        await this.ensureInitialized();\n        return await this._api.getFullContractState({\n            address: args.address.toString(),\n        });\n    }\n    /**\n     * Requests accounts with specified code hash\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getAccountsByCodeHash(args) {\n        await this.ensureInitialized();\n        const { accounts, continuation } = await this._api.getAccountsByCodeHash({\n            ...args,\n        });\n        return {\n            accounts: accounts.map((address) => new utils_1.Address(address)),\n            continuation,\n        };\n    }\n    /**\n     * Requests contract transactions\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getTransactions(args) {\n        await this.ensureInitialized();\n        const { transactions, continuation, info } = await this._api.getTransactions({\n            ...args,\n            address: args.address.toString(),\n        });\n        return {\n            transactions: transactions.map(models_1.parseTransaction),\n            continuation,\n            info,\n        };\n    }\n    /**\n     * Searches transaction by hash\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getTransaction(args) {\n        await this.ensureInitialized();\n        const { transaction } = await this._api.getTransaction({\n            ...args,\n        });\n        return {\n            transaction: transaction ? (0, models_1.parseTransaction)(transaction) : undefined,\n        };\n    }\n    /**\n     * Computes contract address from code and init params\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getExpectedAddress(abi, args) {\n        const { address } = await this.getStateInit(abi, args);\n        return address;\n    }\n    /**\n     * Computes contract address and state from code and init params\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getStateInit(abi, args) {\n        await this.ensureInitialized();\n        const { address, stateInit } = await this._api.getExpectedAddress({\n            abi: JSON.stringify(abi),\n            ...args,\n            initParams: (0, models_1.serializeTokensObject)(args.initParams),\n        });\n        return {\n            address: new utils_1.Address(address),\n            stateInit,\n        };\n    }\n    /**\n     * Computes hash of base64 encoded BOC\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getBocHash(boc) {\n        await this.ensureInitialized();\n        return await this._api.getBocHash({\n            boc,\n        }).then(({ hash }) => hash);\n    }\n    /**\n     * Creates base64 encoded BOC\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async packIntoCell(args) {\n        await this.ensureInitialized();\n        return await this._api.packIntoCell({\n            abiVersion: args.abiVersion,\n            structure: args.structure,\n            data: (0, models_1.serializeTokensObject)(args.data),\n        });\n    }\n    /**\n     * Decodes base64 encoded BOC\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async unpackFromCell(args) {\n        await this.ensureInitialized();\n        const { data } = await this._api.unpackFromCell({\n            ...args,\n            structure: args.structure,\n        });\n        return {\n            data: (0, models_1.parseTokensObject)(args.structure, data),\n        };\n    }\n    /**\n     * Extracts public key from raw account state\n     *\n     * **NOTE:** can only be used on contracts which are deployed and has `pubkey` header\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async extractPublicKey(boc) {\n        await this.ensureInitialized();\n        const { publicKey } = await this._api.extractPublicKey({\n            boc,\n        });\n        return publicKey;\n    }\n    /**\n     * Converts base64 encoded contract code into tvc with default init data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async codeToTvc(code) {\n        await this.ensureInitialized();\n        const { tvc } = await this._api.codeToTvc({\n            code,\n        });\n        return tvc;\n    }\n    /**\n     * Merges code and data into state init\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async mergeTvc(args) {\n        await this.ensureInitialized();\n        return await this._api.mergeTvc(args);\n    }\n    /**\n     * Splits base64 encoded state init into code and data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async splitTvc(tvc) {\n        await this.ensureInitialized();\n        return await this._api.splitTvc({\n            tvc,\n        });\n    }\n    /**\n     * Merges code and data into state init\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async setCodeSalt(args) {\n        let salt;\n        if (typeof args.salt === 'string') {\n            await this.ensureInitialized();\n            salt = args.salt;\n        }\n        else {\n            const { boc } = await this.packIntoCell(args.salt);\n            salt = boc;\n        }\n        return await this._api.setCodeSalt({ code: args.code, salt });\n    }\n    /**\n     * Retrieves salt from code. Returns undefined if code doesn't contain salt\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getCodeSalt(args) {\n        await this.ensureInitialized();\n        const { salt } = await this.rawApi.getCodeSalt({\n            code: args.code,\n        });\n        return salt;\n    }\n    /**\n     * Adds asset to the selected account\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async addAsset(args) {\n        await this.ensureInitialized();\n        let params;\n        switch (args.type) {\n            case 'tip3_token': {\n                params = {\n                    rootContract: args.params.rootContract.toString(),\n                };\n                break;\n            }\n            default:\n                throw new Error('Unknown asset type');\n        }\n        return await this._api.addAsset({\n            account: args.account.toString(),\n            type: args.type,\n            params,\n        });\n    }\n    async verifySignature(args) {\n        await this.ensureInitialized();\n        return await this._api.verifySignature(args);\n    }\n    /**\n     * Signs arbitrary data.\n     *\n     * NOTE: hashes data before signing. Use `signDataRaw` to sign without hash.\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async signData(args) {\n        await this.ensureInitialized();\n        return await this._api.signData(args);\n    }\n    /**\n     * Signs arbitrary data without hashing it\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async signDataRaw(args) {\n        await this.ensureInitialized();\n        return await this._api.signDataRaw(args);\n    }\n    /**\n     * Encrypts arbitrary data with specified algorithm for each specified recipient\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async encryptData(args) {\n        await this.ensureInitialized();\n        const { encryptedData } = await this._api.encryptData(args);\n        return encryptedData;\n    }\n    /**\n     * Decrypts encrypted data. Returns base64 encoded data\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async decryptData(encryptedData) {\n        await this.ensureInitialized();\n        const { data } = await this._api.decryptData({ encryptedData });\n        return data;\n    }\n    /**\n     * Sends an internal message from the user account.\n     * Shows an approval window to the user.\n     *\n     * ---\n     * Required permissions: `accountInteraction`\n     */\n    async sendMessage(args) {\n        await this.ensureInitialized();\n        const { transaction } = await this._api.sendMessage({\n            sender: args.sender.toString(),\n            recipient: args.recipient.toString(),\n            amount: args.amount,\n            bounce: args.bounce,\n            payload: args.payload ? ({\n                abi: args.payload.abi,\n                method: args.payload.method,\n                params: (0, models_1.serializeTokensObject)(args.payload.params),\n            }) : undefined,\n        });\n        return {\n            transaction: (0, models_1.parseTransaction)(transaction),\n        };\n    }\n    /**\n     * Sends an internal message from the user account without waiting for the transaction.\n     * Shows an approval window to the user.\n     *\n     * @see messageStatusUpdated\n     *\n     * ---\n     * Required permissions: `accountInteraction`\n     */\n    async sendMessageDelayed(args) {\n        await this.ensureInitialized();\n        const transactions = new utils_1.DelayedTransactions;\n        const subscription = await this.subscribe('messageStatusUpdated');\n        subscription.on('data', (data) => {\n            if (!data.address.equals(args.sender)) {\n                return;\n            }\n            transactions.fillTransaction(data.hash, data.transaction);\n        });\n        const { message } = await this._api.sendMessageDelayed({\n            sender: args.sender.toString(),\n            recipient: args.recipient.toString(),\n            amount: args.amount,\n            bounce: args.bounce,\n            payload: args.payload ? ({\n                abi: args.payload.abi,\n                method: args.payload.method,\n                params: (0, models_1.serializeTokensObject)(args.payload.params),\n            }) : undefined,\n        }).catch(e => {\n            subscription.unsubscribe().catch(console.error);\n            throw e;\n        });\n        const transaction = transactions\n            .waitTransaction(args.sender, message.hash)\n            .finally(() => subscription.unsubscribe().catch(console.error));\n        return {\n            messageHash: message.hash,\n            expireAt: message.expireAt,\n            transaction,\n        };\n    }\n    _registerEventHandlers(provider) {\n        const knownEvents = {\n            'connected': (data) => data,\n            'disconnected': (data) => data,\n            'transactionsFound': (data) => ({\n                address: new utils_1.Address(data.address),\n                transactions: data.transactions.map(models_1.parseTransaction),\n                info: data.info,\n            }),\n            'contractStateChanged': (data) => ({\n                address: new utils_1.Address(data.address),\n                state: data.state,\n            }),\n            'messageStatusUpdated': (data) => ({\n                address: new utils_1.Address(data.address),\n                hash: data.hash,\n                transaction: data.transaction != null ? (0, models_1.parseTransaction)(data.transaction) : undefined,\n            }),\n            'networkChanged': data => data,\n            'permissionsChanged': (data) => ({\n                permissions: (0, models_1.parsePermissions)(data.permissions),\n            }),\n            'loggedOut': data => data,\n        };\n        for (const [eventName, extractor] of Object.entries(knownEvents)) {\n            provider.addListener(eventName, (data) => {\n                const handlers = this._subscriptions[eventName];\n                const parsed = extractor(data);\n                for (const handler of handlers.values()) {\n                    handler(parsed);\n                }\n            });\n        }\n    }\n}\nexports.ProviderRpcClient = ProviderRpcClient;\n/**\n * @category Provider\n */\nclass ProviderNotFoundException extends Error {\n    constructor() {\n        super('Everscale provider was not found');\n    }\n}\nexports.ProviderNotFoundException = ProviderNotFoundException;\n/**\n * @category Provider\n */\nclass ProviderNotInitializedException extends Error {\n    constructor() {\n        super('Everscale provider was not initialized yet');\n    }\n}\nexports.ProviderNotInitializedException = ProviderNotInitializedException;\nfunction foldSubscriptions(subscriptions, except) {\n    const total = { state: false, transactions: false };\n    const withoutExcluded = Object.assign({}, total);\n    for (const item of subscriptions) {\n        if (withoutExcluded.transactions && withoutExcluded.state) {\n            break;\n        }\n        total.state || (total.state = item.state);\n        total.transactions || (total.transactions = item.transactions);\n        if (item !== except) {\n            withoutExcluded.state || (withoutExcluded.state = item.state);\n            withoutExcluded.transactions || (withoutExcluded.transactions = item.transactions);\n        }\n    }\n    return { total, withoutExcluded };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLWlucGFnZS1wcm92aWRlci9kaXN0L2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXIvZGlzdC9pbmRleC5qcz83MTM1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm92aWRlck5vdEluaXRpYWxpemVkRXhjZXB0aW9uID0gZXhwb3J0cy5Qcm92aWRlck5vdEZvdW5kRXhjZXB0aW9uID0gZXhwb3J0cy5Qcm92aWRlclJwY0NsaWVudCA9IGV4cG9ydHMuaGFzRXZlcnNjYWxlUHJvdmlkZXIgPSBleHBvcnRzLkxUX0NPTExBVE9SID0gZXhwb3J0cy5tZXJnZVRyYW5zYWN0aW9ucyA9IGV4cG9ydHMuTWVzc2FnZUV4cGlyZWRFeGNlcHRpb24gPSBleHBvcnRzLkFkZHJlc3NMaXRlcmFsID0gZXhwb3J0cy5BZGRyZXNzID0gZXhwb3J0cy5TdWJzY3JpYmVyID0gdm9pZCAwO1xuY29uc3QgbW9kZWxzXzEgPSByZXF1aXJlKFwiLi9tb2RlbHNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBzdWJzY3JpYmVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3N0cmVhbVwiKSk7XG5jb25zdCBjb250cmFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9jb250cmFjdFwiKSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXBpXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnRyYWN0XCIpLCBleHBvcnRzKTtcbnZhciBzdHJlYW1fMSA9IHJlcXVpcmUoXCIuL3N0cmVhbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN1YnNjcmliZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmVhbV8xLlN1YnNjcmliZXI7IH0gfSk7XG52YXIgdXRpbHNfMiA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5BZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWRkcmVzc0xpdGVyYWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuQWRkcmVzc0xpdGVyYWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlRXhwaXJlZEV4Y2VwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5NZXNzYWdlRXhwaXJlZEV4Y2VwdGlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1lcmdlVHJhbnNhY3Rpb25zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLm1lcmdlVHJhbnNhY3Rpb25zOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTFRfQ09MTEFUT1JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuTFRfQ09MTEFUT1I7IH0gfSk7XG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbmxldCBlbnN1cmVQYWdlTG9hZGVkO1xuaWYgKCFpc0Jyb3dzZXIgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgIGVuc3VyZVBhZ2VMb2FkZWQgPSBQcm9taXNlLnJlc29sdmUoKTtcbn1cbmVsc2Uge1xuICAgIGVuc3VyZVBhZ2VMb2FkZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5jb25zdCBnZXRQcm92aWRlciA9ICgpID0+IGlzQnJvd3NlciA/IHdpbmRvdy5fX2V2ZXIgfHwgd2luZG93LnRvbiA6IHVuZGVmaW5lZDtcbi8qKlxuICogQGNhdGVnb3J5IFByb3ZpZGVyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhc0V2ZXJzY2FsZVByb3ZpZGVyKCkge1xuICAgIGlmICghaXNCcm93c2VyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXdhaXQgZW5zdXJlUGFnZUxvYWRlZDtcbiAgICByZXR1cm4gd2luZG93Ll9faGFzRXZlcnNjYWxlUHJvdmlkZXIgPT09IHRydWUgfHwgd2luZG93Lmhhc1RvblByb3ZpZGVyID09PSB0cnVlO1xufVxuZXhwb3J0cy5oYXNFdmVyc2NhbGVQcm92aWRlciA9IGhhc0V2ZXJzY2FsZVByb3ZpZGVyO1xuLyoqXG4gKiBAY2F0ZWdvcnkgUHJvdmlkZXJcbiAqL1xuY2xhc3MgUHJvdmlkZXJScGNDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMgPSB7fSkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0ge1xuICAgICAgICAgICAgY29ubmVjdGVkOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBkaXNjb25uZWN0ZWQ6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uc0ZvdW5kOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBjb250cmFjdFN0YXRlQ2hhbmdlZDogbmV3IE1hcCgpLFxuICAgICAgICAgICAgbWVzc2FnZVN0YXR1c1VwZGF0ZWQ6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIG5ldHdvcmtDaGFuZ2VkOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBwZXJtaXNzaW9uc0NoYW5nZWQ6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGxvZ2dlZE91dDogbmV3IE1hcCgpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jb250cmFjdFN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgLy8gQ3JlYXRlIGNvbnRyYWN0IHByb3h5IHR5cGVcbiAgICAgICAgY2xhc3MgUHJvdmlkZXJDb250cmFjdCBleHRlbmRzIGNvbnRyYWN0LkNvbnRyYWN0IHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKGFiaSwgYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHN1cGVyKHNlbGYsIGFiaSwgYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5Db250cmFjdCA9IFByb3ZpZGVyQ29udHJhY3Q7XG4gICAgICAgIC8vIENyZWF0ZSBzdWJzY3JpYmVyIHByb3h5IHR5cGVcbiAgICAgICAgY2xhc3MgUHJvdmlkZXJTdWJzY3JpYmVyIGV4dGVuZHMgc3Vic2NyaWJlci5TdWJzY3JpYmVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuU3Vic2NyaWJlciA9IFByb3ZpZGVyU3Vic2NyaWJlcjtcbiAgICAgICAgLy8gV3JhcCBwcm92aWRlciByZXF1ZXN0c1xuICAgICAgICB0aGlzLl9hcGkgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgIGdldDogKF9vYmplY3QsIG1ldGhvZCkgPT4gKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcm92aWRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm92aWRlci5yZXF1ZXN0KHsgbWV0aG9kLCBwYXJhbXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUHJvdmlkZXJOb3RJbml0aWFsaXplZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvcGVydGllcy5mb3JjZVVzZUZhbGxiYWNrID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXphdGlvblByb21pc2UgPSBwcm9wZXJ0aWVzLmZhbGxiYWNrICE9IG51bGxcbiAgICAgICAgICAgICAgICA/IHByb3BlcnRpZXMuZmFsbGJhY2soKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigocHJvdmlkZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHByb3ZpZGVyIHdpdGggaW5qZWN0ZWQgb2JqZWN0IGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIHRoaXMuX3Byb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcm92aWRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJvdmlkZXIgYXMgYWxyZWFkeSBpbmplY3RlZFxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemF0aW9uUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCBwYWdlIGlzIGxvYWRlZCBhbmQgaW5pdGlhbGl6YXRpb24gY29tcGxldGVcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXphdGlvblByb21pc2UgPSBoYXNFdmVyc2NhbGVQcm92aWRlcigpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChoYXNQcm92aWRlcikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRnVsbHkgbG9hZGVkIHBhZ2UgZG9lc24ndCBldmVuIGNvbnRhaW4gcHJvdmlkZXIgZmxhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IGluamVjdGVkIHByb3ZpZGVyIGluaXRpYWxpemF0aW9uIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm92aWRlciA9IGdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcm92aWRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudE5hbWUgPSB3aW5kb3cuX19oYXNFdmVyc2NhbGVQcm92aWRlciA9PT0gdHJ1ZSA/ICdldmVyI2luaXRpYWxpemVkJyA6ICd0b24jaW5pdGlhbGl6ZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCAoXykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcm92aWRlciA9PSBudWxsICYmIHByb3BlcnRpZXMuZmFsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBhd2FpdCBwcm9wZXJ0aWVzLmZhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXaWxsIG9ubHkgcmVnaXN0ZXIgaGFuZGxlcnMgZm9yIHN1Y2Nlc3NmdWxseSBsb2FkZWQgaW5qZWN0ZWQgcHJvdmlkZXJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Byb3ZpZGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWdpc3RlckV2ZW50SGFuZGxlcnModGhpcy5fcHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBwYWdlIGhhcyBpbmplY3RlZCBFdmVyc2NhbGUgcHJvdmlkZXIgb3JcbiAgICAgKiB0aGVyZSBpcyBhIGZhbGxiYWNrIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGFzeW5jIGhhc1Byb3ZpZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvcGVydGllcy5mYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzRXZlcnNjYWxlUHJvdmlkZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgdW50aWwgcHJvdmlkZXIgYXBpIHdpbGwgYmUgYXZhaWxhYmxlLiBDYWxscyBgZmFsbGJhY2tgIGlmIG5vIHByb3ZpZGVyIHdhcyBmb3VuZFxuICAgICAqXG4gICAgICogQHRocm93cyBQcm92aWRlck5vdEZvdW5kRXhjZXB0aW9uIHdoZW4gbm8gcHJvdmlkZXIgZm91bmRcbiAgICAgKi9cbiAgICBhc3luYyBlbnN1cmVJbml0aWFsaXplZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgICAgICBpZiAodGhpcy5fcHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFByb3ZpZGVyTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHByb3ZpZGVyIGFwaSBpcyByZWFkeVxuICAgICAqL1xuICAgIGdldCBpc0luaXRpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvdmlkZXIgIT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmF3IHByb3ZpZGVyXG4gICAgICovXG4gICAgZ2V0IHJhdygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb3ZpZGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQcm92aWRlck5vdEluaXRpYWxpemVkRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmF3IHByb3ZpZGVyIGFwaVxuICAgICAqL1xuICAgIGdldCByYXdBcGkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcGk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdHlwZWQgY29udHJhY3Qgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhYmkgUmVhZG9ubHkgb2JqZWN0IChtdXN0IGJlIGRlY2xhcmVkIHdpdGggYGFzIGNvbnN0YClcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBEZWZhdWx0IGNvbnRyYWN0IGFkZHJlc3NcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIGBuZXcgZXZlci5Db250cmFjdChhYmksIGFkZHJlc3MpYCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkXG4gICAgICovXG4gICAgY3JlYXRlQ29udHJhY3QoYWJpLCBhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5Db250cmFjdChhYmksIGFkZHJlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHN1YnNjcmlwdGlvbnMgZ3JvdXBcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIGBuZXcgZXZlci5TdWJzY3JpYmVyKClgIHNob3VsZCBiZSB1c2VkIGluc3RlYWRcbiAgICAgKi9cbiAgICBjcmVhdGVTdWJzY3JpYmVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuU3Vic2NyaWJlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBuZXcgcGVybWlzc2lvbnMgZm9yIGN1cnJlbnQgb3JpZ2luLlxuICAgICAqIFNob3dzIGFuIGFwcHJvdmFsIHdpbmRvdyB0byB0aGUgdXNlci5cbiAgICAgKiBXaWxsIG92ZXJ3cml0ZSBhbHJlYWR5IGV4aXN0aW5nIHBlcm1pc3Npb25zXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogbm9uZVxuICAgICAqL1xuICAgIGFzeW5jIHJlcXVlc3RQZXJtaXNzaW9ucyhhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fYXBpLnJlcXVlc3RQZXJtaXNzaW9ucyh7XG4gICAgICAgICAgICBwZXJtaXNzaW9uczogYXJncy5wZXJtaXNzaW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoMCwgbW9kZWxzXzEucGFyc2VQZXJtaXNzaW9ucykocmVzdWx0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBgYWNjb3VudEludGVyYWN0aW9uYCBwZXJtaXNzaW9uIHZhbHVlXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlcyBwZXJtaXNzaW9uczogYGFjY291bnRJbnRlcmFjdGlvbmBcbiAgICAgKi9cbiAgICBhc3luYyBjaGFuZ2VBY2NvdW50KCkge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2FwaS5jaGFuZ2VBY2NvdW50KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHBlcm1pc3Npb25zIGZvciBjdXJyZW50IG9yaWdpbiBhbmQgc3RvcHMgYWxsIHN1YnNjcmlwdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2FwaS5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIGFzeW5jIHN1YnNjcmliZShldmVudE5hbWUsIHBhcmFtcykge1xuICAgICAgICBjbGFzcyBTdWJzY3JpcHRpb25JbXBsIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKF9zdWJzY3JpYmUsIF91bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IF9zdWJzY3JpYmU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSBfdW5zdWJzY3JpYmU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlZDogW10sXG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlZDogW10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMuX2xpc3RlbmVyc1snc3Vic2NyaWJlZCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMuX2xpc3RlbmVyc1sndW5zdWJzY3JpYmVkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50TmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3RpZnkoZGF0YSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiB0aGlzLl9saXN0ZW5lcnNbJ2RhdGEnXSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGlzdGluZ1N1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zW2V2ZW50TmFtZV07XG4gICAgICAgIGNvbnN0IGlkID0gKDAsIHV0aWxzXzEuZ2V0VW5pcXVlSWQpKCk7XG4gICAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2VTdGF0dXNVcGRhdGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ25ldHdvcmtDaGFuZ2VkJzpcbiAgICAgICAgICAgIGNhc2UgJ3Blcm1pc3Npb25zQ2hhbmdlZCc6XG4gICAgICAgICAgICBjYXNlICdsb2dnZWRPdXQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbkltcGwoYXN5bmMgKHN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdTdWJzY3JpcHRpb25zLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1N1YnNjcmlwdGlvbnMuc2V0KGlkLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLm5vdGlmeShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1N1YnNjcmlwdGlvbnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzdWJzY3JpcHRpb24uc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3RyYW5zYWN0aW9uc0ZvdW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRyYWN0U3RhdGVDaGFuZ2VkJzoge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZHJlc3MgbXVzdCBiZSBzcGVjaWZpZWQgZm9yIHRoZSBzdWJzY3JpcHRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBwYXJhbXMuYWRkcmVzcy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25JbXBsKGFzeW5jIChzdWJzY3JpcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nU3Vic2NyaXB0aW9ucy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdTdWJzY3JpcHRpb25zLnNldChpZCwgKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5hZGRyZXNzLnRvU3RyaW5nKCkgPT09IGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24ubm90aWZ5KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250cmFjdFN1YnNjcmlwdGlvbnMgPSB0aGlzLl9jb250cmFjdFN1YnNjcmlwdGlvbnMuZ2V0KGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJhY3RTdWJzY3JpcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0U3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRyYWN0U3Vic2NyaXB0aW9ucy5zZXQoYWRkcmVzcywgY29udHJhY3RTdWJzY3JpcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25TdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBldmVudE5hbWUgPT09ICdjb250cmFjdFN0YXRlQ2hhbmdlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IGV2ZW50TmFtZSA9PT0gJ3RyYW5zYWN0aW9uc0ZvdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RTdWJzY3JpcHRpb25zLnNldChpZCwgc3Vic2NyaXB0aW9uU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRvdGFsLCB3aXRob3V0RXhjbHVkZWQsIH0gPSBmb2xkU3Vic2NyaXB0aW9ucyhjb250cmFjdFN1YnNjcmlwdGlvbnMudmFsdWVzKCksIHN1YnNjcmlwdGlvblN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbC50cmFuc2FjdGlvbnMgIT09IHdpdGhvdXRFeGNsdWRlZC50cmFuc2FjdGlvbnMgfHwgdG90YWwuc3RhdGUgIT09IHdpdGhvdXRFeGNsdWRlZC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmF3QXBpLnN1YnNjcmliZSh7IGFkZHJlc3MsIHN1YnNjcmlwdGlvbnM6IHRvdGFsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1N1YnNjcmlwdGlvbnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0U3Vic2NyaXB0aW9ucy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdTdWJzY3JpcHRpb25zLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0U3Vic2NyaXB0aW9ucyA9IHRoaXMuX2NvbnRyYWN0U3Vic2NyaXB0aW9ucy5nZXQoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cmFjdFN1YnNjcmlwdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBjb250cmFjdFN1YnNjcmlwdGlvbnMuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0b3RhbCwgd2l0aG91dEV4Y2x1ZGVkIH0gPSBmb2xkU3Vic2NyaXB0aW9ucyhjb250cmFjdFN1YnNjcmlwdGlvbnMudmFsdWVzKCksIHVwZGF0ZXMpO1xuICAgICAgICAgICAgICAgICAgICBjb250cmFjdFN1YnNjcmlwdGlvbnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3aXRob3V0RXhjbHVkZWQudHJhbnNhY3Rpb25zICYmICF3aXRob3V0RXhjbHVkZWQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmF3QXBpLnVuc3Vic2NyaWJlKHsgYWRkcmVzcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b3RhbC50cmFuc2FjdGlvbnMgIT09IHdpdGhvdXRFeGNsdWRlZC50cmFuc2FjdGlvbnMgfHwgdG90YWwuc3RhdGUgIT09IHdpdGhvdXRFeGNsdWRlZC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yYXdBcGkuc3Vic2NyaWJlKHsgYWRkcmVzcywgc3Vic2NyaXB0aW9uczogd2l0aG91dEV4Y2x1ZGVkIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3Vic2NyaXB0aW9uLnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGV2ZW50ICR7ZXZlbnROYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcHJvdmlkZXIgYXBpIHN0YXRlXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogbm9uZVxuICAgICAqL1xuICAgIGFzeW5jIGdldFByb3ZpZGVyU3RhdGUoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBhd2FpdCB0aGlzLl9hcGkuZ2V0UHJvdmlkZXJTdGF0ZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBwZXJtaXNzaW9uczogKDAsIG1vZGVsc18xLnBhcnNlUGVybWlzc2lvbnMpKHN0YXRlLnBlcm1pc3Npb25zKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgY29udHJhY3QgYmFsYW5jZVxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCYWxhbmNlKGFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gYXdhaXQgdGhpcy5nZXRGdWxsQ29udHJhY3RTdGF0ZSh7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN0YXRlID09IG51bGwgPyAnMCcgOiBzdGF0ZSA9PT0gbnVsbCB8fCBzdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdGUuYmFsYW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgY29udHJhY3QgZGF0YVxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBnZXRGdWxsQ29udHJhY3RTdGF0ZShhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FwaS5nZXRGdWxsQ29udHJhY3RTdGF0ZSh7XG4gICAgICAgICAgICBhZGRyZXNzOiBhcmdzLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGFjY291bnRzIHdpdGggc3BlY2lmaWVkIGNvZGUgaGFzaFxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY2NvdW50c0J5Q29kZUhhc2goYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGNvbnN0IHsgYWNjb3VudHMsIGNvbnRpbnVhdGlvbiB9ID0gYXdhaXQgdGhpcy5fYXBpLmdldEFjY291bnRzQnlDb2RlSGFzaCh7XG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50cy5tYXAoKGFkZHJlc3MpID0+IG5ldyB1dGlsc18xLkFkZHJlc3MoYWRkcmVzcykpLFxuICAgICAgICAgICAgY29udGludWF0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBjb250cmFjdCB0cmFuc2FjdGlvbnNcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqIFJlcXVpcmVkIHBlcm1pc3Npb25zOiBgYmFzaWNgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25zKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9ucywgY29udGludWF0aW9uLCBpbmZvIH0gPSBhd2FpdCB0aGlzLl9hcGkuZ2V0VHJhbnNhY3Rpb25zKHtcbiAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICBhZGRyZXNzOiBhcmdzLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9ucy5tYXAobW9kZWxzXzEucGFyc2VUcmFuc2FjdGlvbiksXG4gICAgICAgICAgICBjb250aW51YXRpb24sXG4gICAgICAgICAgICBpbmZvLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0cmFuc2FjdGlvbiBieSBoYXNoXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogYGJhc2ljYFxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0aGlzLl9hcGkuZ2V0VHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24gPyAoMCwgbW9kZWxzXzEucGFyc2VUcmFuc2FjdGlvbikodHJhbnNhY3Rpb24pIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBjb250cmFjdCBhZGRyZXNzIGZyb20gY29kZSBhbmQgaW5pdCBwYXJhbXNcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqIFJlcXVpcmVkIHBlcm1pc3Npb25zOiBgYmFzaWNgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RXhwZWN0ZWRBZGRyZXNzKGFiaSwgYXJncykge1xuICAgICAgICBjb25zdCB7IGFkZHJlc3MgfSA9IGF3YWl0IHRoaXMuZ2V0U3RhdGVJbml0KGFiaSwgYXJncyk7XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBjb250cmFjdCBhZGRyZXNzIGFuZCBzdGF0ZSBmcm9tIGNvZGUgYW5kIGluaXQgcGFyYW1zXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogYGJhc2ljYFxuICAgICAqL1xuICAgIGFzeW5jIGdldFN0YXRlSW5pdChhYmksIGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IGFkZHJlc3MsIHN0YXRlSW5pdCB9ID0gYXdhaXQgdGhpcy5fYXBpLmdldEV4cGVjdGVkQWRkcmVzcyh7XG4gICAgICAgICAgICBhYmk6IEpTT04uc3RyaW5naWZ5KGFiaSksXG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgaW5pdFBhcmFtczogKDAsIG1vZGVsc18xLnNlcmlhbGl6ZVRva2Vuc09iamVjdCkoYXJncy5pbml0UGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzOiBuZXcgdXRpbHNfMS5BZGRyZXNzKGFkZHJlc3MpLFxuICAgICAgICAgICAgc3RhdGVJbml0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBoYXNoIG9mIGJhc2U2NCBlbmNvZGVkIEJPQ1xuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCb2NIYXNoKGJvYykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hcGkuZ2V0Qm9jSGFzaCh7XG4gICAgICAgICAgICBib2MsXG4gICAgICAgIH0pLnRoZW4oKHsgaGFzaCB9KSA9PiBoYXNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBiYXNlNjQgZW5jb2RlZCBCT0NcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqIFJlcXVpcmVkIHBlcm1pc3Npb25zOiBgYmFzaWNgXG4gICAgICovXG4gICAgYXN5bmMgcGFja0ludG9DZWxsKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYXBpLnBhY2tJbnRvQ2VsbCh7XG4gICAgICAgICAgICBhYmlWZXJzaW9uOiBhcmdzLmFiaVZlcnNpb24sXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IGFyZ3Muc3RydWN0dXJlLFxuICAgICAgICAgICAgZGF0YTogKDAsIG1vZGVsc18xLnNlcmlhbGl6ZVRva2Vuc09iamVjdCkoYXJncy5kYXRhKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYmFzZTY0IGVuY29kZWQgQk9DXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogYGJhc2ljYFxuICAgICAqL1xuICAgIGFzeW5jIHVucGFja0Zyb21DZWxsKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHRoaXMuX2FwaS51bnBhY2tGcm9tQ2VsbCh7XG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgc3RydWN0dXJlOiBhcmdzLnN0cnVjdHVyZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiAoMCwgbW9kZWxzXzEucGFyc2VUb2tlbnNPYmplY3QpKGFyZ3Muc3RydWN0dXJlLCBkYXRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgcHVibGljIGtleSBmcm9tIHJhdyBhY2NvdW50IHN0YXRlXG4gICAgICpcbiAgICAgKiAqKk5PVEU6KiogY2FuIG9ubHkgYmUgdXNlZCBvbiBjb250cmFjdHMgd2hpY2ggYXJlIGRlcGxveWVkIGFuZCBoYXMgYHB1YmtleWAgaGVhZGVyXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogYGJhc2ljYFxuICAgICAqL1xuICAgIGFzeW5jIGV4dHJhY3RQdWJsaWNLZXkoYm9jKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgeyBwdWJsaWNLZXkgfSA9IGF3YWl0IHRoaXMuX2FwaS5leHRyYWN0UHVibGljS2V5KHtcbiAgICAgICAgICAgIGJvYyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwdWJsaWNLZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGJhc2U2NCBlbmNvZGVkIGNvbnRyYWN0IGNvZGUgaW50byB0dmMgd2l0aCBkZWZhdWx0IGluaXQgZGF0YVxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBjb2RlVG9UdmMoY29kZSkge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGNvbnN0IHsgdHZjIH0gPSBhd2FpdCB0aGlzLl9hcGkuY29kZVRvVHZjKHtcbiAgICAgICAgICAgIGNvZGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHZjO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgY29kZSBhbmQgZGF0YSBpbnRvIHN0YXRlIGluaXRcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqIFJlcXVpcmVkIHBlcm1pc3Npb25zOiBgYmFzaWNgXG4gICAgICovXG4gICAgYXN5bmMgbWVyZ2VUdmMoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hcGkubWVyZ2VUdmMoYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBiYXNlNjQgZW5jb2RlZCBzdGF0ZSBpbml0IGludG8gY29kZSBhbmQgZGF0YVxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBzcGxpdFR2Yyh0dmMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYXBpLnNwbGl0VHZjKHtcbiAgICAgICAgICAgIHR2YyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBjb2RlIGFuZCBkYXRhIGludG8gc3RhdGUgaW5pdFxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBzZXRDb2RlU2FsdChhcmdzKSB7XG4gICAgICAgIGxldCBzYWx0O1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3Muc2FsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgICAgIHNhbHQgPSBhcmdzLnNhbHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IGJvYyB9ID0gYXdhaXQgdGhpcy5wYWNrSW50b0NlbGwoYXJncy5zYWx0KTtcbiAgICAgICAgICAgIHNhbHQgPSBib2M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FwaS5zZXRDb2RlU2FsdCh7IGNvZGU6IGFyZ3MuY29kZSwgc2FsdCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHNhbHQgZnJvbSBjb2RlLiBSZXR1cm5zIHVuZGVmaW5lZCBpZiBjb2RlIGRvZXNuJ3QgY29udGFpbiBzYWx0XG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogYGJhc2ljYFxuICAgICAqL1xuICAgIGFzeW5jIGdldENvZGVTYWx0KGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IHNhbHQgfSA9IGF3YWl0IHRoaXMucmF3QXBpLmdldENvZGVTYWx0KHtcbiAgICAgICAgICAgIGNvZGU6IGFyZ3MuY29kZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzYWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFzc2V0IHRvIHRoZSBzZWxlY3RlZCBhY2NvdW50XG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlcyBwZXJtaXNzaW9uczogYGFjY291bnRJbnRlcmFjdGlvbmBcbiAgICAgKi9cbiAgICBhc3luYyBhZGRBc3NldChhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgc3dpdGNoIChhcmdzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RpcDNfdG9rZW4nOiB7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICByb290Q29udHJhY3Q6IGFyZ3MucGFyYW1zLnJvb3RDb250cmFjdC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBhc3NldCB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FwaS5hZGRBc3NldCh7XG4gICAgICAgICAgICBhY2NvdW50OiBhcmdzLmFjY291bnQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHR5cGU6IGFyZ3MudHlwZSxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeVNpZ25hdHVyZShhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FwaS52ZXJpZnlTaWduYXR1cmUoYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIGFyYml0cmFyeSBkYXRhLlxuICAgICAqXG4gICAgICogTk9URTogaGFzaGVzIGRhdGEgYmVmb3JlIHNpZ25pbmcuIFVzZSBgc2lnbkRhdGFSYXdgIHRvIHNpZ24gd2l0aG91dCBoYXNoLlxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZXMgcGVybWlzc2lvbnM6IGBhY2NvdW50SW50ZXJhY3Rpb25gXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkRhdGEoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hcGkuc2lnbkRhdGEoYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIGFyYml0cmFyeSBkYXRhIHdpdGhvdXQgaGFzaGluZyBpdFxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZXMgcGVybWlzc2lvbnM6IGBhY2NvdW50SW50ZXJhY3Rpb25gXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkRhdGFSYXcoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hcGkuc2lnbkRhdGFSYXcoYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY3J5cHRzIGFyYml0cmFyeSBkYXRhIHdpdGggc3BlY2lmaWVkIGFsZ29yaXRobSBmb3IgZWFjaCBzcGVjaWZpZWQgcmVjaXBpZW50XG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlcyBwZXJtaXNzaW9uczogYGFjY291bnRJbnRlcmFjdGlvbmBcbiAgICAgKi9cbiAgICBhc3luYyBlbmNyeXB0RGF0YShhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgeyBlbmNyeXB0ZWREYXRhIH0gPSBhd2FpdCB0aGlzLl9hcGkuZW5jcnlwdERhdGEoYXJncyk7XG4gICAgICAgIHJldHVybiBlbmNyeXB0ZWREYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNyeXB0cyBlbmNyeXB0ZWQgZGF0YS4gUmV0dXJucyBiYXNlNjQgZW5jb2RlZCBkYXRhXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlcyBwZXJtaXNzaW9uczogYGFjY291bnRJbnRlcmFjdGlvbmBcbiAgICAgKi9cbiAgICBhc3luYyBkZWNyeXB0RGF0YShlbmNyeXB0ZWREYXRhKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCB0aGlzLl9hcGkuZGVjcnlwdERhdGEoeyBlbmNyeXB0ZWREYXRhIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYW4gaW50ZXJuYWwgbWVzc2FnZSBmcm9tIHRoZSB1c2VyIGFjY291bnQuXG4gICAgICogU2hvd3MgYW4gYXBwcm92YWwgd2luZG93IHRvIHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBhY2NvdW50SW50ZXJhY3Rpb25gXG4gICAgICovXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb24gfSA9IGF3YWl0IHRoaXMuX2FwaS5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICBzZW5kZXI6IGFyZ3Muc2VuZGVyLnRvU3RyaW5nKCksXG4gICAgICAgICAgICByZWNpcGllbnQ6IGFyZ3MucmVjaXBpZW50LnRvU3RyaW5nKCksXG4gICAgICAgICAgICBhbW91bnQ6IGFyZ3MuYW1vdW50LFxuICAgICAgICAgICAgYm91bmNlOiBhcmdzLmJvdW5jZSxcbiAgICAgICAgICAgIHBheWxvYWQ6IGFyZ3MucGF5bG9hZCA/ICh7XG4gICAgICAgICAgICAgICAgYWJpOiBhcmdzLnBheWxvYWQuYWJpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogYXJncy5wYXlsb2FkLm1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6ICgwLCBtb2RlbHNfMS5zZXJpYWxpemVUb2tlbnNPYmplY3QpKGFyZ3MucGF5bG9hZC5wYXJhbXMpLFxuICAgICAgICAgICAgfSkgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246ICgwLCBtb2RlbHNfMS5wYXJzZVRyYW5zYWN0aW9uKSh0cmFuc2FjdGlvbiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGFuIGludGVybmFsIG1lc3NhZ2UgZnJvbSB0aGUgdXNlciBhY2NvdW50IHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIFNob3dzIGFuIGFwcHJvdmFsIHdpbmRvdyB0byB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBzZWUgbWVzc2FnZVN0YXR1c1VwZGF0ZWRcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqIFJlcXVpcmVkIHBlcm1pc3Npb25zOiBgYWNjb3VudEludGVyYWN0aW9uYFxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRNZXNzYWdlRGVsYXllZChhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zID0gbmV3IHV0aWxzXzEuRGVsYXllZFRyYW5zYWN0aW9ucztcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYXdhaXQgdGhpcy5zdWJzY3JpYmUoJ21lc3NhZ2VTdGF0dXNVcGRhdGVkJyk7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRhdGEuYWRkcmVzcy5lcXVhbHMoYXJncy5zZW5kZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNhY3Rpb25zLmZpbGxUcmFuc2FjdGlvbihkYXRhLmhhc2gsIGRhdGEudHJhbnNhY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBhd2FpdCB0aGlzLl9hcGkuc2VuZE1lc3NhZ2VEZWxheWVkKHtcbiAgICAgICAgICAgIHNlbmRlcjogYXJncy5zZW5kZXIudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHJlY2lwaWVudDogYXJncy5yZWNpcGllbnQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGFtb3VudDogYXJncy5hbW91bnQsXG4gICAgICAgICAgICBib3VuY2U6IGFyZ3MuYm91bmNlLFxuICAgICAgICAgICAgcGF5bG9hZDogYXJncy5wYXlsb2FkID8gKHtcbiAgICAgICAgICAgICAgICBhYmk6IGFyZ3MucGF5bG9hZC5hYmksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBhcmdzLnBheWxvYWQubWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogKDAsIG1vZGVsc18xLnNlcmlhbGl6ZVRva2Vuc09iamVjdCkoYXJncy5wYXlsb2FkLnBhcmFtcyksXG4gICAgICAgICAgICB9KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgLndhaXRUcmFuc2FjdGlvbihhcmdzLnNlbmRlciwgbWVzc2FnZS5oYXNoKVxuICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCkuY2F0Y2goY29uc29sZS5lcnJvcikpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZUhhc2g6IG1lc3NhZ2UuaGFzaCxcbiAgICAgICAgICAgIGV4cGlyZUF0OiBtZXNzYWdlLmV4cGlyZUF0LFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9yZWdpc3RlckV2ZW50SGFuZGxlcnMocHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3Qga25vd25FdmVudHMgPSB7XG4gICAgICAgICAgICAnY29ubmVjdGVkJzogKGRhdGEpID0+IGRhdGEsXG4gICAgICAgICAgICAnZGlzY29ubmVjdGVkJzogKGRhdGEpID0+IGRhdGEsXG4gICAgICAgICAgICAndHJhbnNhY3Rpb25zRm91bmQnOiAoZGF0YSkgPT4gKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBuZXcgdXRpbHNfMS5BZGRyZXNzKGRhdGEuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBkYXRhLnRyYW5zYWN0aW9ucy5tYXAobW9kZWxzXzEucGFyc2VUcmFuc2FjdGlvbiksXG4gICAgICAgICAgICAgICAgaW5mbzogZGF0YS5pbmZvLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAnY29udHJhY3RTdGF0ZUNoYW5nZWQnOiAoZGF0YSkgPT4gKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBuZXcgdXRpbHNfMS5BZGRyZXNzKGRhdGEuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgc3RhdGU6IGRhdGEuc3RhdGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICdtZXNzYWdlU3RhdHVzVXBkYXRlZCc6IChkYXRhKSA9PiAoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IG5ldyB1dGlsc18xLkFkZHJlc3MoZGF0YS5hZGRyZXNzKSxcbiAgICAgICAgICAgICAgICBoYXNoOiBkYXRhLmhhc2gsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IGRhdGEudHJhbnNhY3Rpb24gIT0gbnVsbCA/ICgwLCBtb2RlbHNfMS5wYXJzZVRyYW5zYWN0aW9uKShkYXRhLnRyYW5zYWN0aW9uKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgJ25ldHdvcmtDaGFuZ2VkJzogZGF0YSA9PiBkYXRhLFxuICAgICAgICAgICAgJ3Blcm1pc3Npb25zQ2hhbmdlZCc6IChkYXRhKSA9PiAoe1xuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiAoMCwgbW9kZWxzXzEucGFyc2VQZXJtaXNzaW9ucykoZGF0YS5wZXJtaXNzaW9ucyksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICdsb2dnZWRPdXQnOiBkYXRhID0+IGRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgW2V2ZW50TmFtZSwgZXh0cmFjdG9yXSBvZiBPYmplY3QuZW50cmllcyhrbm93bkV2ZW50cykpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuX3N1YnNjcmlwdGlvbnNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBleHRyYWN0b3IoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUHJvdmlkZXJScGNDbGllbnQgPSBQcm92aWRlclJwY0NsaWVudDtcbi8qKlxuICogQGNhdGVnb3J5IFByb3ZpZGVyXG4gKi9cbmNsYXNzIFByb3ZpZGVyTm90Rm91bmRFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdFdmVyc2NhbGUgcHJvdmlkZXIgd2FzIG5vdCBmb3VuZCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdmlkZXJOb3RGb3VuZEV4Y2VwdGlvbiA9IFByb3ZpZGVyTm90Rm91bmRFeGNlcHRpb247XG4vKipcbiAqIEBjYXRlZ29yeSBQcm92aWRlclxuICovXG5jbGFzcyBQcm92aWRlck5vdEluaXRpYWxpemVkRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignRXZlcnNjYWxlIHByb3ZpZGVyIHdhcyBub3QgaW5pdGlhbGl6ZWQgeWV0Jyk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm92aWRlck5vdEluaXRpYWxpemVkRXhjZXB0aW9uID0gUHJvdmlkZXJOb3RJbml0aWFsaXplZEV4Y2VwdGlvbjtcbmZ1bmN0aW9uIGZvbGRTdWJzY3JpcHRpb25zKHN1YnNjcmlwdGlvbnMsIGV4Y2VwdCkge1xuICAgIGNvbnN0IHRvdGFsID0geyBzdGF0ZTogZmFsc2UsIHRyYW5zYWN0aW9uczogZmFsc2UgfTtcbiAgICBjb25zdCB3aXRob3V0RXhjbHVkZWQgPSBPYmplY3QuYXNzaWduKHt9LCB0b3RhbCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgaWYgKHdpdGhvdXRFeGNsdWRlZC50cmFuc2FjdGlvbnMgJiYgd2l0aG91dEV4Y2x1ZGVkLnN0YXRlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0b3RhbC5zdGF0ZSB8fCAodG90YWwuc3RhdGUgPSBpdGVtLnN0YXRlKTtcbiAgICAgICAgdG90YWwudHJhbnNhY3Rpb25zIHx8ICh0b3RhbC50cmFuc2FjdGlvbnMgPSBpdGVtLnRyYW5zYWN0aW9ucyk7XG4gICAgICAgIGlmIChpdGVtICE9PSBleGNlcHQpIHtcbiAgICAgICAgICAgIHdpdGhvdXRFeGNsdWRlZC5zdGF0ZSB8fCAod2l0aG91dEV4Y2x1ZGVkLnN0YXRlID0gaXRlbS5zdGF0ZSk7XG4gICAgICAgICAgICB3aXRob3V0RXhjbHVkZWQudHJhbnNhY3Rpb25zIHx8ICh3aXRob3V0RXhjbHVkZWQudHJhbnNhY3Rpb25zID0gaXRlbS50cmFuc2FjdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHRvdGFsLCB3aXRob3V0RXhjbHVkZWQgfTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/everscale-inpage-provider/dist/index.js\n");

/***/ }),

/***/ "./node_modules/everscale-inpage-provider/dist/models.js":
/*!***************************************************************!*\
  !*** ./node_modules/everscale-inpage-provider/dist/models.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseTokensObject = exports.serializeTokensObject = exports.parseAccountInteraction = exports.parsePermissions = exports.parseMessage = exports.serializeMessage = exports.parseTransaction = exports.serializeTransaction = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/everscale-inpage-provider/dist/utils.js\");\n/**\n * @category Models\n */\nfunction serializeTransaction(transaction) {\n    return {\n        ...transaction,\n        inMessage: serializeMessage(transaction.inMessage),\n        outMessages: transaction.outMessages.map(serializeMessage),\n    };\n}\nexports.serializeTransaction = serializeTransaction;\n/**\n * @category Models\n */\nfunction parseTransaction(transaction) {\n    return {\n        ...transaction,\n        inMessage: parseMessage(transaction.inMessage),\n        outMessages: transaction.outMessages.map(parseMessage),\n    };\n}\nexports.parseTransaction = parseTransaction;\n/**\n * @category Models\n */\nfunction serializeMessage(message) {\n    return {\n        ...message,\n        src: message.src ? message.src.toString() : undefined,\n        dst: message.dst ? message.dst.toString() : undefined,\n    };\n}\nexports.serializeMessage = serializeMessage;\n/**\n * @category Models\n */\nfunction parseMessage(message) {\n    return {\n        ...message,\n        src: message.src ? new utils_1.Address(message.src) : undefined,\n        dst: message.dst ? new utils_1.Address(message.dst) : undefined,\n    };\n}\nexports.parseMessage = parseMessage;\n/**\n * @category Models\n */\nfunction parsePermissions(permissions) {\n    return {\n        ...permissions,\n        accountInteraction: permissions.accountInteraction ? parseAccountInteraction(permissions.accountInteraction) : undefined,\n    };\n}\nexports.parsePermissions = parsePermissions;\n/**\n * @category Models\n */\nfunction parseAccountInteraction(accountInteraction) {\n    return {\n        ...accountInteraction,\n        address: new utils_1.Address(accountInteraction.address),\n    };\n}\nexports.parseAccountInteraction = parseAccountInteraction;\n/**\n * @category Models\n */\nfunction serializeTokensObject(object) {\n    return serializeTokenValue(object);\n}\nexports.serializeTokensObject = serializeTokensObject;\nfunction serializeTokenValue(token) {\n    if (token instanceof utils_1.Address) {\n        return token.toString();\n    }\n    if (Array.isArray(token)) {\n        const result = [];\n        for (const item of token) {\n            result.push(serializeTokenValue(item));\n        }\n        return result;\n    }\n    else if (token != null && typeof token === 'object') {\n        const result = {};\n        for (const [key, value] of Object.entries(token)) {\n            result[key] = serializeTokenValue(value);\n        }\n        return result;\n    }\n    else {\n        return token;\n    }\n}\n/**\n * @category Models\n */\nfunction parseTokensObject(params, object) {\n    const result = {};\n    for (const param of params) {\n        result[param.name] = parseTokenValue(param, object[param.name]);\n    }\n    return result;\n}\nexports.parseTokensObject = parseTokensObject;\nfunction parseTokenValue(param, token) {\n    if (!param.type.startsWith('map')) {\n        const isArray = param.type.endsWith('[]');\n        const isOptional = !isArray && param.type.startsWith('optional');\n        const rawType = (isArray ?\n            param.type.slice(0, -2) :\n            isOptional ?\n                param.type.slice(9, -1) :\n                param.type);\n        if (isArray) {\n            const rawParam = { name: param.name, type: rawType, components: param.components };\n            const result = [];\n            for (const item of token) {\n                result.push(parseTokenValue(rawParam, item));\n            }\n            return result;\n        }\n        else if (isOptional) {\n            if (token == null) {\n                return null;\n            }\n            else {\n                const rawParam = { name: param.name, type: rawType, components: param.components };\n                return parseTokenValue(rawParam, token);\n            }\n        }\n        else if (rawType === 'tuple') {\n            const result = {};\n            if (param.components != null) {\n                for (const component of param.components) {\n                    result[component.name] = parseTokenValue(component, token[component.name]);\n                }\n            }\n            return result;\n        }\n        else if (rawType === 'address') {\n            return new utils_1.Address(token);\n        }\n        else {\n            return token;\n        }\n    }\n    else {\n        let [keyType, valueType] = param.type.split(',');\n        keyType = keyType.slice(4);\n        valueType = valueType.slice(0, -1);\n        const result = [];\n        for (const [key, value] of token) {\n            result.push([parseTokenValue({\n                    name: '',\n                    type: keyType,\n                }, key), parseTokenValue({\n                    name: '',\n                    type: valueType,\n                    components: param.components,\n                }, value)]);\n        }\n        return result;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLWlucGFnZS1wcm92aWRlci9kaXN0L21vZGVscy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9ldmVyc2NhbGUtaW5wYWdlLXByb3ZpZGVyL2Rpc3QvbW9kZWxzLmpzPzhkOGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlVG9rZW5zT2JqZWN0ID0gZXhwb3J0cy5zZXJpYWxpemVUb2tlbnNPYmplY3QgPSBleHBvcnRzLnBhcnNlQWNjb3VudEludGVyYWN0aW9uID0gZXhwb3J0cy5wYXJzZVBlcm1pc3Npb25zID0gZXhwb3J0cy5wYXJzZU1lc3NhZ2UgPSBleHBvcnRzLnNlcmlhbGl6ZU1lc3NhZ2UgPSBleHBvcnRzLnBhcnNlVHJhbnNhY3Rpb24gPSBleHBvcnRzLnNlcmlhbGl6ZVRyYW5zYWN0aW9uID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgTW9kZWxzXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgIGluTWVzc2FnZTogc2VyaWFsaXplTWVzc2FnZSh0cmFuc2FjdGlvbi5pbk1lc3NhZ2UpLFxuICAgICAgICBvdXRNZXNzYWdlczogdHJhbnNhY3Rpb24ub3V0TWVzc2FnZXMubWFwKHNlcmlhbGl6ZU1lc3NhZ2UpLFxuICAgIH07XG59XG5leHBvcnRzLnNlcmlhbGl6ZVRyYW5zYWN0aW9uID0gc2VyaWFsaXplVHJhbnNhY3Rpb247XG4vKipcbiAqIEBjYXRlZ29yeSBNb2RlbHNcbiAqL1xuZnVuY3Rpb24gcGFyc2VUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnRyYW5zYWN0aW9uLFxuICAgICAgICBpbk1lc3NhZ2U6IHBhcnNlTWVzc2FnZSh0cmFuc2FjdGlvbi5pbk1lc3NhZ2UpLFxuICAgICAgICBvdXRNZXNzYWdlczogdHJhbnNhY3Rpb24ub3V0TWVzc2FnZXMubWFwKHBhcnNlTWVzc2FnZSksXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyc2VUcmFuc2FjdGlvbiA9IHBhcnNlVHJhbnNhY3Rpb247XG4vKipcbiAqIEBjYXRlZ29yeSBNb2RlbHNcbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVzc2FnZSxcbiAgICAgICAgc3JjOiBtZXNzYWdlLnNyYyA/IG1lc3NhZ2Uuc3JjLnRvU3RyaW5nKCkgOiB1bmRlZmluZWQsXG4gICAgICAgIGRzdDogbWVzc2FnZS5kc3QgPyBtZXNzYWdlLmRzdC50b1N0cmluZygpIDogdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnRzLnNlcmlhbGl6ZU1lc3NhZ2UgPSBzZXJpYWxpemVNZXNzYWdlO1xuLyoqXG4gKiBAY2F0ZWdvcnkgTW9kZWxzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVzc2FnZSxcbiAgICAgICAgc3JjOiBtZXNzYWdlLnNyYyA/IG5ldyB1dGlsc18xLkFkZHJlc3MobWVzc2FnZS5zcmMpIDogdW5kZWZpbmVkLFxuICAgICAgICBkc3Q6IG1lc3NhZ2UuZHN0ID8gbmV3IHV0aWxzXzEuQWRkcmVzcyhtZXNzYWdlLmRzdCkgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyc2VNZXNzYWdlID0gcGFyc2VNZXNzYWdlO1xuLyoqXG4gKiBAY2F0ZWdvcnkgTW9kZWxzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUGVybWlzc2lvbnMocGVybWlzc2lvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5wZXJtaXNzaW9ucyxcbiAgICAgICAgYWNjb3VudEludGVyYWN0aW9uOiBwZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb24gPyBwYXJzZUFjY291bnRJbnRlcmFjdGlvbihwZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb24pIDogdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnRzLnBhcnNlUGVybWlzc2lvbnMgPSBwYXJzZVBlcm1pc3Npb25zO1xuLyoqXG4gKiBAY2F0ZWdvcnkgTW9kZWxzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQWNjb3VudEludGVyYWN0aW9uKGFjY291bnRJbnRlcmFjdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFjY291bnRJbnRlcmFjdGlvbixcbiAgICAgICAgYWRkcmVzczogbmV3IHV0aWxzXzEuQWRkcmVzcyhhY2NvdW50SW50ZXJhY3Rpb24uYWRkcmVzcyksXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyc2VBY2NvdW50SW50ZXJhY3Rpb24gPSBwYXJzZUFjY291bnRJbnRlcmFjdGlvbjtcbi8qKlxuICogQGNhdGVnb3J5IE1vZGVsc1xuICovXG5mdW5jdGlvbiBzZXJpYWxpemVUb2tlbnNPYmplY3Qob2JqZWN0KSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZVRva2VuVmFsdWUob2JqZWN0KTtcbn1cbmV4cG9ydHMuc2VyaWFsaXplVG9rZW5zT2JqZWN0ID0gc2VyaWFsaXplVG9rZW5zT2JqZWN0O1xuZnVuY3Rpb24gc2VyaWFsaXplVG9rZW5WYWx1ZSh0b2tlbikge1xuICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIHV0aWxzXzEuQWRkcmVzcykge1xuICAgICAgICByZXR1cm4gdG9rZW4udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodG9rZW4pKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdG9rZW4pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNlcmlhbGl6ZVRva2VuVmFsdWUoaXRlbSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRva2VuICE9IG51bGwgJiYgdHlwZW9mIHRva2VuID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModG9rZW4pKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHNlcmlhbGl6ZVRva2VuVmFsdWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxufVxuLyoqXG4gKiBAY2F0ZWdvcnkgTW9kZWxzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVG9rZW5zT2JqZWN0KHBhcmFtcywgb2JqZWN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiBwYXJhbXMpIHtcbiAgICAgICAgcmVzdWx0W3BhcmFtLm5hbWVdID0gcGFyc2VUb2tlblZhbHVlKHBhcmFtLCBvYmplY3RbcGFyYW0ubmFtZV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wYXJzZVRva2Vuc09iamVjdCA9IHBhcnNlVG9rZW5zT2JqZWN0O1xuZnVuY3Rpb24gcGFyc2VUb2tlblZhbHVlKHBhcmFtLCB0b2tlbikge1xuICAgIGlmICghcGFyYW0udHlwZS5zdGFydHNXaXRoKCdtYXAnKSkge1xuICAgICAgICBjb25zdCBpc0FycmF5ID0gcGFyYW0udHlwZS5lbmRzV2l0aCgnW10nKTtcbiAgICAgICAgY29uc3QgaXNPcHRpb25hbCA9ICFpc0FycmF5ICYmIHBhcmFtLnR5cGUuc3RhcnRzV2l0aCgnb3B0aW9uYWwnKTtcbiAgICAgICAgY29uc3QgcmF3VHlwZSA9IChpc0FycmF5ID9cbiAgICAgICAgICAgIHBhcmFtLnR5cGUuc2xpY2UoMCwgLTIpIDpcbiAgICAgICAgICAgIGlzT3B0aW9uYWwgP1xuICAgICAgICAgICAgICAgIHBhcmFtLnR5cGUuc2xpY2UoOSwgLTEpIDpcbiAgICAgICAgICAgICAgICBwYXJhbS50eXBlKTtcbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhd1BhcmFtID0geyBuYW1lOiBwYXJhbS5uYW1lLCB0eXBlOiByYXdUeXBlLCBjb21wb25lbnRzOiBwYXJhbS5jb21wb25lbnRzIH07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0b2tlbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlVG9rZW5WYWx1ZShyYXdQYXJhbSwgaXRlbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09wdGlvbmFsKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3UGFyYW0gPSB7IG5hbWU6IHBhcmFtLm5hbWUsIHR5cGU6IHJhd1R5cGUsIGNvbXBvbmVudHM6IHBhcmFtLmNvbXBvbmVudHMgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblZhbHVlKHJhd1BhcmFtLCB0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmF3VHlwZSA9PT0gJ3R1cGxlJykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAocGFyYW0uY29tcG9uZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgcGFyYW0uY29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbY29tcG9uZW50Lm5hbWVdID0gcGFyc2VUb2tlblZhbHVlKGNvbXBvbmVudCwgdG9rZW5bY29tcG9uZW50Lm5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJhd1R5cGUgPT09ICdhZGRyZXNzJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB1dGlsc18xLkFkZHJlc3ModG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgW2tleVR5cGUsIHZhbHVlVHlwZV0gPSBwYXJhbS50eXBlLnNwbGl0KCcsJyk7XG4gICAgICAgIGtleVR5cGUgPSBrZXlUeXBlLnNsaWNlKDQpO1xuICAgICAgICB2YWx1ZVR5cGUgPSB2YWx1ZVR5cGUuc2xpY2UoMCwgLTEpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdG9rZW4pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtwYXJzZVRva2VuVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZToga2V5VHlwZSxcbiAgICAgICAgICAgICAgICB9LCBrZXkpLCBwYXJzZVRva2VuVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdmFsdWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBwYXJhbS5jb21wb25lbnRzLFxuICAgICAgICAgICAgICAgIH0sIHZhbHVlKV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/everscale-inpage-provider/dist/models.js\n");

/***/ }),

/***/ "./node_modules/everscale-inpage-provider/dist/stream.js":
/*!***************************************************************!*\
  !*** ./node_modules/everscale-inpage-provider/dist/stream.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Subscriber = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/everscale-inpage-provider/dist/utils.js\");\nconst models_1 = __webpack_require__(/*! ./models */ \"./node_modules/everscale-inpage-provider/dist/models.js\");\n/**\n * @category Stream\n */\nclass Subscriber {\n    constructor(provider) {\n        this.provider = provider;\n        this.subscriptions = new Map();\n        this.scanners = new Map();\n        this.unsubscribe = async () => this._unsubscribe();\n    }\n    /**\n     * Returns a stream of new transactions\n     */\n    transactions(address) {\n        return this._addSubscription('transactionsFound', address, false);\n    }\n    /**\n     * Returns a finite stream of child transactions\n     * @param transaction - root transaction\n     */\n    trace(transaction) {\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl((onData, onEnd) => {\n            const scanner = new TraceTransactionsScanner(this.provider, {\n                origin: transaction,\n                onData,\n                onEnd: (eof) => {\n                    this.scanners.delete(id);\n                    onEnd(eof);\n                },\n            });\n            this.scanners.set(id, scanner);\n            scanner.start();\n            // Subscription is not required\n            return Promise.resolve();\n        }, async () => {\n            const scanner = this.scanners.get(id);\n            if (scanner != null) {\n                this.scanners.delete(id);\n                await scanner.stop();\n            }\n        }, identity, true);\n    }\n    /**\n     * Returns a stream of old transactions\n     */\n    oldTransactions(address, filter) {\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl((onData, onEnd) => {\n            const scanner = new UnorderedTransactionsScanner(this.provider, {\n                address,\n                onData,\n                onEnd: (eof) => {\n                    this.scanners.delete(id);\n                    onEnd(eof);\n                },\n                ...filter,\n            });\n            this.scanners.set(id, scanner);\n            scanner.start();\n            // Subscription is not required\n            return Promise.resolve();\n        }, async () => {\n            const scanner = this.scanners.get(id);\n            if (scanner != null) {\n                this.scanners.delete(id);\n                await scanner.stop();\n            }\n        }, identity, true);\n    }\n    states(address) {\n        return this._addSubscription('contractStateChanged', address, false);\n    }\n    async _unsubscribe() {\n        const tasks = [];\n        for (const item of this.subscriptions.values()) {\n            for (const [event, eventData] of Object.entries(item)) {\n                delete item[event];\n                if (eventData != null) {\n                    tasks.push(eventData.subscription\n                        .then(item => item.unsubscribe())\n                        .catch(() => {\n                    }));\n                }\n            }\n        }\n        this.subscriptions.clear();\n        for (const scanner of this.scanners.values()) {\n            tasks.push(scanner.stop());\n        }\n        this.scanners.clear();\n        await Promise.all(tasks);\n    }\n    _addSubscription(event, address, isFinite) {\n        const rawAddress = address.toString();\n        const stopProducer = (id) => {\n            const subscriptions = this.subscriptions.get(rawAddress);\n            if (subscriptions == null) {\n                // No subscriptions for the address\n                return;\n            }\n            const eventData = subscriptions[event];\n            if (eventData != null) {\n                const handler = eventData.handlers.get(id);\n                if (handler != null) {\n                    // Remove event handler with the id\n                    eventData.handlers.delete(id);\n                    const { queue, onEnd, state } = handler;\n                    if (!state.finished) {\n                        state.finished = true;\n                        queue.clear();\n                        queue.enqueue(async () => onEnd(state.eof));\n                    }\n                }\n                // Remove event data subscription if there are none of them\n                if (eventData.handlers.size === 0) {\n                    const subscription = eventData.subscription;\n                    delete subscriptions[event];\n                    subscription\n                        .then((subscription) => subscription.unsubscribe())\n                        .catch(console.debug);\n                }\n            }\n            // Remove address subscriptions object if it is empty\n            if (subscriptions.contractStateChanged == null && subscriptions.transactionsFound == null) {\n                this.subscriptions.delete(rawAddress);\n            }\n        };\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl((onData, onEnd) => {\n            const subscriptions = this.subscriptions.get(rawAddress);\n            let eventData = subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions[event];\n            const state = { eof: false, finished: false };\n            // Create handler object\n            const handler = {\n                onData,\n                onEnd,\n                queue: new PromiseQueue(),\n                state,\n            };\n            if (eventData != null) {\n                // Add handler if there is already a handler group\n                eventData.handlers.set(id, handler);\n                return Promise.resolve();\n            }\n            // Create handlers group\n            const handlers = new Map();\n            handlers.set(id, handler);\n            // Create subscription\n            const subscription = this.provider.subscribe(event, { address })\n                .then((subscription) => {\n                subscription.on('data', (data) => {\n                    for (const { onData, queue, state } of handlers.values()) {\n                        // Skip closed streams\n                        if (state.eof || state.finished) {\n                            continue;\n                        }\n                        queue.enqueue(async () => {\n                            if (!(await onData(data))) {\n                                state.eof = true;\n                                stopProducer(id);\n                            }\n                        });\n                    }\n                });\n                subscription.on('unsubscribed', () => {\n                    for (const id of handlers.keys()) {\n                        stopProducer(id);\n                    }\n                });\n                return subscription;\n            }).catch((e) => {\n                console.error(e);\n                for (const id of handlers.keys()) {\n                    stopProducer(id);\n                }\n                throw e;\n            });\n            // Add event data to subscriptions\n            eventData = { subscription, handlers };\n            if (subscriptions == null) {\n                this.subscriptions.set(rawAddress, { [event]: eventData });\n            }\n            else {\n                subscriptions[event] = eventData;\n            }\n            // Wait until subscribed\n            return subscription.then(() => {\n            });\n        }, () => stopProducer(id), identity, isFinite);\n    }\n}\nexports.Subscriber = Subscriber;\nasync function identity(item, handler) {\n    return handler(item);\n}\nclass StreamImpl {\n    constructor(makeProducer, stopProducer, extractor, isFinite) {\n        this.makeProducer = makeProducer;\n        this.stopProducer = stopProducer;\n        this.extractor = extractor;\n        this.isFinite = isFinite;\n        /**\n         * Folds every element into an accumulator by applying an operation, returning the final result\n         */\n        this.fold = this.onlyFinite((init, f, ctx) => {\n            let state = init;\n            return new Promise((resolve, reject) => {\n                const subscribed = this.makeProducer(\n                // onData\n                (data) => this.extractor(data, async (item) => {\n                    state = await f(state, item);\n                    return true;\n                }), \n                // onEnd\n                (eof) => {\n                    if (eof) {\n                        resolve(state);\n                    }\n                    else {\n                        reject(new Error('Subscription closed'));\n                    }\n                });\n                if (ctx != null) {\n                    ctx.subscribed = subscribed;\n                }\n            });\n        });\n        /**\n         * Waits until the end of the stream\n         */\n        this.finished = this.onlyFinite((ctx) => {\n            return new Promise((resolve, reject) => {\n                const subscribed = this.makeProducer(\n                // onData\n                (data) => this.extractor(data, (_item) => true), \n                // onEnd\n                (eof) => {\n                    if (eof) {\n                        resolve(undefined);\n                    }\n                    else {\n                        reject(new Error('Subscription closed'));\n                    }\n                });\n                if (ctx != null) {\n                    ctx.subscribed = subscribed;\n                }\n            });\n        });\n    }\n    async delayed(f) {\n        const { subscribed, result } = f({\n            first: (() => {\n                const ctx = {};\n                const result = this.first(ctx);\n                return { subscribed: ctx.subscribed, result };\n            }),\n            on: (handler) => {\n                const ctx = {};\n                this.on(handler, ctx);\n                return { subscribed: ctx.subscribed, result: undefined };\n            },\n            fold: this.fold != null ? (init, f) => {\n                const ctx = {};\n                const result = this.fold(init, f, ctx);\n                return { subscribed: ctx.subscribed, result };\n            } : undefined,\n            finished: this.finished != null ? () => {\n                const ctx = {};\n                const result = this.finished(ctx);\n                return { subscribed: ctx.subscribed, result };\n            } : undefined,\n        });\n        await subscribed;\n        return () => result;\n    }\n    first(ctx) {\n        const state = { found: false };\n        return new Promise((resolve, reject) => {\n            const subscribed = this.makeProducer(\n            // onData\n            (data) => this.extractor(data, (item) => {\n                Object.assign(state, { found: true, result: item });\n                return false;\n            }), \n            // onEnd\n            (eof) => {\n                if (eof) {\n                    if (this.isFinite) {\n                        resolve((state.found ? state.result : undefined));\n                    }\n                    else if (state.found) {\n                        resolve(state.result);\n                    }\n                    else {\n                        reject(new Error('Unexpected end of stream'));\n                    }\n                }\n                else {\n                    reject(new Error('Subscription closed'));\n                }\n            });\n            if (ctx != null) {\n                ctx.subscribed = subscribed;\n            }\n        });\n    }\n    on(handler, ctx) {\n        const subscribed = this.makeProducer((event) => this.extractor(event, async (item) => {\n            await handler(item);\n            return true;\n        }), (_eof) => {\n        });\n        if (ctx != null) {\n            ctx.subscribed = subscribed;\n        }\n    }\n    merge(other) {\n        return new StreamImpl((onData, onEnd) => {\n            const state = {\n                stopped: false,\n                counter: 0,\n            };\n            const checkEnd = (eof) => {\n                if (state.stopped) {\n                    return;\n                }\n                if (++state.counter == 2 || !eof) {\n                    state.stopped = true;\n                    onEnd(eof);\n                }\n            };\n            return Promise.all([\n                this.makeProducer(onData, checkEnd),\n                other.makeProducer(onData, checkEnd),\n            ]).then(() => {\n            });\n        }, () => {\n            this.stopProducer();\n            other.stopProducer();\n        }, this.extractor, (this.isFinite && other.isFinite));\n    }\n    enumerate() {\n        const state = {\n            index: 0,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            return handler({\n                index: state.index++,\n                item,\n            });\n        }), this.isFinite);\n    }\n    tap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            await f(item);\n            return handler(item);\n        }), this.isFinite);\n    }\n    filter(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (await f(item)) {\n                return handler(item);\n            }\n            else {\n                return true;\n            }\n        }), this.isFinite);\n    }\n    filterMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const newItem = await f(item);\n            if (newItem !== undefined) {\n                return handler(newItem);\n            }\n            else {\n                return true;\n            }\n        }), this.isFinite);\n    }\n    map(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const newItem = await f(item);\n            return handler(newItem);\n        }), this.isFinite);\n    }\n    flatMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const items = await f(item);\n            for (const newItem of items) {\n                if (!(await handler(newItem))) {\n                    return false;\n                }\n            }\n            return true;\n        }), this.isFinite);\n    }\n    skip(n) {\n        const state = {\n            index: 0,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, (item) => {\n            if (state.index >= n) {\n                return handler(item);\n            }\n            else {\n                ++state.index;\n                return true;\n            }\n        }), this.isFinite);\n    }\n    skipWhile(f) {\n        const state = {\n            shouldSkip: true,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (!state.shouldSkip || !(await f(item))) {\n                state.shouldSkip = false;\n                return handler(item);\n            }\n            else {\n                return true;\n            }\n        }), this.isFinite);\n    }\n    take(n) {\n        const state = {\n            index: 0,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, (item) => {\n            if (state.index < n) {\n                ++state.index;\n                return handler(item);\n            }\n            else {\n                return false;\n            }\n        }), true);\n    }\n    takeWhile(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (await f(item)) {\n                return handler(item);\n            }\n            else {\n                return false;\n            }\n        }), true);\n    }\n    takeWhileMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const newItem = await f(item);\n            if (newItem !== undefined) {\n                return handler(newItem);\n            }\n            else {\n                return false;\n            }\n        }), true);\n    }\n    onlyFinite(f) {\n        if (this.isFinite) {\n            return f;\n        }\n        else {\n            return undefined;\n        }\n    }\n}\nclass UnorderedTransactionsScanner {\n    constructor(provider, params) {\n        this.provider = provider;\n        this.params = params;\n        this.queue = new PromiseQueue();\n        this.isRunning = false;\n    }\n    start() {\n        if (this.isRunning || this.promise != null) {\n            return;\n        }\n        this.isRunning = true;\n        this.promise = (async () => {\n            const params = this.params;\n            const state = {\n                complete: false,\n            };\n            while (this.isRunning && !state.complete) {\n                try {\n                    const { transactions, continuation } = await this.provider.getTransactions({\n                        address: this.params.address,\n                        continuation: this.continuation,\n                    });\n                    state.complete = !state.complete && transactions.length == null;\n                    if (!this.isRunning || state.complete) {\n                        break;\n                    }\n                    const filteredTransactions = transactions.filter((item) => ((params.fromLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, params.fromLt) > 0) &&\n                        (params.fromUtime == null || item.createdAt > params.fromUtime)));\n                    if (filteredTransactions.length == 0) {\n                        state.complete = true;\n                        break;\n                    }\n                    const info = {\n                        maxLt: filteredTransactions[0].id.lt,\n                        minLt: filteredTransactions[filteredTransactions.length - 1].id.lt,\n                        batchType: 'old',\n                    };\n                    this.queue.enqueue(async () => {\n                        const isRunning = this.params.onData({\n                            address: this.params.address,\n                            transactions: filteredTransactions,\n                            info,\n                        });\n                        if (!isRunning) {\n                            state.complete = true;\n                            this.isRunning = false;\n                        }\n                    });\n                    if (continuation != null) {\n                        this.continuation = continuation;\n                    }\n                    else {\n                        state.complete = true;\n                        break;\n                    }\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            }\n            this.queue.enqueue(async () => this.params.onEnd(state.complete));\n            this.isRunning = false;\n            this.continuation = undefined;\n        })();\n    }\n    async stop() {\n        this.isRunning = false;\n        this.queue.clear();\n        if (this.promise != null) {\n            await this.promise;\n        }\n        else {\n            this.params.onEnd(false);\n        }\n    }\n}\nclass TraceTransactionsScanner {\n    constructor(provider, params) {\n        this.provider = provider;\n        this.params = params;\n        this.queue = new PromiseQueue();\n        this.isRunning = false;\n        this.semaphore = new utils_1.Semaphore(10);\n    }\n    start() {\n        if (this.isRunning || this.promise != null) {\n            return;\n        }\n        const provider = this.provider;\n        this.isRunning = true;\n        this.promise = (async () => {\n            const state = {\n                complete: false,\n            };\n            const makePendingTransaction = (messageHash) => {\n                const state = { stopped: false };\n                const promise = (async () => {\n                    let timeout = 500;\n                    while (true) {\n                        const release = await this.semaphore.acquire();\n                        if (state.stopped) {\n                            release();\n                            return;\n                        }\n                        const result = await provider.rawApi.findTransaction({\n                            inMessageHash: messageHash,\n                        }).catch(() => ({ transaction: undefined })).finally(() => release());\n                        if (state.stopped) {\n                            return;\n                        }\n                        if (result.transaction != null) {\n                            const transaction = (0, models_1.parseTransaction)(result.transaction);\n                            transaction.account = transaction.inMessage.dst;\n                            return transaction;\n                        }\n                        let resolve;\n                        const promise = new Promise((resolvePromise, rejectPromise) => {\n                            resolve = () => resolvePromise();\n                            state.reject = () => rejectPromise();\n                        });\n                        state.timeout = setTimeout(resolve, timeout);\n                        await promise;\n                        if (state.stopped) {\n                            return;\n                        }\n                        state.reject = undefined;\n                        timeout = Math.min(timeout * 2, 3000);\n                    }\n                })();\n                const reject = () => {\n                    var _a;\n                    state.stopped = true;\n                    (_a = state.reject) === null || _a === void 0 ? void 0 : _a.call(state);\n                    if (state.timeout != null) {\n                        clearTimeout(state.timeout);\n                    }\n                };\n                return { promise, reject };\n            };\n            const transactionsQueue = [this.params.origin];\n            try {\n                outer: while (this.isRunning) {\n                    const transaction = transactionsQueue.shift();\n                    if (transaction == null) {\n                        state.complete = true;\n                        break;\n                    }\n                    // Spawn promises\n                    const pendingTransactions = transaction\n                        .outMessages\n                        .filter((message) => message.dst != null)\n                        .map((message) => {\n                        const messageHash = message.hash;\n                        return makePendingTransaction(messageHash);\n                    });\n                    this.pendingTransactions = pendingTransactions;\n                    for (const { promise } of pendingTransactions) {\n                        const childTransaction = await promise;\n                        if (!this.isRunning || state.complete || childTransaction == null) {\n                            break outer;\n                        }\n                        this.queue.enqueue(async () => {\n                            const isRunning = this.params.onData(childTransaction);\n                            if (!isRunning) {\n                                state.complete = true;\n                                this.isRunning = false;\n                                this.rejectPendingTransactions();\n                            }\n                        });\n                        transactionsQueue.push(childTransaction);\n                    }\n                    this.pendingTransactions = undefined;\n                }\n            }\n            catch (e) {\n                console.error(e);\n                /* do nothing */\n            }\n            finally {\n                this.queue.enqueue(async () => this.params.onEnd(state.complete));\n                this.isRunning = false;\n                this.rejectPendingTransactions();\n            }\n        })();\n    }\n    async stop() {\n        this.isRunning = false;\n        this.queue.clear();\n        this.rejectPendingTransactions();\n        if (this.promise != null) {\n            await this.promise;\n        }\n        else {\n            this.params.onEnd(false);\n        }\n    }\n    rejectPendingTransactions() {\n        if (this.pendingTransactions != null) {\n            for (const pendingTransaction of this.pendingTransactions) {\n                pendingTransaction.reject();\n            }\n            this.pendingTransactions = undefined;\n        }\n        this.semaphore.releaseAll();\n    }\n}\nclass PromiseQueue {\n    constructor() {\n        this.queue = [];\n        this.workingOnPromise = false;\n    }\n    enqueue(promise) {\n        this.queue.push(promise);\n        this._dequeue().catch(() => {\n        });\n    }\n    clear() {\n        this.queue.length = 0;\n    }\n    async _dequeue() {\n        if (this.workingOnPromise) {\n            return;\n        }\n        const item = this.queue.shift();\n        if (!item) {\n            return;\n        }\n        this.workingOnPromise = true;\n        item()\n            .then(() => {\n            this.workingOnPromise = false;\n            this._dequeue();\n        })\n            .catch(() => {\n            this.workingOnPromise = false;\n            this._dequeue();\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLWlucGFnZS1wcm92aWRlci9kaXN0L3N0cmVhbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9ldmVyc2NhbGUtaW5wYWdlLXByb3ZpZGVyL2Rpc3Qvc3RyZWFtLmpzPzQ1ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN1YnNjcmliZXIgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBtb2RlbHNfMSA9IHJlcXVpcmUoXCIuL21vZGVsc1wiKTtcbi8qKlxuICogQGNhdGVnb3J5IFN0cmVhbVxuICovXG5jbGFzcyBTdWJzY3JpYmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zY2FubmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSA9IGFzeW5jICgpID0+IHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJlYW0gb2YgbmV3IHRyYW5zYWN0aW9uc1xuICAgICAqL1xuICAgIHRyYW5zYWN0aW9ucyhhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRTdWJzY3JpcHRpb24oJ3RyYW5zYWN0aW9uc0ZvdW5kJywgYWRkcmVzcywgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZmluaXRlIHN0cmVhbSBvZiBjaGlsZCB0cmFuc2FjdGlvbnNcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSByb290IHRyYW5zYWN0aW9uXG4gICAgICovXG4gICAgdHJhY2UodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgaWQgPSAoMCwgdXRpbHNfMS5nZXRVbmlxdWVJZCkoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKChvbkRhdGEsIG9uRW5kKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2FubmVyID0gbmV3IFRyYWNlVHJhbnNhY3Rpb25zU2Nhbm5lcih0aGlzLnByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgb3JpZ2luOiB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBvbkRhdGEsXG4gICAgICAgICAgICAgICAgb25FbmQ6IChlb2YpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FubmVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgICAgICBvbkVuZChlb2YpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2Nhbm5lcnMuc2V0KGlkLCBzY2FubmVyKTtcbiAgICAgICAgICAgIHNjYW5uZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIC8vIFN1YnNjcmlwdGlvbiBpcyBub3QgcmVxdWlyZWRcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2Nhbm5lciA9IHRoaXMuc2Nhbm5lcnMuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmIChzY2FubmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc2Nhbm5lci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGlkZW50aXR5LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmVhbSBvZiBvbGQgdHJhbnNhY3Rpb25zXG4gICAgICovXG4gICAgb2xkVHJhbnNhY3Rpb25zKGFkZHJlc3MsIGZpbHRlcikge1xuICAgICAgICBjb25zdCBpZCA9ICgwLCB1dGlsc18xLmdldFVuaXF1ZUlkKSgpO1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwoKG9uRGF0YSwgb25FbmQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjYW5uZXIgPSBuZXcgVW5vcmRlcmVkVHJhbnNhY3Rpb25zU2Nhbm5lcih0aGlzLnByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBvbkRhdGEsXG4gICAgICAgICAgICAgICAgb25FbmQ6IChlb2YpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FubmVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgICAgICBvbkVuZChlb2YpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLi4uZmlsdGVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNjYW5uZXJzLnNldChpZCwgc2Nhbm5lcik7XG4gICAgICAgICAgICBzY2FubmVyLnN0YXJ0KCk7XG4gICAgICAgICAgICAvLyBTdWJzY3JpcHRpb24gaXMgbm90IHJlcXVpcmVkXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH0sIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjYW5uZXIgPSB0aGlzLnNjYW5uZXJzLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoc2Nhbm5lciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FubmVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHNjYW5uZXIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpZGVudGl0eSwgdHJ1ZSk7XG4gICAgfVxuICAgIHN0YXRlcyhhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRTdWJzY3JpcHRpb24oJ2NvbnRyYWN0U3RhdGVDaGFuZ2VkJywgYWRkcmVzcywgZmFsc2UpO1xuICAgIH1cbiAgICBhc3luYyBfdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGNvbnN0IHRhc2tzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLnN1YnNjcmlwdGlvbnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2V2ZW50LCBldmVudERhdGFdIG9mIE9iamVjdC5lbnRyaWVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW1bZXZlbnRdO1xuICAgICAgICAgICAgICAgIGlmIChldmVudERhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKGV2ZW50RGF0YS5zdWJzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGl0ZW0gPT4gaXRlbS51bnN1YnNjcmliZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgZm9yIChjb25zdCBzY2FubmVyIG9mIHRoaXMuc2Nhbm5lcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHRhc2tzLnB1c2goc2Nhbm5lci5zdG9wKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nhbm5lcnMuY2xlYXIoKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGFza3MpO1xuICAgIH1cbiAgICBfYWRkU3Vic2NyaXB0aW9uKGV2ZW50LCBhZGRyZXNzLCBpc0Zpbml0ZSkge1xuICAgICAgICBjb25zdCByYXdBZGRyZXNzID0gYWRkcmVzcy50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBzdG9wUHJvZHVjZXIgPSAoaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KHJhd0FkZHJlc3MpO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIHN1YnNjcmlwdGlvbnMgZm9yIHRoZSBhZGRyZXNzXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXZlbnREYXRhID0gc3Vic2NyaXB0aW9uc1tldmVudF07XG4gICAgICAgICAgICBpZiAoZXZlbnREYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gZXZlbnREYXRhLmhhbmRsZXJzLmdldChpZCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZXZlbnQgaGFuZGxlciB3aXRoIHRoZSBpZFxuICAgICAgICAgICAgICAgICAgICBldmVudERhdGEuaGFuZGxlcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBxdWV1ZSwgb25FbmQsIHN0YXRlIH0gPSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiBvbkVuZChzdGF0ZS5lb2YpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZXZlbnQgZGF0YSBzdWJzY3JpcHRpb24gaWYgdGhlcmUgYXJlIG5vbmUgb2YgdGhlbVxuICAgICAgICAgICAgICAgIGlmIChldmVudERhdGEuaGFuZGxlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBldmVudERhdGEuc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3Vic2NyaXB0aW9uc1tldmVudF07XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHN1YnNjcmlwdGlvbikgPT4gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goY29uc29sZS5kZWJ1Zyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIGFkZHJlc3Mgc3Vic2NyaXB0aW9ucyBvYmplY3QgaWYgaXQgaXMgZW1wdHlcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25zLmNvbnRyYWN0U3RhdGVDaGFuZ2VkID09IG51bGwgJiYgc3Vic2NyaXB0aW9ucy50cmFuc2FjdGlvbnNGb3VuZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmRlbGV0ZShyYXdBZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaWQgPSAoMCwgdXRpbHNfMS5nZXRVbmlxdWVJZCkoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKChvbkRhdGEsIG9uRW5kKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zLmdldChyYXdBZGRyZXNzKTtcbiAgICAgICAgICAgIGxldCBldmVudERhdGEgPSBzdWJzY3JpcHRpb25zID09PSBudWxsIHx8IHN1YnNjcmlwdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1YnNjcmlwdGlvbnNbZXZlbnRdO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB7IGVvZjogZmFsc2UsIGZpbmlzaGVkOiBmYWxzZSB9O1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGhhbmRsZXIgb2JqZWN0XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0ge1xuICAgICAgICAgICAgICAgIG9uRGF0YSxcbiAgICAgICAgICAgICAgICBvbkVuZCxcbiAgICAgICAgICAgICAgICBxdWV1ZTogbmV3IFByb21pc2VRdWV1ZSgpLFxuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChldmVudERhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBoYW5kbGVyIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBoYW5kbGVyIGdyb3VwXG4gICAgICAgICAgICAgICAgZXZlbnREYXRhLmhhbmRsZXJzLnNldChpZCwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3JlYXRlIGhhbmRsZXJzIGdyb3VwXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGhhbmRsZXJzLnNldChpZCwgaGFuZGxlcik7XG4gICAgICAgICAgICAvLyBDcmVhdGUgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLnByb3ZpZGVyLnN1YnNjcmliZShldmVudCwgeyBhZGRyZXNzIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBvbkRhdGEsIHF1ZXVlLCBzdGF0ZSB9IG9mIGhhbmRsZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGNsb3NlZCBzdHJlYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZW9mIHx8IHN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhd2FpdCBvbkRhdGEoZGF0YSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmVvZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BQcm9kdWNlcihpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24ub24oJ3Vuc3Vic2NyaWJlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpZCBvZiBoYW5kbGVycy5rZXlzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BQcm9kdWNlcihpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaWQgb2YgaGFuZGxlcnMua2V5cygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BQcm9kdWNlcihpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFkZCBldmVudCBkYXRhIHRvIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIGV2ZW50RGF0YSA9IHsgc3Vic2NyaXB0aW9uLCBoYW5kbGVycyB9O1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQocmF3QWRkcmVzcywgeyBbZXZlbnRdOiBldmVudERhdGEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zW2V2ZW50XSA9IGV2ZW50RGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgc3Vic2NyaWJlZFxuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbi50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCAoKSA9PiBzdG9wUHJvZHVjZXIoaWQpLCBpZGVudGl0eSwgaXNGaW5pdGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3Vic2NyaWJlciA9IFN1YnNjcmliZXI7XG5hc3luYyBmdW5jdGlvbiBpZGVudGl0eShpdGVtLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGhhbmRsZXIoaXRlbSk7XG59XG5jbGFzcyBTdHJlYW1JbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihtYWtlUHJvZHVjZXIsIHN0b3BQcm9kdWNlciwgZXh0cmFjdG9yLCBpc0Zpbml0ZSkge1xuICAgICAgICB0aGlzLm1ha2VQcm9kdWNlciA9IG1ha2VQcm9kdWNlcjtcbiAgICAgICAgdGhpcy5zdG9wUHJvZHVjZXIgPSBzdG9wUHJvZHVjZXI7XG4gICAgICAgIHRoaXMuZXh0cmFjdG9yID0gZXh0cmFjdG9yO1xuICAgICAgICB0aGlzLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb2xkcyBldmVyeSBlbGVtZW50IGludG8gYW4gYWNjdW11bGF0b3IgYnkgYXBwbHlpbmcgYW4gb3BlcmF0aW9uLCByZXR1cm5pbmcgdGhlIGZpbmFsIHJlc3VsdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb2xkID0gdGhpcy5vbmx5RmluaXRlKChpbml0LCBmLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IGluaXQ7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZWQgPSB0aGlzLm1ha2VQcm9kdWNlcihcbiAgICAgICAgICAgICAgICAvLyBvbkRhdGFcbiAgICAgICAgICAgICAgICAoZGF0YSkgPT4gdGhpcy5leHRyYWN0b3IoZGF0YSwgYXN5bmMgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBhd2FpdCBmKHN0YXRlLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgICAgIC8vIG9uRW5kXG4gICAgICAgICAgICAgICAgKGVvZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1N1YnNjcmlwdGlvbiBjbG9zZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN1YnNjcmliZWQgPSBzdWJzY3JpYmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdhaXRzIHVudGlsIHRoZSBlbmQgb2YgdGhlIHN0cmVhbVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRoaXMub25seUZpbml0ZSgoY3R4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZWQgPSB0aGlzLm1ha2VQcm9kdWNlcihcbiAgICAgICAgICAgICAgICAvLyBvbkRhdGFcbiAgICAgICAgICAgICAgICAoZGF0YSkgPT4gdGhpcy5leHRyYWN0b3IoZGF0YSwgKF9pdGVtKSA9PiB0cnVlKSwgXG4gICAgICAgICAgICAgICAgLy8gb25FbmRcbiAgICAgICAgICAgICAgICAoZW9mKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1N1YnNjcmlwdGlvbiBjbG9zZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN1YnNjcmliZWQgPSBzdWJzY3JpYmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZGVsYXllZChmKSB7XG4gICAgICAgIGNvbnN0IHsgc3Vic2NyaWJlZCwgcmVzdWx0IH0gPSBmKHtcbiAgICAgICAgICAgIGZpcnN0OiAoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZmlyc3QoY3R4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdWJzY3JpYmVkOiBjdHguc3Vic2NyaWJlZCwgcmVzdWx0IH07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9uOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMub24oaGFuZGxlciwgY3R4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdWJzY3JpYmVkOiBjdHguc3Vic2NyaWJlZCwgcmVzdWx0OiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb2xkOiB0aGlzLmZvbGQgIT0gbnVsbCA/IChpbml0LCBmKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0ge307XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5mb2xkKGluaXQsIGYsIGN0eCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3Vic2NyaWJlZDogY3R4LnN1YnNjcmliZWQsIHJlc3VsdCB9O1xuICAgICAgICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZpbmlzaGVkOiB0aGlzLmZpbmlzaGVkICE9IG51bGwgPyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0ge307XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5maW5pc2hlZChjdHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN1YnNjcmliZWQ6IGN0eC5zdWJzY3JpYmVkLCByZXN1bHQgfTtcbiAgICAgICAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBzdWJzY3JpYmVkO1xuICAgICAgICByZXR1cm4gKCkgPT4gcmVzdWx0O1xuICAgIH1cbiAgICBmaXJzdChjdHgpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7IGZvdW5kOiBmYWxzZSB9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlZCA9IHRoaXMubWFrZVByb2R1Y2VyKFxuICAgICAgICAgICAgLy8gb25EYXRhXG4gICAgICAgICAgICAoZGF0YSkgPT4gdGhpcy5leHRyYWN0b3IoZGF0YSwgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0YXRlLCB7IGZvdW5kOiB0cnVlLCByZXN1bHQ6IGl0ZW0gfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgLy8gb25FbmRcbiAgICAgICAgICAgIChlb2YpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRmluaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKChzdGF0ZS5mb3VuZCA/IHN0YXRlLnJlc3VsdCA6IHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlLmZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0YXRlLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBzdHJlYW0nKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1N1YnNjcmlwdGlvbiBjbG9zZWQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Vic2NyaWJlZCA9IHN1YnNjcmliZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbihoYW5kbGVyLCBjdHgpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlZCA9IHRoaXMubWFrZVByb2R1Y2VyKChldmVudCkgPT4gdGhpcy5leHRyYWN0b3IoZXZlbnQsIGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVyKGl0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pLCAoX2VvZikgPT4ge1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdHguc3Vic2NyaWJlZCA9IHN1YnNjcmliZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKChvbkRhdGEsIG9uRW5kKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBzdG9wcGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb3VudGVyOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrRW5kID0gKGVvZikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCsrc3RhdGUuY291bnRlciA9PSAyIHx8ICFlb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG9uRW5kKGVvZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5tYWtlUHJvZHVjZXIob25EYXRhLCBjaGVja0VuZCksXG4gICAgICAgICAgICAgICAgb3RoZXIubWFrZVByb2R1Y2VyKG9uRGF0YSwgY2hlY2tFbmQpLFxuICAgICAgICAgICAgXSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdG9wUHJvZHVjZXIoKTtcbiAgICAgICAgICAgIG90aGVyLnN0b3BQcm9kdWNlcigpO1xuICAgICAgICB9LCB0aGlzLmV4dHJhY3RvciwgKHRoaXMuaXNGaW5pdGUgJiYgb3RoZXIuaXNGaW5pdGUpKTtcbiAgICB9XG4gICAgZW51bWVyYXRlKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwodGhpcy5tYWtlUHJvZHVjZXIsIHRoaXMuc3RvcFByb2R1Y2VyLCAoZXZlbnQsIGhhbmRsZXIpID0+IHRoaXMuZXh0cmFjdG9yKGV2ZW50LCBhc3luYyAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIGluZGV4OiBzdGF0ZS5pbmRleCsrLFxuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSksIHRoaXMuaXNGaW5pdGUpO1xuICAgIH1cbiAgICB0YXAoZikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwodGhpcy5tYWtlUHJvZHVjZXIsIHRoaXMuc3RvcFByb2R1Y2VyLCAoZXZlbnQsIGhhbmRsZXIpID0+IHRoaXMuZXh0cmFjdG9yKGV2ZW50LCBhc3luYyAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgZihpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyKGl0ZW0pO1xuICAgICAgICB9KSwgdGhpcy5pc0Zpbml0ZSk7XG4gICAgfVxuICAgIGZpbHRlcihmKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCh0aGlzLm1ha2VQcm9kdWNlciwgdGhpcy5zdG9wUHJvZHVjZXIsIChldmVudCwgaGFuZGxlcikgPT4gdGhpcy5leHRyYWN0b3IoZXZlbnQsIGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXdhaXQgZihpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCB0aGlzLmlzRmluaXRlKTtcbiAgICB9XG4gICAgZmlsdGVyTWFwKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKHRoaXMubWFrZVByb2R1Y2VyLCB0aGlzLnN0b3BQcm9kdWNlciwgKGV2ZW50LCBoYW5kbGVyKSA9PiB0aGlzLmV4dHJhY3RvcihldmVudCwgYXN5bmMgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW0gPSBhd2FpdCBmKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKG5ld0l0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyKG5ld0l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCB0aGlzLmlzRmluaXRlKTtcbiAgICB9XG4gICAgbWFwKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKHRoaXMubWFrZVByb2R1Y2VyLCB0aGlzLnN0b3BQcm9kdWNlciwgKGV2ZW50LCBoYW5kbGVyKSA9PiB0aGlzLmV4dHJhY3RvcihldmVudCwgYXN5bmMgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW0gPSBhd2FpdCBmKGl0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIobmV3SXRlbSk7XG4gICAgICAgIH0pLCB0aGlzLmlzRmluaXRlKTtcbiAgICB9XG4gICAgZmxhdE1hcChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCh0aGlzLm1ha2VQcm9kdWNlciwgdGhpcy5zdG9wUHJvZHVjZXIsIChldmVudCwgaGFuZGxlcikgPT4gdGhpcy5leHRyYWN0b3IoZXZlbnQsIGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IGF3YWl0IGYoaXRlbSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5ld0l0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShhd2FpdCBoYW5kbGVyKG5ld0l0ZW0pKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pLCB0aGlzLmlzRmluaXRlKTtcbiAgICB9XG4gICAgc2tpcChuKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCh0aGlzLm1ha2VQcm9kdWNlciwgdGhpcy5zdG9wUHJvZHVjZXIsIChldmVudCwgaGFuZGxlcikgPT4gdGhpcy5leHRyYWN0b3IoZXZlbnQsIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaW5kZXggPj0gbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKytzdGF0ZS5pbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHRoaXMuaXNGaW5pdGUpO1xuICAgIH1cbiAgICBza2lwV2hpbGUoZikge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIHNob3VsZFNraXA6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCh0aGlzLm1ha2VQcm9kdWNlciwgdGhpcy5zdG9wUHJvZHVjZXIsIChldmVudCwgaGFuZGxlcikgPT4gdGhpcy5leHRyYWN0b3IoZXZlbnQsIGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLnNob3VsZFNraXAgfHwgIShhd2FpdCBmKGl0ZW0pKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnNob3VsZFNraXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcihpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgdGhpcy5pc0Zpbml0ZSk7XG4gICAgfVxuICAgIHRha2Uobikge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwodGhpcy5tYWtlUHJvZHVjZXIsIHRoaXMuc3RvcFByb2R1Y2VyLCAoZXZlbnQsIGhhbmRsZXIpID0+IHRoaXMuZXh0cmFjdG9yKGV2ZW50LCAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmluZGV4IDwgbikge1xuICAgICAgICAgICAgICAgICsrc3RhdGUuaW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCB0cnVlKTtcbiAgICB9XG4gICAgdGFrZVdoaWxlKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKHRoaXMubWFrZVByb2R1Y2VyLCB0aGlzLnN0b3BQcm9kdWNlciwgKGV2ZW50LCBoYW5kbGVyKSA9PiB0aGlzLmV4dHJhY3RvcihldmVudCwgYXN5bmMgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChhd2FpdCBmKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCB0cnVlKTtcbiAgICB9XG4gICAgdGFrZVdoaWxlTWFwKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKHRoaXMubWFrZVByb2R1Y2VyLCB0aGlzLnN0b3BQcm9kdWNlciwgKGV2ZW50LCBoYW5kbGVyKSA9PiB0aGlzLmV4dHJhY3RvcihldmVudCwgYXN5bmMgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW0gPSBhd2FpdCBmKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKG5ld0l0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyKG5ld0l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgfVxuICAgIG9ubHlGaW5pdGUoZikge1xuICAgICAgICBpZiAodGhpcy5pc0Zpbml0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgVW5vcmRlcmVkVHJhbnNhY3Rpb25zU2Nhbm5lciB7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIHBhcmFtcykge1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnF1ZXVlID0gbmV3IFByb21pc2VRdWV1ZSgpO1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nIHx8IHRoaXMucHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNSdW5uaW5nICYmICFzdGF0ZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zLCBjb250aW51YXRpb24gfSA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMucGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51YXRpb246IHRoaXMuY29udGludWF0aW9uLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY29tcGxldGUgPSAhc3RhdGUuY29tcGxldGUgJiYgdHJhbnNhY3Rpb25zLmxlbmd0aCA9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nIHx8IHN0YXRlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5maWx0ZXIoKGl0ZW0pID0+ICgocGFyYW1zLmZyb21MdCA9PSBudWxsIHx8IHV0aWxzXzEuTFRfQ09MTEFUT1IuY29tcGFyZShpdGVtLmlkLmx0LCBwYXJhbXMuZnJvbUx0KSA+IDApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAocGFyYW1zLmZyb21VdGltZSA9PSBudWxsIHx8IGl0ZW0uY3JlYXRlZEF0ID4gcGFyYW1zLmZyb21VdGltZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkVHJhbnNhY3Rpb25zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4THQ6IGZpbHRlcmVkVHJhbnNhY3Rpb25zWzBdLmlkLmx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluTHQ6IGZpbHRlcmVkVHJhbnNhY3Rpb25zW2ZpbHRlcmVkVHJhbnNhY3Rpb25zLmxlbmd0aCAtIDFdLmlkLmx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hUeXBlOiAnb2xkJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzUnVubmluZyA9IHRoaXMucGFyYW1zLm9uRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5wYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IGZpbHRlcmVkVHJhbnNhY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGludWF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGludWF0aW9uID0gY29udGludWF0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWUoYXN5bmMgKCkgPT4gdGhpcy5wYXJhbXMub25FbmQoc3RhdGUuY29tcGxldGUpKTtcbiAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNvbnRpbnVhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5xdWV1ZS5jbGVhcigpO1xuICAgICAgICBpZiAodGhpcy5wcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLm9uRW5kKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFRyYWNlVHJhbnNhY3Rpb25zU2Nhbm5lciB7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIHBhcmFtcykge1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnF1ZXVlID0gbmV3IFByb21pc2VRdWV1ZSgpO1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbWFwaG9yZSA9IG5ldyB1dGlsc18xLlNlbWFwaG9yZSgxMCk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5pc1J1bm5pbmcgfHwgdGhpcy5wcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucHJvdmlkZXI7XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBtYWtlUGVuZGluZ1RyYW5zYWN0aW9uID0gKG1lc3NhZ2VIYXNoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB7IHN0b3BwZWQ6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0aW1lb3V0ID0gNTAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsZWFzZSA9IGF3YWl0IHRoaXMuc2VtYXBob3JlLmFjcXVpcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLnJhd0FwaS5maW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluTWVzc2FnZUhhc2g6IG1lc3NhZ2VIYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKCkgPT4gKHsgdHJhbnNhY3Rpb246IHVuZGVmaW5lZCB9KSkuZmluYWxseSgoKSA9PiByZWxlYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnRyYW5zYWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9ICgwLCBtb2RlbHNfMS5wYXJzZVRyYW5zYWN0aW9uKShyZXN1bHQudHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFjY291bnQgPSB0cmFuc2FjdGlvbi5pbk1lc3NhZ2UuZHN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlUHJvbWlzZSwgcmVqZWN0UHJvbWlzZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSAoKSA9PiByZXNvbHZlUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnJlamVjdCA9ICgpID0+IHJlamVjdFByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudGltZW91dCA9IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5yZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gTWF0aC5taW4odGltZW91dCAqIDIsIDMwMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWplY3QgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN0YXRlLnJlamVjdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUudGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc3RhdGUudGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHByb21pc2UsIHJlamVjdCB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uc1F1ZXVlID0gW3RoaXMucGFyYW1zLm9yaWdpbl07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG91dGVyOiB3aGlsZSAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbnNRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU3Bhd24gcHJvbWlzZXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ1RyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAub3V0TWVzc2FnZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKG1lc3NhZ2UpID0+IG1lc3NhZ2UuZHN0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlSGFzaCA9IG1lc3NhZ2UuaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlUGVuZGluZ1RyYW5zYWN0aW9uKG1lc3NhZ2VIYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1RyYW5zYWN0aW9ucyA9IHBlbmRpbmdUcmFuc2FjdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBwcm9taXNlIH0gb2YgcGVuZGluZ1RyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRUcmFuc2FjdGlvbiA9IGF3YWl0IHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nIHx8IHN0YXRlLmNvbXBsZXRlIHx8IGNoaWxkVHJhbnNhY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1J1bm5pbmcgPSB0aGlzLnBhcmFtcy5vbkRhdGEoY2hpbGRUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1J1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdFBlbmRpbmdUcmFuc2FjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uc1F1ZXVlLnB1c2goY2hpbGRUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVHJhbnNhY3Rpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAvKiBkbyBub3RoaW5nICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWUoYXN5bmMgKCkgPT4gdGhpcy5wYXJhbXMub25FbmQoc3RhdGUuY29tcGxldGUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0UGVuZGluZ1RyYW5zYWN0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBhc3luYyBzdG9wKCkge1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnF1ZXVlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMucmVqZWN0UGVuZGluZ1RyYW5zYWN0aW9ucygpO1xuICAgICAgICBpZiAodGhpcy5wcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLm9uRW5kKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWplY3RQZW5kaW5nVHJhbnNhY3Rpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nVHJhbnNhY3Rpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGVuZGluZ1RyYW5zYWN0aW9uIG9mIHRoaXMucGVuZGluZ1RyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdUcmFuc2FjdGlvbi5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1RyYW5zYWN0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbWFwaG9yZS5yZWxlYXNlQWxsKCk7XG4gICAgfVxufVxuY2xhc3MgUHJvbWlzZVF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLndvcmtpbmdPblByb21pc2UgPSBmYWxzZTtcbiAgICB9XG4gICAgZW5xdWV1ZShwcm9taXNlKSB7XG4gICAgICAgIHRoaXMucXVldWUucHVzaChwcm9taXNlKTtcbiAgICAgICAgdGhpcy5fZGVxdWV1ZSgpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGFzeW5jIF9kZXF1ZXVlKCkge1xuICAgICAgICBpZiAodGhpcy53b3JraW5nT25Qcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53b3JraW5nT25Qcm9taXNlID0gdHJ1ZTtcbiAgICAgICAgaXRlbSgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndvcmtpbmdPblByb21pc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2RlcXVldWUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndvcmtpbmdPblByb21pc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2RlcXVldWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/everscale-inpage-provider/dist/stream.js\n");

/***/ }),

/***/ "./node_modules/everscale-inpage-provider/dist/utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/everscale-inpage-provider/dist/utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getUniqueId = exports.mergeTransactions = exports.LT_COLLATOR = exports.Semaphore = exports.DelayedTransactions = exports.MessageExpiredException = exports.AddressLiteral = exports.Address = void 0;\n/**\n * @category Utils\n */\nclass Address {\n    constructor(address) {\n        this.equals = (other) => this._equals(other);\n        this._address = address;\n    }\n    toString() {\n        return this._address;\n    }\n    toJSON() {\n        return this._address;\n    }\n    _equals(other) {\n        if (other instanceof Address) {\n            return this._address === other._address;\n        }\n        else {\n            return this._address === other;\n        }\n    }\n}\nexports.Address = Address;\n/**\n * @category Utils\n */\nclass AddressLiteral extends Address {\n    constructor(address) {\n        super(address);\n    }\n}\nexports.AddressLiteral = AddressLiteral;\n/**\n * @category Utils\n */\nclass MessageExpiredException extends Error {\n    constructor(address, hash) {\n        super('Message expired');\n        this.address = address;\n        this.hash = hash;\n    }\n}\nexports.MessageExpiredException = MessageExpiredException;\nclass DelayedTransactions {\n    constructor() {\n        this.transactions = new Map();\n    }\n    async waitTransaction(address, hash) {\n        var _a;\n        let transaction = (_a = this.transactions.get(hash)) === null || _a === void 0 ? void 0 : _a.promise;\n        if (transaction == null) {\n            let resolve;\n            let reject;\n            transaction = new Promise((promiseResolve, promiseReject) => {\n                resolve = (tx) => promiseResolve(tx);\n                reject = () => promiseReject();\n            });\n            this.transactions.set(hash, {\n                promise: transaction,\n                resolve: resolve,\n                reject: reject,\n            });\n        }\n        const tx = await transaction;\n        if (tx == null) {\n            throw new MessageExpiredException(address, hash);\n        }\n        return tx;\n    }\n    fillTransaction(hash, transaction) {\n        const pendingTransaction = this.transactions.get(hash);\n        if (pendingTransaction != null) {\n            pendingTransaction.resolve(transaction);\n        }\n        else {\n            this.transactions.set(hash, {\n                promise: Promise.resolve(transaction),\n                resolve: () => {\n                },\n                reject: () => {\n                },\n            });\n        }\n    }\n}\nexports.DelayedTransactions = DelayedTransactions;\n/**\n * @category Utils\n */\nclass Semaphore {\n    constructor(count) {\n        this.tasks = [];\n        this.sched = () => {\n            var _a;\n            if (this.count > 0 && this.tasks.length > 0) {\n                this.count--;\n                (_a = this.tasks.shift()) === null || _a === void 0 ? void 0 : _a();\n            }\n        };\n        this.count = count;\n    }\n    acquire() {\n        return new Promise((res, _rej) => {\n            this.tasks.push(() => {\n                let released = false;\n                res(() => {\n                    if (!released) {\n                        released = true;\n                        this.count++;\n                        this.sched();\n                    }\n                });\n            });\n            nextTick(this.sched);\n        });\n    }\n    releaseAll() {\n        var _a;\n        while (this.tasks.length > 0) {\n            (_a = this.tasks.shift()) === null || _a === void 0 ? void 0 : _a();\n        }\n    }\n}\nexports.Semaphore = Semaphore;\nfunction byObserver(Observer) {\n    const node = document.createTextNode('');\n    let queue, currentQueue, bit = 0, i = 0;\n    new Observer(function () {\n        let callback;\n        if (!queue) {\n            if (!currentQueue)\n                return;\n            queue = currentQueue;\n        }\n        else if (currentQueue) {\n            queue = currentQueue.slice(i).concat(queue);\n        }\n        currentQueue = queue;\n        queue = null;\n        i = 0;\n        if (typeof currentQueue === 'function') {\n            callback = currentQueue;\n            currentQueue = null;\n            callback();\n            return;\n        }\n        node.data = (bit = ++bit % 2);\n        while (i < currentQueue.length) {\n            callback = currentQueue[i];\n            i++;\n            if (i === currentQueue.length)\n                currentQueue = null;\n            callback();\n        }\n    }).observe(node, { characterData: true });\n    return function (fn) {\n        if (queue) {\n            if (typeof queue === 'function')\n                queue = [queue, fn];\n            else\n                queue.push(fn);\n            return;\n        }\n        queue = fn;\n        node.data = (bit = ++bit % 2);\n    };\n}\nconst nextTick = (function () {\n    // queueMicrotask\n    if (typeof queueMicrotask === 'function') {\n        return queueMicrotask;\n    }\n    // MutationObserver\n    if ((typeof document === 'object') && document) {\n        if (typeof MutationObserver === 'function')\n            return byObserver(MutationObserver);\n        if (typeof window.WebKitMutationObserver === 'function')\n            return byObserver(window.WebKitMutationObserver);\n    }\n    /* @ts-ignore */\n    if (typeof setImmediate === 'function') {\n        /* @ts-ignore */\n        return setImmediate;\n    }\n    if ((typeof setTimeout === 'function') || (typeof setTimeout === 'object')) {\n        return function (cb) {\n            setTimeout(cb, 0);\n        };\n    }\n    throw new Error('No `nextTick` implementation found');\n}());\n/**\n * @category Utils\n */\nexports.LT_COLLATOR = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });\n/**\n * Modifies knownTransactions array, merging it with new transactions.\n * All arrays are assumed to be sorted by descending logical time.\n *\n * > Note! This method does not remove duplicates.\n *\n * @param knownTransactions\n * @param newTransactions\n * @param info\n *\n * @category Utils\n */\nfunction mergeTransactions(knownTransactions, newTransactions, info) {\n    if (info.batchType === 'old') {\n        knownTransactions.push(...newTransactions);\n        return knownTransactions;\n    }\n    if (knownTransactions.length === 0) {\n        knownTransactions.push(...newTransactions);\n        return knownTransactions;\n    }\n    // Example:\n    // known lts: [N, N-1, N-2, N-3, (!) N-10,...]\n    // new lts: [N-4, N-5]\n    // batch info: { minLt: N-5, maxLt: N-4, batchType: 'new' }\n    // 1. Skip indices until known transaction lt is greater than the biggest in the batch\n    let i = 0;\n    while (i < knownTransactions.length &&\n        exports.LT_COLLATOR.compare(knownTransactions[i].id.lt, info.maxLt) >= 0) {\n        ++i;\n    }\n    // 2. Insert new transactions\n    knownTransactions.splice(i, 0, ...newTransactions);\n    return knownTransactions;\n}\nexports.mergeTransactions = mergeTransactions;\nconst MAX = 4294967295;\nlet idCounter = Math.floor(Math.random() * MAX);\nfunction getUniqueId() {\n    idCounter = (idCounter + 1) % MAX;\n    return idCounter;\n}\nexports.getUniqueId = getUniqueId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLWlucGFnZS1wcm92aWRlci9kaXN0L3V0aWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXIvZGlzdC91dGlscy5qcz80M2IyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRVbmlxdWVJZCA9IGV4cG9ydHMubWVyZ2VUcmFuc2FjdGlvbnMgPSBleHBvcnRzLkxUX0NPTExBVE9SID0gZXhwb3J0cy5TZW1hcGhvcmUgPSBleHBvcnRzLkRlbGF5ZWRUcmFuc2FjdGlvbnMgPSBleHBvcnRzLk1lc3NhZ2VFeHBpcmVkRXhjZXB0aW9uID0gZXhwb3J0cy5BZGRyZXNzTGl0ZXJhbCA9IGV4cG9ydHMuQWRkcmVzcyA9IHZvaWQgMDtcbi8qKlxuICogQGNhdGVnb3J5IFV0aWxzXG4gKi9cbmNsYXNzIEFkZHJlc3Mge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MpIHtcbiAgICAgICAgdGhpcy5lcXVhbHMgPSAob3RoZXIpID0+IHRoaXMuX2VxdWFscyhvdGhlcik7XG4gICAgICAgIHRoaXMuX2FkZHJlc3MgPSBhZGRyZXNzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3M7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3M7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQWRkcmVzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3MgPT09IG90aGVyLl9hZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3MgPT09IG90aGVyO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzID0gQWRkcmVzcztcbi8qKlxuICogQGNhdGVnb3J5IFV0aWxzXG4gKi9cbmNsYXNzIEFkZHJlc3NMaXRlcmFsIGV4dGVuZHMgQWRkcmVzcyB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcykge1xuICAgICAgICBzdXBlcihhZGRyZXNzKTtcbiAgICB9XG59XG5leHBvcnRzLkFkZHJlc3NMaXRlcmFsID0gQWRkcmVzc0xpdGVyYWw7XG4vKipcbiAqIEBjYXRlZ29yeSBVdGlsc1xuICovXG5jbGFzcyBNZXNzYWdlRXhwaXJlZEV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBoYXNoKSB7XG4gICAgICAgIHN1cGVyKCdNZXNzYWdlIGV4cGlyZWQnKTtcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5oYXNoID0gaGFzaDtcbiAgICB9XG59XG5leHBvcnRzLk1lc3NhZ2VFeHBpcmVkRXhjZXB0aW9uID0gTWVzc2FnZUV4cGlyZWRFeGNlcHRpb247XG5jbGFzcyBEZWxheWVkVHJhbnNhY3Rpb25zIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRUcmFuc2FjdGlvbihhZGRyZXNzLCBoYXNoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHRyYW5zYWN0aW9uID0gKF9hID0gdGhpcy50cmFuc2FjdGlvbnMuZ2V0KGhhc2gpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvbWlzZTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlO1xuICAgICAgICAgICAgbGV0IHJlamVjdDtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gbmV3IFByb21pc2UoKHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9ICh0eCkgPT4gcHJvbWlzZVJlc29sdmUodHgpO1xuICAgICAgICAgICAgICAgIHJlamVjdCA9ICgpID0+IHByb21pc2VSZWplY3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMuc2V0KGhhc2gsIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlOiB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0cmFuc2FjdGlvbjtcbiAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZXNzYWdlRXhwaXJlZEV4Y2VwdGlvbihhZGRyZXNzLCBoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIGZpbGxUcmFuc2FjdGlvbihoYXNoLCB0cmFuc2FjdGlvbikge1xuICAgICAgICBjb25zdCBwZW5kaW5nVHJhbnNhY3Rpb24gPSB0aGlzLnRyYW5zYWN0aW9ucy5nZXQoaGFzaCk7XG4gICAgICAgIGlmIChwZW5kaW5nVHJhbnNhY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgcGVuZGluZ1RyYW5zYWN0aW9uLnJlc29sdmUodHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMuc2V0KGhhc2gsIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlOiBQcm9taXNlLnJlc29sdmUodHJhbnNhY3Rpb24pLFxuICAgICAgICAgICAgICAgIHJlc29sdmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlamVjdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRGVsYXllZFRyYW5zYWN0aW9ucyA9IERlbGF5ZWRUcmFuc2FjdGlvbnM7XG4vKipcbiAqIEBjYXRlZ29yeSBVdGlsc1xuICovXG5jbGFzcyBTZW1hcGhvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNvdW50KSB7XG4gICAgICAgIHRoaXMudGFza3MgPSBbXTtcbiAgICAgICAgdGhpcy5zY2hlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50ID4gMCAmJiB0aGlzLnRhc2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50LS07XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy50YXNrcy5zaGlmdCgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgIH1cbiAgICBhY3F1aXJlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgX3JlaikgPT4ge1xuICAgICAgICAgICAgdGhpcy50YXNrcy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVsZWFzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXMoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbGVhc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjaGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV4dFRpY2sodGhpcy5zY2hlZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWxlYXNlQWxsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHdoaWxlICh0aGlzLnRhc2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMudGFza3Muc2hpZnQoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNlbWFwaG9yZSA9IFNlbWFwaG9yZTtcbmZ1bmN0aW9uIGJ5T2JzZXJ2ZXIoT2JzZXJ2ZXIpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIGxldCBxdWV1ZSwgY3VycmVudFF1ZXVlLCBiaXQgPSAwLCBpID0gMDtcbiAgICBuZXcgT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgY2FsbGJhY2s7XG4gICAgICAgIGlmICghcXVldWUpIHtcbiAgICAgICAgICAgIGlmICghY3VycmVudFF1ZXVlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuc2xpY2UoaSkuY29uY2F0KHF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBudWxsO1xuICAgICAgICBpID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50UXVldWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY3VycmVudFF1ZXVlO1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5kYXRhID0gKGJpdCA9ICsrYml0ICUgMik7XG4gICAgICAgIHdoaWxlIChpIDwgY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjdXJyZW50UXVldWVbaV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAoaSA9PT0gY3VycmVudFF1ZXVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH0pLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKHF1ZXVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXVlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHF1ZXVlID0gW3F1ZXVlLCBmbl07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcXVldWUgPSBmbjtcbiAgICAgICAgbm9kZS5kYXRhID0gKGJpdCA9ICsrYml0ICUgMik7XG4gICAgfTtcbn1cbmNvbnN0IG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBxdWV1ZU1pY3JvdGFza1xuICAgIGlmICh0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXVlTWljcm90YXNrO1xuICAgIH1cbiAgICAvLyBNdXRhdGlvbk9ic2VydmVyXG4gICAgaWYgKCh0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnKSAmJiBkb2N1bWVudCkge1xuICAgICAgICBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm4gYnlPYnNlcnZlcihNdXRhdGlvbk9ic2VydmVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiBieU9ic2VydmVyKHdpbmRvdy5XZWJLaXRNdXRhdGlvbk9ic2VydmVyKTtcbiAgICB9XG4gICAgLyogQHRzLWlnbm9yZSAqL1xuICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZTtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykgfHwgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gYG5leHRUaWNrYCBpbXBsZW1lbnRhdGlvbiBmb3VuZCcpO1xufSgpKTtcbi8qKlxuICogQGNhdGVnb3J5IFV0aWxzXG4gKi9cbmV4cG9ydHMuTFRfQ09MTEFUT1IgPSBuZXcgSW50bC5Db2xsYXRvcih1bmRlZmluZWQsIHsgbnVtZXJpYzogdHJ1ZSwgc2Vuc2l0aXZpdHk6ICdiYXNlJyB9KTtcbi8qKlxuICogTW9kaWZpZXMga25vd25UcmFuc2FjdGlvbnMgYXJyYXksIG1lcmdpbmcgaXQgd2l0aCBuZXcgdHJhbnNhY3Rpb25zLlxuICogQWxsIGFycmF5cyBhcmUgYXNzdW1lZCB0byBiZSBzb3J0ZWQgYnkgZGVzY2VuZGluZyBsb2dpY2FsIHRpbWUuXG4gKlxuICogPiBOb3RlISBUaGlzIG1ldGhvZCBkb2VzIG5vdCByZW1vdmUgZHVwbGljYXRlcy5cbiAqXG4gKiBAcGFyYW0ga25vd25UcmFuc2FjdGlvbnNcbiAqIEBwYXJhbSBuZXdUcmFuc2FjdGlvbnNcbiAqIEBwYXJhbSBpbmZvXG4gKlxuICogQGNhdGVnb3J5IFV0aWxzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlVHJhbnNhY3Rpb25zKGtub3duVHJhbnNhY3Rpb25zLCBuZXdUcmFuc2FjdGlvbnMsIGluZm8pIHtcbiAgICBpZiAoaW5mby5iYXRjaFR5cGUgPT09ICdvbGQnKSB7XG4gICAgICAgIGtub3duVHJhbnNhY3Rpb25zLnB1c2goLi4ubmV3VHJhbnNhY3Rpb25zKTtcbiAgICAgICAgcmV0dXJuIGtub3duVHJhbnNhY3Rpb25zO1xuICAgIH1cbiAgICBpZiAoa25vd25UcmFuc2FjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGtub3duVHJhbnNhY3Rpb25zLnB1c2goLi4ubmV3VHJhbnNhY3Rpb25zKTtcbiAgICAgICAgcmV0dXJuIGtub3duVHJhbnNhY3Rpb25zO1xuICAgIH1cbiAgICAvLyBFeGFtcGxlOlxuICAgIC8vIGtub3duIGx0czogW04sIE4tMSwgTi0yLCBOLTMsICghKSBOLTEwLC4uLl1cbiAgICAvLyBuZXcgbHRzOiBbTi00LCBOLTVdXG4gICAgLy8gYmF0Y2ggaW5mbzogeyBtaW5MdDogTi01LCBtYXhMdDogTi00LCBiYXRjaFR5cGU6ICduZXcnIH1cbiAgICAvLyAxLiBTa2lwIGluZGljZXMgdW50aWwga25vd24gdHJhbnNhY3Rpb24gbHQgaXMgZ3JlYXRlciB0aGFuIHRoZSBiaWdnZXN0IGluIHRoZSBiYXRjaFxuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGtub3duVHJhbnNhY3Rpb25zLmxlbmd0aCAmJlxuICAgICAgICBleHBvcnRzLkxUX0NPTExBVE9SLmNvbXBhcmUoa25vd25UcmFuc2FjdGlvbnNbaV0uaWQubHQsIGluZm8ubWF4THQpID49IDApIHtcbiAgICAgICAgKytpO1xuICAgIH1cbiAgICAvLyAyLiBJbnNlcnQgbmV3IHRyYW5zYWN0aW9uc1xuICAgIGtub3duVHJhbnNhY3Rpb25zLnNwbGljZShpLCAwLCAuLi5uZXdUcmFuc2FjdGlvbnMpO1xuICAgIHJldHVybiBrbm93blRyYW5zYWN0aW9ucztcbn1cbmV4cG9ydHMubWVyZ2VUcmFuc2FjdGlvbnMgPSBtZXJnZVRyYW5zYWN0aW9ucztcbmNvbnN0IE1BWCA9IDQyOTQ5NjcyOTU7XG5sZXQgaWRDb3VudGVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTUFYKTtcbmZ1bmN0aW9uIGdldFVuaXF1ZUlkKCkge1xuICAgIGlkQ291bnRlciA9IChpZENvdW50ZXIgKyAxKSAlIE1BWDtcbiAgICByZXR1cm4gaWRDb3VudGVyO1xufVxuZXhwb3J0cy5nZXRVbmlxdWVJZCA9IGdldFVuaXF1ZUlkO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/everscale-inpage-provider/dist/utils.js\n");

/***/ }),

/***/ "./node_modules/everscale-standalone-client/client/AccountsStorage/Generic.js":
/*!************************************************************************************!*\
  !*** ./node_modules/everscale-standalone-client/client/AccountsStorage/Generic.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MsigAccount = exports.GenericAccount = void 0;\nconst everscale_inpage_provider_1 = __webpack_require__(/*! everscale-inpage-provider */ \"./node_modules/everscale-inpage-provider/dist/index.js\");\n/**\n * @category AccountsStorage\n */\nclass GenericAccount {\n    constructor(args) {\n        this.address = args.address instanceof everscale_inpage_provider_1.Address ? args.address : new everscale_inpage_provider_1.Address(args.address);\n        this.abi = typeof args.abi === 'string' ? args.abi : JSON.stringify(args.abi);\n        this.prepareMessageImpl = args.prepareMessage;\n        this.publicKey = args.publicKey;\n    }\n    async fetchPublicKey(ctx) {\n        if (this.publicKey != null) {\n            return this.publicKey;\n        }\n        this.publicKey = await ctx.fetchPublicKey(this.address);\n        return this.publicKey;\n    }\n    async prepareMessage(args, ctx) {\n        const publicKey = await this.fetchPublicKey(ctx);\n        const signer = await ctx.getSigner(publicKey);\n        const { method, params, stateInit } = await this.prepareMessageImpl(args, ctx);\n        return await ctx.createExternalMessage({\n            address: this.address,\n            signer,\n            timeout: args.timeout,\n            abi: this.abi,\n            method,\n            params,\n            stateInit,\n        });\n    }\n}\nexports.GenericAccount = GenericAccount;\n/**\n * @category AccountsStorage\n */\nclass MsigAccount extends GenericAccount {\n    constructor(args) {\n        super({\n            address: args.address,\n            publicKey: args.publicKey,\n            abi: MSIG_ABI,\n            prepareMessage: async (args, ctx) => {\n                const payload = args.payload\n                    ? ctx.encodeInternalInput(args.payload)\n                    : '';\n                return {\n                    method: 'sendTransaction',\n                    params: {\n                        dest: args.recipient,\n                        value: args.amount,\n                        bounce: args.bounce,\n                        flags: 3,\n                        payload,\n                    },\n                };\n            },\n        });\n    }\n}\nexports.MsigAccount = MsigAccount;\nconst MSIG_ABI = `{\n  \"ABI version\": 2,\n  \"header\": [\"pubkey\", \"time\", \"expire\"],\n  \"functions\": [{\n    \"name\": \"sendTransaction\",\n    \"inputs\": [\n      {\"name\":\"dest\",\"type\":\"address\"},\n      {\"name\":\"value\",\"type\":\"uint128\"},\n      {\"name\":\"bounce\",\"type\":\"bool\"},\n      {\"name\":\"flags\",\"type\":\"uint8\"},\n      {\"name\":\"payload\",\"type\":\"cell\"}\n    ],\n    \"outputs\": []\n  }],\n  \"events\": []\n}`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9BY2NvdW50c1N0b3JhZ2UvR2VuZXJpYy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9ldmVyc2NhbGUtc3RhbmRhbG9uZS1jbGllbnQvY2xpZW50L0FjY291bnRzU3RvcmFnZS9HZW5lcmljLmpzP2MyYmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1zaWdBY2NvdW50ID0gZXhwb3J0cy5HZW5lcmljQWNjb3VudCA9IHZvaWQgMDtcbmNvbnN0IGV2ZXJzY2FsZV9pbnBhZ2VfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCJldmVyc2NhbGUtaW5wYWdlLXByb3ZpZGVyXCIpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgQWNjb3VudHNTdG9yYWdlXG4gKi9cbmNsYXNzIEdlbmVyaWNBY2NvdW50IHtcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFyZ3MuYWRkcmVzcyBpbnN0YW5jZW9mIGV2ZXJzY2FsZV9pbnBhZ2VfcHJvdmlkZXJfMS5BZGRyZXNzID8gYXJncy5hZGRyZXNzIDogbmV3IGV2ZXJzY2FsZV9pbnBhZ2VfcHJvdmlkZXJfMS5BZGRyZXNzKGFyZ3MuYWRkcmVzcyk7XG4gICAgICAgIHRoaXMuYWJpID0gdHlwZW9mIGFyZ3MuYWJpID09PSAnc3RyaW5nJyA/IGFyZ3MuYWJpIDogSlNPTi5zdHJpbmdpZnkoYXJncy5hYmkpO1xuICAgICAgICB0aGlzLnByZXBhcmVNZXNzYWdlSW1wbCA9IGFyZ3MucHJlcGFyZU1lc3NhZ2U7XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gYXJncy5wdWJsaWNLZXk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoUHVibGljS2V5KGN0eCkge1xuICAgICAgICBpZiAodGhpcy5wdWJsaWNLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVibGljS2V5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gYXdhaXQgY3R4LmZldGNoUHVibGljS2V5KHRoaXMuYWRkcmVzcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY0tleTtcbiAgICB9XG4gICAgYXN5bmMgcHJlcGFyZU1lc3NhZ2UoYXJncywgY3R4KSB7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IHRoaXMuZmV0Y2hQdWJsaWNLZXkoY3R4KTtcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgY3R4LmdldFNpZ25lcihwdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCB7IG1ldGhvZCwgcGFyYW1zLCBzdGF0ZUluaXQgfSA9IGF3YWl0IHRoaXMucHJlcGFyZU1lc3NhZ2VJbXBsKGFyZ3MsIGN0eCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBjdHguY3JlYXRlRXh0ZXJuYWxNZXNzYWdlKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgIHNpZ25lcixcbiAgICAgICAgICAgIHRpbWVvdXQ6IGFyZ3MudGltZW91dCxcbiAgICAgICAgICAgIGFiaTogdGhpcy5hYmksXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICBzdGF0ZUluaXQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuR2VuZXJpY0FjY291bnQgPSBHZW5lcmljQWNjb3VudDtcbi8qKlxuICogQGNhdGVnb3J5IEFjY291bnRzU3RvcmFnZVxuICovXG5jbGFzcyBNc2lnQWNjb3VudCBleHRlbmRzIEdlbmVyaWNBY2NvdW50IHtcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGFyZ3MuYWRkcmVzcyxcbiAgICAgICAgICAgIHB1YmxpY0tleTogYXJncy5wdWJsaWNLZXksXG4gICAgICAgICAgICBhYmk6IE1TSUdfQUJJLFxuICAgICAgICAgICAgcHJlcGFyZU1lc3NhZ2U6IGFzeW5jIChhcmdzLCBjdHgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXJncy5wYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgID8gY3R4LmVuY29kZUludGVybmFsSW5wdXQoYXJncy5wYXlsb2FkKVxuICAgICAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdDogYXJncy5yZWNpcGllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXJncy5hbW91bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuY2U6IGFyZ3MuYm91bmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLk1zaWdBY2NvdW50ID0gTXNpZ0FjY291bnQ7XG5jb25zdCBNU0lHX0FCSSA9IGB7XG4gIFwiQUJJIHZlcnNpb25cIjogMixcbiAgXCJoZWFkZXJcIjogW1wicHVia2V5XCIsIFwidGltZVwiLCBcImV4cGlyZVwiXSxcbiAgXCJmdW5jdGlvbnNcIjogW3tcbiAgICBcIm5hbWVcIjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XCJuYW1lXCI6XCJkZXN0XCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9LFxuICAgICAge1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjpcInVpbnQxMjhcIn0sXG4gICAgICB7XCJuYW1lXCI6XCJib3VuY2VcIixcInR5cGVcIjpcImJvb2xcIn0sXG4gICAgICB7XCJuYW1lXCI6XCJmbGFnc1wiLFwidHlwZVwiOlwidWludDhcIn0sXG4gICAgICB7XCJuYW1lXCI6XCJwYXlsb2FkXCIsXCJ0eXBlXCI6XCJjZWxsXCJ9XG4gICAgXSxcbiAgICBcIm91dHB1dHNcIjogW11cbiAgfV0sXG4gIFwiZXZlbnRzXCI6IFtdXG59YDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/everscale-standalone-client/client/AccountsStorage/Generic.js\n");

/***/ }),

/***/ "./node_modules/everscale-standalone-client/client/AccountsStorage/Giver.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/everscale-standalone-client/client/AccountsStorage/Giver.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GiverAccount = void 0;\nconst everscale_inpage_provider_1 = __webpack_require__(/*! everscale-inpage-provider */ \"./node_modules/everscale-inpage-provider/dist/index.js\");\n/**\n * Any account which supports Giver ABI (GiverV2, GiverV3):\n *\n * ```\n * {\n *   \"ABI version\": 2,\n *   \"header\": [\"pubkey\", \"time\", \"expire\"],\n *   \"functions\": [{\n *     \"name\": \"sendTransaction\",\n *     \"inputs\": [\n *       {\"name\":\"dest\",\"type\":\"address\"},\n *       {\"name\":\"value\",\"type\":\"uint128\"},\n *       {\"name\":\"bounce\",\"type\":\"bool\"},\n *     ],\n *     \"outputs\": []\n *   }],\n *   \"events\": []\n * }\n * ```\n *\n * @category AccountsStorage\n */\nclass GiverAccount {\n    constructor(args) {\n        this.address = args.address instanceof everscale_inpage_provider_1.Address ? args.address : new everscale_inpage_provider_1.Address(args.address);\n        this.publicKey = args.publicKey;\n    }\n    static fromVersion(version) {\n        let address;\n        switch (version) {\n            case 2:\n                address = '0:ece57bcc6c530283becbbd8a3b24d3c5987cdddc3c8b7b33be6e4a6312490415';\n                break;\n            case 3:\n                address = '0:78fbd6980c10cf41401b32e9b51810415e7578b52403af80dae68ddf99714498';\n                break;\n            default:\n                throw new Error('Unknown version');\n        }\n        return new GiverAccount({\n            address,\n            publicKey: GiverAccount.GIVER_KEY_PAIR.publicKey,\n        });\n    }\n    async fetchPublicKey(_ctx) {\n        return this.publicKey;\n    }\n    async prepareMessage(args, ctx) {\n        if (args.payload != null) {\n            console.warn('Giver contract does not support payload');\n        }\n        const signer = await ctx.getSigner(this.publicKey);\n        return await ctx.createExternalMessage({\n            address: this.address,\n            signer,\n            timeout: args.timeout,\n            abi: GIVER_ABI,\n            method: 'sendTransaction',\n            params: {\n                dest: args.recipient,\n                value: args.amount,\n                bounce: args.bounce,\n            },\n        });\n    }\n}\nexports.GiverAccount = GiverAccount;\nGiverAccount.GIVER_KEY_PAIR = {\n    secretKey: '172af540e43a524763dd53b26a066d472a97c4de37d5498170564510608250c3',\n    publicKey: '2ada2e65ab8eeab09490e3521415f45b6e42df9c760a639bcf53957550b25a16',\n};\nconst GIVER_ABI = `{\n  \"ABI version\": 2,\n  \"header\": [\"time\", \"expire\"],\n  \"functions\": [{\n    \"name\": \"sendTransaction\",\n    \"inputs\": [\n      {\"name\":\"dest\",\"type\":\"address\"},\n      {\"name\":\"value\",\"type\":\"uint128\"},\n      {\"name\":\"bounce\",\"type\":\"bool\"}\n    ],\n    \"outputs\": []\n  }],\n  \"events\": []\n}`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9BY2NvdW50c1N0b3JhZ2UvR2l2ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9BY2NvdW50c1N0b3JhZ2UvR2l2ZXIuanM/YWMzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2l2ZXJBY2NvdW50ID0gdm9pZCAwO1xuY29uc3QgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xID0gcmVxdWlyZShcImV2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXJcIik7XG4vKipcbiAqIEFueSBhY2NvdW50IHdoaWNoIHN1cHBvcnRzIEdpdmVyIEFCSSAoR2l2ZXJWMiwgR2l2ZXJWMyk6XG4gKlxuICogYGBgXG4gKiB7XG4gKiAgIFwiQUJJIHZlcnNpb25cIjogMixcbiAqICAgXCJoZWFkZXJcIjogW1wicHVia2V5XCIsIFwidGltZVwiLCBcImV4cGlyZVwiXSxcbiAqICAgXCJmdW5jdGlvbnNcIjogW3tcbiAqICAgICBcIm5hbWVcIjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAqICAgICBcImlucHV0c1wiOiBbXG4gKiAgICAgICB7XCJuYW1lXCI6XCJkZXN0XCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9LFxuICogICAgICAge1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjpcInVpbnQxMjhcIn0sXG4gKiAgICAgICB7XCJuYW1lXCI6XCJib3VuY2VcIixcInR5cGVcIjpcImJvb2xcIn0sXG4gKiAgICAgXSxcbiAqICAgICBcIm91dHB1dHNcIjogW11cbiAqICAgfV0sXG4gKiAgIFwiZXZlbnRzXCI6IFtdXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgQWNjb3VudHNTdG9yYWdlXG4gKi9cbmNsYXNzIEdpdmVyQWNjb3VudCB7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhcmdzLmFkZHJlc3MgaW5zdGFuY2VvZiBldmVyc2NhbGVfaW5wYWdlX3Byb3ZpZGVyXzEuQWRkcmVzcyA/IGFyZ3MuYWRkcmVzcyA6IG5ldyBldmVyc2NhbGVfaW5wYWdlX3Byb3ZpZGVyXzEuQWRkcmVzcyhhcmdzLmFkZHJlc3MpO1xuICAgICAgICB0aGlzLnB1YmxpY0tleSA9IGFyZ3MucHVibGljS2V5O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVZlcnNpb24odmVyc2lvbikge1xuICAgICAgICBsZXQgYWRkcmVzcztcbiAgICAgICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9ICcwOmVjZTU3YmNjNmM1MzAyODNiZWNiYmQ4YTNiMjRkM2M1OTg3Y2RkZGMzYzhiN2IzM2JlNmU0YTYzMTI0OTA0MTUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGFkZHJlc3MgPSAnMDo3OGZiZDY5ODBjMTBjZjQxNDAxYjMyZTliNTE4MTA0MTVlNzU3OGI1MjQwM2FmODBkYWU2OGRkZjk5NzE0NDk4JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHZlcnNpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEdpdmVyQWNjb3VudCh7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgcHVibGljS2V5OiBHaXZlckFjY291bnQuR0lWRVJfS0VZX1BBSVIucHVibGljS2V5LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hQdWJsaWNLZXkoX2N0eCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNLZXk7XG4gICAgfVxuICAgIGFzeW5jIHByZXBhcmVNZXNzYWdlKGFyZ3MsIGN0eCkge1xuICAgICAgICBpZiAoYXJncy5wYXlsb2FkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignR2l2ZXIgY29udHJhY3QgZG9lcyBub3Qgc3VwcG9ydCBwYXlsb2FkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgY3R4LmdldFNpZ25lcih0aGlzLnB1YmxpY0tleSk7XG4gICAgICAgIHJldHVybiBhd2FpdCBjdHguY3JlYXRlRXh0ZXJuYWxNZXNzYWdlKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgIHNpZ25lcixcbiAgICAgICAgICAgIHRpbWVvdXQ6IGFyZ3MudGltZW91dCxcbiAgICAgICAgICAgIGFiaTogR0lWRVJfQUJJLFxuICAgICAgICAgICAgbWV0aG9kOiAnc2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGRlc3Q6IGFyZ3MucmVjaXBpZW50LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhcmdzLmFtb3VudCxcbiAgICAgICAgICAgICAgICBib3VuY2U6IGFyZ3MuYm91bmNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5HaXZlckFjY291bnQgPSBHaXZlckFjY291bnQ7XG5HaXZlckFjY291bnQuR0lWRVJfS0VZX1BBSVIgPSB7XG4gICAgc2VjcmV0S2V5OiAnMTcyYWY1NDBlNDNhNTI0NzYzZGQ1M2IyNmEwNjZkNDcyYTk3YzRkZTM3ZDU0OTgxNzA1NjQ1MTA2MDgyNTBjMycsXG4gICAgcHVibGljS2V5OiAnMmFkYTJlNjVhYjhlZWFiMDk0OTBlMzUyMTQxNWY0NWI2ZTQyZGY5Yzc2MGE2MzliY2Y1Mzk1NzU1MGIyNWExNicsXG59O1xuY29uc3QgR0lWRVJfQUJJID0gYHtcbiAgXCJBQkkgdmVyc2lvblwiOiAyLFxuICBcImhlYWRlclwiOiBbXCJ0aW1lXCIsIFwiZXhwaXJlXCJdLFxuICBcImZ1bmN0aW9uc1wiOiBbe1xuICAgIFwibmFtZVwiOiBcInNlbmRUcmFuc2FjdGlvblwiLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcIm5hbWVcIjpcImRlc3RcIixcInR5cGVcIjpcImFkZHJlc3NcIn0sXG4gICAgICB7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOlwidWludDEyOFwifSxcbiAgICAgIHtcIm5hbWVcIjpcImJvdW5jZVwiLFwidHlwZVwiOlwiYm9vbFwifVxuICAgIF0sXG4gICAgXCJvdXRwdXRzXCI6IFtdXG4gIH1dLFxuICBcImV2ZW50c1wiOiBbXVxufWA7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/everscale-standalone-client/client/AccountsStorage/Giver.js\n");

/***/ }),

/***/ "./node_modules/everscale-standalone-client/client/AccountsStorage/HighloadWalletV2.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/everscale-standalone-client/client/AccountsStorage/HighloadWalletV2.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HighloadWalletV2 = void 0;\nconst everscale_inpage_provider_1 = __webpack_require__(/*! everscale-inpage-provider */ \"./node_modules/everscale-inpage-provider/dist/index.js\");\nconst bignumber_js_1 = __importDefault(__webpack_require__(/*! bignumber.js */ \"./node_modules/bignumber.js/bignumber.js\"));\nconst core_1 = __importDefault(__webpack_require__(/*! ../../core */ \"./node_modules/everscale-standalone-client/core.js\"));\nconst { ensureNekotonLoaded, nekoton } = core_1.default;\n/**\n * @category AccountsStorage\n */\nclass HighloadWalletV2 {\n    constructor(address) {\n        this.address = address instanceof everscale_inpage_provider_1.Address ? address : new everscale_inpage_provider_1.Address(address);\n    }\n    static async computeAddress(args) {\n        // TODO: Somehow propagate init params\n        await ensureNekotonLoaded();\n        const publicKey = args.publicKey instanceof bignumber_js_1.default\n            ? args.publicKey\n            : new bignumber_js_1.default(`0x${args.publicKey}`);\n        const tvc = makeStateInit(publicKey);\n        const hash = nekoton.getBocHash(tvc);\n        return new everscale_inpage_provider_1.Address(`${args.workchain != null ? args.workchain : 0}:${hash}`);\n    }\n    static async fromPubkey(args) {\n        const publicKey = new bignumber_js_1.default(`0x${args.publicKey}`);\n        const address = await HighloadWalletV2.computeAddress({ publicKey, workchain: args.workchain });\n        const result = new HighloadWalletV2(address);\n        result.publicKey = publicKey;\n        return result;\n    }\n    async fetchPublicKey(ctx) {\n        let publicKey = this.publicKey;\n        if (publicKey == null) {\n            publicKey = this.publicKey = await ctx.fetchPublicKey(this.address)\n                .then(publicKey => new bignumber_js_1.default(`0x${publicKey}`));\n        }\n        return publicKey.toString(16).padStart(64, '0');\n    }\n    async prepareMessage(args, ctx) {\n        const { publicKey, stateInit } = await this.fetchState(ctx);\n        const signer = await ctx.getSigner(publicKey);\n        const expireAt = ctx.nowSec + args.timeout;\n        const attachedPayload = args.payload\n            ? ctx.encodeInternalInput(args.payload)\n            : undefined;\n        const internalMessage = ctx.encodeInternalMessage({\n            dst: args.recipient,\n            bounce: args.bounce,\n            stateInit: args.stateInit,\n            body: attachedPayload,\n            amount: args.amount,\n        });\n        const params = {\n            messages: [[0, {\n                        flags: 3,\n                        message: internalMessage,\n                    }]],\n        };\n        const messages = ctx.packIntoCell({ structure: MESSAGES_STRUCTURE, data: params });\n        const messagesHash = ctx.getBocHash(messages);\n        params.walletId = WALLET_ID;\n        params.expireAt = expireAt;\n        params.messagesHash = `0x${messagesHash.slice(-8)}`;\n        const unsignedPayload = ctx.packIntoCell({ structure: UNSIGNED_TRANSFER_STRUCTURE, data: params });\n        const hash = ctx.getBocHash(unsignedPayload);\n        const signature = await signer.sign(hash);\n        const { signatureParts } = ctx.extendSignature(signature);\n        params.signatureHigh = signatureParts.high;\n        params.signatureLow = signatureParts.low;\n        const signedPayload = ctx.packIntoCell({ structure: SIGNED_TRANSFER_STRUCTURE, data: params });\n        return ctx.createRawExternalMessage({\n            address: this.address.toString(),\n            body: signedPayload,\n            stateInit,\n            expireAt,\n        });\n    }\n    async fetchState(ctx) {\n        let stateInit = undefined;\n        let publicKey;\n        const state = await ctx.getFullContractState(this.address);\n        if (state == null || !state.isDeployed) {\n            if (this.publicKey == null) {\n                throw new Error('Contract not deployed and public key was not specified');\n            }\n            stateInit = makeStateInit(this.publicKey);\n            publicKey = this.publicKey;\n        }\n        else if (this.publicKey == null) {\n            const data = ctx.extractContractData(state.boc);\n            if (data == null) {\n                throw new Error('Failed to extract contract data');\n            }\n            publicKey = parseInitData(ctx, data).publicKey;\n        }\n        else {\n            publicKey = this.publicKey;\n        }\n        if (this.publicKey == null) {\n            this.publicKey = publicKey;\n        }\n        return {\n            publicKey: publicKey.toString(16).padStart(64, '0'),\n            stateInit,\n        };\n    }\n}\nexports.HighloadWalletV2 = HighloadWalletV2;\nconst parseInitData = (ctx, boc) => {\n    const parsed = ctx.unpackFromCell({ structure: DATA_STRUCTURE, boc, allowPartial: true });\n    if (typeof parsed !== 'object' || typeof parsed['publicKey'] !== 'string') {\n        throw new Error('Invalid contract data');\n    }\n    return {\n        publicKey: new bignumber_js_1.default(parsed.publicKey),\n    };\n};\nconst makeStateInit = (publicKey) => {\n    const data = nekoton.packIntoCell(DATA_STRUCTURE, {\n        walletId: WALLET_ID,\n        lastCleaned: 0,\n        publicKey: publicKey.toFixed(0),\n        queries: false,\n    });\n    return nekoton.mergeTvc(HIGHLOAD_WALLET_V2_CODE, data);\n};\nconst MESSAGES_STRUCTURE = [\n    {\n        name: 'messages',\n        type: 'map(uint16,tuple)',\n        components: [\n            { name: 'flags', type: 'uint8' },\n            { name: 'message', type: 'cell' },\n        ],\n    },\n];\nconst UNSIGNED_TRANSFER_STRUCTURE = [\n    { name: 'walletId', type: 'uint32' },\n    { name: 'expireAt', type: 'uint32' },\n    { name: 'messagesHash', type: 'uint32' },\n    ...MESSAGES_STRUCTURE,\n];\nconst SIGNED_TRANSFER_STRUCTURE = [\n    { name: 'signatureHigh', type: 'uint256' },\n    { name: 'signatureLow', type: 'uint256' },\n    ...UNSIGNED_TRANSFER_STRUCTURE,\n];\nconst DATA_STRUCTURE = [\n    { name: 'walletId', type: 'uint32' },\n    { name: 'lastCleaned', type: 'uint64' },\n    { name: 'publicKey', type: 'uint256' },\n    { name: 'queries', type: 'bool' },\n];\nconst HIGHLOAD_WALLET_V2_CODE = 'te6ccgEBCQEA5QABFP8A9KQT9LzyyAsBAgEgBAIB6vKDCNcYINMf0z/4I6ofUyC58mPtRNDTH9M/0//0BNFTYIBA9A5voTHyYFFzuvKiB/kBVBCH+RDyowL0BNH4AH+OFiGAEPR4b6UgmALTB9QwAfsAkTLiAbPmW4MlochANIBA9EOK5jHIEssfE8s/y//0AMntVAMANCCAQPSWb6UyURCUMFMDud4gkzM2AZIyMOKzAgFICAUCASAHBgBBvl+XaiaGmPmOmf6f+Y+gJoqRBAIHoHN9CYyS2/yV3R8UABe9nOdqJoaa+Y64X/wABNAw';\nconst WALLET_ID = 0;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9BY2NvdW50c1N0b3JhZ2UvSGlnaGxvYWRXYWxsZXRWMi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9ldmVyc2NhbGUtc3RhbmRhbG9uZS1jbGllbnQvY2xpZW50L0FjY291bnRzU3RvcmFnZS9IaWdobG9hZFdhbGxldFYyLmpzP2QwYTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhpZ2hsb2FkV2FsbGV0VjIgPSB2b2lkIDA7XG5jb25zdCBldmVyc2NhbGVfaW5wYWdlX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiZXZlcnNjYWxlLWlucGFnZS1wcm92aWRlclwiKTtcbmNvbnN0IGJpZ251bWJlcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJiaWdudW1iZXIuanNcIikpO1xuY29uc3QgY29yZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9jb3JlXCIpKTtcbmNvbnN0IHsgZW5zdXJlTmVrb3RvbkxvYWRlZCwgbmVrb3RvbiB9ID0gY29yZV8xLmRlZmF1bHQ7XG4vKipcbiAqIEBjYXRlZ29yeSBBY2NvdW50c1N0b3JhZ2VcbiAqL1xuY2xhc3MgSGlnaGxvYWRXYWxsZXRWMiB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcykge1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzIGluc3RhbmNlb2YgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3MgPyBhZGRyZXNzIDogbmV3IGV2ZXJzY2FsZV9pbnBhZ2VfcHJvdmlkZXJfMS5BZGRyZXNzKGFkZHJlc3MpO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY29tcHV0ZUFkZHJlc3MoYXJncykge1xuICAgICAgICAvLyBUT0RPOiBTb21laG93IHByb3BhZ2F0ZSBpbml0IHBhcmFtc1xuICAgICAgICBhd2FpdCBlbnN1cmVOZWtvdG9uTG9hZGVkKCk7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGFyZ3MucHVibGljS2V5IGluc3RhbmNlb2YgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdFxuICAgICAgICAgICAgPyBhcmdzLnB1YmxpY0tleVxuICAgICAgICAgICAgOiBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdChgMHgke2FyZ3MucHVibGljS2V5fWApO1xuICAgICAgICBjb25zdCB0dmMgPSBtYWtlU3RhdGVJbml0KHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBuZWtvdG9uLmdldEJvY0hhc2godHZjKTtcbiAgICAgICAgcmV0dXJuIG5ldyBldmVyc2NhbGVfaW5wYWdlX3Byb3ZpZGVyXzEuQWRkcmVzcyhgJHthcmdzLndvcmtjaGFpbiAhPSBudWxsID8gYXJncy53b3JrY2hhaW4gOiAwfToke2hhc2h9YCk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBmcm9tUHVia2V5KGFyZ3MpIHtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQoYDB4JHthcmdzLnB1YmxpY0tleX1gKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IEhpZ2hsb2FkV2FsbGV0VjIuY29tcHV0ZUFkZHJlc3MoeyBwdWJsaWNLZXksIHdvcmtjaGFpbjogYXJncy53b3JrY2hhaW4gfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBIaWdobG9hZFdhbGxldFYyKGFkZHJlc3MpO1xuICAgICAgICByZXN1bHQucHVibGljS2V5ID0gcHVibGljS2V5O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFB1YmxpY0tleShjdHgpIHtcbiAgICAgICAgbGV0IHB1YmxpY0tleSA9IHRoaXMucHVibGljS2V5O1xuICAgICAgICBpZiAocHVibGljS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHB1YmxpY0tleSA9IHRoaXMucHVibGljS2V5ID0gYXdhaXQgY3R4LmZldGNoUHVibGljS2V5KHRoaXMuYWRkcmVzcylcbiAgICAgICAgICAgICAgICAudGhlbihwdWJsaWNLZXkgPT4gbmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQoYDB4JHtwdWJsaWNLZXl9YCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwdWJsaWNLZXkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDY0LCAnMCcpO1xuICAgIH1cbiAgICBhc3luYyBwcmVwYXJlTWVzc2FnZShhcmdzLCBjdHgpIHtcbiAgICAgICAgY29uc3QgeyBwdWJsaWNLZXksIHN0YXRlSW5pdCB9ID0gYXdhaXQgdGhpcy5mZXRjaFN0YXRlKGN0eCk7XG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IGN0eC5nZXRTaWduZXIocHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgZXhwaXJlQXQgPSBjdHgubm93U2VjICsgYXJncy50aW1lb3V0O1xuICAgICAgICBjb25zdCBhdHRhY2hlZFBheWxvYWQgPSBhcmdzLnBheWxvYWRcbiAgICAgICAgICAgID8gY3R4LmVuY29kZUludGVybmFsSW5wdXQoYXJncy5wYXlsb2FkKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGludGVybmFsTWVzc2FnZSA9IGN0eC5lbmNvZGVJbnRlcm5hbE1lc3NhZ2Uoe1xuICAgICAgICAgICAgZHN0OiBhcmdzLnJlY2lwaWVudCxcbiAgICAgICAgICAgIGJvdW5jZTogYXJncy5ib3VuY2UsXG4gICAgICAgICAgICBzdGF0ZUluaXQ6IGFyZ3Muc3RhdGVJbml0LFxuICAgICAgICAgICAgYm9keTogYXR0YWNoZWRQYXlsb2FkLFxuICAgICAgICAgICAgYW1vdW50OiBhcmdzLmFtb3VudCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBbWzAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogaW50ZXJuYWxNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9XV0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gY3R4LnBhY2tJbnRvQ2VsbCh7IHN0cnVjdHVyZTogTUVTU0FHRVNfU1RSVUNUVVJFLCBkYXRhOiBwYXJhbXMgfSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzSGFzaCA9IGN0eC5nZXRCb2NIYXNoKG1lc3NhZ2VzKTtcbiAgICAgICAgcGFyYW1zLndhbGxldElkID0gV0FMTEVUX0lEO1xuICAgICAgICBwYXJhbXMuZXhwaXJlQXQgPSBleHBpcmVBdDtcbiAgICAgICAgcGFyYW1zLm1lc3NhZ2VzSGFzaCA9IGAweCR7bWVzc2FnZXNIYXNoLnNsaWNlKC04KX1gO1xuICAgICAgICBjb25zdCB1bnNpZ25lZFBheWxvYWQgPSBjdHgucGFja0ludG9DZWxsKHsgc3RydWN0dXJlOiBVTlNJR05FRF9UUkFOU0ZFUl9TVFJVQ1RVUkUsIGRhdGE6IHBhcmFtcyB9KTtcbiAgICAgICAgY29uc3QgaGFzaCA9IGN0eC5nZXRCb2NIYXNoKHVuc2lnbmVkUGF5bG9hZCk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25lci5zaWduKGhhc2gpO1xuICAgICAgICBjb25zdCB7IHNpZ25hdHVyZVBhcnRzIH0gPSBjdHguZXh0ZW5kU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgICAgIHBhcmFtcy5zaWduYXR1cmVIaWdoID0gc2lnbmF0dXJlUGFydHMuaGlnaDtcbiAgICAgICAgcGFyYW1zLnNpZ25hdHVyZUxvdyA9IHNpZ25hdHVyZVBhcnRzLmxvdztcbiAgICAgICAgY29uc3Qgc2lnbmVkUGF5bG9hZCA9IGN0eC5wYWNrSW50b0NlbGwoeyBzdHJ1Y3R1cmU6IFNJR05FRF9UUkFOU0ZFUl9TVFJVQ1RVUkUsIGRhdGE6IHBhcmFtcyB9KTtcbiAgICAgICAgcmV0dXJuIGN0eC5jcmVhdGVSYXdFeHRlcm5hbE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWRkcmVzczogdGhpcy5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBib2R5OiBzaWduZWRQYXlsb2FkLFxuICAgICAgICAgICAgc3RhdGVJbml0LFxuICAgICAgICAgICAgZXhwaXJlQXQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFN0YXRlKGN0eCkge1xuICAgICAgICBsZXQgc3RhdGVJbml0ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcHVibGljS2V5O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGF3YWl0IGN0eC5nZXRGdWxsQ29udHJhY3RTdGF0ZSh0aGlzLmFkZHJlc3MpO1xuICAgICAgICBpZiAoc3RhdGUgPT0gbnVsbCB8fCAhc3RhdGUuaXNEZXBsb3llZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHVibGljS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyYWN0IG5vdCBkZXBsb3llZCBhbmQgcHVibGljIGtleSB3YXMgbm90IHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGVJbml0ID0gbWFrZVN0YXRlSW5pdCh0aGlzLnB1YmxpY0tleSk7XG4gICAgICAgICAgICBwdWJsaWNLZXkgPSB0aGlzLnB1YmxpY0tleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnB1YmxpY0tleSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY3R4LmV4dHJhY3RDb250cmFjdERhdGEoc3RhdGUuYm9jKTtcbiAgICAgICAgICAgIGlmIChkYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBleHRyYWN0IGNvbnRyYWN0IGRhdGEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHB1YmxpY0tleSA9IHBhcnNlSW5pdERhdGEoY3R4LCBkYXRhKS5wdWJsaWNLZXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwdWJsaWNLZXkgPSB0aGlzLnB1YmxpY0tleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wdWJsaWNLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBwdWJsaWNLZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHB1YmxpY0tleTogcHVibGljS2V5LnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgJzAnKSxcbiAgICAgICAgICAgIHN0YXRlSW5pdCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkhpZ2hsb2FkV2FsbGV0VjIgPSBIaWdobG9hZFdhbGxldFYyO1xuY29uc3QgcGFyc2VJbml0RGF0YSA9IChjdHgsIGJvYykgPT4ge1xuICAgIGNvbnN0IHBhcnNlZCA9IGN0eC51bnBhY2tGcm9tQ2VsbCh7IHN0cnVjdHVyZTogREFUQV9TVFJVQ1RVUkUsIGJvYywgYWxsb3dQYXJ0aWFsOiB0cnVlIH0pO1xuICAgIGlmICh0eXBlb2YgcGFyc2VkICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFyc2VkWydwdWJsaWNLZXknXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbnRyYWN0IGRhdGEnKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHVibGljS2V5OiBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdChwYXJzZWQucHVibGljS2V5KSxcbiAgICB9O1xufTtcbmNvbnN0IG1ha2VTdGF0ZUluaXQgPSAocHVibGljS2V5KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IG5la290b24ucGFja0ludG9DZWxsKERBVEFfU1RSVUNUVVJFLCB7XG4gICAgICAgIHdhbGxldElkOiBXQUxMRVRfSUQsXG4gICAgICAgIGxhc3RDbGVhbmVkOiAwLFxuICAgICAgICBwdWJsaWNLZXk6IHB1YmxpY0tleS50b0ZpeGVkKDApLFxuICAgICAgICBxdWVyaWVzOiBmYWxzZSxcbiAgICB9KTtcbiAgICByZXR1cm4gbmVrb3Rvbi5tZXJnZVR2YyhISUdITE9BRF9XQUxMRVRfVjJfQ09ERSwgZGF0YSk7XG59O1xuY29uc3QgTUVTU0FHRVNfU1RSVUNUVVJFID0gW1xuICAgIHtcbiAgICAgICAgbmFtZTogJ21lc3NhZ2VzJyxcbiAgICAgICAgdHlwZTogJ21hcCh1aW50MTYsdHVwbGUpJyxcbiAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgeyBuYW1lOiAnZmxhZ3MnLCB0eXBlOiAndWludDgnIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtZXNzYWdlJywgdHlwZTogJ2NlbGwnIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbl07XG5jb25zdCBVTlNJR05FRF9UUkFOU0ZFUl9TVFJVQ1RVUkUgPSBbXG4gICAgeyBuYW1lOiAnd2FsbGV0SWQnLCB0eXBlOiAndWludDMyJyB9LFxuICAgIHsgbmFtZTogJ2V4cGlyZUF0JywgdHlwZTogJ3VpbnQzMicgfSxcbiAgICB7IG5hbWU6ICdtZXNzYWdlc0hhc2gnLCB0eXBlOiAndWludDMyJyB9LFxuICAgIC4uLk1FU1NBR0VTX1NUUlVDVFVSRSxcbl07XG5jb25zdCBTSUdORURfVFJBTlNGRVJfU1RSVUNUVVJFID0gW1xuICAgIHsgbmFtZTogJ3NpZ25hdHVyZUhpZ2gnLCB0eXBlOiAndWludDI1NicgfSxcbiAgICB7IG5hbWU6ICdzaWduYXR1cmVMb3cnLCB0eXBlOiAndWludDI1NicgfSxcbiAgICAuLi5VTlNJR05FRF9UUkFOU0ZFUl9TVFJVQ1RVUkUsXG5dO1xuY29uc3QgREFUQV9TVFJVQ1RVUkUgPSBbXG4gICAgeyBuYW1lOiAnd2FsbGV0SWQnLCB0eXBlOiAndWludDMyJyB9LFxuICAgIHsgbmFtZTogJ2xhc3RDbGVhbmVkJywgdHlwZTogJ3VpbnQ2NCcgfSxcbiAgICB7IG5hbWU6ICdwdWJsaWNLZXknLCB0eXBlOiAndWludDI1NicgfSxcbiAgICB7IG5hbWU6ICdxdWVyaWVzJywgdHlwZTogJ2Jvb2wnIH0sXG5dO1xuY29uc3QgSElHSExPQURfV0FMTEVUX1YyX0NPREUgPSAndGU2Y2NnRUJDUUVBNVFBQkZQOEE5S1FUOUx6eXlBc0JBZ0VnQkFJQjZ2S0RDTmNZSU5NZjB6LzRJNm9mVXlDNThtUHRSTkRUSDlNLzAvLzBCTkZUWUlCQTlBNXZvVEh5WUZGenV2S2lCL2tCVkJDSCtSRHlvd0wwQk5INEFIK09GaUdBRVBSNGI2VWdtQUxUQjlRd0Fmc0FrVExpQWJQbVc0TWxvY2hBTklCQTlFT0s1akhJRXNzZkU4cy95Ly8wQU1udFZBTUFOQ0NBUVBTV2I2VXlVUkNVTUZNRHVkNGdrek0yQVpJeU1PS3pBZ0ZJQ0FVQ0FTQUhCZ0JCdmwrWGFpYUdtUG1PbWY2ZitZK2dKb3FSQkFJSG9ITjlDWXlTMi95VjNSOFVBQmU5bk9kcUpvYWErWTY0WC93QUJOQXcnO1xuY29uc3QgV0FMTEVUX0lEID0gMDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/everscale-standalone-client/client/AccountsStorage/HighloadWalletV2.js\n");

/***/ }),

/***/ "./node_modules/everscale-standalone-client/client/AccountsStorage/WalletV3.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/everscale-standalone-client/client/AccountsStorage/WalletV3.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletV3Account = void 0;\nconst everscale_inpage_provider_1 = __webpack_require__(/*! everscale-inpage-provider */ \"./node_modules/everscale-inpage-provider/dist/index.js\");\nconst bignumber_js_1 = __importDefault(__webpack_require__(/*! bignumber.js */ \"./node_modules/bignumber.js/bignumber.js\"));\nconst core_1 = __importDefault(__webpack_require__(/*! ../../core */ \"./node_modules/everscale-standalone-client/core.js\"));\nconst { ensureNekotonLoaded, nekoton } = core_1.default;\n/**\n * @category AccountsStorage\n */\nclass WalletV3Account {\n    constructor(address) {\n        this.address = address;\n    }\n    static async computeAddress(args) {\n        // TODO: Somehow propagate init params\n        await ensureNekotonLoaded();\n        const publicKey = args.publicKey instanceof bignumber_js_1.default\n            ? args.publicKey\n            : new bignumber_js_1.default(`0x${args.publicKey}`);\n        const tvc = makeStateInit(publicKey);\n        const hash = nekoton.getBocHash(tvc);\n        return new everscale_inpage_provider_1.Address(`${args.workchain != null ? args.workchain : 0}:${hash}`);\n    }\n    static async fromPubkey(args) {\n        const publicKey = new bignumber_js_1.default(`0x${args.publicKey}`);\n        const address = await WalletV3Account.computeAddress({ publicKey, workchain: args.workchain });\n        const result = new WalletV3Account(address);\n        result.publicKey = publicKey;\n        return result;\n    }\n    async fetchPublicKey(ctx) {\n        let publicKey = this.publicKey;\n        if (publicKey == null) {\n            publicKey = this.publicKey = await ctx.fetchPublicKey(this.address)\n                .then(publicKey => new bignumber_js_1.default(`0x${publicKey}`));\n        }\n        return publicKey.toString(16).padStart(64, '0');\n    }\n    async prepareMessage(args, ctx) {\n        const { seqno, publicKey, stateInit } = await this.fetchState(ctx);\n        const signer = await ctx.getSigner(publicKey);\n        const expireAt = ctx.nowSec + args.timeout;\n        const attachedPayload = args.payload\n            ? ctx.encodeInternalInput(args.payload)\n            : undefined;\n        const internalMessage = ctx.encodeInternalMessage({\n            dst: args.recipient,\n            bounce: args.bounce,\n            stateInit: args.stateInit,\n            body: attachedPayload,\n            amount: args.amount,\n        });\n        const params = {\n            walletId: WALLET_ID,\n            expireAt,\n            seqno,\n            flags: 3,\n            message: internalMessage,\n        };\n        const unsignedPayload = ctx.packIntoCell({ structure: UNSIGNED_TRANSFER_STRUCTURE, data: params });\n        const hash = ctx.getBocHash(unsignedPayload);\n        const signature = await signer.sign(hash);\n        const { signatureParts } = ctx.extendSignature(signature);\n        params.signatureHigh = signatureParts.high;\n        params.signatureLow = signatureParts.low;\n        const signedPayload = ctx.packIntoCell({\n            structure: SIGNED_TRANSFER_STRUCTURE,\n            data: params,\n        });\n        return ctx.createRawExternalMessage({\n            address: this.address,\n            body: signedPayload,\n            stateInit,\n            expireAt,\n        });\n    }\n    async fetchState(ctx) {\n        let stateInit = undefined;\n        let result;\n        const state = await ctx.getFullContractState(this.address);\n        if (state == null || !state.isDeployed) {\n            if (this.publicKey == null) {\n                throw new Error('Contract not deployed and public key was not specified');\n            }\n            stateInit = makeStateInit(this.publicKey);\n            result = { seqno: 0, publicKey: this.publicKey };\n        }\n        else {\n            const data = ctx.extractContractData(state.boc);\n            if (data == null) {\n                throw new Error('Failed to extract contract data');\n            }\n            result = parseInitData(ctx, data);\n        }\n        if (this.publicKey == null) {\n            this.publicKey = result.publicKey;\n        }\n        else if (!this.publicKey.eq(result.publicKey)) {\n            throw new Error('Public key mismatch');\n        }\n        return {\n            seqno: result.seqno,\n            publicKey: result.publicKey.toString(16).padStart(64, '0'),\n            stateInit,\n        };\n    }\n}\nexports.WalletV3Account = WalletV3Account;\nconst parseInitData = (ctx, boc) => {\n    const parsed = ctx.unpackFromCell({\n        structure: DATA_STRUCTURE,\n        boc,\n        allowPartial: false,\n    });\n    if (typeof parsed !== 'object' || typeof parsed['seqno'] !== 'string' || typeof parsed['publicKey'] !== 'string') {\n        throw new Error('Invalid contract data ');\n    }\n    return {\n        seqno: parseInt(parsed.seqno),\n        publicKey: new bignumber_js_1.default(parsed.publicKey),\n    };\n};\nconst makeStateInit = (publicKey) => {\n    const data = nekoton.packIntoCell(DATA_STRUCTURE, {\n        seqno: 0,\n        walletId: WALLET_ID,\n        publicKey: publicKey.toFixed(0),\n    });\n    return nekoton.mergeTvc(WALLET_V3_CODE, data);\n};\nconst UNSIGNED_TRANSFER_STRUCTURE = [\n    { name: 'walletId', type: 'uint32' },\n    { name: 'expireAt', type: 'uint32' },\n    { name: 'seqno', type: 'uint32' },\n    { name: 'flags', type: 'uint8' },\n    { name: 'message', type: 'cell' },\n];\nconst SIGNED_TRANSFER_STRUCTURE = [\n    { name: 'signatureHigh', type: 'uint256' },\n    { name: 'signatureLow', type: 'uint256' },\n    ...UNSIGNED_TRANSFER_STRUCTURE,\n];\nconst DATA_STRUCTURE = [\n    { name: 'seqno', type: 'uint32' },\n    { name: 'walletId', type: 'uint32' },\n    { name: 'publicKey', type: 'uint256' },\n];\nconst WALLET_V3_CODE = 'te6ccgEBAQEAcQAA3v8AIN0gggFMl7ohggEznLqxn3Gw7UTQ0x/THzHXC//jBOCk8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVA==';\nconst WALLET_ID = 0x4BA92D8A;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9BY2NvdW50c1N0b3JhZ2UvV2FsbGV0VjMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9BY2NvdW50c1N0b3JhZ2UvV2FsbGV0VjMuanM/NTdmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2FsbGV0VjNBY2NvdW50ID0gdm9pZCAwO1xuY29uc3QgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xID0gcmVxdWlyZShcImV2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXJcIik7XG5jb25zdCBiaWdudW1iZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmlnbnVtYmVyLmpzXCIpKTtcbmNvbnN0IGNvcmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vY29yZVwiKSk7XG5jb25zdCB7IGVuc3VyZU5la290b25Mb2FkZWQsIG5la290b24gfSA9IGNvcmVfMS5kZWZhdWx0O1xuLyoqXG4gKiBAY2F0ZWdvcnkgQWNjb3VudHNTdG9yYWdlXG4gKi9cbmNsYXNzIFdhbGxldFYzQWNjb3VudCB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcykge1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY29tcHV0ZUFkZHJlc3MoYXJncykge1xuICAgICAgICAvLyBUT0RPOiBTb21laG93IHByb3BhZ2F0ZSBpbml0IHBhcmFtc1xuICAgICAgICBhd2FpdCBlbnN1cmVOZWtvdG9uTG9hZGVkKCk7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGFyZ3MucHVibGljS2V5IGluc3RhbmNlb2YgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdFxuICAgICAgICAgICAgPyBhcmdzLnB1YmxpY0tleVxuICAgICAgICAgICAgOiBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdChgMHgke2FyZ3MucHVibGljS2V5fWApO1xuICAgICAgICBjb25zdCB0dmMgPSBtYWtlU3RhdGVJbml0KHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBuZWtvdG9uLmdldEJvY0hhc2godHZjKTtcbiAgICAgICAgcmV0dXJuIG5ldyBldmVyc2NhbGVfaW5wYWdlX3Byb3ZpZGVyXzEuQWRkcmVzcyhgJHthcmdzLndvcmtjaGFpbiAhPSBudWxsID8gYXJncy53b3JrY2hhaW4gOiAwfToke2hhc2h9YCk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBmcm9tUHVia2V5KGFyZ3MpIHtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQoYDB4JHthcmdzLnB1YmxpY0tleX1gKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IFdhbGxldFYzQWNjb3VudC5jb21wdXRlQWRkcmVzcyh7IHB1YmxpY0tleSwgd29ya2NoYWluOiBhcmdzLndvcmtjaGFpbiB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFdhbGxldFYzQWNjb3VudChhZGRyZXNzKTtcbiAgICAgICAgcmVzdWx0LnB1YmxpY0tleSA9IHB1YmxpY0tleTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hQdWJsaWNLZXkoY3R4KSB7XG4gICAgICAgIGxldCBwdWJsaWNLZXkgPSB0aGlzLnB1YmxpY0tleTtcbiAgICAgICAgaWYgKHB1YmxpY0tleSA9PSBudWxsKSB7XG4gICAgICAgICAgICBwdWJsaWNLZXkgPSB0aGlzLnB1YmxpY0tleSA9IGF3YWl0IGN0eC5mZXRjaFB1YmxpY0tleSh0aGlzLmFkZHJlc3MpXG4gICAgICAgICAgICAgICAgLnRoZW4ocHVibGljS2V5ID0+IG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KGAweCR7cHVibGljS2V5fWApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVibGljS2V5LnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgJzAnKTtcbiAgICB9XG4gICAgYXN5bmMgcHJlcGFyZU1lc3NhZ2UoYXJncywgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgc2Vxbm8sIHB1YmxpY0tleSwgc3RhdGVJbml0IH0gPSBhd2FpdCB0aGlzLmZldGNoU3RhdGUoY3R4KTtcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgY3R4LmdldFNpZ25lcihwdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBleHBpcmVBdCA9IGN0eC5ub3dTZWMgKyBhcmdzLnRpbWVvdXQ7XG4gICAgICAgIGNvbnN0IGF0dGFjaGVkUGF5bG9hZCA9IGFyZ3MucGF5bG9hZFxuICAgICAgICAgICAgPyBjdHguZW5jb2RlSW50ZXJuYWxJbnB1dChhcmdzLnBheWxvYWQpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxNZXNzYWdlID0gY3R4LmVuY29kZUludGVybmFsTWVzc2FnZSh7XG4gICAgICAgICAgICBkc3Q6IGFyZ3MucmVjaXBpZW50LFxuICAgICAgICAgICAgYm91bmNlOiBhcmdzLmJvdW5jZSxcbiAgICAgICAgICAgIHN0YXRlSW5pdDogYXJncy5zdGF0ZUluaXQsXG4gICAgICAgICAgICBib2R5OiBhdHRhY2hlZFBheWxvYWQsXG4gICAgICAgICAgICBhbW91bnQ6IGFyZ3MuYW1vdW50LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgd2FsbGV0SWQ6IFdBTExFVF9JRCxcbiAgICAgICAgICAgIGV4cGlyZUF0LFxuICAgICAgICAgICAgc2Vxbm8sXG4gICAgICAgICAgICBmbGFnczogMyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGludGVybmFsTWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdW5zaWduZWRQYXlsb2FkID0gY3R4LnBhY2tJbnRvQ2VsbCh7IHN0cnVjdHVyZTogVU5TSUdORURfVFJBTlNGRVJfU1RSVUNUVVJFLCBkYXRhOiBwYXJhbXMgfSk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBjdHguZ2V0Qm9jSGFzaCh1bnNpZ25lZFBheWxvYWQpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzaWduZXIuc2lnbihoYXNoKTtcbiAgICAgICAgY29uc3QgeyBzaWduYXR1cmVQYXJ0cyB9ID0gY3R4LmV4dGVuZFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICBwYXJhbXMuc2lnbmF0dXJlSGlnaCA9IHNpZ25hdHVyZVBhcnRzLmhpZ2g7XG4gICAgICAgIHBhcmFtcy5zaWduYXR1cmVMb3cgPSBzaWduYXR1cmVQYXJ0cy5sb3c7XG4gICAgICAgIGNvbnN0IHNpZ25lZFBheWxvYWQgPSBjdHgucGFja0ludG9DZWxsKHtcbiAgICAgICAgICAgIHN0cnVjdHVyZTogU0lHTkVEX1RSQU5TRkVSX1NUUlVDVFVSRSxcbiAgICAgICAgICAgIGRhdGE6IHBhcmFtcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjdHguY3JlYXRlUmF3RXh0ZXJuYWxNZXNzYWdlKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgIGJvZHk6IHNpZ25lZFBheWxvYWQsXG4gICAgICAgICAgICBzdGF0ZUluaXQsXG4gICAgICAgICAgICBleHBpcmVBdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoU3RhdGUoY3R4KSB7XG4gICAgICAgIGxldCBzdGF0ZUluaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgY3R4LmdldEZ1bGxDb250cmFjdFN0YXRlKHRoaXMuYWRkcmVzcyk7XG4gICAgICAgIGlmIChzdGF0ZSA9PSBudWxsIHx8ICFzdGF0ZS5pc0RlcGxveWVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wdWJsaWNLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udHJhY3Qgbm90IGRlcGxveWVkIGFuZCBwdWJsaWMga2V5IHdhcyBub3Qgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZUluaXQgPSBtYWtlU3RhdGVJbml0KHRoaXMucHVibGljS2V5KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHsgc2Vxbm86IDAsIHB1YmxpY0tleTogdGhpcy5wdWJsaWNLZXkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjdHguZXh0cmFjdENvbnRyYWN0RGF0YShzdGF0ZS5ib2MpO1xuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGV4dHJhY3QgY29udHJhY3QgZGF0YScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VJbml0RGF0YShjdHgsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnB1YmxpY0tleSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnB1YmxpY0tleSA9IHJlc3VsdC5wdWJsaWNLZXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMucHVibGljS2V5LmVxKHJlc3VsdC5wdWJsaWNLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1B1YmxpYyBrZXkgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2Vxbm86IHJlc3VsdC5zZXFubyxcbiAgICAgICAgICAgIHB1YmxpY0tleTogcmVzdWx0LnB1YmxpY0tleS50b1N0cmluZygxNikucGFkU3RhcnQoNjQsICcwJyksXG4gICAgICAgICAgICBzdGF0ZUluaXQsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5XYWxsZXRWM0FjY291bnQgPSBXYWxsZXRWM0FjY291bnQ7XG5jb25zdCBwYXJzZUluaXREYXRhID0gKGN0eCwgYm9jKSA9PiB7XG4gICAgY29uc3QgcGFyc2VkID0gY3R4LnVucGFja0Zyb21DZWxsKHtcbiAgICAgICAgc3RydWN0dXJlOiBEQVRBX1NUUlVDVFVSRSxcbiAgICAgICAgYm9jLFxuICAgICAgICBhbGxvd1BhcnRpYWw6IGZhbHNlLFxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgcGFyc2VkICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFyc2VkWydzZXFubyddICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgcGFyc2VkWydwdWJsaWNLZXknXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbnRyYWN0IGRhdGEgJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNlcW5vOiBwYXJzZUludChwYXJzZWQuc2Vxbm8pLFxuICAgICAgICBwdWJsaWNLZXk6IG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KHBhcnNlZC5wdWJsaWNLZXkpLFxuICAgIH07XG59O1xuY29uc3QgbWFrZVN0YXRlSW5pdCA9IChwdWJsaWNLZXkpID0+IHtcbiAgICBjb25zdCBkYXRhID0gbmVrb3Rvbi5wYWNrSW50b0NlbGwoREFUQV9TVFJVQ1RVUkUsIHtcbiAgICAgICAgc2Vxbm86IDAsXG4gICAgICAgIHdhbGxldElkOiBXQUxMRVRfSUQsXG4gICAgICAgIHB1YmxpY0tleTogcHVibGljS2V5LnRvRml4ZWQoMCksXG4gICAgfSk7XG4gICAgcmV0dXJuIG5la290b24ubWVyZ2VUdmMoV0FMTEVUX1YzX0NPREUsIGRhdGEpO1xufTtcbmNvbnN0IFVOU0lHTkVEX1RSQU5TRkVSX1NUUlVDVFVSRSA9IFtcbiAgICB7IG5hbWU6ICd3YWxsZXRJZCcsIHR5cGU6ICd1aW50MzInIH0sXG4gICAgeyBuYW1lOiAnZXhwaXJlQXQnLCB0eXBlOiAndWludDMyJyB9LFxuICAgIHsgbmFtZTogJ3NlcW5vJywgdHlwZTogJ3VpbnQzMicgfSxcbiAgICB7IG5hbWU6ICdmbGFncycsIHR5cGU6ICd1aW50OCcgfSxcbiAgICB7IG5hbWU6ICdtZXNzYWdlJywgdHlwZTogJ2NlbGwnIH0sXG5dO1xuY29uc3QgU0lHTkVEX1RSQU5TRkVSX1NUUlVDVFVSRSA9IFtcbiAgICB7IG5hbWU6ICdzaWduYXR1cmVIaWdoJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgeyBuYW1lOiAnc2lnbmF0dXJlTG93JywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgLi4uVU5TSUdORURfVFJBTlNGRVJfU1RSVUNUVVJFLFxuXTtcbmNvbnN0IERBVEFfU1RSVUNUVVJFID0gW1xuICAgIHsgbmFtZTogJ3NlcW5vJywgdHlwZTogJ3VpbnQzMicgfSxcbiAgICB7IG5hbWU6ICd3YWxsZXRJZCcsIHR5cGU6ICd1aW50MzInIH0sXG4gICAgeyBuYW1lOiAncHVibGljS2V5JywgdHlwZTogJ3VpbnQyNTYnIH0sXG5dO1xuY29uc3QgV0FMTEVUX1YzX0NPREUgPSAndGU2Y2NnRUJBUUVBY1FBQTN2OEFJTjBnZ2dGTWw3b2hnZ0V6bkxxeG4zR3c3VVRRMHgvVEh6SFhDLy9qQk9DazhtQ0RDTmNZSU5NZjB4L1RIL2dqRTd2eVkrMUUwTk1mMHgvVC85RlJNcnJ5b1ZGRXV2S2lCUGtCVkJCVitSRHlvL2dBa3lEWFNwYlRCOVFDK3dEbzBRR2t5TXNmeXgvTC84bnRWQT09JztcbmNvbnN0IFdBTExFVF9JRCA9IDB4NEJBOTJEOEE7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/everscale-standalone-client/client/AccountsStorage/WalletV3.js\n");

/***/ }),

/***/ "./node_modules/everscale-standalone-client/client/AccountsStorage/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/everscale-standalone-client/client/AccountsStorage/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SimpleAccountsStorage = exports.AccountsStorageContext = exports.HighloadWalletV2 = exports.WalletV3Account = exports.MsigAccount = exports.GenericAccount = exports.GiverAccount = void 0;\nconst everscale_inpage_provider_1 = __webpack_require__(/*! everscale-inpage-provider */ \"./node_modules/everscale-inpage-provider/dist/index.js\");\nvar Giver_1 = __webpack_require__(/*! ./Giver */ \"./node_modules/everscale-standalone-client/client/AccountsStorage/Giver.js\");\nObject.defineProperty(exports, \"GiverAccount\", ({ enumerable: true, get: function () { return Giver_1.GiverAccount; } }));\nvar Generic_1 = __webpack_require__(/*! ./Generic */ \"./node_modules/everscale-standalone-client/client/AccountsStorage/Generic.js\");\nObject.defineProperty(exports, \"GenericAccount\", ({ enumerable: true, get: function () { return Generic_1.GenericAccount; } }));\nObject.defineProperty(exports, \"MsigAccount\", ({ enumerable: true, get: function () { return Generic_1.MsigAccount; } }));\nvar WalletV3_1 = __webpack_require__(/*! ./WalletV3 */ \"./node_modules/everscale-standalone-client/client/AccountsStorage/WalletV3.js\");\nObject.defineProperty(exports, \"WalletV3Account\", ({ enumerable: true, get: function () { return WalletV3_1.WalletV3Account; } }));\nvar HighloadWalletV2_1 = __webpack_require__(/*! ./HighloadWalletV2 */ \"./node_modules/everscale-standalone-client/client/AccountsStorage/HighloadWalletV2.js\");\nObject.defineProperty(exports, \"HighloadWalletV2\", ({ enumerable: true, get: function () { return HighloadWalletV2_1.HighloadWalletV2; } }));\n/**\n * @category AccountsStorage\n */\nclass AccountsStorageContext {\n    constructor(clock, connectionController, nekoton, keystore) {\n        this.clock = clock;\n        this.connectionController = connectionController;\n        this.nekoton = nekoton;\n        this.keystore = keystore;\n    }\n    async getSigner(publicKey) {\n        if (this.keystore == null) {\n            throw new Error('Keystore not found');\n        }\n        const signer = await this.keystore.getSigner(publicKey);\n        if (signer == null) {\n            throw new Error('Signer not found');\n        }\n        return signer;\n    }\n    get nowMs() {\n        return this.clock.nowMs;\n    }\n    get nowSec() {\n        return ~~(this.clock.nowMs / 1000);\n    }\n    async fetchPublicKey(address) {\n        const state = await this.getFullContractState(address);\n        if (state == null || !state.isDeployed) {\n            throw new Error('Contract not deployed');\n        }\n        return this.nekoton.extractPublicKey(state.boc);\n    }\n    async getFullContractState(address) {\n        return this.connectionController.use(async ({ data: { transport } }) => transport.getFullContractState(address.toString()));\n    }\n    extractContractData(boc) {\n        return this.nekoton.extractContractData(boc);\n    }\n    packIntoCell(args) {\n        return this.nekoton.packIntoCell(args.structure, args.data, args.abiVersion);\n    }\n    unpackFromCell(args) {\n        return this.nekoton.unpackFromCell(args.structure, args.boc, args.allowPartial, args.abiVersion);\n    }\n    getBocHash(boc) {\n        return this.nekoton.getBocHash(boc);\n    }\n    extendSignature(signature) {\n        return this.nekoton.extendSignature(signature);\n    }\n    encodeInternalInput(args) {\n        return this.nekoton.encodeInternalInput(args.abi, args.method, args.params);\n    }\n    encodeInternalMessage(args) {\n        return this.nekoton.encodeInternalMessage(args.src, args.dst, args.bounce, args.stateInit, args.body, args.amount);\n    }\n    async createExternalMessage(args) {\n        const unsignedMessage = this.nekoton.createExternalMessage(this.clock, args.address.toString(), args.abi, args.method, args.stateInit, args.params, args.signer.publicKey, args.timeout);\n        try {\n            const signature = await args.signer.sign(unsignedMessage.hash);\n            return unsignedMessage.sign(signature);\n        }\n        finally {\n            unsignedMessage.free();\n        }\n    }\n    createRawExternalMessage(args) {\n        return this.nekoton.createRawExternalMessage(args.address.toString(), args.stateInit, args.body, args.expireAt);\n    }\n}\nexports.AccountsStorageContext = AccountsStorageContext;\n/**\n * @category AccountsStorage\n */\nclass SimpleAccountsStorage {\n    /**\n     * Creates new simple accounts storage.\n     *\n     * If no `defaultAccount` provided, uses first provided entry\n     *\n     * @param args\n     */\n    constructor(args = {}) {\n        this.accounts = new Map();\n        if (args.entries != null) {\n            for (const account of args.entries) {\n                if (this._defaultAccount == null) {\n                    this._defaultAccount = account.address;\n                }\n                this.accounts.set(account.address.toString(), account);\n            }\n        }\n        if (args.defaultAccount != null) {\n            let defaultAccount;\n            if (args.defaultAccount instanceof everscale_inpage_provider_1.Address) {\n                defaultAccount = args.defaultAccount;\n            }\n            else {\n                defaultAccount = new everscale_inpage_provider_1.Address(args.defaultAccount);\n            }\n            if (!this.accounts.has(defaultAccount.toString())) {\n                throw new Error('Provided default account not found in storage');\n            }\n            this._defaultAccount = defaultAccount;\n        }\n    }\n    get defaultAccount() {\n        return this._defaultAccount;\n    }\n    set defaultAccount(value) {\n        const address = value === null || value === void 0 ? void 0 : value.toString();\n        if (address != null && !this.accounts.has(address)) {\n            throw new Error('Account not found in storage');\n        }\n        this._defaultAccount = (value == null || value instanceof everscale_inpage_provider_1.Address) ? value : new everscale_inpage_provider_1.Address(value);\n    }\n    async getAccount(address) {\n        return this.accounts.get(address.toString());\n    }\n    addAccount(account) {\n        const address = account.address;\n        this.accounts.set(address.toString(), account);\n        return address;\n    }\n    hasAccount(address) {\n        return this.accounts.has(address.toString());\n    }\n    removeAccount(address) {\n        this.accounts.delete(address.toString());\n    }\n}\nexports.SimpleAccountsStorage = SimpleAccountsStorage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9BY2NvdW50c1N0b3JhZ2UvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9BY2NvdW50c1N0b3JhZ2UvaW5kZXguanM/NjI4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2ltcGxlQWNjb3VudHNTdG9yYWdlID0gZXhwb3J0cy5BY2NvdW50c1N0b3JhZ2VDb250ZXh0ID0gZXhwb3J0cy5IaWdobG9hZFdhbGxldFYyID0gZXhwb3J0cy5XYWxsZXRWM0FjY291bnQgPSBleHBvcnRzLk1zaWdBY2NvdW50ID0gZXhwb3J0cy5HZW5lcmljQWNjb3VudCA9IGV4cG9ydHMuR2l2ZXJBY2NvdW50ID0gdm9pZCAwO1xuY29uc3QgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xID0gcmVxdWlyZShcImV2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXJcIik7XG52YXIgR2l2ZXJfMSA9IHJlcXVpcmUoXCIuL0dpdmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR2l2ZXJBY2NvdW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBHaXZlcl8xLkdpdmVyQWNjb3VudDsgfSB9KTtcbnZhciBHZW5lcmljXzEgPSByZXF1aXJlKFwiLi9HZW5lcmljXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR2VuZXJpY0FjY291bnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEdlbmVyaWNfMS5HZW5lcmljQWNjb3VudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1zaWdBY2NvdW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBHZW5lcmljXzEuTXNpZ0FjY291bnQ7IH0gfSk7XG52YXIgV2FsbGV0VjNfMSA9IHJlcXVpcmUoXCIuL1dhbGxldFYzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV2FsbGV0VjNBY2NvdW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBXYWxsZXRWM18xLldhbGxldFYzQWNjb3VudDsgfSB9KTtcbnZhciBIaWdobG9hZFdhbGxldFYyXzEgPSByZXF1aXJlKFwiLi9IaWdobG9hZFdhbGxldFYyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSGlnaGxvYWRXYWxsZXRWMlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSGlnaGxvYWRXYWxsZXRWMl8xLkhpZ2hsb2FkV2FsbGV0VjI7IH0gfSk7XG4vKipcbiAqIEBjYXRlZ29yeSBBY2NvdW50c1N0b3JhZ2VcbiAqL1xuY2xhc3MgQWNjb3VudHNTdG9yYWdlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoY2xvY2ssIGNvbm5lY3Rpb25Db250cm9sbGVyLCBuZWtvdG9uLCBrZXlzdG9yZSkge1xuICAgICAgICB0aGlzLmNsb2NrID0gY2xvY2s7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkNvbnRyb2xsZXIgPSBjb25uZWN0aW9uQ29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5uZWtvdG9uID0gbmVrb3RvbjtcbiAgICAgICAgdGhpcy5rZXlzdG9yZSA9IGtleXN0b3JlO1xuICAgIH1cbiAgICBhc3luYyBnZXRTaWduZXIocHVibGljS2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmtleXN0b3JlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5c3RvcmUgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgdGhpcy5rZXlzdG9yZS5nZXRTaWduZXIocHVibGljS2V5KTtcbiAgICAgICAgaWYgKHNpZ25lciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25lciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2lnbmVyO1xuICAgIH1cbiAgICBnZXQgbm93TXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb2NrLm5vd01zO1xuICAgIH1cbiAgICBnZXQgbm93U2VjKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5jbG9jay5ub3dNcyAvIDEwMDApO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFB1YmxpY0tleShhZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgdGhpcy5nZXRGdWxsQ29udHJhY3RTdGF0ZShhZGRyZXNzKTtcbiAgICAgICAgaWYgKHN0YXRlID09IG51bGwgfHwgIXN0YXRlLmlzRGVwbG95ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udHJhY3Qgbm90IGRlcGxveWVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmVrb3Rvbi5leHRyYWN0UHVibGljS2V5KHN0YXRlLmJvYyk7XG4gICAgfVxuICAgIGFzeW5jIGdldEZ1bGxDb250cmFjdFN0YXRlKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbkNvbnRyb2xsZXIudXNlKGFzeW5jICh7IGRhdGE6IHsgdHJhbnNwb3J0IH0gfSkgPT4gdHJhbnNwb3J0LmdldEZ1bGxDb250cmFjdFN0YXRlKGFkZHJlc3MudG9TdHJpbmcoKSkpO1xuICAgIH1cbiAgICBleHRyYWN0Q29udHJhY3REYXRhKGJvYykge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWtvdG9uLmV4dHJhY3RDb250cmFjdERhdGEoYm9jKTtcbiAgICB9XG4gICAgcGFja0ludG9DZWxsKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVrb3Rvbi5wYWNrSW50b0NlbGwoYXJncy5zdHJ1Y3R1cmUsIGFyZ3MuZGF0YSwgYXJncy5hYmlWZXJzaW9uKTtcbiAgICB9XG4gICAgdW5wYWNrRnJvbUNlbGwoYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWtvdG9uLnVucGFja0Zyb21DZWxsKGFyZ3Muc3RydWN0dXJlLCBhcmdzLmJvYywgYXJncy5hbGxvd1BhcnRpYWwsIGFyZ3MuYWJpVmVyc2lvbik7XG4gICAgfVxuICAgIGdldEJvY0hhc2goYm9jKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5la290b24uZ2V0Qm9jSGFzaChib2MpO1xuICAgIH1cbiAgICBleHRlbmRTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5la290b24uZXh0ZW5kU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGVuY29kZUludGVybmFsSW5wdXQoYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWtvdG9uLmVuY29kZUludGVybmFsSW5wdXQoYXJncy5hYmksIGFyZ3MubWV0aG9kLCBhcmdzLnBhcmFtcyk7XG4gICAgfVxuICAgIGVuY29kZUludGVybmFsTWVzc2FnZShhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5la290b24uZW5jb2RlSW50ZXJuYWxNZXNzYWdlKGFyZ3Muc3JjLCBhcmdzLmRzdCwgYXJncy5ib3VuY2UsIGFyZ3Muc3RhdGVJbml0LCBhcmdzLmJvZHksIGFyZ3MuYW1vdW50KTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRXh0ZXJuYWxNZXNzYWdlKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgdW5zaWduZWRNZXNzYWdlID0gdGhpcy5uZWtvdG9uLmNyZWF0ZUV4dGVybmFsTWVzc2FnZSh0aGlzLmNsb2NrLCBhcmdzLmFkZHJlc3MudG9TdHJpbmcoKSwgYXJncy5hYmksIGFyZ3MubWV0aG9kLCBhcmdzLnN0YXRlSW5pdCwgYXJncy5wYXJhbXMsIGFyZ3Muc2lnbmVyLnB1YmxpY0tleSwgYXJncy50aW1lb3V0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGFyZ3Muc2lnbmVyLnNpZ24odW5zaWduZWRNZXNzYWdlLmhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIHVuc2lnbmVkTWVzc2FnZS5zaWduKHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB1bnNpZ25lZE1lc3NhZ2UuZnJlZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVJhd0V4dGVybmFsTWVzc2FnZShhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5la290b24uY3JlYXRlUmF3RXh0ZXJuYWxNZXNzYWdlKGFyZ3MuYWRkcmVzcy50b1N0cmluZygpLCBhcmdzLnN0YXRlSW5pdCwgYXJncy5ib2R5LCBhcmdzLmV4cGlyZUF0KTtcbiAgICB9XG59XG5leHBvcnRzLkFjY291bnRzU3RvcmFnZUNvbnRleHQgPSBBY2NvdW50c1N0b3JhZ2VDb250ZXh0O1xuLyoqXG4gKiBAY2F0ZWdvcnkgQWNjb3VudHNTdG9yYWdlXG4gKi9cbmNsYXNzIFNpbXBsZUFjY291bnRzU3RvcmFnZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgc2ltcGxlIGFjY291bnRzIHN0b3JhZ2UuXG4gICAgICpcbiAgICAgKiBJZiBubyBgZGVmYXVsdEFjY291bnRgIHByb3ZpZGVkLCB1c2VzIGZpcnN0IHByb3ZpZGVkIGVudHJ5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MgPSB7fSkge1xuICAgICAgICB0aGlzLmFjY291bnRzID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoYXJncy5lbnRyaWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWNjb3VudCBvZiBhcmdzLmVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGVmYXVsdEFjY291bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWZhdWx0QWNjb3VudCA9IGFjY291bnQuYWRkcmVzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hY2NvdW50cy5zZXQoYWNjb3VudC5hZGRyZXNzLnRvU3RyaW5nKCksIGFjY291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmRlZmF1bHRBY2NvdW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBkZWZhdWx0QWNjb3VudDtcbiAgICAgICAgICAgIGlmIChhcmdzLmRlZmF1bHRBY2NvdW50IGluc3RhbmNlb2YgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWNjb3VudCA9IGFyZ3MuZGVmYXVsdEFjY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWNjb3VudCA9IG5ldyBldmVyc2NhbGVfaW5wYWdlX3Byb3ZpZGVyXzEuQWRkcmVzcyhhcmdzLmRlZmF1bHRBY2NvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5hY2NvdW50cy5oYXMoZGVmYXVsdEFjY291bnQudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIGRlZmF1bHQgYWNjb3VudCBub3QgZm91bmQgaW4gc3RvcmFnZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdEFjY291bnQgPSBkZWZhdWx0QWNjb3VudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZGVmYXVsdEFjY291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0QWNjb3VudDtcbiAgICB9XG4gICAgc2V0IGRlZmF1bHRBY2NvdW50KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKGFkZHJlc3MgIT0gbnVsbCAmJiAhdGhpcy5hY2NvdW50cy5oYXMoYWRkcmVzcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWNjb3VudCBub3QgZm91bmQgaW4gc3RvcmFnZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlZmF1bHRBY2NvdW50ID0gKHZhbHVlID09IG51bGwgfHwgdmFsdWUgaW5zdGFuY2VvZiBldmVyc2NhbGVfaW5wYWdlX3Byb3ZpZGVyXzEuQWRkcmVzcykgPyB2YWx1ZSA6IG5ldyBldmVyc2NhbGVfaW5wYWdlX3Byb3ZpZGVyXzEuQWRkcmVzcyh2YWx1ZSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEFjY291bnQoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NvdW50cy5nZXQoYWRkcmVzcy50b1N0cmluZygpKTtcbiAgICB9XG4gICAgYWRkQWNjb3VudChhY2NvdW50KSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhY2NvdW50LmFkZHJlc3M7XG4gICAgICAgIHRoaXMuYWNjb3VudHMuc2V0KGFkZHJlc3MudG9TdHJpbmcoKSwgYWNjb3VudCk7XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH1cbiAgICBoYXNBY2NvdW50KGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjb3VudHMuaGFzKGFkZHJlc3MudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHJlbW92ZUFjY291bnQoYWRkcmVzcykge1xuICAgICAgICB0aGlzLmFjY291bnRzLmRlbGV0ZShhZGRyZXNzLnRvU3RyaW5nKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2ltcGxlQWNjb3VudHNTdG9yYWdlID0gU2ltcGxlQWNjb3VudHNTdG9yYWdlO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/everscale-standalone-client/client/AccountsStorage/index.js\n");

/***/ }),

/***/ "./node_modules/everscale-standalone-client/client/ConnectionController/gql.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/everscale-standalone-client/client/ConnectionController/gql.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GqlSocket = void 0;\nconst core_1 = __importDefault(__webpack_require__(/*! ../../core */ \"./node_modules/everscale-standalone-client/core.js\"));\nconst { nekoton, fetch, fetchAgent, debugLog } = core_1.default;\nclass GqlSocket {\n    async connect(clock, params) {\n        class GqlSender {\n            constructor(params) {\n                this.nextLatencyDetectionTime = 0;\n                this.params = params;\n                this.latencyDetectionInterval = params.latencyDetectionInterval || 60000;\n                this.endpoints = params.endpoints.map(GqlSocket.expandAddress);\n                if (this.endpoints.length == 1) {\n                    this.currentEndpoint = this.endpoints[0];\n                    this.nextLatencyDetectionTime = Number.MAX_VALUE;\n                }\n            }\n            isLocal() {\n                return this.params.local;\n            }\n            send(data, handler, _longQuery) {\n                ;\n                (async () => {\n                    const now = Date.now();\n                    try {\n                        let endpoint;\n                        if (this.currentEndpoint != null && now < this.nextLatencyDetectionTime) {\n                            // Default route\n                            endpoint = this.currentEndpoint;\n                        }\n                        else if (this.resolutionPromise != null) {\n                            // Already resolving\n                            endpoint = await this.resolutionPromise;\n                            delete this.resolutionPromise;\n                        }\n                        else {\n                            delete this.currentEndpoint;\n                            // Start resolving (current endpoint is null, or it is time to refresh)\n                            this.resolutionPromise = this._selectQueryingEndpoint().then((endpoint) => {\n                                this.currentEndpoint = endpoint;\n                                this.nextLatencyDetectionTime = Date.now() + this.latencyDetectionInterval;\n                                return endpoint;\n                            });\n                            endpoint = await this.resolutionPromise;\n                            delete this.resolutionPromise;\n                        }\n                        const response = await fetch(endpoint.url, {\n                            method: 'post',\n                            headers: DEFAULT_HEADERS,\n                            body: data,\n                            agent: endpoint.agent,\n                        }).then((response) => response.text());\n                        handler.onReceive(response);\n                    }\n                    catch (e) {\n                        handler.onError(e);\n                    }\n                })();\n            }\n            async _selectQueryingEndpoint() {\n                const maxLatency = this.params.maxLatency || 60000;\n                const endpointCount = this.endpoints.length;\n                for (let retryCount = 0; retryCount < 5; ++retryCount) {\n                    let handlers;\n                    const promise = new Promise((resolve, reject) => {\n                        handlers = {\n                            resolve: (endpoint) => resolve(endpoint),\n                            reject: () => reject(undefined),\n                        };\n                    });\n                    let checkedEndpoints = 0;\n                    let lastLatency;\n                    for (const endpoint of this.endpoints) {\n                        GqlSocket.checkLatency(endpoint).then((latency) => {\n                            ++checkedEndpoints;\n                            if (latency !== undefined && latency <= maxLatency) {\n                                return handlers.resolve(endpoint);\n                            }\n                            if (lastLatency === undefined ||\n                                lastLatency.latency === undefined ||\n                                (latency !== undefined && latency < lastLatency.latency)) {\n                                lastLatency = { endpoint, latency };\n                            }\n                            if (checkedEndpoints >= endpointCount) {\n                                if ((lastLatency === null || lastLatency === void 0 ? void 0 : lastLatency.latency) !== undefined) {\n                                    handlers.resolve(lastLatency.endpoint);\n                                }\n                                else {\n                                    handlers.reject();\n                                }\n                            }\n                        });\n                    }\n                    try {\n                        return await promise;\n                    }\n                    catch (e) {\n                        let resolveDelay;\n                        const delayPromise = new Promise((resolve) => {\n                            resolveDelay = () => resolve();\n                        });\n                        setTimeout(() => resolveDelay(), Math.min(100 * retryCount, 5000));\n                        await delayPromise;\n                    }\n                }\n                throw new Error('Not available endpoint found');\n            }\n        }\n        return new nekoton.GqlConnection(clock, new GqlSender(params));\n    }\n    static async checkLatency(endpoint) {\n        const response = await fetch(`${endpoint.url}?query=%7Binfo%7Bversion%20time%20latency%7D%7D`, {\n            method: 'get',\n            agent: endpoint.agent,\n        })\n            .then((response) => response.json())\n            .catch((e) => {\n            debugLog(e);\n            return undefined;\n        });\n        if (typeof response !== 'object' || response == null) {\n            return;\n        }\n        const data = response['data'];\n        if (typeof data !== 'object' || data == null) {\n            return;\n        }\n        const info = data['info'];\n        if (typeof info !== 'object' || info == null) {\n            return;\n        }\n        const latency = info['latency'];\n        if (typeof latency !== 'number') {\n            return;\n        }\n        return latency;\n    }\n}\nexports.GqlSocket = GqlSocket;\nGqlSocket.expandAddress = (baseUrl) => {\n    const lastBackslashIndex = baseUrl.lastIndexOf('/');\n    baseUrl = lastBackslashIndex < 0 ? baseUrl : baseUrl.substring(0, lastBackslashIndex);\n    let url;\n    if (baseUrl.startsWith('http://') || baseUrl.startsWith('https://')) {\n        url = `${baseUrl}/graphql`;\n    }\n    else if (['localhost', '127.0.0.1'].indexOf(baseUrl) >= 0) {\n        url = `http://${baseUrl}/graphql`;\n    }\n    else {\n        url = `https://${baseUrl}/graphql`;\n    }\n    return {\n        url,\n        agent: fetchAgent(url),\n    };\n};\nconst DEFAULT_HEADERS = {\n    'Content-Type': 'application/json',\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9Db25uZWN0aW9uQ29udHJvbGxlci9ncWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9Db25uZWN0aW9uQ29udHJvbGxlci9ncWwuanM/MTYwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR3FsU29ja2V0ID0gdm9pZCAwO1xuY29uc3QgY29yZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9jb3JlXCIpKTtcbmNvbnN0IHsgbmVrb3RvbiwgZmV0Y2gsIGZldGNoQWdlbnQsIGRlYnVnTG9nIH0gPSBjb3JlXzEuZGVmYXVsdDtcbmNsYXNzIEdxbFNvY2tldCB7XG4gICAgYXN5bmMgY29ubmVjdChjbG9jaywgcGFyYW1zKSB7XG4gICAgICAgIGNsYXNzIEdxbFNlbmRlciB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMYXRlbmN5RGV0ZWN0aW9uVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlbmN5RGV0ZWN0aW9uSW50ZXJ2YWwgPSBwYXJhbXMubGF0ZW5jeURldGVjdGlvbkludGVydmFsIHx8IDYwMDAwO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kcG9pbnRzID0gcGFyYW1zLmVuZHBvaW50cy5tYXAoR3FsU29ja2V0LmV4cGFuZEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuZHBvaW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRFbmRwb2ludCA9IHRoaXMuZW5kcG9pbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRMYXRlbmN5RGV0ZWN0aW9uVGltZSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNMb2NhbCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMubG9jYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZW5kKGRhdGEsIGhhbmRsZXIsIF9sb25nUXVlcnkpIHtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRFbmRwb2ludCAhPSBudWxsICYmIG5vdyA8IHRoaXMubmV4dExhdGVuY3lEZXRlY3Rpb25UaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCByb3V0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50ID0gdGhpcy5jdXJyZW50RW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnJlc29sdXRpb25Qcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IHJlc29sdmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50ID0gYXdhaXQgdGhpcy5yZXNvbHV0aW9uUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZXNvbHV0aW9uUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRFbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCByZXNvbHZpbmcgKGN1cnJlbnQgZW5kcG9pbnQgaXMgbnVsbCwgb3IgaXQgaXMgdGltZSB0byByZWZyZXNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x1dGlvblByb21pc2UgPSB0aGlzLl9zZWxlY3RRdWVyeWluZ0VuZHBvaW50KCkudGhlbigoZW5kcG9pbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RW5kcG9pbnQgPSBlbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0TGF0ZW5jeURldGVjdGlvblRpbWUgPSBEYXRlLm5vdygpICsgdGhpcy5sYXRlbmN5RGV0ZWN0aW9uSW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludCA9IGF3YWl0IHRoaXMucmVzb2x1dGlvblByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVzb2x1dGlvblByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGVuZHBvaW50LnVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3Bvc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IERFRkFVTFRfSEVBREVSUyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50OiBlbmRwb2ludC5hZ2VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS50ZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5vblJlY2VpdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXN5bmMgX3NlbGVjdFF1ZXJ5aW5nRW5kcG9pbnQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4TGF0ZW5jeSA9IHRoaXMucGFyYW1zLm1heExhdGVuY3kgfHwgNjAwMDA7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kcG9pbnRDb3VudCA9IHRoaXMuZW5kcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByZXRyeUNvdW50ID0gMDsgcmV0cnlDb3VudCA8IDU7ICsrcmV0cnlDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGFuZGxlcnM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiAoZW5kcG9pbnQpID0+IHJlc29sdmUoZW5kcG9pbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdDogKCkgPT4gcmVqZWN0KHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoZWNrZWRFbmRwb2ludHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdExhdGVuY3k7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW5kcG9pbnQgb2YgdGhpcy5lbmRwb2ludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEdxbFNvY2tldC5jaGVja0xhdGVuY3koZW5kcG9pbnQpLnRoZW4oKGxhdGVuY3kpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2NoZWNrZWRFbmRwb2ludHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhdGVuY3kgIT09IHVuZGVmaW5lZCAmJiBsYXRlbmN5IDw9IG1heExhdGVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJzLnJlc29sdmUoZW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdExhdGVuY3kgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TGF0ZW5jeS5sYXRlbmN5ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxhdGVuY3kgIT09IHVuZGVmaW5lZCAmJiBsYXRlbmN5IDwgbGFzdExhdGVuY3kubGF0ZW5jeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdExhdGVuY3kgPSB7IGVuZHBvaW50LCBsYXRlbmN5IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGVja2VkRW5kcG9pbnRzID49IGVuZHBvaW50Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChsYXN0TGF0ZW5jeSA9PT0gbnVsbCB8fCBsYXN0TGF0ZW5jeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdExhdGVuY3kubGF0ZW5jeSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMucmVzb2x2ZShsYXN0TGF0ZW5jeS5lbmRwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc29sdmVEZWxheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZURlbGF5ID0gKCkgPT4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmVEZWxheSgpLCBNYXRoLm1pbigxMDAgKiByZXRyeUNvdW50LCA1MDAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBkZWxheVByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXZhaWxhYmxlIGVuZHBvaW50IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBuZWtvdG9uLkdxbENvbm5lY3Rpb24oY2xvY2ssIG5ldyBHcWxTZW5kZXIocGFyYW1zKSk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjaGVja0xhdGVuY3koZW5kcG9pbnQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtlbmRwb2ludC51cmx9P3F1ZXJ5PSU3QmluZm8lN0J2ZXJzaW9uJTIwdGltZSUyMGxhdGVuY3klN0QlN0RgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdnZXQnLFxuICAgICAgICAgICAgYWdlbnQ6IGVuZHBvaW50LmFnZW50LFxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGRlYnVnTG9nKGUpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UgIT09ICdvYmplY3QnIHx8IHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyB8fCBkYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmZvID0gZGF0YVsnaW5mbyddO1xuICAgICAgICBpZiAodHlwZW9mIGluZm8gIT09ICdvYmplY3QnIHx8IGluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhdGVuY3kgPSBpbmZvWydsYXRlbmN5J107XG4gICAgICAgIGlmICh0eXBlb2YgbGF0ZW5jeSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF0ZW5jeTtcbiAgICB9XG59XG5leHBvcnRzLkdxbFNvY2tldCA9IEdxbFNvY2tldDtcbkdxbFNvY2tldC5leHBhbmRBZGRyZXNzID0gKGJhc2VVcmwpID0+IHtcbiAgICBjb25zdCBsYXN0QmFja3NsYXNoSW5kZXggPSBiYXNlVXJsLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgYmFzZVVybCA9IGxhc3RCYWNrc2xhc2hJbmRleCA8IDAgPyBiYXNlVXJsIDogYmFzZVVybC5zdWJzdHJpbmcoMCwgbGFzdEJhY2tzbGFzaEluZGV4KTtcbiAgICBsZXQgdXJsO1xuICAgIGlmIChiYXNlVXJsLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSB8fCBiYXNlVXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIHtcbiAgICAgICAgdXJsID0gYCR7YmFzZVVybH0vZ3JhcGhxbGA7XG4gICAgfVxuICAgIGVsc2UgaWYgKFsnbG9jYWxob3N0JywgJzEyNy4wLjAuMSddLmluZGV4T2YoYmFzZVVybCkgPj0gMCkge1xuICAgICAgICB1cmwgPSBgaHR0cDovLyR7YmFzZVVybH0vZ3JhcGhxbGA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1cmwgPSBgaHR0cHM6Ly8ke2Jhc2VVcmx9L2dyYXBocWxgO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB1cmwsXG4gICAgICAgIGFnZW50OiBmZXRjaEFnZW50KHVybCksXG4gICAgfTtcbn07XG5jb25zdCBERUZBVUxUX0hFQURFUlMgPSB7XG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/everscale-standalone-client/client/ConnectionController/gql.js\n");

/***/ }),

/***/ "./node_modules/everscale-standalone-client/client/ConnectionController/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/everscale-standalone-client/client/ConnectionController/index.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectionController = exports.createConnectionController = exports.ConnectionError = exports.checkConnection = exports.NETWORK_PRESETS = exports.DEFAULT_NETWORK_GROUP = void 0;\nconst await_semaphore_1 = __webpack_require__(/*! @broxus/await-semaphore */ \"./node_modules/@broxus/await-semaphore/dist/index.js\");\nconst core_1 = __importDefault(__webpack_require__(/*! ../../core */ \"./node_modules/everscale-standalone-client/core.js\"));\nconst gql_1 = __webpack_require__(/*! ./gql */ \"./node_modules/everscale-standalone-client/client/ConnectionController/gql.js\");\nconst jrpc_1 = __webpack_require__(/*! ./jrpc */ \"./node_modules/everscale-standalone-client/client/ConnectionController/jrpc.js\");\nconst { nekoton, debugLog } = core_1.default;\nexports.DEFAULT_NETWORK_GROUP = 'mainnet';\n/**\n * @category Client\n */\nexports.NETWORK_PRESETS = {\n    mainnet: {\n        id: 1,\n        group: 'mainnet',\n        type: 'graphql',\n        data: {\n            endpoints: [\n                'eri01.main.everos.dev',\n                'gra01.main.everos.dev',\n                'gra02.main.everos.dev',\n                'lim01.main.everos.dev',\n                'rbx01.main.everos.dev',\n            ],\n            local: false,\n        },\n    },\n    mainnetJrpc: {\n        id: 1,\n        group: 'mainnet',\n        type: 'jrpc',\n        data: {\n            endpoint: 'https://jrpc.everwallet.net/rpc',\n        },\n    },\n    testnet: {\n        id: 2,\n        group: 'testnet',\n        type: 'graphql',\n        data: {\n            endpoints: ['eri01.net.everos.dev', 'rbx01.net.everos.dev', 'gra01.net.everos.dev'],\n            local: false,\n        },\n    },\n    fld: {\n        id: 10,\n        group: 'fld',\n        type: 'graphql',\n        data: {\n            endpoints: ['gql.custler.net'],\n            local: false,\n        },\n    },\n    local: {\n        id: 31337,\n        group: 'localnet',\n        type: 'graphql',\n        data: {\n            endpoints: ['127.0.0.1'],\n            local: true,\n        },\n    },\n};\nfunction loadPreset(params) {\n    if (typeof params === 'string') {\n        const targetPreset = exports.NETWORK_PRESETS[params];\n        if (targetPreset == null) {\n            throw new Error(`Target preset id not found: ${params}`);\n        }\n        return targetPreset;\n    }\n    else {\n        return params;\n    }\n}\n/**\n * Tries to connect with the specified params. Throws an exception in case of error\n *\n * @category Client\n * @throws ConnectionError\n */\nasync function checkConnection(params) {\n    const preset = loadPreset(params);\n    const clock = new nekoton.ClockWithOffset();\n    try {\n        const controller = new ConnectionController(clock);\n        await controller['_connect'](preset);\n        if (controller['_initializedTransport'] != null) {\n            cleanupInitializedTransport(controller['_initializedTransport']);\n        }\n    }\n    catch (e) {\n        throw new ConnectionError(preset, e.toString());\n    }\n    finally {\n        clock.free();\n    }\n}\nexports.checkConnection = checkConnection;\n/**\n * @category Client\n */\nclass ConnectionError extends Error {\n    constructor(params, message) {\n        super(message);\n        this.params = params;\n    }\n}\nexports.ConnectionError = ConnectionError;\nasync function createConnectionController(clock, params, retry = false) {\n    const preset = loadPreset(params);\n    // Try connect\n    while (true) {\n        try {\n            const controller = new ConnectionController(clock);\n            await controller.startSwitchingNetwork(preset).then((handle) => handle.switch());\n            debugLog(`Successfully connected to ${preset.group}`);\n            return controller;\n        }\n        catch (e) {\n            if (retry) {\n                console.error('Connection failed:', e);\n                await new Promise((resolve) => {\n                    setTimeout(() => resolve(), 5000);\n                });\n                debugLog('Restarting connection process');\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n}\nexports.createConnectionController = createConnectionController;\nclass ConnectionController {\n    constructor(clock) {\n        this._networkMutex = new await_semaphore_1.Mutex();\n        this._acquiredTransportCounter = 0;\n        this._clock = clock;\n    }\n    async acquire() {\n        requireInitializedTransport(this._initializedTransport);\n        await this._acquireTransport();\n        return {\n            transport: this._initializedTransport,\n            release: () => this._releaseTransport(),\n        };\n    }\n    async use(f) {\n        requireInitializedTransport(this._initializedTransport);\n        await this._acquireTransport();\n        return f(this._initializedTransport)\n            .finally(() => {\n            this._releaseTransport();\n        });\n    }\n    async startSwitchingNetwork(params) {\n        var _a;\n        class NetworkSwitchHandle {\n            constructor(controller, release, params) {\n                this._controller = controller;\n                this._release = release;\n                this._params = params;\n            }\n            async switch() {\n                await this._controller\n                    ._connect(this._params)\n                    .finally(() => this._release());\n            }\n        }\n        (_a = this._cancelTestTransport) === null || _a === void 0 ? void 0 : _a.call(this);\n        const release = await this._networkMutex.acquire();\n        return new NetworkSwitchHandle(this, release, params);\n    }\n    get initializedTransport() {\n        return this._initializedTransport;\n    }\n    async _connect(params) {\n        if (this._initializedTransport != null) {\n            cleanupInitializedTransport(this._initializedTransport);\n        }\n        this._initializedTransport = undefined;\n        let TestConnectionResult;\n        (function (TestConnectionResult) {\n            TestConnectionResult[TestConnectionResult[\"DONE\"] = 0] = \"DONE\";\n            TestConnectionResult[TestConnectionResult[\"CANCELLED\"] = 1] = \"CANCELLED\";\n        })(TestConnectionResult || (TestConnectionResult = {}));\n        const testTransport = async ({ data: { transport } }, local) => {\n            return new Promise((resolve, reject) => {\n                this._cancelTestTransport = () => resolve(TestConnectionResult.CANCELLED);\n                if (local) {\n                    transport\n                        .getAccountsByCodeHash('4e92716de61d456e58f16e4e867e3e93a7548321eace86301b51c8b80ca6239b', 1)\n                        .then(() => resolve(TestConnectionResult.DONE))\n                        .catch((e) => reject(e));\n                }\n                else {\n                    // Try to get any account state\n                    transport\n                        .getFullContractState('-1:0000000000000000000000000000000000000000000000000000000000000000')\n                        .then(() => resolve(TestConnectionResult.DONE))\n                        .catch((e) => reject(e));\n                }\n                setTimeout(() => reject(new Error('Connection timeout')), 10000);\n            }).finally(() => this._cancelTestTransport = undefined);\n        };\n        try {\n            const { local, transportData } = await (params.type === 'graphql'\n                ? async () => {\n                    const socket = new gql_1.GqlSocket();\n                    const connection = await socket.connect(this._clock, params.data);\n                    const transport = nekoton.Transport.fromGqlConnection(connection);\n                    const transportData = {\n                        id: params.id,\n                        group: params.group,\n                        type: 'graphql',\n                        data: {\n                            socket,\n                            connection,\n                            transport,\n                        },\n                    };\n                    return {\n                        local: params.data.local,\n                        transportData,\n                    };\n                }\n                : async () => {\n                    const socket = new jrpc_1.JrpcSocket();\n                    const connection = await socket.connect(this._clock, params.data);\n                    const transport = nekoton.Transport.fromJrpcConnection(connection);\n                    const transportData = {\n                        id: params.id,\n                        group: params.group,\n                        type: 'jrpc',\n                        data: {\n                            socket,\n                            connection,\n                            transport,\n                        },\n                    };\n                    return {\n                        local: false,\n                        transportData,\n                    };\n                })();\n            try {\n                if (await testTransport(transportData, local) == TestConnectionResult.CANCELLED) {\n                    cleanupInitializedTransport(transportData);\n                    return;\n                }\n            }\n            catch (e) {\n                // Free transport data in case of error\n                cleanupInitializedTransport(transportData);\n                throw e;\n            }\n            this._initializedTransport = transportData;\n        }\n        catch (e) {\n            throw new Error(`Failed to create connection: ${e.toString()}`);\n        }\n    }\n    async _acquireTransport() {\n        debugLog('_acquireTransport');\n        if (this._acquiredTransportCounter > 0) {\n            debugLog('_acquireTransport -> increase');\n            this._acquiredTransportCounter += 1;\n        }\n        else {\n            this._acquiredTransportCounter = 1;\n            if (this._release != null) {\n                console.warn('mutex is already acquired');\n            }\n            else {\n                debugLog('_acquireTransport -> await');\n                this._release = await this._networkMutex.acquire();\n                debugLog('_acquireTransport -> create');\n            }\n        }\n    }\n    _releaseTransport() {\n        var _a;\n        debugLog('_releaseTransport');\n        this._acquiredTransportCounter -= 1;\n        if (this._acquiredTransportCounter <= 0) {\n            debugLog('_releaseTransport -> release');\n            (_a = this._release) === null || _a === void 0 ? void 0 : _a.call(this);\n            this._release = undefined;\n        }\n    }\n}\nexports.ConnectionController = ConnectionController;\nfunction cleanupInitializedTransport(transport) {\n    transport.data.transport.free();\n    transport.data.connection.free();\n}\nfunction requireInitializedTransport(transport) {\n    if (transport == null) {\n        throw new Error('Connection is not initialized');\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9Db25uZWN0aW9uQ29udHJvbGxlci9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9ldmVyc2NhbGUtc3RhbmRhbG9uZS1jbGllbnQvY2xpZW50L0Nvbm5lY3Rpb25Db250cm9sbGVyL2luZGV4LmpzP2IyMTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbm5lY3Rpb25Db250cm9sbGVyID0gZXhwb3J0cy5jcmVhdGVDb25uZWN0aW9uQ29udHJvbGxlciA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5jaGVja0Nvbm5lY3Rpb24gPSBleHBvcnRzLk5FVFdPUktfUFJFU0VUUyA9IGV4cG9ydHMuREVGQVVMVF9ORVRXT1JLX0dST1VQID0gdm9pZCAwO1xuY29uc3QgYXdhaXRfc2VtYXBob3JlXzEgPSByZXF1aXJlKFwiQGJyb3h1cy9hd2FpdC1zZW1hcGhvcmVcIik7XG5jb25zdCBjb3JlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2NvcmVcIikpO1xuY29uc3QgZ3FsXzEgPSByZXF1aXJlKFwiLi9ncWxcIik7XG5jb25zdCBqcnBjXzEgPSByZXF1aXJlKFwiLi9qcnBjXCIpO1xuY29uc3QgeyBuZWtvdG9uLCBkZWJ1Z0xvZyB9ID0gY29yZV8xLmRlZmF1bHQ7XG5leHBvcnRzLkRFRkFVTFRfTkVUV09SS19HUk9VUCA9ICdtYWlubmV0Jztcbi8qKlxuICogQGNhdGVnb3J5IENsaWVudFxuICovXG5leHBvcnRzLk5FVFdPUktfUFJFU0VUUyA9IHtcbiAgICBtYWlubmV0OiB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBncm91cDogJ21haW5uZXQnLFxuICAgICAgICB0eXBlOiAnZ3JhcGhxbCcsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGVuZHBvaW50czogW1xuICAgICAgICAgICAgICAgICdlcmkwMS5tYWluLmV2ZXJvcy5kZXYnLFxuICAgICAgICAgICAgICAgICdncmEwMS5tYWluLmV2ZXJvcy5kZXYnLFxuICAgICAgICAgICAgICAgICdncmEwMi5tYWluLmV2ZXJvcy5kZXYnLFxuICAgICAgICAgICAgICAgICdsaW0wMS5tYWluLmV2ZXJvcy5kZXYnLFxuICAgICAgICAgICAgICAgICdyYngwMS5tYWluLmV2ZXJvcy5kZXYnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGxvY2FsOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIG1haW5uZXRKcnBjOiB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBncm91cDogJ21haW5uZXQnLFxuICAgICAgICB0eXBlOiAnanJwYycsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGVuZHBvaW50OiAnaHR0cHM6Ly9qcnBjLmV2ZXJ3YWxsZXQubmV0L3JwYycsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB0ZXN0bmV0OiB7XG4gICAgICAgIGlkOiAyLFxuICAgICAgICBncm91cDogJ3Rlc3RuZXQnLFxuICAgICAgICB0eXBlOiAnZ3JhcGhxbCcsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGVuZHBvaW50czogWydlcmkwMS5uZXQuZXZlcm9zLmRldicsICdyYngwMS5uZXQuZXZlcm9zLmRldicsICdncmEwMS5uZXQuZXZlcm9zLmRldiddLFxuICAgICAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgZmxkOiB7XG4gICAgICAgIGlkOiAxMCxcbiAgICAgICAgZ3JvdXA6ICdmbGQnLFxuICAgICAgICB0eXBlOiAnZ3JhcGhxbCcsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGVuZHBvaW50czogWydncWwuY3VzdGxlci5uZXQnXSxcbiAgICAgICAgICAgIGxvY2FsOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIGxvY2FsOiB7XG4gICAgICAgIGlkOiAzMTMzNyxcbiAgICAgICAgZ3JvdXA6ICdsb2NhbG5ldCcsXG4gICAgICAgIHR5cGU6ICdncmFwaHFsJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZW5kcG9pbnRzOiBbJzEyNy4wLjAuMSddLFxuICAgICAgICAgICAgbG9jYWw6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5mdW5jdGlvbiBsb2FkUHJlc2V0KHBhcmFtcykge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCB0YXJnZXRQcmVzZXQgPSBleHBvcnRzLk5FVFdPUktfUFJFU0VUU1twYXJhbXNdO1xuICAgICAgICBpZiAodGFyZ2V0UHJlc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGFyZ2V0IHByZXNldCBpZCBub3QgZm91bmQ6ICR7cGFyYW1zfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRQcmVzZXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbn1cbi8qKlxuICogVHJpZXMgdG8gY29ubmVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgYW4gZXhjZXB0aW9uIGluIGNhc2Ugb2YgZXJyb3JcbiAqXG4gKiBAY2F0ZWdvcnkgQ2xpZW50XG4gKiBAdGhyb3dzIENvbm5lY3Rpb25FcnJvclxuICovXG5hc3luYyBmdW5jdGlvbiBjaGVja0Nvbm5lY3Rpb24ocGFyYW1zKSB7XG4gICAgY29uc3QgcHJlc2V0ID0gbG9hZFByZXNldChwYXJhbXMpO1xuICAgIGNvbnN0IGNsb2NrID0gbmV3IG5la290b24uQ2xvY2tXaXRoT2Zmc2V0KCk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBDb25uZWN0aW9uQ29udHJvbGxlcihjbG9jayk7XG4gICAgICAgIGF3YWl0IGNvbnRyb2xsZXJbJ19jb25uZWN0J10ocHJlc2V0KTtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXJbJ19pbml0aWFsaXplZFRyYW5zcG9ydCddICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFudXBJbml0aWFsaXplZFRyYW5zcG9ydChjb250cm9sbGVyWydfaW5pdGlhbGl6ZWRUcmFuc3BvcnQnXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihwcmVzZXQsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBjbG9jay5mcmVlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja0Nvbm5lY3Rpb24gPSBjaGVja0Nvbm5lY3Rpb247XG4vKipcbiAqIEBjYXRlZ29yeSBDbGllbnRcbiAqL1xuY2xhc3MgQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcywgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfVxufVxuZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBDb25uZWN0aW9uRXJyb3I7XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uQ29udHJvbGxlcihjbG9jaywgcGFyYW1zLCByZXRyeSA9IGZhbHNlKSB7XG4gICAgY29uc3QgcHJlc2V0ID0gbG9hZFByZXNldChwYXJhbXMpO1xuICAgIC8vIFRyeSBjb25uZWN0XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQ29ubmVjdGlvbkNvbnRyb2xsZXIoY2xvY2spO1xuICAgICAgICAgICAgYXdhaXQgY29udHJvbGxlci5zdGFydFN3aXRjaGluZ05ldHdvcmsocHJlc2V0KS50aGVuKChoYW5kbGUpID0+IGhhbmRsZS5zd2l0Y2goKSk7XG4gICAgICAgICAgICBkZWJ1Z0xvZyhgU3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZCB0byAke3ByZXNldC5ncm91cH1gKTtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAocmV0cnkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDb25uZWN0aW9uIGZhaWxlZDonLCBlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoKSwgNTAwMCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGVidWdMb2coJ1Jlc3RhcnRpbmcgY29ubmVjdGlvbiBwcm9jZXNzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVDb25uZWN0aW9uQ29udHJvbGxlciA9IGNyZWF0ZUNvbm5lY3Rpb25Db250cm9sbGVyO1xuY2xhc3MgQ29ubmVjdGlvbkNvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKGNsb2NrKSB7XG4gICAgICAgIHRoaXMuX25ldHdvcmtNdXRleCA9IG5ldyBhd2FpdF9zZW1hcGhvcmVfMS5NdXRleCgpO1xuICAgICAgICB0aGlzLl9hY3F1aXJlZFRyYW5zcG9ydENvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLl9jbG9jayA9IGNsb2NrO1xuICAgIH1cbiAgICBhc3luYyBhY3F1aXJlKCkge1xuICAgICAgICByZXF1aXJlSW5pdGlhbGl6ZWRUcmFuc3BvcnQodGhpcy5faW5pdGlhbGl6ZWRUcmFuc3BvcnQpO1xuICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlVHJhbnNwb3J0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFuc3BvcnQ6IHRoaXMuX2luaXRpYWxpemVkVHJhbnNwb3J0LFxuICAgICAgICAgICAgcmVsZWFzZTogKCkgPT4gdGhpcy5fcmVsZWFzZVRyYW5zcG9ydCgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyB1c2UoZikge1xuICAgICAgICByZXF1aXJlSW5pdGlhbGl6ZWRUcmFuc3BvcnQodGhpcy5faW5pdGlhbGl6ZWRUcmFuc3BvcnQpO1xuICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlVHJhbnNwb3J0KCk7XG4gICAgICAgIHJldHVybiBmKHRoaXMuX2luaXRpYWxpemVkVHJhbnNwb3J0KVxuICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVsZWFzZVRyYW5zcG9ydCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc3RhcnRTd2l0Y2hpbmdOZXR3b3JrKHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNsYXNzIE5ldHdvcmtTd2l0Y2hIYW5kbGUge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoY29udHJvbGxlciwgcmVsZWFzZSwgcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVsZWFzZSA9IHJlbGVhc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXN5bmMgc3dpdGNoKCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgLl9jb25uZWN0KHRoaXMuX3BhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4gdGhpcy5fcmVsZWFzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLl9jYW5jZWxUZXN0VHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICAgICAgY29uc3QgcmVsZWFzZSA9IGF3YWl0IHRoaXMuX25ldHdvcmtNdXRleC5hY3F1aXJlKCk7XG4gICAgICAgIHJldHVybiBuZXcgTmV0d29ya1N3aXRjaEhhbmRsZSh0aGlzLCByZWxlYXNlLCBwYXJhbXMpO1xuICAgIH1cbiAgICBnZXQgaW5pdGlhbGl6ZWRUcmFuc3BvcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbml0aWFsaXplZFRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgX2Nvbm5lY3QocGFyYW1zKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZFRyYW5zcG9ydCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhbnVwSW5pdGlhbGl6ZWRUcmFuc3BvcnQodGhpcy5faW5pdGlhbGl6ZWRUcmFuc3BvcnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkVHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgVGVzdENvbm5lY3Rpb25SZXN1bHQ7XG4gICAgICAgIChmdW5jdGlvbiAoVGVzdENvbm5lY3Rpb25SZXN1bHQpIHtcbiAgICAgICAgICAgIFRlc3RDb25uZWN0aW9uUmVzdWx0W1Rlc3RDb25uZWN0aW9uUmVzdWx0W1wiRE9ORVwiXSA9IDBdID0gXCJET05FXCI7XG4gICAgICAgICAgICBUZXN0Q29ubmVjdGlvblJlc3VsdFtUZXN0Q29ubmVjdGlvblJlc3VsdFtcIkNBTkNFTExFRFwiXSA9IDFdID0gXCJDQU5DRUxMRURcIjtcbiAgICAgICAgfSkoVGVzdENvbm5lY3Rpb25SZXN1bHQgfHwgKFRlc3RDb25uZWN0aW9uUmVzdWx0ID0ge30pKTtcbiAgICAgICAgY29uc3QgdGVzdFRyYW5zcG9ydCA9IGFzeW5jICh7IGRhdGE6IHsgdHJhbnNwb3J0IH0gfSwgbG9jYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsVGVzdFRyYW5zcG9ydCA9ICgpID0+IHJlc29sdmUoVGVzdENvbm5lY3Rpb25SZXN1bHQuQ0FOQ0VMTEVEKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0QWNjb3VudHNCeUNvZGVIYXNoKCc0ZTkyNzE2ZGU2MWQ0NTZlNThmMTZlNGU4NjdlM2U5M2E3NTQ4MzIxZWFjZTg2MzAxYjUxYzhiODBjYTYyMzliJywgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHJlc29sdmUoVGVzdENvbm5lY3Rpb25SZXN1bHQuRE9ORSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHJlamVjdChlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZ2V0IGFueSBhY2NvdW50IHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldEZ1bGxDb250cmFjdFN0YXRlKCctMTowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHJlc29sdmUoVGVzdENvbm5lY3Rpb25SZXN1bHQuRE9ORSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHJlamVjdChlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignQ29ubmVjdGlvbiB0aW1lb3V0JykpLCAxMDAwMCk7XG4gICAgICAgICAgICB9KS5maW5hbGx5KCgpID0+IHRoaXMuX2NhbmNlbFRlc3RUcmFuc3BvcnQgPSB1bmRlZmluZWQpO1xuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBsb2NhbCwgdHJhbnNwb3J0RGF0YSB9ID0gYXdhaXQgKHBhcmFtcy50eXBlID09PSAnZ3JhcGhxbCdcbiAgICAgICAgICAgICAgICA/IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gbmV3IGdxbF8xLkdxbFNvY2tldCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgc29ja2V0LmNvbm5lY3QodGhpcy5fY2xvY2ssIHBhcmFtcy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmVrb3Rvbi5UcmFuc3BvcnQuZnJvbUdxbENvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zcG9ydERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcGFyYW1zLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IHBhcmFtcy5ncm91cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdncmFwaHFsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWw6IHBhcmFtcy5kYXRhLmxvY2FsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvY2tldCA9IG5ldyBqcnBjXzEuSnJwY1NvY2tldCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgc29ja2V0LmNvbm5lY3QodGhpcy5fY2xvY2ssIHBhcmFtcy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmVrb3Rvbi5UcmFuc3BvcnQuZnJvbUpycGNDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc3BvcnREYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiBwYXJhbXMuZ3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnanJwYycsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydERhdGEsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGF3YWl0IHRlc3RUcmFuc3BvcnQodHJhbnNwb3J0RGF0YSwgbG9jYWwpID09IFRlc3RDb25uZWN0aW9uUmVzdWx0LkNBTkNFTExFRCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwSW5pdGlhbGl6ZWRUcmFuc3BvcnQodHJhbnNwb3J0RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIEZyZWUgdHJhbnNwb3J0IGRhdGEgaW4gY2FzZSBvZiBlcnJvclxuICAgICAgICAgICAgICAgIGNsZWFudXBJbml0aWFsaXplZFRyYW5zcG9ydCh0cmFuc3BvcnREYXRhKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWRUcmFuc3BvcnQgPSB0cmFuc3BvcnREYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgY29ubmVjdGlvbjogJHtlLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2FjcXVpcmVUcmFuc3BvcnQoKSB7XG4gICAgICAgIGRlYnVnTG9nKCdfYWNxdWlyZVRyYW5zcG9ydCcpO1xuICAgICAgICBpZiAodGhpcy5fYWNxdWlyZWRUcmFuc3BvcnRDb3VudGVyID4gMCkge1xuICAgICAgICAgICAgZGVidWdMb2coJ19hY3F1aXJlVHJhbnNwb3J0IC0+IGluY3JlYXNlJyk7XG4gICAgICAgICAgICB0aGlzLl9hY3F1aXJlZFRyYW5zcG9ydENvdW50ZXIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FjcXVpcmVkVHJhbnNwb3J0Q291bnRlciA9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVsZWFzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdtdXRleCBpcyBhbHJlYWR5IGFjcXVpcmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z0xvZygnX2FjcXVpcmVUcmFuc3BvcnQgLT4gYXdhaXQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWxlYXNlID0gYXdhaXQgdGhpcy5fbmV0d29ya011dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgICAgICBkZWJ1Z0xvZygnX2FjcXVpcmVUcmFuc3BvcnQgLT4gY3JlYXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3JlbGVhc2VUcmFuc3BvcnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZGVidWdMb2coJ19yZWxlYXNlVHJhbnNwb3J0Jyk7XG4gICAgICAgIHRoaXMuX2FjcXVpcmVkVHJhbnNwb3J0Q291bnRlciAtPSAxO1xuICAgICAgICBpZiAodGhpcy5fYWNxdWlyZWRUcmFuc3BvcnRDb3VudGVyIDw9IDApIHtcbiAgICAgICAgICAgIGRlYnVnTG9nKCdfcmVsZWFzZVRyYW5zcG9ydCAtPiByZWxlYXNlJyk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLl9yZWxlYXNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbGVhc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNvbm5lY3Rpb25Db250cm9sbGVyID0gQ29ubmVjdGlvbkNvbnRyb2xsZXI7XG5mdW5jdGlvbiBjbGVhbnVwSW5pdGlhbGl6ZWRUcmFuc3BvcnQodHJhbnNwb3J0KSB7XG4gICAgdHJhbnNwb3J0LmRhdGEudHJhbnNwb3J0LmZyZWUoKTtcbiAgICB0cmFuc3BvcnQuZGF0YS5jb25uZWN0aW9uLmZyZWUoKTtcbn1cbmZ1bmN0aW9uIHJlcXVpcmVJbml0aWFsaXplZFRyYW5zcG9ydCh0cmFuc3BvcnQpIHtcbiAgICBpZiAodHJhbnNwb3J0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25uZWN0aW9uIGlzIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/everscale-standalone-client/client/ConnectionController/index.js\n");

/***/ }),

/***/ "./node_modules/everscale-standalone-client/client/ConnectionController/jrpc.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/everscale-standalone-client/client/ConnectionController/jrpc.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JrpcSocket = void 0;\nconst core_1 = __importDefault(__webpack_require__(/*! ../../core */ \"./node_modules/everscale-standalone-client/core.js\"));\nconst { nekoton, fetch, fetchAgent } = core_1.default;\nclass JrpcSocket {\n    async connect(clock, params) {\n        class JrpcSender {\n            constructor(params) {\n                this.endpoint = params.endpoint;\n                this.endpointAgent = fetchAgent(this.endpoint);\n                this.alternativeEndpoint = params.alternativeEndpoint != null\n                    ? params.alternativeEndpoint\n                    : params.endpoint;\n                this.alternativeEndpointAgent = fetchAgent(this.alternativeEndpoint);\n            }\n            send(data, handler, requiresDb) {\n                ;\n                (async () => {\n                    try {\n                        const url = requiresDb ? this.endpoint : this.alternativeEndpoint;\n                        const agent = requiresDb ? this.endpointAgent : this.alternativeEndpointAgent;\n                        const response = await fetch(url, {\n                            method: 'post',\n                            headers: DEFAULT_HEADERS,\n                            body: data,\n                            agent,\n                        }).then((response) => response.text());\n                        handler.onReceive(response);\n                    }\n                    catch (e) {\n                        handler.onError(e);\n                    }\n                })();\n            }\n        }\n        return new nekoton.JrpcConnection(clock, new JrpcSender(params));\n    }\n}\nexports.JrpcSocket = JrpcSocket;\nconst DEFAULT_HEADERS = {\n    'Content-Type': 'application/json',\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9Db25uZWN0aW9uQ29udHJvbGxlci9qcnBjLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvQ29ubmVjdGlvbkNvbnRyb2xsZXIvanJwYy5qcz9iNDY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5KcnBjU29ja2V0ID0gdm9pZCAwO1xuY29uc3QgY29yZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9jb3JlXCIpKTtcbmNvbnN0IHsgbmVrb3RvbiwgZmV0Y2gsIGZldGNoQWdlbnQgfSA9IGNvcmVfMS5kZWZhdWx0O1xuY2xhc3MgSnJwY1NvY2tldCB7XG4gICAgYXN5bmMgY29ubmVjdChjbG9jaywgcGFyYW1zKSB7XG4gICAgICAgIGNsYXNzIEpycGNTZW5kZXIge1xuICAgICAgICAgICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRwb2ludCA9IHBhcmFtcy5lbmRwb2ludDtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50QWdlbnQgPSBmZXRjaEFnZW50KHRoaXMuZW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRpdmVFbmRwb2ludCA9IHBhcmFtcy5hbHRlcm5hdGl2ZUVuZHBvaW50ICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJhbXMuYWx0ZXJuYXRpdmVFbmRwb2ludFxuICAgICAgICAgICAgICAgICAgICA6IHBhcmFtcy5lbmRwb2ludDtcbiAgICAgICAgICAgICAgICB0aGlzLmFsdGVybmF0aXZlRW5kcG9pbnRBZ2VudCA9IGZldGNoQWdlbnQodGhpcy5hbHRlcm5hdGl2ZUVuZHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbmQoZGF0YSwgaGFuZGxlciwgcmVxdWlyZXNEYikge1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gcmVxdWlyZXNEYiA/IHRoaXMuZW5kcG9pbnQgOiB0aGlzLmFsdGVybmF0aXZlRW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZ2VudCA9IHJlcXVpcmVzRGIgPyB0aGlzLmVuZHBvaW50QWdlbnQgOiB0aGlzLmFsdGVybmF0aXZlRW5kcG9pbnRBZ2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAncG9zdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogREVGQVVMVF9IRUFERVJTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UudGV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIub25SZWNlaXZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5vbkVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IG5la290b24uSnJwY0Nvbm5lY3Rpb24oY2xvY2ssIG5ldyBKcnBjU2VuZGVyKHBhcmFtcykpO1xuICAgIH1cbn1cbmV4cG9ydHMuSnJwY1NvY2tldCA9IEpycGNTb2NrZXQ7XG5jb25zdCBERUZBVUxUX0hFQURFUlMgPSB7XG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/everscale-standalone-client/client/ConnectionController/jrpc.js\n");

/***/ }),

/***/ "./node_modules/everscale-standalone-client/client/SubscriptionController/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/everscale-standalone-client/client/SubscriptionController/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SubscriptionController = void 0;\nconst await_semaphore_1 = __webpack_require__(/*! @broxus/await-semaphore */ \"./node_modules/@broxus/await-semaphore/dist/index.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/everscale-standalone-client/client/utils.js\");\nconst subscription_1 = __webpack_require__(/*! ./subscription */ \"./node_modules/everscale-standalone-client/client/SubscriptionController/subscription.js\");\nconst DEFAULT_POLLING_INTERVAL = 10000; // 10s\nclass SubscriptionController {\n    constructor(connectionController, notify) {\n        this._subscriptions = new Map();\n        this._subscriptionsMutex = new await_semaphore_1.Mutex();\n        this._sendMessageRequests = new Map();\n        this._subscriptionStates = new Map();\n        this._connectionController = connectionController;\n        this._notify = notify;\n    }\n    async sendMessageLocally(address, signedMessage) {\n        const subscriptionId = (0, utils_1.getUniqueId)();\n        try {\n            await this.subscribeToContract(address, { state: true }, subscriptionId);\n            const subscription = this._subscriptions.get(address);\n            if (subscription == null) {\n                throw new Error('Failed to subscribe to contract');\n            }\n            return await subscription.use((contract) => contract.sendMessageLocally(signedMessage));\n        }\n        finally {\n            this.unsubscribeFromContract(address, subscriptionId).catch(console.error);\n        }\n    }\n    sendMessage(address, signedMessage) {\n        let messageRequests = this._sendMessageRequests.get(address);\n        if (messageRequests == null) {\n            messageRequests = new Map();\n            this._sendMessageRequests.set(address, messageRequests);\n        }\n        const subscriptionId = (0, utils_1.getUniqueId)();\n        return new Promise((resolve, reject) => {\n            const id = signedMessage.hash;\n            messageRequests.set(id, { resolve, reject });\n            this.subscribeToContract(address, { state: true }, subscriptionId)\n                .then(async () => {\n                const subscription = this._subscriptions.get(address);\n                if (subscription == null) {\n                    throw new Error('Failed to subscribe to contract');\n                }\n                await subscription.prepareReliablePolling();\n                await subscription\n                    .use(async (contract) => {\n                    await contract.sendMessage(signedMessage);\n                    subscription.skipRefreshTimer();\n                });\n            })\n                .catch((e) => this._rejectMessageRequest(address, id, e))\n                .finally(() => {\n                this.unsubscribeFromContract(address, subscriptionId).catch(console.error);\n            });\n        });\n    }\n    async subscribeToContract(address, params, internalId) {\n        return this._subscriptionsMutex.use(async () => {\n            let mergeInputParams = (currentParams) => {\n                const newParams = { ...currentParams };\n                Object.keys(newParams).map((param) => {\n                    if (param !== 'state' && param !== 'transactions') {\n                        throw new Error(`Unknown subscription topic: ${param}`);\n                    }\n                    const value = params[param];\n                    if (typeof value === 'boolean') {\n                        newParams[param] = value;\n                    }\n                    else if (value == null) {\n                        return;\n                    }\n                    else {\n                        throw new Error(`Unknown subscription topic value ${param}: ${value}`);\n                    }\n                });\n                return newParams;\n            };\n            const subscriptionState = this._subscriptionStates.get(address) || makeDefaultSubscriptionState();\n            let changedParams;\n            if (internalId == null) {\n                // Client subscription without id\n                // Changed params are `SubscriptionState.client`\n                changedParams = mergeInputParams(subscriptionState.client);\n            }\n            else {\n                // Internal subscription with id\n                // Changed params are `SubscriptionState.internal[internalId]`\n                let exisingParams = subscriptionState.internal.get(internalId);\n                if (exisingParams != null) {\n                    // Updating existing internal params\n                    changedParams = mergeInputParams(exisingParams);\n                    // Remove entry if it is empty\n                    if (isEmptySubscription(changedParams)) {\n                        subscriptionState.internal.delete(internalId);\n                    }\n                }\n                else {\n                    // Merge input params with empty struct\n                    changedParams = mergeInputParams({ state: false, transactions: false });\n                }\n            }\n            // Merge changed params with the rest of internal params\n            let computedParams = { ...changedParams };\n            for (const params of subscriptionState.internal.values()) {\n                computedParams.state || (computedParams.state = params.state);\n                computedParams.transactions || (computedParams.transactions = params.transactions);\n            }\n            // Remove subscription if all params are empty\n            if (isEmptySubscription(computedParams)) {\n                this._subscriptionStates.delete(address);\n                await this._tryUnsubscribe(address);\n                return { ...computedParams };\n            }\n            // Create subscription if it doesn't exist\n            let existingSubscription = this._subscriptions.get(address);\n            const isNewSubscription = existingSubscription == null;\n            if (existingSubscription == null) {\n                existingSubscription = await this._createSubscription(address);\n            }\n            // Update subscription state\n            if (internalId == null) {\n                // Update client params\n                subscriptionState.client = changedParams;\n            }\n            else {\n                // Set new internal params\n                subscriptionState.internal.set(internalId, changedParams);\n            }\n            this._subscriptionStates.set(address, subscriptionState);\n            // Start subscription\n            if (isNewSubscription) {\n                await existingSubscription.start();\n            }\n            // Returns only changed params\n            return { ...changedParams };\n        });\n    }\n    async unsubscribeFromContract(address, internalId) {\n        await this.subscribeToContract(address, {\n            state: false,\n            transactions: false,\n        }, internalId);\n    }\n    async unsubscribeFromAllContracts(internalId) {\n        for (const address of this._subscriptions.keys()) {\n            await this.unsubscribeFromContract(address, internalId);\n        }\n    }\n    get subscriptionStates() {\n        const result = {};\n        for (const [key, value] of this._subscriptionStates.entries()) {\n            result[key] = { ...value.client };\n        }\n        return result;\n    }\n    async _createSubscription(address) {\n        class ContractHandler {\n            constructor(address, controller) {\n                this._enabled = false;\n                this._address = address;\n                this._controller = controller;\n            }\n            enabledNotifications() {\n                this._enabled = true;\n            }\n            onMessageExpired(pendingTransaction) {\n                if (this._enabled) {\n                    this._controller\n                        ._resolveMessageRequest(this._address, pendingTransaction.messageHash, undefined)\n                        .catch(console.error);\n                }\n            }\n            onMessageSent(pendingTransaction, transaction) {\n                if (this._enabled) {\n                    this._controller\n                        ._resolveMessageRequest(this._address, pendingTransaction.messageHash, transaction)\n                        .catch(console.error);\n                }\n            }\n            onStateChanged(newState) {\n                if (this._enabled) {\n                    this._controller._notifyStateChanged(this._address, newState);\n                }\n            }\n            onTransactionsFound(transactions, info) {\n                if (this._enabled) {\n                    this._controller._notifyTransactionsFound(this._address, transactions, info);\n                }\n            }\n        }\n        const handler = new ContractHandler(address, this);\n        const subscription = await subscription_1.ContractSubscription.subscribe(this._connectionController, address, handler);\n        subscription.setPollingInterval(DEFAULT_POLLING_INTERVAL);\n        handler.enabledNotifications();\n        this._subscriptions.set(address, subscription);\n        return subscription;\n    }\n    async _tryUnsubscribe(address) {\n        const subscriptionState = this._subscriptionStates.get(address);\n        const sendMessageRequests = this._sendMessageRequests.get(address);\n        if (subscriptionState == null && ((sendMessageRequests === null || sendMessageRequests === void 0 ? void 0 : sendMessageRequests.size) || 0) == 0) {\n            const subscription = this._subscriptions.get(address);\n            this._subscriptions.delete(address);\n            await (subscription === null || subscription === void 0 ? void 0 : subscription.stop());\n        }\n    }\n    async _rejectMessageRequest(address, id, error) {\n        this._deleteMessageRequestAndGetCallback(address, id).reject(error);\n        await this._subscriptionsMutex.use(async () => this._tryUnsubscribe(address));\n    }\n    async _resolveMessageRequest(address, id, transaction) {\n        this._deleteMessageRequestAndGetCallback(address, id).resolve(transaction);\n        await this._subscriptionsMutex.use(async () => this._tryUnsubscribe(address));\n    }\n    _notifyStateChanged(address, state) {\n        const subscriptionState = this._subscriptionStates.get(address);\n        if (subscriptionState === null || subscriptionState === void 0 ? void 0 : subscriptionState.client.state) {\n            this._notify('contractStateChanged', {\n                address,\n                state,\n            });\n        }\n    }\n    _notifyTransactionsFound(address, transactions, info) {\n        const subscriptionState = this._subscriptionStates.get(address);\n        if (subscriptionState === null || subscriptionState === void 0 ? void 0 : subscriptionState.client.transactions) {\n            this._notify('transactionsFound', {\n                address,\n                transactions,\n                info,\n            });\n        }\n    }\n    _deleteMessageRequestAndGetCallback(address, id) {\n        var _a;\n        const callbacks = (_a = this._sendMessageRequests.get(address)) === null || _a === void 0 ? void 0 : _a.get(id);\n        if (!callbacks) {\n            throw new Error(`SendMessage request with id '${id}' not found`);\n        }\n        this._deleteMessageRequest(address, id);\n        return callbacks;\n    }\n    _deleteMessageRequest(address, id) {\n        const accountMessageRequests = this._sendMessageRequests.get(address);\n        if (!accountMessageRequests) {\n            return;\n        }\n        accountMessageRequests.delete(id);\n        if (accountMessageRequests.size == 0) {\n            this._sendMessageRequests.delete(address);\n        }\n    }\n}\nexports.SubscriptionController = SubscriptionController;\nconst makeDefaultSubscriptionState = () => ({\n    internal: new Map(),\n    client: {\n        state: false,\n        transactions: false,\n    },\n});\nconst isEmptySubscription = (params) => !params.state && !params.transactions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9TdWJzY3JpcHRpb25Db250cm9sbGVyL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvU3Vic2NyaXB0aW9uQ29udHJvbGxlci9pbmRleC5qcz8zMjU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdWJzY3JpcHRpb25Db250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgYXdhaXRfc2VtYXBob3JlXzEgPSByZXF1aXJlKFwiQGJyb3h1cy9hd2FpdC1zZW1hcGhvcmVcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3Qgc3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKFwiLi9zdWJzY3JpcHRpb25cIik7XG5jb25zdCBERUZBVUxUX1BPTExJTkdfSU5URVJWQUwgPSAxMDAwMDsgLy8gMTBzXG5jbGFzcyBTdWJzY3JpcHRpb25Db250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uQ29udHJvbGxlciwgbm90aWZ5KSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNNdXRleCA9IG5ldyBhd2FpdF9zZW1hcGhvcmVfMS5NdXRleCgpO1xuICAgICAgICB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Db250cm9sbGVyID0gY29ubmVjdGlvbkNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuX25vdGlmeSA9IG5vdGlmeTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZE1lc3NhZ2VMb2NhbGx5KGFkZHJlc3MsIHNpZ25lZE1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uSWQgPSAoMCwgdXRpbHNfMS5nZXRVbmlxdWVJZCkoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3Vic2NyaWJlVG9Db250cmFjdChhZGRyZXNzLCB7IHN0YXRlOiB0cnVlIH0sIHN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnMuZ2V0KGFkZHJlc3MpO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc3Vic2NyaWJlIHRvIGNvbnRyYWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgc3Vic2NyaXB0aW9uLnVzZSgoY29udHJhY3QpID0+IGNvbnRyYWN0LnNlbmRNZXNzYWdlTG9jYWxseShzaWduZWRNZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbUNvbnRyYWN0KGFkZHJlc3MsIHN1YnNjcmlwdGlvbklkKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kTWVzc2FnZShhZGRyZXNzLCBzaWduZWRNZXNzYWdlKSB7XG4gICAgICAgIGxldCBtZXNzYWdlUmVxdWVzdHMgPSB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzLmdldChhZGRyZXNzKTtcbiAgICAgICAgaWYgKG1lc3NhZ2VSZXF1ZXN0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlUmVxdWVzdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzLnNldChhZGRyZXNzLCBtZXNzYWdlUmVxdWVzdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbklkID0gKDAsIHV0aWxzXzEuZ2V0VW5pcXVlSWQpKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHNpZ25lZE1lc3NhZ2UuaGFzaDtcbiAgICAgICAgICAgIG1lc3NhZ2VSZXF1ZXN0cy5zZXQoaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NvbnRyYWN0KGFkZHJlc3MsIHsgc3RhdGU6IHRydWUgfSwgc3Vic2NyaXB0aW9uSWQpXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnMuZ2V0KGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzdWJzY3JpYmUgdG8gY29udHJhY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgc3Vic2NyaXB0aW9uLnByZXBhcmVSZWxpYWJsZVBvbGxpbmcoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgLnVzZShhc3luYyAoY29udHJhY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY29udHJhY3Quc2VuZE1lc3NhZ2Uoc2lnbmVkTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5za2lwUmVmcmVzaFRpbWVyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4gdGhpcy5fcmVqZWN0TWVzc2FnZVJlcXVlc3QoYWRkcmVzcywgaWQsIGUpKVxuICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbUNvbnRyYWN0KGFkZHJlc3MsIHN1YnNjcmlwdGlvbklkKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc3Vic2NyaWJlVG9Db250cmFjdChhZGRyZXNzLCBwYXJhbXMsIGludGVybmFsSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbnNNdXRleC51c2UoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IG1lcmdlSW5wdXRQYXJhbXMgPSAoY3VycmVudFBhcmFtcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHsgLi4uY3VycmVudFBhcmFtcyB9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG5ld1BhcmFtcykubWFwKChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0gIT09ICdzdGF0ZScgJiYgcGFyYW0gIT09ICd0cmFuc2FjdGlvbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3Vic2NyaXB0aW9uIHRvcGljOiAke3BhcmFtfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zW3BhcmFtXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJhbXNbcGFyYW1dID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN1YnNjcmlwdGlvbiB0b3BpYyB2YWx1ZSAke3BhcmFtfTogJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdQYXJhbXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU3RhdGUgPSB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZXMuZ2V0KGFkZHJlc3MpIHx8IG1ha2VEZWZhdWx0U3Vic2NyaXB0aW9uU3RhdGUoKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkUGFyYW1zO1xuICAgICAgICAgICAgaWYgKGludGVybmFsSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIENsaWVudCBzdWJzY3JpcHRpb24gd2l0aG91dCBpZFxuICAgICAgICAgICAgICAgIC8vIENoYW5nZWQgcGFyYW1zIGFyZSBgU3Vic2NyaXB0aW9uU3RhdGUuY2xpZW50YFxuICAgICAgICAgICAgICAgIGNoYW5nZWRQYXJhbXMgPSBtZXJnZUlucHV0UGFyYW1zKHN1YnNjcmlwdGlvblN0YXRlLmNsaWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbnRlcm5hbCBzdWJzY3JpcHRpb24gd2l0aCBpZFxuICAgICAgICAgICAgICAgIC8vIENoYW5nZWQgcGFyYW1zIGFyZSBgU3Vic2NyaXB0aW9uU3RhdGUuaW50ZXJuYWxbaW50ZXJuYWxJZF1gXG4gICAgICAgICAgICAgICAgbGV0IGV4aXNpbmdQYXJhbXMgPSBzdWJzY3JpcHRpb25TdGF0ZS5pbnRlcm5hbC5nZXQoaW50ZXJuYWxJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXNpbmdQYXJhbXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGluZyBleGlzdGluZyBpbnRlcm5hbCBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZFBhcmFtcyA9IG1lcmdlSW5wdXRQYXJhbXMoZXhpc2luZ1BhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBlbnRyeSBpZiBpdCBpcyBlbXB0eVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eVN1YnNjcmlwdGlvbihjaGFuZ2VkUGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uU3RhdGUuaW50ZXJuYWwuZGVsZXRlKGludGVybmFsSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBNZXJnZSBpbnB1dCBwYXJhbXMgd2l0aCBlbXB0eSBzdHJ1Y3RcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZFBhcmFtcyA9IG1lcmdlSW5wdXRQYXJhbXMoeyBzdGF0ZTogZmFsc2UsIHRyYW5zYWN0aW9uczogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWVyZ2UgY2hhbmdlZCBwYXJhbXMgd2l0aCB0aGUgcmVzdCBvZiBpbnRlcm5hbCBwYXJhbXNcbiAgICAgICAgICAgIGxldCBjb21wdXRlZFBhcmFtcyA9IHsgLi4uY2hhbmdlZFBhcmFtcyB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJhbXMgb2Ygc3Vic2NyaXB0aW9uU3RhdGUuaW50ZXJuYWwudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlZFBhcmFtcy5zdGF0ZSB8fCAoY29tcHV0ZWRQYXJhbXMuc3RhdGUgPSBwYXJhbXMuc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkUGFyYW1zLnRyYW5zYWN0aW9ucyB8fCAoY29tcHV0ZWRQYXJhbXMudHJhbnNhY3Rpb25zID0gcGFyYW1zLnRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaXB0aW9uIGlmIGFsbCBwYXJhbXMgYXJlIGVtcHR5XG4gICAgICAgICAgICBpZiAoaXNFbXB0eVN1YnNjcmlwdGlvbihjb21wdXRlZFBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZXMuZGVsZXRlKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3RyeVVuc3Vic2NyaWJlKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLmNvbXB1dGVkUGFyYW1zIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgc3Vic2NyaXB0aW9uIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgIGxldCBleGlzdGluZ1N1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnMuZ2V0KGFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgaXNOZXdTdWJzY3JpcHRpb24gPSBleGlzdGluZ1N1YnNjcmlwdGlvbiA9PSBudWxsO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nU3Vic2NyaXB0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1N1YnNjcmlwdGlvbiA9IGF3YWl0IHRoaXMuX2NyZWF0ZVN1YnNjcmlwdGlvbihhZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzdWJzY3JpcHRpb24gc3RhdGVcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbElkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY2xpZW50IHBhcmFtc1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvblN0YXRlLmNsaWVudCA9IGNoYW5nZWRQYXJhbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgbmV3IGludGVybmFsIHBhcmFtc1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvblN0YXRlLmludGVybmFsLnNldChpbnRlcm5hbElkLCBjaGFuZ2VkUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlcy5zZXQoYWRkcmVzcywgc3Vic2NyaXB0aW9uU3RhdGUpO1xuICAgICAgICAgICAgLy8gU3RhcnQgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICBpZiAoaXNOZXdTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBleGlzdGluZ1N1YnNjcmlwdGlvbi5zdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0dXJucyBvbmx5IGNoYW5nZWQgcGFyYW1zXG4gICAgICAgICAgICByZXR1cm4geyAuLi5jaGFuZ2VkUGFyYW1zIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB1bnN1YnNjcmliZUZyb21Db250cmFjdChhZGRyZXNzLCBpbnRlcm5hbElkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3Vic2NyaWJlVG9Db250cmFjdChhZGRyZXNzLCB7XG4gICAgICAgICAgICBzdGF0ZTogZmFsc2UsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbnM6IGZhbHNlLFxuICAgICAgICB9LCBpbnRlcm5hbElkKTtcbiAgICB9XG4gICAgYXN5bmMgdW5zdWJzY3JpYmVGcm9tQWxsQ29udHJhY3RzKGludGVybmFsSWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIHRoaXMuX3N1YnNjcmlwdGlvbnMua2V5cygpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnVuc3Vic2NyaWJlRnJvbUNvbnRyYWN0KGFkZHJlc3MsIGludGVybmFsSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzdWJzY3JpcHRpb25TdGF0ZXMoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHsgLi4udmFsdWUuY2xpZW50IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgX2NyZWF0ZVN1YnNjcmlwdGlvbihhZGRyZXNzKSB7XG4gICAgICAgIGNsYXNzIENvbnRyYWN0SGFuZGxlciB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5hYmxlZE5vdGlmaWNhdGlvbnMoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbk1lc3NhZ2VFeHBpcmVkKHBlbmRpbmdUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5fcmVzb2x2ZU1lc3NhZ2VSZXF1ZXN0KHRoaXMuX2FkZHJlc3MsIHBlbmRpbmdUcmFuc2FjdGlvbi5tZXNzYWdlSGFzaCwgdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uTWVzc2FnZVNlbnQocGVuZGluZ1RyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5fcmVzb2x2ZU1lc3NhZ2VSZXF1ZXN0KHRoaXMuX2FkZHJlc3MsIHBlbmRpbmdUcmFuc2FjdGlvbi5tZXNzYWdlSGFzaCwgdHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25TdGF0ZUNoYW5nZWQobmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250cm9sbGVyLl9ub3RpZnlTdGF0ZUNoYW5nZWQodGhpcy5fYWRkcmVzcywgbmV3U3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uVHJhbnNhY3Rpb25zRm91bmQodHJhbnNhY3Rpb25zLCBpbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udHJvbGxlci5fbm90aWZ5VHJhbnNhY3Rpb25zRm91bmQodGhpcy5fYWRkcmVzcywgdHJhbnNhY3Rpb25zLCBpbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlciA9IG5ldyBDb250cmFjdEhhbmRsZXIoYWRkcmVzcywgdGhpcyk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IHN1YnNjcmlwdGlvbl8xLkNvbnRyYWN0U3Vic2NyaXB0aW9uLnN1YnNjcmliZSh0aGlzLl9jb25uZWN0aW9uQ29udHJvbGxlciwgYWRkcmVzcywgaGFuZGxlcik7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5zZXRQb2xsaW5nSW50ZXJ2YWwoREVGQVVMVF9QT0xMSU5HX0lOVEVSVkFMKTtcbiAgICAgICAgaGFuZGxlci5lbmFibGVkTm90aWZpY2F0aW9ucygpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnNldChhZGRyZXNzLCBzdWJzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH1cbiAgICBhc3luYyBfdHJ5VW5zdWJzY3JpYmUoYWRkcmVzcykge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25TdGF0ZSA9IHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlcy5nZXQoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IHNlbmRNZXNzYWdlUmVxdWVzdHMgPSB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzLmdldChhZGRyZXNzKTtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvblN0YXRlID09IG51bGwgJiYgKChzZW5kTWVzc2FnZVJlcXVlc3RzID09PSBudWxsIHx8IHNlbmRNZXNzYWdlUmVxdWVzdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbmRNZXNzYWdlUmVxdWVzdHMuc2l6ZSkgfHwgMCkgPT0gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5fc3Vic2NyaXB0aW9ucy5nZXQoYWRkcmVzcyk7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmRlbGV0ZShhZGRyZXNzKTtcbiAgICAgICAgICAgIGF3YWl0IChzdWJzY3JpcHRpb24gPT09IG51bGwgfHwgc3Vic2NyaXB0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdWJzY3JpcHRpb24uc3RvcCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfcmVqZWN0TWVzc2FnZVJlcXVlc3QoYWRkcmVzcywgaWQsIGVycm9yKSB7XG4gICAgICAgIHRoaXMuX2RlbGV0ZU1lc3NhZ2VSZXF1ZXN0QW5kR2V0Q2FsbGJhY2soYWRkcmVzcywgaWQpLnJlamVjdChlcnJvcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3N1YnNjcmlwdGlvbnNNdXRleC51c2UoYXN5bmMgKCkgPT4gdGhpcy5fdHJ5VW5zdWJzY3JpYmUoYWRkcmVzcykpO1xuICAgIH1cbiAgICBhc3luYyBfcmVzb2x2ZU1lc3NhZ2VSZXF1ZXN0KGFkZHJlc3MsIGlkLCB0cmFuc2FjdGlvbikge1xuICAgICAgICB0aGlzLl9kZWxldGVNZXNzYWdlUmVxdWVzdEFuZEdldENhbGxiYWNrKGFkZHJlc3MsIGlkKS5yZXNvbHZlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3Vic2NyaXB0aW9uc011dGV4LnVzZShhc3luYyAoKSA9PiB0aGlzLl90cnlVbnN1YnNjcmliZShhZGRyZXNzKSk7XG4gICAgfVxuICAgIF9ub3RpZnlTdGF0ZUNoYW5nZWQoYWRkcmVzcywgc3RhdGUpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU3RhdGUgPSB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZXMuZ2V0KGFkZHJlc3MpO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uU3RhdGUgPT09IG51bGwgfHwgc3Vic2NyaXB0aW9uU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1YnNjcmlwdGlvblN0YXRlLmNsaWVudC5zdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fbm90aWZ5KCdjb250cmFjdFN0YXRlQ2hhbmdlZCcsIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX25vdGlmeVRyYW5zYWN0aW9uc0ZvdW5kKGFkZHJlc3MsIHRyYW5zYWN0aW9ucywgaW5mbykge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25TdGF0ZSA9IHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlcy5nZXQoYWRkcmVzcyk7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25TdGF0ZSA9PT0gbnVsbCB8fCBzdWJzY3JpcHRpb25TdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Vic2NyaXB0aW9uU3RhdGUuY2xpZW50LnRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fbm90aWZ5KCd0cmFuc2FjdGlvbnNGb3VuZCcsIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgICAgICAgICAgICBpbmZvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2RlbGV0ZU1lc3NhZ2VSZXF1ZXN0QW5kR2V0Q2FsbGJhY2soYWRkcmVzcywgaWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAoX2EgPSB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzLmdldChhZGRyZXNzKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChpZCk7XG4gICAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlbmRNZXNzYWdlIHJlcXVlc3Qgd2l0aCBpZCAnJHtpZH0nIG5vdCBmb3VuZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlbGV0ZU1lc3NhZ2VSZXF1ZXN0KGFkZHJlc3MsIGlkKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrcztcbiAgICB9XG4gICAgX2RlbGV0ZU1lc3NhZ2VSZXF1ZXN0KGFkZHJlc3MsIGlkKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnRNZXNzYWdlUmVxdWVzdHMgPSB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzLmdldChhZGRyZXNzKTtcbiAgICAgICAgaWYgKCFhY2NvdW50TWVzc2FnZVJlcXVlc3RzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWNjb3VudE1lc3NhZ2VSZXF1ZXN0cy5kZWxldGUoaWQpO1xuICAgICAgICBpZiAoYWNjb3VudE1lc3NhZ2VSZXF1ZXN0cy5zaXplID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRNZXNzYWdlUmVxdWVzdHMuZGVsZXRlKGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TdWJzY3JpcHRpb25Db250cm9sbGVyID0gU3Vic2NyaXB0aW9uQ29udHJvbGxlcjtcbmNvbnN0IG1ha2VEZWZhdWx0U3Vic2NyaXB0aW9uU3RhdGUgPSAoKSA9PiAoe1xuICAgIGludGVybmFsOiBuZXcgTWFwKCksXG4gICAgY2xpZW50OiB7XG4gICAgICAgIHN0YXRlOiBmYWxzZSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBmYWxzZSxcbiAgICB9LFxufSk7XG5jb25zdCBpc0VtcHR5U3Vic2NyaXB0aW9uID0gKHBhcmFtcykgPT4gIXBhcmFtcy5zdGF0ZSAmJiAhcGFyYW1zLnRyYW5zYWN0aW9ucztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/everscale-standalone-client/client/SubscriptionController/index.js\n");

/***/ }),

/***/ "./node_modules/everscale-standalone-client/client/SubscriptionController/subscription.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/everscale-standalone-client/client/SubscriptionController/subscription.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContractSubscription = void 0;\nconst await_semaphore_1 = __webpack_require__(/*! @broxus/await-semaphore */ \"./node_modules/@broxus/await-semaphore/dist/index.js\");\nconst core_1 = __importDefault(__webpack_require__(/*! ../../core */ \"./node_modules/everscale-standalone-client/core.js\"));\nconst { nekoton, debugLog } = core_1.default;\nclass ContractSubscription {\n    constructor(connection, release, address, contract) {\n        this._contractMutex = new await_semaphore_1.Mutex();\n        this._pollingInterval = BACKGROUND_POLLING_INTERVAL;\n        this._isRunning = false;\n        this._connection = connection;\n        this._address = address;\n        this._contract = contract;\n        this._releaseTransport = release;\n        this._currentPollingMethod = contract.pollingMethod;\n    }\n    static async subscribe(connectionController, address, handler) {\n        const { transport: { data: { connection, transport } }, release, } = await connectionController.acquire();\n        try {\n            const contract = await transport.subscribeToGenericContract(address, handler);\n            if (contract == null) {\n                throw new Error(`Failed to subscribe to contract: ${address}`);\n            }\n            return new ContractSubscription(connection, release, address, contract);\n        }\n        catch (e) {\n            release();\n            throw e;\n        }\n    }\n    setPollingInterval(interval) {\n        this._pollingInterval = interval;\n    }\n    async start() {\n        if (this._releaseTransport == null) {\n            throw new Error('Contract subscription must not be started after being closed');\n        }\n        if (this._loopPromise) {\n            debugLog('ContractSubscription -> awaiting loop promise');\n            await this._loopPromise;\n        }\n        debugLog('ContractSubscription -> loop started');\n        this._loopPromise = (async () => {\n            const isSimple = !(this._connection instanceof nekoton.GqlConnection);\n            this._isRunning = true;\n            let previousPollingMethod = this._currentPollingMethod;\n            while (this._isRunning) {\n                const pollingMethodChanged = previousPollingMethod != this._currentPollingMethod;\n                previousPollingMethod = this._currentPollingMethod;\n                if (isSimple || this._currentPollingMethod == 'manual') {\n                    this._currentBlockId = undefined;\n                    debugLog('ContractSubscription -> manual -> waiting begins');\n                    const pollingInterval = this._currentPollingMethod == 'manual'\n                        ? this._pollingInterval\n                        : INTENSIVE_POLLING_INTERVAL;\n                    await new Promise((resolve) => {\n                        const timerHandle = setTimeout(() => {\n                            this._refreshTimer = undefined;\n                            resolve();\n                        }, pollingInterval);\n                        this._refreshTimer = [timerHandle, resolve];\n                    });\n                    debugLog('ContractSubscription -> manual -> waiting ends');\n                    if (!this._isRunning) {\n                        break;\n                    }\n                    debugLog('ContractSubscription -> manual -> refreshing begins');\n                    try {\n                        this._currentPollingMethod = await this._contractMutex.use(async () => {\n                            await this._contract.refresh();\n                            return this._contract.pollingMethod;\n                        });\n                    }\n                    catch (e) {\n                        console.error(`Error during account refresh (${this._address})`, e);\n                    }\n                    debugLog('ContractSubscription -> manual -> refreshing ends');\n                }\n                else {\n                    // SAFETY: connection is always GqlConnection here due to `isSimple`\n                    const connection = this._connection;\n                    debugLog('ContractSubscription -> reliable start');\n                    if (pollingMethodChanged && this._suggestedBlockId != null) {\n                        this._currentBlockId = this._suggestedBlockId;\n                    }\n                    this._suggestedBlockId = undefined;\n                    let nextBlockId;\n                    if (this._currentBlockId == null) {\n                        console.warn('Starting reliable connection with unknown block');\n                        try {\n                            const latestBlock = await connection.getLatestBlock(this._address);\n                            this._currentBlockId = latestBlock.id;\n                            nextBlockId = this._currentBlockId;\n                        }\n                        catch (e) {\n                            console.error(`Failed to get latest block for ${this._address}`, e);\n                            continue;\n                        }\n                    }\n                    else {\n                        try {\n                            nextBlockId = await connection.waitForNextBlock(this._currentBlockId, this._address, NEXT_BLOCK_TIMEOUT);\n                        }\n                        catch (e) {\n                            console.error(`Failed to wait for next block for ${this._address}`);\n                            continue; // retry\n                        }\n                    }\n                    try {\n                        this._currentPollingMethod = await this._contractMutex.use(async () => {\n                            await this._contract.handleBlock(nextBlockId);\n                            return this._contract.pollingMethod;\n                        });\n                        this._currentBlockId = nextBlockId;\n                    }\n                    catch (e) {\n                        console.error(`Failed to handle block for ${this._address}`, e);\n                    }\n                }\n            }\n            debugLog('ContractSubscription -> loop finished');\n        })();\n    }\n    skipRefreshTimer() {\n        var _a, _b;\n        clearTimeout((_a = this._refreshTimer) === null || _a === void 0 ? void 0 : _a[0]);\n        (_b = this._refreshTimer) === null || _b === void 0 ? void 0 : _b[1]();\n        this._refreshTimer = undefined;\n    }\n    async pause() {\n        if (!this._isRunning) {\n            return;\n        }\n        this._isRunning = false;\n        this.skipRefreshTimer();\n        await this._loopPromise;\n        this._loopPromise = undefined;\n        this._currentPollingMethod = await this._contractMutex.use(async () => {\n            return this._contract.pollingMethod;\n        });\n        this._currentBlockId = undefined;\n        this._suggestedBlockId = undefined;\n    }\n    async stop() {\n        var _a;\n        await this.pause();\n        this._contract.free();\n        (_a = this._releaseTransport) === null || _a === void 0 ? void 0 : _a.call(this);\n        this._releaseTransport = undefined;\n    }\n    async prepareReliablePolling() {\n        try {\n            if (this._connection instanceof nekoton.GqlConnection) {\n                this._suggestedBlockId = (await this._connection.getLatestBlock(this._address)).id;\n            }\n        }\n        catch (e) {\n            throw new Error(`Failed to prepare reliable polling: ${e.toString()}`);\n        }\n    }\n    async use(f) {\n        const release = await this._contractMutex.acquire();\n        return f(this._contract)\n            .then((res) => {\n            release();\n            return res;\n        })\n            .catch((err) => {\n            release();\n            throw err;\n        });\n    }\n}\nexports.ContractSubscription = ContractSubscription;\nconst NEXT_BLOCK_TIMEOUT = 60; // 60s\nconst INTENSIVE_POLLING_INTERVAL = 2000; // 2s\nconst BACKGROUND_POLLING_INTERVAL = 60000;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9TdWJzY3JpcHRpb25Db250cm9sbGVyL3N1YnNjcmlwdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9ldmVyc2NhbGUtc3RhbmRhbG9uZS1jbGllbnQvY2xpZW50L1N1YnNjcmlwdGlvbkNvbnRyb2xsZXIvc3Vic2NyaXB0aW9uLmpzP2Q3OWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnRyYWN0U3Vic2NyaXB0aW9uID0gdm9pZCAwO1xuY29uc3QgYXdhaXRfc2VtYXBob3JlXzEgPSByZXF1aXJlKFwiQGJyb3h1cy9hd2FpdC1zZW1hcGhvcmVcIik7XG5jb25zdCBjb3JlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2NvcmVcIikpO1xuY29uc3QgeyBuZWtvdG9uLCBkZWJ1Z0xvZyB9ID0gY29yZV8xLmRlZmF1bHQ7XG5jbGFzcyBDb250cmFjdFN1YnNjcmlwdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgcmVsZWFzZSwgYWRkcmVzcywgY29udHJhY3QpIHtcbiAgICAgICAgdGhpcy5fY29udHJhY3RNdXRleCA9IG5ldyBhd2FpdF9zZW1hcGhvcmVfMS5NdXRleCgpO1xuICAgICAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSBCQUNLR1JPVU5EX1BPTExJTkdfSU5URVJWQUw7XG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5fYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIHRoaXMuX2NvbnRyYWN0ID0gY29udHJhY3Q7XG4gICAgICAgIHRoaXMuX3JlbGVhc2VUcmFuc3BvcnQgPSByZWxlYXNlO1xuICAgICAgICB0aGlzLl9jdXJyZW50UG9sbGluZ01ldGhvZCA9IGNvbnRyYWN0LnBvbGxpbmdNZXRob2Q7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBzdWJzY3JpYmUoY29ubmVjdGlvbkNvbnRyb2xsZXIsIGFkZHJlc3MsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgeyB0cmFuc3BvcnQ6IHsgZGF0YTogeyBjb25uZWN0aW9uLCB0cmFuc3BvcnQgfSB9LCByZWxlYXNlLCB9ID0gYXdhaXQgY29ubmVjdGlvbkNvbnRyb2xsZXIuYWNxdWlyZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBhd2FpdCB0cmFuc3BvcnQuc3Vic2NyaWJlVG9HZW5lcmljQ29udHJhY3QoYWRkcmVzcywgaGFuZGxlcik7XG4gICAgICAgICAgICBpZiAoY29udHJhY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHN1YnNjcmliZSB0byBjb250cmFjdDogJHthZGRyZXNzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFN1YnNjcmlwdGlvbihjb25uZWN0aW9uLCByZWxlYXNlLCBhZGRyZXNzLCBjb250cmFjdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UG9sbGluZ0ludGVydmFsKGludGVydmFsKSB7XG4gICAgICAgIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCA9IGludGVydmFsO1xuICAgIH1cbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbGVhc2VUcmFuc3BvcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250cmFjdCBzdWJzY3JpcHRpb24gbXVzdCBub3QgYmUgc3RhcnRlZCBhZnRlciBiZWluZyBjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbG9vcFByb21pc2UpIHtcbiAgICAgICAgICAgIGRlYnVnTG9nKCdDb250cmFjdFN1YnNjcmlwdGlvbiAtPiBhd2FpdGluZyBsb29wIHByb21pc2UnKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2xvb3BQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnTG9nKCdDb250cmFjdFN1YnNjcmlwdGlvbiAtPiBsb29wIHN0YXJ0ZWQnKTtcbiAgICAgICAgdGhpcy5fbG9vcFByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNTaW1wbGUgPSAhKHRoaXMuX2Nvbm5lY3Rpb24gaW5zdGFuY2VvZiBuZWtvdG9uLkdxbENvbm5lY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBwcmV2aW91c1BvbGxpbmdNZXRob2QgPSB0aGlzLl9jdXJyZW50UG9sbGluZ01ldGhvZDtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2xsaW5nTWV0aG9kQ2hhbmdlZCA9IHByZXZpb3VzUG9sbGluZ01ldGhvZCAhPSB0aGlzLl9jdXJyZW50UG9sbGluZ01ldGhvZDtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1BvbGxpbmdNZXRob2QgPSB0aGlzLl9jdXJyZW50UG9sbGluZ01ldGhvZDtcbiAgICAgICAgICAgICAgICBpZiAoaXNTaW1wbGUgfHwgdGhpcy5fY3VycmVudFBvbGxpbmdNZXRob2QgPT0gJ21hbnVhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEJsb2NrSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nKCdDb250cmFjdFN1YnNjcmlwdGlvbiAtPiBtYW51YWwgLT4gd2FpdGluZyBiZWdpbnMnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9sbGluZ0ludGVydmFsID0gdGhpcy5fY3VycmVudFBvbGxpbmdNZXRob2QgPT0gJ21hbnVhbCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5fcG9sbGluZ0ludGVydmFsXG4gICAgICAgICAgICAgICAgICAgICAgICA6IElOVEVOU0lWRV9QT0xMSU5HX0lOVEVSVkFMO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZXJIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWZyZXNoVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hUaW1lciA9IFt0aW1lckhhbmRsZSwgcmVzb2x2ZV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZygnQ29udHJhY3RTdWJzY3JpcHRpb24gLT4gbWFudWFsIC0+IHdhaXRpbmcgZW5kcycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzUnVubmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVidWdMb2coJ0NvbnRyYWN0U3Vic2NyaXB0aW9uIC0+IG1hbnVhbCAtPiByZWZyZXNoaW5nIGJlZ2lucycpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFBvbGxpbmdNZXRob2QgPSBhd2FpdCB0aGlzLl9jb250cmFjdE11dGV4LnVzZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fY29udHJhY3QucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250cmFjdC5wb2xsaW5nTWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGR1cmluZyBhY2NvdW50IHJlZnJlc2ggKCR7dGhpcy5fYWRkcmVzc30pYCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVidWdMb2coJ0NvbnRyYWN0U3Vic2NyaXB0aW9uIC0+IG1hbnVhbCAtPiByZWZyZXNoaW5nIGVuZHMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogY29ubmVjdGlvbiBpcyBhbHdheXMgR3FsQ29ubmVjdGlvbiBoZXJlIGR1ZSB0byBgaXNTaW1wbGVgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLl9jb25uZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZygnQ29udHJhY3RTdWJzY3JpcHRpb24gLT4gcmVsaWFibGUgc3RhcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvbGxpbmdNZXRob2RDaGFuZ2VkICYmIHRoaXMuX3N1Z2dlc3RlZEJsb2NrSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEJsb2NrSWQgPSB0aGlzLl9zdWdnZXN0ZWRCbG9ja0lkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1Z2dlc3RlZEJsb2NrSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0QmxvY2tJZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRCbG9ja0lkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignU3RhcnRpbmcgcmVsaWFibGUgY29ubmVjdGlvbiB3aXRoIHVua25vd24gYmxvY2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2sgPSBhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NrKHRoaXMuX2FkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRCbG9ja0lkID0gbGF0ZXN0QmxvY2suaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEJsb2NrSWQgPSB0aGlzLl9jdXJyZW50QmxvY2tJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGdldCBsYXRlc3QgYmxvY2sgZm9yICR7dGhpcy5fYWRkcmVzc31gLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEJsb2NrSWQgPSBhd2FpdCBjb25uZWN0aW9uLndhaXRGb3JOZXh0QmxvY2sodGhpcy5fY3VycmVudEJsb2NrSWQsIHRoaXMuX2FkZHJlc3MsIE5FWFRfQkxPQ0tfVElNRU9VVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byB3YWl0IGZvciBuZXh0IGJsb2NrIGZvciAke3RoaXMuX2FkZHJlc3N9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQb2xsaW5nTWV0aG9kID0gYXdhaXQgdGhpcy5fY29udHJhY3RNdXRleC51c2UoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NvbnRyYWN0LmhhbmRsZUJsb2NrKG5leHRCbG9ja0lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udHJhY3QucG9sbGluZ01ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEJsb2NrSWQgPSBuZXh0QmxvY2tJZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGhhbmRsZSBibG9jayBmb3IgJHt0aGlzLl9hZGRyZXNzfWAsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVidWdMb2coJ0NvbnRyYWN0U3Vic2NyaXB0aW9uIC0+IGxvb3AgZmluaXNoZWQnKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgc2tpcFJlZnJlc2hUaW1lcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY2xlYXJUaW1lb3V0KChfYSA9IHRoaXMuX3JlZnJlc2hUaW1lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKTtcbiAgICAgICAgKF9iID0gdGhpcy5fcmVmcmVzaFRpbWVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMV0oKTtcbiAgICAgICAgdGhpcy5fcmVmcmVzaFRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyBwYXVzZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5za2lwUmVmcmVzaFRpbWVyKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2xvb3BQcm9taXNlO1xuICAgICAgICB0aGlzLl9sb29wUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY3VycmVudFBvbGxpbmdNZXRob2QgPSBhd2FpdCB0aGlzLl9jb250cmFjdE11dGV4LnVzZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udHJhY3QucG9sbGluZ01ldGhvZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCbG9ja0lkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zdWdnZXN0ZWRCbG9ja0lkID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyBzdG9wKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGF3YWl0IHRoaXMucGF1c2UoKTtcbiAgICAgICAgdGhpcy5fY29udHJhY3QuZnJlZSgpO1xuICAgICAgICAoX2EgPSB0aGlzLl9yZWxlYXNlVHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVsZWFzZVRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXN5bmMgcHJlcGFyZVJlbGlhYmxlUG9sbGluZygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb25uZWN0aW9uIGluc3RhbmNlb2YgbmVrb3Rvbi5HcWxDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3VnZ2VzdGVkQmxvY2tJZCA9IChhd2FpdCB0aGlzLl9jb25uZWN0aW9uLmdldExhdGVzdEJsb2NrKHRoaXMuX2FkZHJlc3MpKS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcHJlcGFyZSByZWxpYWJsZSBwb2xsaW5nOiAke2UudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1c2UoZikge1xuICAgICAgICBjb25zdCByZWxlYXNlID0gYXdhaXQgdGhpcy5fY29udHJhY3RNdXRleC5hY3F1aXJlKCk7XG4gICAgICAgIHJldHVybiBmKHRoaXMuX2NvbnRyYWN0KVxuICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJhY3RTdWJzY3JpcHRpb24gPSBDb250cmFjdFN1YnNjcmlwdGlvbjtcbmNvbnN0IE5FWFRfQkxPQ0tfVElNRU9VVCA9IDYwOyAvLyA2MHNcbmNvbnN0IElOVEVOU0lWRV9QT0xMSU5HX0lOVEVSVkFMID0gMjAwMDsgLy8gMnNcbmNvbnN0IEJBQ0tHUk9VTkRfUE9MTElOR19JTlRFUlZBTCA9IDYwMDAwO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/everscale-standalone-client/client/SubscriptionController/subscription.js\n");

/***/ }),

/***/ "./node_modules/everscale-standalone-client/client/clock.js":
/*!******************************************************************!*\
  !*** ./node_modules/everscale-standalone-client/client/clock.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Clock = void 0;\n/**\n * Wrapper around clocks which are used in `EverscaleStandaloneClient` instances\n *\n * @category Client\n */\nclass Clock {\n    constructor(offset) {\n        this.impls = [];\n        this.currentOffset = 0;\n        if (offset != null) {\n            this.currentOffset = offset;\n        }\n    }\n    /**\n     * Clock offset in milliseconds\n     */\n    get offset() {\n        return this.currentOffset;\n    }\n    /**\n     * Set clock offset in milliseconds\n     */\n    set offset(value) {\n        this.currentOffset = value;\n        for (const impl of this.impls) {\n            impl.updateOffset(this.currentOffset);\n        }\n    }\n    /**\n     * Returns current time in milliseconds\n     */\n    get time() {\n        return new Date().getTime() + this.offset;\n    }\n    /**\n     * Detaches all affected providers\n     *\n     * NOTE: affected providers offset remains the same\n     */\n    detach() {\n        this.impls = [];\n    }\n}\nexports.Clock = Clock;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9jbG9jay5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9ldmVyc2NhbGUtc3RhbmRhbG9uZS1jbGllbnQvY2xpZW50L2Nsb2NrLmpzPzM2YWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsb2NrID0gdm9pZCAwO1xuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCBjbG9ja3Mgd2hpY2ggYXJlIHVzZWQgaW4gYEV2ZXJzY2FsZVN0YW5kYWxvbmVDbGllbnRgIGluc3RhbmNlc1xuICpcbiAqIEBjYXRlZ29yeSBDbGllbnRcbiAqL1xuY2xhc3MgQ2xvY2sge1xuICAgIGNvbnN0cnVjdG9yKG9mZnNldCkge1xuICAgICAgICB0aGlzLmltcGxzID0gW107XG4gICAgICAgIHRoaXMuY3VycmVudE9mZnNldCA9IDA7XG4gICAgICAgIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb2NrIG9mZnNldCBpbiBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICBnZXQgb2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50T2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgY2xvY2sgb2Zmc2V0IGluIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIHNldCBvZmZzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50T2Zmc2V0ID0gdmFsdWU7XG4gICAgICAgIGZvciAoY29uc3QgaW1wbCBvZiB0aGlzLmltcGxzKSB7XG4gICAgICAgICAgICBpbXBsLnVwZGF0ZU9mZnNldCh0aGlzLmN1cnJlbnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VycmVudCB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIGdldCB0aW1lKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyB0aGlzLm9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0YWNoZXMgYWxsIGFmZmVjdGVkIHByb3ZpZGVyc1xuICAgICAqXG4gICAgICogTk9URTogYWZmZWN0ZWQgcHJvdmlkZXJzIG9mZnNldCByZW1haW5zIHRoZSBzYW1lXG4gICAgICovXG4gICAgZGV0YWNoKCkge1xuICAgICAgICB0aGlzLmltcGxzID0gW107XG4gICAgfVxufVxuZXhwb3J0cy5DbG9jayA9IENsb2NrO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/everscale-standalone-client/client/clock.js\n");

/***/ }),

/***/ "./node_modules/everscale-standalone-client/client/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/everscale-standalone-client/client/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EverscaleStandaloneClient = exports.SUPPORTED_PERMISSIONS = exports.VERSION = exports.DEFAULT_CLIENT_PROPERTIES = exports.Clock = exports.SimpleKeystore = exports.checkConnection = exports.ConnectionError = exports.NETWORK_PRESETS = void 0;\nconst fast_safe_stringify_1 = __importDefault(__webpack_require__(/*! fast-safe-stringify */ \"./node_modules/fast-safe-stringify/index.js\"));\nconst core_1 = __importDefault(__webpack_require__(/*! ../core */ \"./node_modules/everscale-standalone-client/core.js\"));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/everscale-standalone-client/client/utils.js\");\nconst ConnectionController_1 = __webpack_require__(/*! ./ConnectionController */ \"./node_modules/everscale-standalone-client/client/ConnectionController/index.js\");\nconst SubscriptionController_1 = __webpack_require__(/*! ./SubscriptionController */ \"./node_modules/everscale-standalone-client/client/SubscriptionController/index.js\");\nconst AccountsStorage_1 = __webpack_require__(/*! ./AccountsStorage */ \"./node_modules/everscale-standalone-client/client/AccountsStorage/index.js\");\nvar ConnectionController_2 = __webpack_require__(/*! ./ConnectionController */ \"./node_modules/everscale-standalone-client/client/ConnectionController/index.js\");\nObject.defineProperty(exports, \"NETWORK_PRESETS\", ({ enumerable: true, get: function () { return ConnectionController_2.NETWORK_PRESETS; } }));\nvar ConnectionController_3 = __webpack_require__(/*! ./ConnectionController */ \"./node_modules/everscale-standalone-client/client/ConnectionController/index.js\");\nObject.defineProperty(exports, \"ConnectionError\", ({ enumerable: true, get: function () { return ConnectionController_3.ConnectionError; } }));\nObject.defineProperty(exports, \"checkConnection\", ({ enumerable: true, get: function () { return ConnectionController_3.checkConnection; } }));\n__exportStar(__webpack_require__(/*! ./AccountsStorage */ \"./node_modules/everscale-standalone-client/client/AccountsStorage/index.js\"), exports);\nvar keystore_1 = __webpack_require__(/*! ./keystore */ \"./node_modules/everscale-standalone-client/client/keystore.js\");\nObject.defineProperty(exports, \"SimpleKeystore\", ({ enumerable: true, get: function () { return keystore_1.SimpleKeystore; } }));\nvar clock_1 = __webpack_require__(/*! ./clock */ \"./node_modules/everscale-standalone-client/client/clock.js\");\nObject.defineProperty(exports, \"Clock\", ({ enumerable: true, get: function () { return clock_1.Clock; } }));\nconst { ensureNekotonLoaded, nekoton } = core_1.default;\nfunction validateMessageProperties(message) {\n    const m = message || {};\n    return {\n        retryCount: m.retryCount != null ? Math.max(1, ~~m.retryCount) : 5,\n        timeout: m.timeout != null ? Math.max(1, ~~m.timeout) : 60,\n        timeoutGrowFactor: m.timeoutGrowFactor || 1.2,\n        retryTransfers: true,\n    };\n}\n/**\n * @category Client\n */\nexports.DEFAULT_CLIENT_PROPERTIES = {\n    connection: ConnectionController_1.DEFAULT_NETWORK_GROUP,\n};\n/**\n * @category Client\n */\nexports.VERSION = '0.2.25';\n/**\n * @category Client\n */\nexports.SUPPORTED_PERMISSIONS = ['basic', 'accountInteraction'];\n/**\n * @category Client\n */\nclass EverscaleStandaloneClient extends utils_1.SafeEventEmitter {\n    constructor(ctx) {\n        super();\n        this._handlers = {\n            requestPermissions,\n            changeAccount,\n            disconnect,\n            subscribe,\n            unsubscribe,\n            unsubscribeAll,\n            getProviderState,\n            getFullContractState,\n            getAccountsByCodeHash,\n            getTransactions,\n            getTransaction,\n            findTransaction,\n            runLocal,\n            getExpectedAddress,\n            getBocHash,\n            packIntoCell,\n            unpackFromCell,\n            extractPublicKey,\n            codeToTvc,\n            mergeTvc,\n            splitTvc,\n            setCodeSalt,\n            getCodeSalt,\n            encodeInternalInput,\n            decodeInput,\n            decodeOutput,\n            decodeEvent,\n            decodeTransaction,\n            decodeTransactionEvents,\n            verifySignature,\n            sendUnsignedExternalMessage,\n            // addAsset, // not supported\n            signData,\n            signDataRaw,\n            // encryptData, // not supported\n            // decryptData, // not supported\n            // estimateFees, // not supported\n            sendMessage,\n            sendMessageDelayed,\n            sendExternalMessage,\n            sendExternalMessageDelayed,\n        };\n        this._context = ctx;\n    }\n    static async create(params) {\n        await ensureNekotonLoaded(params.initInput);\n        // NOTE: capture client inside notify using wrapper object\n        const notificationContext = {};\n        const notify = (method, params) => {\n            var _a;\n            (_a = notificationContext.client) === null || _a === void 0 ? void 0 : _a.emit(method, params);\n        };\n        const clock = new core_1.default.nekoton.ClockWithOffset();\n        if (params.clock != null) {\n            params.clock['impls'].push(clock);\n            clock.updateOffset(params.clock.offset);\n        }\n        try {\n            const connectionController = await (0, ConnectionController_1.createConnectionController)(clock, params.connection);\n            const subscriptionController = new SubscriptionController_1.SubscriptionController(connectionController, notify);\n            const client = new EverscaleStandaloneClient({\n                permissions: {},\n                connectionController,\n                subscriptionController,\n                properties: {\n                    message: validateMessageProperties(params.message),\n                },\n                keystore: params.keystore,\n                accountsStorage: params.accountsStorage,\n                clock,\n                notify,\n            });\n            // NOTE: WeakRef is not working here, so hope it will be garbage collected\n            notificationContext.client = client;\n            return client;\n        }\n        catch (e) {\n            if (params.clock != null) {\n                params.clock['impls'].pop();\n            }\n            clock.free();\n            throw e;\n        }\n    }\n    request(req) {\n        const handler = this._handlers[req.method];\n        if (handler == null) {\n            throw invalidRequest(req, `Method '${req.method}' is not supported by standalone provider`);\n        }\n        return handler(this._context, req);\n    }\n    addListener(eventName, listener) {\n        return super.addListener(eventName, listener);\n    }\n    removeListener(eventName, listener) {\n        return super.removeListener(eventName, listener);\n    }\n    on(eventName, listener) {\n        return super.on(eventName, listener);\n    }\n    once(eventName, listener) {\n        return super.once(eventName, listener);\n    }\n    prependListener(eventName, listener) {\n        return super.prependListener(eventName, listener);\n    }\n    prependOnceListener(eventName, listener) {\n        return super.prependOnceListener(eventName, listener);\n    }\n}\nexports.EverscaleStandaloneClient = EverscaleStandaloneClient;\nconst requestPermissions = async (ctx, req) => {\n    requireParams(req);\n    const { permissions } = req.params;\n    requireArray(req, req.params, 'permissions');\n    const newPermissions = { ...ctx.permissions };\n    for (const permission of permissions) {\n        if (permission === 'basic' || permission === 'tonClient') {\n            newPermissions.basic = true;\n        }\n        else if (permission === 'accountInteraction') {\n            if (newPermissions.accountInteraction != null) {\n                continue;\n            }\n            newPermissions.accountInteraction = await makeAccountInteractionPermission(req, ctx);\n        }\n        else {\n            throw invalidRequest(req, `Permission '${permission}' is not supported by standalone provider`);\n        }\n    }\n    ctx.permissions = newPermissions;\n    // NOTE: be sure to return object copy to prevent adding new permissions\n    const permissionsCopy = JSON.parse(JSON.stringify(newPermissions));\n    ctx.notify('permissionsChanged', {\n        permissions: permissionsCopy,\n    });\n    return permissionsCopy;\n};\nconst changeAccount = async (ctx, req) => {\n    requireAccountsStorage(req, ctx);\n    const newPermissions = { ...ctx.permissions };\n    newPermissions.accountInteraction = await makeAccountInteractionPermission(req, ctx);\n    ctx.permissions = newPermissions;\n    // NOTE: be sure to return object copy to prevent adding new permissions\n    const permissionsCopy = JSON.parse(JSON.stringify(newPermissions));\n    ctx.notify('permissionsChanged', {\n        permissions: permissionsCopy,\n    });\n    return permissionsCopy;\n};\nconst disconnect = async (ctx, _req) => {\n    ctx.permissions = {};\n    await ctx.subscriptionController.unsubscribeFromAllContracts();\n    ctx.notify('permissionsChanged', { permissions: {} });\n    return undefined;\n};\nconst subscribe = async (ctx, req) => {\n    requireParams(req);\n    const { address, subscriptions } = req.params;\n    requireString(req, req.params, 'address');\n    requireOptionalObject(req, req.params, 'subscriptions');\n    let repackedAddress;\n    try {\n        repackedAddress = nekoton.repackAddress(address);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    try {\n        return await ctx.subscriptionController.subscribeToContract(repackedAddress, subscriptions);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst unsubscribe = async (ctx, req) => {\n    requireParams(req);\n    const { address } = req.params;\n    requireString(req, req.params, 'address');\n    let repackedAddress;\n    try {\n        repackedAddress = nekoton.repackAddress(address);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    await ctx.subscriptionController.unsubscribeFromContract(repackedAddress);\n    return undefined;\n};\nconst unsubscribeAll = async (ctx, _req) => {\n    await ctx.subscriptionController.unsubscribeFromAllContracts();\n    return undefined;\n};\nconst getProviderState = async (ctx, req) => {\n    const transport = ctx.connectionController.initializedTransport;\n    if (transport == null) {\n        throw invalidRequest(req, 'Connection controller was not initialized');\n    }\n    const version = exports.VERSION;\n    return {\n        version,\n        numericVersion: (0, utils_1.convertVersionToInt32)(version),\n        networkId: transport.id,\n        selectedConnection: transport.group,\n        supportedPermissions: [...exports.SUPPORTED_PERMISSIONS],\n        permissions: JSON.parse(JSON.stringify(ctx.permissions)),\n        subscriptions: ctx.subscriptionController.subscriptionStates,\n    };\n};\nconst getFullContractState = async (ctx, req) => {\n    requireParams(req);\n    const { address } = req.params;\n    requireString(req, req.params, 'address');\n    const { connectionController } = ctx;\n    try {\n        return connectionController.use(async ({ data: { transport } }) => ({\n            state: await transport.getFullContractState(address),\n        }));\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getAccountsByCodeHash = async (ctx, req) => {\n    requireParams(req);\n    const { codeHash, limit, continuation } = req.params;\n    requireString(req, req.params, 'codeHash');\n    requireOptionalNumber(req, req.params, 'limit');\n    requireOptionalString(req, req.params, 'continuation');\n    const { connectionController } = ctx;\n    try {\n        return connectionController.use(({ data: { transport } }) => transport.getAccountsByCodeHash(codeHash, limit || 50, continuation));\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getTransactions = async (ctx, req) => {\n    requireParams(req);\n    const { address, continuation, limit } = req.params;\n    requireString(req, req.params, 'address');\n    requireOptional(req, req.params, 'continuation', requireTransactionId);\n    requireOptionalNumber(req, req.params, 'limit');\n    const { connectionController } = ctx;\n    try {\n        return connectionController.use(({ data: { transport } }) => transport.getTransactions(address, continuation === null || continuation === void 0 ? void 0 : continuation.lt, limit || 50));\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getTransaction = async (ctx, req) => {\n    requireParams(req);\n    const { hash } = req.params;\n    requireString(req, req.params, 'hash');\n    const { connectionController } = ctx;\n    try {\n        return {\n            transaction: await connectionController.use(({ data: { transport } }) => transport.getTransaction(hash)),\n        };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst findTransaction = async (ctx, req) => {\n    requireParams(req);\n    const { inMessageHash } = req.params;\n    requireOptional(req, req.params, 'inMessageHash', requireString);\n    const { connectionController } = ctx;\n    // TODO: add more filters\n    if (inMessageHash == null) {\n        return {\n            transaction: undefined,\n        };\n    }\n    try {\n        return {\n            transaction: await connectionController.use(({ data: { transport } }) => transport.getDstTransaction(inMessageHash)),\n        };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst runLocal = async (ctx, req) => {\n    requireParams(req);\n    const { address, cachedState, responsible, functionCall } = req.params;\n    requireString(req, req.params, 'address');\n    requireOptional(req, req.params, 'cachedState', requireContractState);\n    requireOptionalBoolean(req, req.params, 'responsible');\n    requireFunctionCall(req, req.params, 'functionCall');\n    const { clock, connectionController } = ctx;\n    let contractState = cachedState;\n    if (contractState == null) {\n        contractState = await connectionController.use(async ({ data: { transport } }) => transport.getFullContractState(address));\n    }\n    if (contractState == null) {\n        throw invalidRequest(req, 'Account not found');\n    }\n    if (!contractState.isDeployed || contractState.lastTransactionId == null) {\n        throw invalidRequest(req, 'Account is not deployed');\n    }\n    try {\n        const { output, code } = nekoton.runLocal(clock, contractState.boc, functionCall.abi, functionCall.method, functionCall.params, responsible || false);\n        return { output, code };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getExpectedAddress = async (_ctx, req) => {\n    requireParams(req);\n    const { tvc, abi, workchain, publicKey, initParams } = req.params;\n    requireString(req, req.params, 'tvc');\n    requireString(req, req.params, 'abi');\n    requireOptionalNumber(req, req.params, 'workchain');\n    requireOptionalString(req, req.params, 'publicKey');\n    try {\n        return nekoton.getExpectedAddress(tvc, abi, workchain || 0, publicKey, initParams);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getBocHash = async (_ctx, req) => {\n    requireParams(req);\n    const { boc } = req.params;\n    requireString(req, req.params, 'boc');\n    try {\n        return { hash: nekoton.getBocHash(boc) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst packIntoCell = async (_ctx, req) => {\n    requireParams(req);\n    const { structure, data, abiVersion } = req.params;\n    requireArray(req, req.params, 'structure');\n    requireOptional(req, req.params, 'abiVersion', requireString);\n    try {\n        return { boc: nekoton.packIntoCell(structure, data, abiVersion) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst unpackFromCell = async (_ctx, req) => {\n    requireParams(req);\n    const { structure, boc, allowPartial, abiVersion } = req.params;\n    requireArray(req, req.params, 'structure');\n    requireString(req, req.params, 'boc');\n    requireBoolean(req, req.params, 'allowPartial');\n    requireOptional(req, req.params, 'abiVersion', requireString);\n    try {\n        return { data: nekoton.unpackFromCell(structure, boc, allowPartial, abiVersion) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst extractPublicKey = async (_ctx, req) => {\n    requireParams(req);\n    const { boc } = req.params;\n    requireString(req, req.params, 'boc');\n    try {\n        return { publicKey: nekoton.extractPublicKey(boc) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst codeToTvc = async (_ctx, req) => {\n    requireParams(req);\n    const { code } = req.params;\n    requireString(req, req.params, 'code');\n    try {\n        return { tvc: nekoton.codeToTvc(code) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst mergeTvc = async (_ctx, req) => {\n    requireParams(req);\n    const { code, data } = req.params;\n    requireString(req, req.params, 'code');\n    requireString(req, req.params, 'data');\n    try {\n        return { tvc: nekoton.mergeTvc(code, data) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst splitTvc = async (_ctx, req) => {\n    requireParams(req);\n    const { tvc } = req.params;\n    requireString(req, req.params, 'tvc');\n    try {\n        return nekoton.splitTvc(tvc);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst setCodeSalt = async (_ctx, req) => {\n    requireParams(req);\n    const { code, salt } = req.params;\n    requireString(req, req.params, 'code');\n    requireString(req, req.params, 'salt');\n    try {\n        return { code: nekoton.setCodeSalt(code, salt) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getCodeSalt = async (_ctx, req) => {\n    requireParams(req);\n    const { code } = req.params;\n    requireString(req, req.params, 'code');\n    try {\n        return { salt: nekoton.getCodeSalt(code) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst encodeInternalInput = async (_ctx, req) => {\n    requireParams(req);\n    requireFunctionCall(req, req, 'params');\n    const { abi, method, params } = req.params;\n    try {\n        return { boc: nekoton.encodeInternalInput(abi, method, params) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeInput = async (_ctx, req) => {\n    requireParams(req);\n    const { body, abi, method, internal } = req.params;\n    requireString(req, req.params, 'body');\n    requireString(req, req.params, 'abi');\n    requireMethodOrArray(req, req.params, 'method');\n    requireBoolean(req, req.params, 'internal');\n    try {\n        return nekoton.decodeInput(body, abi, method, internal) || null;\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeOutput = async (_ctx, req) => {\n    requireParams(req);\n    const { body, abi, method } = req.params;\n    requireString(req, req.params, 'body');\n    requireString(req, req.params, 'abi');\n    requireMethodOrArray(req, req.params, 'method');\n    try {\n        return nekoton.decodeOutput(body, abi, method) || null;\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeEvent = async (_ctx, req) => {\n    requireParams(req);\n    const { body, abi, event } = req.params;\n    requireString(req, req.params, 'body');\n    requireString(req, req.params, 'abi');\n    requireMethodOrArray(req, req.params, 'event');\n    try {\n        return nekoton.decodeEvent(body, abi, event) || null;\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeTransaction = async (_ctx, req) => {\n    requireParams(req);\n    const { transaction, abi, method } = req.params;\n    requireString(req, req.params, 'abi');\n    requireMethodOrArray(req, req.params, 'method');\n    try {\n        return nekoton.decodeTransaction(transaction, abi, method) || null;\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeTransactionEvents = async (_ctx, req) => {\n    requireParams(req);\n    const { transaction, abi } = req.params;\n    requireString(req, req.params, 'abi');\n    try {\n        return { events: nekoton.decodeTransactionEvents(transaction, abi) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst verifySignature = async (_ctx, req) => {\n    requireParams(req);\n    const { publicKey, dataHash, signature } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'dataHash');\n    requireString(req, req.params, 'signature');\n    try {\n        return { isValid: nekoton.verifySignature(publicKey, dataHash, signature) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst sendUnsignedExternalMessage = async (ctx, req) => {\n    requireParams(req);\n    const { recipient, stateInit, payload, local } = req.params;\n    requireString(req, req.params, 'recipient');\n    requireOptionalString(req, req.params, 'stateInit');\n    requireOptionalRawFunctionCall(req, req.params, 'payload');\n    requireOptionalBoolean(req, req.params, 'local');\n    let repackedRecipient;\n    try {\n        repackedRecipient = nekoton.repackAddress(recipient);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    const { clock, subscriptionController, properties } = ctx;\n    const makeSignedMessage = (timeout) => {\n        try {\n            if (typeof payload === 'string' || payload == null) {\n                const expireAt = ~~(clock.nowMs / 1000) + timeout;\n                return nekoton.createRawExternalMessage(repackedRecipient, stateInit, payload, expireAt);\n            }\n            else {\n                return nekoton.createExternalMessageWithoutSignature(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, timeout);\n            }\n        }\n        catch (e) {\n            throw invalidRequest(req, e.toString());\n        }\n    };\n    const handleTransaction = (transaction) => {\n        let output;\n        try {\n            if (typeof payload === 'object' && typeof payload != null) {\n                const decoded = nekoton.decodeTransaction(transaction, payload.abi, payload.method);\n                output = decoded === null || decoded === void 0 ? void 0 : decoded.output;\n            }\n        }\n        catch (_) { /* do nothing */\n        }\n        return { transaction, output };\n    };\n    // Force local execution\n    if (local === true) {\n        const signedMessage = makeSignedMessage(60);\n        const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage);\n        return handleTransaction(transaction);\n    }\n    // Send and wait with several retries\n    let timeout = properties.message.timeout;\n    for (let retry = 0; retry < properties.message.retryCount; ++retry) {\n        const signedMessage = makeSignedMessage(timeout);\n        const transaction = await subscriptionController.sendMessage(repackedRecipient, signedMessage);\n        if (transaction == null) {\n            timeout *= properties.message.timeoutGrowFactor;\n            continue;\n        }\n        return handleTransaction(transaction);\n    }\n    // Execute locally\n    const errorMessage = 'Message expired';\n    const signedMessage = makeSignedMessage(60);\n    const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage)\n        .catch((e) => {\n        throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);\n    });\n    const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';\n    throw invalidRequest(req, `${errorMessage}${additionalText}`);\n};\nconst signData = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireParams(req);\n    const { publicKey, data } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'data');\n    const { keystore } = ctx;\n    const signer = await keystore.getSigner(publicKey);\n    if (signer == null) {\n        throw invalidRequest(req, 'Signer not found for public key');\n    }\n    try {\n        const dataHash = nekoton.getDataHash(data);\n        return {\n            dataHash,\n            ...(await signer.sign(dataHash).then(nekoton.extendSignature)),\n        };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst signDataRaw = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireParams(req);\n    const { publicKey, data } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'data');\n    const { keystore } = ctx;\n    const signer = await keystore.getSigner(publicKey);\n    if (signer == null) {\n        throw invalidRequest(req, 'Signer not found for public key');\n    }\n    try {\n        return await signer.sign(data).then(nekoton.extendSignature);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst sendMessage = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireAccountsStorage(req, ctx);\n    requireParams(req);\n    const { sender, recipient, amount, bounce, payload } = req.params;\n    requireString(req, req.params, 'sender');\n    requireString(req, req.params, 'recipient');\n    requireString(req, req.params, 'amount');\n    requireBoolean(req, req.params, 'bounce');\n    requireOptional(req, req.params, 'payload', requireFunctionCall);\n    const { clock, properties, subscriptionController, connectionController, keystore, accountsStorage } = ctx;\n    let repackedSender;\n    let repackedRecipient;\n    let account;\n    try {\n        repackedSender = nekoton.repackAddress(sender);\n        repackedRecipient = nekoton.repackAddress(recipient);\n        account = await accountsStorage.getAccount(repackedSender).then((account) => {\n            if (account != null) {\n                return account;\n            }\n            else {\n                throw new Error('Sender not found');\n            }\n        });\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    const makeSignedMessage = async (timeout) => {\n        try {\n            return account.prepareMessage({\n                recipient: repackedRecipient,\n                amount,\n                bounce,\n                payload,\n                stateInit: undefined,\n                timeout,\n            }, new AccountsStorage_1.AccountsStorageContext(clock, connectionController, nekoton, keystore));\n        }\n        catch (e) {\n            throw invalidRequest(req, e.toString());\n        }\n    };\n    // Send and wait with several retries\n    let timeout = properties.message.timeout;\n    // Set `retryCount` if not explicitly disabled\n    const retryCount = properties.message.retryTransfers !== false ? properties.message.retryCount : 1;\n    for (let retry = 0; retry < retryCount; ++retry) {\n        const signedMessage = await makeSignedMessage(timeout);\n        const transaction = await subscriptionController.sendMessage(repackedSender, signedMessage);\n        if (transaction == null) {\n            timeout *= properties.message.timeoutGrowFactor;\n            continue;\n        }\n        return { transaction };\n    }\n    // Execute locally\n    const errorMessage = 'Message expired';\n    const signedMessage = await makeSignedMessage(60);\n    const transaction = await subscriptionController.sendMessageLocally(repackedSender, signedMessage)\n        .catch((e) => {\n        throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);\n    });\n    const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';\n    throw invalidRequest(req, `${errorMessage}${additionalText}`);\n};\nconst sendMessageDelayed = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireAccountsStorage(req, ctx);\n    requireParams(req);\n    const { sender, recipient, amount, bounce, payload } = req.params;\n    requireString(req, req.params, 'sender');\n    requireString(req, req.params, 'recipient');\n    requireString(req, req.params, 'amount');\n    requireBoolean(req, req.params, 'bounce');\n    requireOptional(req, req.params, 'payload', requireFunctionCall);\n    const { clock, subscriptionController, connectionController, keystore, accountsStorage, notify } = ctx;\n    let repackedSender;\n    let repackedRecipient;\n    try {\n        repackedSender = nekoton.repackAddress(sender);\n        repackedRecipient = nekoton.repackAddress(recipient);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    let signedMessage;\n    try {\n        const account = await accountsStorage.getAccount(repackedSender);\n        if (account == null) {\n            throw new Error('Sender not found');\n        }\n        signedMessage = await account.prepareMessage({\n            recipient: repackedRecipient,\n            amount,\n            bounce,\n            payload,\n            stateInit: undefined,\n            timeout: 60, // TEMP\n        }, new AccountsStorage_1.AccountsStorageContext(clock, connectionController, nekoton, keystore));\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    subscriptionController.sendMessage(repackedSender, signedMessage)\n        .then(transaction => {\n        notify('messageStatusUpdated', {\n            address: repackedSender,\n            hash: signedMessage.hash,\n            transaction,\n        });\n    })\n        .catch(console.error);\n    return {\n        message: {\n            account: repackedSender,\n            hash: signedMessage.hash,\n            expireAt: signedMessage.expireAt,\n        },\n    };\n};\nconst sendExternalMessage = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireParams(req);\n    const { publicKey, recipient, stateInit, payload, local } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'recipient');\n    requireOptionalString(req, req.params, 'stateInit');\n    requireFunctionCall(req, req.params, 'payload');\n    requireOptionalBoolean(req, req.params, 'local');\n    let repackedRecipient;\n    try {\n        repackedRecipient = nekoton.repackAddress(recipient);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    const { clock, subscriptionController, keystore, properties } = ctx;\n    const signer = await keystore.getSigner(publicKey);\n    if (signer == null) {\n        throw invalidRequest(req, 'Signer not found for public key');\n    }\n    const makeSignedMessage = async (timeout) => {\n        let unsignedMessage;\n        try {\n            unsignedMessage = nekoton.createExternalMessage(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, publicKey, timeout);\n        }\n        catch (e) {\n            throw invalidRequest(req, e.toString());\n        }\n        try {\n            const signature = await signer.sign(unsignedMessage.hash);\n            return unsignedMessage.sign(signature);\n        }\n        catch (e) {\n            throw invalidRequest(req, e.toString());\n        }\n        finally {\n            unsignedMessage.free();\n        }\n    };\n    const handleTransaction = (transaction) => {\n        let output;\n        try {\n            const decoded = nekoton.decodeTransaction(transaction, payload.abi, payload.method);\n            output = decoded === null || decoded === void 0 ? void 0 : decoded.output;\n        }\n        catch (_) { /* do nothing */\n        }\n        return { transaction, output };\n    };\n    // Force local execution\n    if (local === true) {\n        const signedMessage = await makeSignedMessage(60);\n        const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage);\n        return handleTransaction(transaction);\n    }\n    // Send and wait with several retries\n    let timeout = properties.message.timeout;\n    for (let retry = 0; retry < properties.message.retryCount; ++retry) {\n        const signedMessage = await makeSignedMessage(timeout);\n        const transaction = await subscriptionController.sendMessage(repackedRecipient, signedMessage);\n        if (transaction == null) {\n            timeout *= properties.message.timeoutGrowFactor;\n            continue;\n        }\n        return handleTransaction(transaction);\n    }\n    // Execute locally\n    const errorMessage = 'Message expired';\n    const signedMessage = await makeSignedMessage(60);\n    const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage)\n        .catch((e) => {\n        throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);\n    });\n    const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';\n    throw invalidRequest(req, `${errorMessage}${additionalText}`);\n};\nconst sendExternalMessageDelayed = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireParams(req);\n    const { publicKey, recipient, stateInit, payload } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'recipient');\n    requireOptionalString(req, req.params, 'stateInit');\n    requireFunctionCall(req, req.params, 'payload');\n    let repackedRecipient;\n    try {\n        repackedRecipient = nekoton.repackAddress(recipient);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    const { clock, subscriptionController, keystore, properties, notify } = ctx;\n    const signer = await keystore.getSigner(publicKey);\n    if (signer == null) {\n        throw invalidRequest(req, 'Signer not found for public key');\n    }\n    let unsignedMessage;\n    try {\n        unsignedMessage = nekoton.createExternalMessage(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, publicKey, properties.message.timeout);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    let signedMessage;\n    try {\n        const signature = await signer.sign(unsignedMessage.hash);\n        signedMessage = unsignedMessage.sign(signature);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    finally {\n        unsignedMessage.free();\n    }\n    subscriptionController.sendMessage(repackedRecipient, signedMessage)\n        .then(transaction => {\n        notify('messageStatusUpdated', {\n            address: repackedRecipient,\n            hash: signedMessage.hash,\n            transaction,\n        });\n    })\n        .catch(console.error);\n    return {\n        message: {\n            account: repackedRecipient,\n            hash: signedMessage.hash,\n            expireAt: signedMessage.expireAt,\n        },\n    };\n};\nfunction requireKeystore(req, context) {\n    if (context.keystore == null) {\n        throw invalidRequest(req, 'Keystore not found');\n    }\n}\nfunction requireAccountsStorage(req, context) {\n    if (context.accountsStorage == null) {\n        throw invalidRequest(req, 'AccountsStorage not found');\n    }\n}\nfunction requireParams(req) {\n    if (req.params == null || typeof req.params !== 'object') {\n        throw invalidRequest(req, 'required params object');\n    }\n}\nfunction requireObject(req, object, key) {\n    const property = object[key];\n    if (typeof property !== 'object') {\n        throw invalidRequest(req, `'${String(key)}' must be an object`);\n    }\n}\nfunction requireOptionalObject(req, object, key) {\n    const property = object[key];\n    if (property != null && typeof property !== 'object') {\n        throw invalidRequest(req, `'${String(key)}' must be an object if specified`);\n    }\n}\nfunction requireBoolean(req, object, key) {\n    const property = object[key];\n    if (typeof property !== 'boolean') {\n        throw invalidRequest(req, `'${String(key)}' must be a boolean`);\n    }\n}\nfunction requireOptionalBoolean(req, object, key) {\n    const property = object[key];\n    if (property != null && typeof property !== 'boolean') {\n        throw invalidRequest(req, `'${String(key)}' must be a boolean if specified`);\n    }\n}\nfunction requireString(req, object, key) {\n    const property = object[key];\n    if (typeof property !== 'string' || property.length === 0) {\n        throw invalidRequest(req, `'${String(key)}' must be non-empty string`);\n    }\n}\nfunction requireOptionalString(req, object, key) {\n    const property = object[key];\n    if (property != null && (typeof property !== 'string' || property.length === 0)) {\n        throw invalidRequest(req, `'${String(key)}' must be a non-empty string if provided`);\n    }\n}\nfunction requireOptionalNumber(req, object, key) {\n    const property = object[key];\n    if (property != null && typeof property !== 'number') {\n        throw invalidRequest(req, `'${String(key)}' must be a number if provider`);\n    }\n}\nfunction requireArray(req, object, key) {\n    const property = object[key];\n    if (!Array.isArray(property)) {\n        throw invalidRequest(req, `'${String(key)}' must be an array`);\n    }\n}\nfunction requireOptional(req, object, key, predicate) {\n    const property = object[key];\n    if (property != null) {\n        predicate(req, object, key);\n    }\n}\nfunction requireTransactionId(req, object, key) {\n    requireObject(req, object, key);\n    const property = object[key];\n    requireString(req, property, 'lt');\n    requireString(req, property, 'hash');\n}\nfunction requireLastTransactionId(req, object, key) {\n    requireObject(req, object, key);\n    const property = object[key];\n    requireBoolean(req, property, 'isExact');\n    requireString(req, property, 'lt');\n    requireOptionalString(req, property, 'hash');\n}\nfunction requireContractState(req, object, key) {\n    requireObject(req, object, key);\n    const property = object[key];\n    requireString(req, property, 'balance');\n    requireOptional(req, property, 'lastTransactionId', requireLastTransactionId);\n    requireBoolean(req, property, 'isDeployed');\n}\nfunction requireFunctionCall(req, object, key) {\n    requireObject(req, object, key);\n    const property = object[key];\n    requireString(req, property, 'abi');\n    requireString(req, property, 'method');\n    requireObject(req, property, 'params');\n}\nfunction requireOptionalRawFunctionCall(req, object, key) {\n    const property = object[key];\n    if (typeof property === 'string' || property == null) {\n        return;\n    }\n    else if (typeof property === 'object') {\n        requireString(req, property, 'abi');\n        requireString(req, property, 'method');\n        requireObject(req, property, 'params');\n    }\n    else {\n        throw invalidRequest(req, `'${String(key)}' must be a function all or optional string`);\n    }\n}\nfunction requireMethodOrArray(req, object, key) {\n    const property = object[key];\n    if (property != null && typeof property !== 'string' && !Array.isArray(property)) {\n        throw invalidRequest(req, `'${String(key)}' must be a method name or an array of possible names`);\n    }\n}\nasync function makeAccountInteractionPermission(req, ctx) {\n    requireAccountsStorage(req, ctx);\n    const defaultAccount = ctx.accountsStorage.defaultAccount;\n    if (defaultAccount == null) {\n        throw invalidRequest(req, 'Default account not set in accounts storage');\n    }\n    const account = await ctx.accountsStorage.getAccount(defaultAccount);\n    if (account == null) {\n        throw invalidRequest(req, 'Default account not found');\n    }\n    const publicKey = await account.fetchPublicKey(new AccountsStorage_1.AccountsStorageContext(ctx.clock, ctx.connectionController, nekoton));\n    return {\n        address: account.address.toString(),\n        publicKey,\n        contractType: 'unknown',\n    };\n}\nconst invalidRequest = (req, message, data) => new NekotonRpcError(2, `${req.method}: ${message}`, data);\nclass NekotonRpcError extends Error {\n    constructor(code, message, data) {\n        if (!Number.isInteger(code)) {\n            throw new Error('\"code\" must be an integer');\n        }\n        if (!message || typeof message !== 'string') {\n            throw new Error('\"message\" must be a nonempty string');\n        }\n        super(message);\n        this.code = code;\n        this.data = data;\n    }\n    serialize() {\n        const serialized = {\n            code: this.code,\n            message: this.message,\n        };\n        if (this.data !== undefined) {\n            serialized.data = this.data;\n        }\n        if (this.stack) {\n            serialized.stack = this.stack;\n        }\n        return serialized;\n    }\n    toString() {\n        return (0, fast_safe_stringify_1.default)(this.serialize(), stringifyReplacer, 2);\n    }\n}\nconst stringifyReplacer = (_, value) => {\n    if (value === '[Circular]') {\n        return undefined;\n    }\n    return value;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9ldmVyc2NhbGUtc3RhbmRhbG9uZS1jbGllbnQvY2xpZW50L2luZGV4LmpzP2UxMDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXZlcnNjYWxlU3RhbmRhbG9uZUNsaWVudCA9IGV4cG9ydHMuU1VQUE9SVEVEX1BFUk1JU1NJT05TID0gZXhwb3J0cy5WRVJTSU9OID0gZXhwb3J0cy5ERUZBVUxUX0NMSUVOVF9QUk9QRVJUSUVTID0gZXhwb3J0cy5DbG9jayA9IGV4cG9ydHMuU2ltcGxlS2V5c3RvcmUgPSBleHBvcnRzLmNoZWNrQ29ubmVjdGlvbiA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5ORVRXT1JLX1BSRVNFVFMgPSB2b2lkIDA7XG5jb25zdCBmYXN0X3NhZmVfc3RyaW5naWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImZhc3Qtc2FmZS1zdHJpbmdpZnlcIikpO1xuY29uc3QgY29yZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9jb3JlXCIpKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IENvbm5lY3Rpb25Db250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi9Db25uZWN0aW9uQ29udHJvbGxlclwiKTtcbmNvbnN0IFN1YnNjcmlwdGlvbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL1N1YnNjcmlwdGlvbkNvbnRyb2xsZXJcIik7XG5jb25zdCBBY2NvdW50c1N0b3JhZ2VfMSA9IHJlcXVpcmUoXCIuL0FjY291bnRzU3RvcmFnZVwiKTtcbnZhciBDb25uZWN0aW9uQ29udHJvbGxlcl8yID0gcmVxdWlyZShcIi4vQ29ubmVjdGlvbkNvbnRyb2xsZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJORVRXT1JLX1BSRVNFVFNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvbm5lY3Rpb25Db250cm9sbGVyXzIuTkVUV09SS19QUkVTRVRTOyB9IH0pO1xudmFyIENvbm5lY3Rpb25Db250cm9sbGVyXzMgPSByZXF1aXJlKFwiLi9Db25uZWN0aW9uQ29udHJvbGxlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25FcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ29ubmVjdGlvbkNvbnRyb2xsZXJfMy5Db25uZWN0aW9uRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjaGVja0Nvbm5lY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvbm5lY3Rpb25Db250cm9sbGVyXzMuY2hlY2tDb25uZWN0aW9uOyB9IH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0FjY291bnRzU3RvcmFnZVwiKSwgZXhwb3J0cyk7XG52YXIga2V5c3RvcmVfMSA9IHJlcXVpcmUoXCIuL2tleXN0b3JlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2ltcGxlS2V5c3RvcmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGtleXN0b3JlXzEuU2ltcGxlS2V5c3RvcmU7IH0gfSk7XG52YXIgY2xvY2tfMSA9IHJlcXVpcmUoXCIuL2Nsb2NrXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2xvY2tcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsb2NrXzEuQ2xvY2s7IH0gfSk7XG5jb25zdCB7IGVuc3VyZU5la290b25Mb2FkZWQsIG5la290b24gfSA9IGNvcmVfMS5kZWZhdWx0O1xuZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlUHJvcGVydGllcyhtZXNzYWdlKSB7XG4gICAgY29uc3QgbSA9IG1lc3NhZ2UgfHwge307XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmV0cnlDb3VudDogbS5yZXRyeUNvdW50ICE9IG51bGwgPyBNYXRoLm1heCgxLCB+fm0ucmV0cnlDb3VudCkgOiA1LFxuICAgICAgICB0aW1lb3V0OiBtLnRpbWVvdXQgIT0gbnVsbCA/IE1hdGgubWF4KDEsIH5+bS50aW1lb3V0KSA6IDYwLFxuICAgICAgICB0aW1lb3V0R3Jvd0ZhY3RvcjogbS50aW1lb3V0R3Jvd0ZhY3RvciB8fCAxLjIsXG4gICAgICAgIHJldHJ5VHJhbnNmZXJzOiB0cnVlLFxuICAgIH07XG59XG4vKipcbiAqIEBjYXRlZ29yeSBDbGllbnRcbiAqL1xuZXhwb3J0cy5ERUZBVUxUX0NMSUVOVF9QUk9QRVJUSUVTID0ge1xuICAgIGNvbm5lY3Rpb246IENvbm5lY3Rpb25Db250cm9sbGVyXzEuREVGQVVMVF9ORVRXT1JLX0dST1VQLFxufTtcbi8qKlxuICogQGNhdGVnb3J5IENsaWVudFxuICovXG5leHBvcnRzLlZFUlNJT04gPSAnMC4yLjI1Jztcbi8qKlxuICogQGNhdGVnb3J5IENsaWVudFxuICovXG5leHBvcnRzLlNVUFBPUlRFRF9QRVJNSVNTSU9OUyA9IFsnYmFzaWMnLCAnYWNjb3VudEludGVyYWN0aW9uJ107XG4vKipcbiAqIEBjYXRlZ29yeSBDbGllbnRcbiAqL1xuY2xhc3MgRXZlcnNjYWxlU3RhbmRhbG9uZUNsaWVudCBleHRlbmRzIHV0aWxzXzEuU2FmZUV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge1xuICAgICAgICAgICAgcmVxdWVzdFBlcm1pc3Npb25zLFxuICAgICAgICAgICAgY2hhbmdlQWNjb3VudCxcbiAgICAgICAgICAgIGRpc2Nvbm5lY3QsXG4gICAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgICB1bnN1YnNjcmliZSxcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlQWxsLFxuICAgICAgICAgICAgZ2V0UHJvdmlkZXJTdGF0ZSxcbiAgICAgICAgICAgIGdldEZ1bGxDb250cmFjdFN0YXRlLFxuICAgICAgICAgICAgZ2V0QWNjb3VudHNCeUNvZGVIYXNoLFxuICAgICAgICAgICAgZ2V0VHJhbnNhY3Rpb25zLFxuICAgICAgICAgICAgZ2V0VHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBmaW5kVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBydW5Mb2NhbCxcbiAgICAgICAgICAgIGdldEV4cGVjdGVkQWRkcmVzcyxcbiAgICAgICAgICAgIGdldEJvY0hhc2gsXG4gICAgICAgICAgICBwYWNrSW50b0NlbGwsXG4gICAgICAgICAgICB1bnBhY2tGcm9tQ2VsbCxcbiAgICAgICAgICAgIGV4dHJhY3RQdWJsaWNLZXksXG4gICAgICAgICAgICBjb2RlVG9UdmMsXG4gICAgICAgICAgICBtZXJnZVR2YyxcbiAgICAgICAgICAgIHNwbGl0VHZjLFxuICAgICAgICAgICAgc2V0Q29kZVNhbHQsXG4gICAgICAgICAgICBnZXRDb2RlU2FsdCxcbiAgICAgICAgICAgIGVuY29kZUludGVybmFsSW5wdXQsXG4gICAgICAgICAgICBkZWNvZGVJbnB1dCxcbiAgICAgICAgICAgIGRlY29kZU91dHB1dCxcbiAgICAgICAgICAgIGRlY29kZUV2ZW50LFxuICAgICAgICAgICAgZGVjb2RlVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBkZWNvZGVUcmFuc2FjdGlvbkV2ZW50cyxcbiAgICAgICAgICAgIHZlcmlmeVNpZ25hdHVyZSxcbiAgICAgICAgICAgIHNlbmRVbnNpZ25lZEV4dGVybmFsTWVzc2FnZSxcbiAgICAgICAgICAgIC8vIGFkZEFzc2V0LCAvLyBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICBzaWduRGF0YSxcbiAgICAgICAgICAgIHNpZ25EYXRhUmF3LFxuICAgICAgICAgICAgLy8gZW5jcnlwdERhdGEsIC8vIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIC8vIGRlY3J5cHREYXRhLCAvLyBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAvLyBlc3RpbWF0ZUZlZXMsIC8vIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlLFxuICAgICAgICAgICAgc2VuZE1lc3NhZ2VEZWxheWVkLFxuICAgICAgICAgICAgc2VuZEV4dGVybmFsTWVzc2FnZSxcbiAgICAgICAgICAgIHNlbmRFeHRlcm5hbE1lc3NhZ2VEZWxheWVkLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY3R4O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKHBhcmFtcykge1xuICAgICAgICBhd2FpdCBlbnN1cmVOZWtvdG9uTG9hZGVkKHBhcmFtcy5pbml0SW5wdXQpO1xuICAgICAgICAvLyBOT1RFOiBjYXB0dXJlIGNsaWVudCBpbnNpZGUgbm90aWZ5IHVzaW5nIHdyYXBwZXIgb2JqZWN0XG4gICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbkNvbnRleHQgPSB7fTtcbiAgICAgICAgY29uc3Qgbm90aWZ5ID0gKG1ldGhvZCwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSBub3RpZmljYXRpb25Db250ZXh0LmNsaWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtaXQobWV0aG9kLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjbG9jayA9IG5ldyBjb3JlXzEuZGVmYXVsdC5uZWtvdG9uLkNsb2NrV2l0aE9mZnNldCgpO1xuICAgICAgICBpZiAocGFyYW1zLmNsb2NrICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmFtcy5jbG9ja1snaW1wbHMnXS5wdXNoKGNsb2NrKTtcbiAgICAgICAgICAgIGNsb2NrLnVwZGF0ZU9mZnNldChwYXJhbXMuY2xvY2sub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbkNvbnRyb2xsZXIgPSBhd2FpdCAoMCwgQ29ubmVjdGlvbkNvbnRyb2xsZXJfMS5jcmVhdGVDb25uZWN0aW9uQ29udHJvbGxlcikoY2xvY2ssIHBhcmFtcy5jb25uZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbkNvbnRyb2xsZXIgPSBuZXcgU3Vic2NyaXB0aW9uQ29udHJvbGxlcl8xLlN1YnNjcmlwdGlvbkNvbnRyb2xsZXIoY29ubmVjdGlvbkNvbnRyb2xsZXIsIG5vdGlmeSk7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBuZXcgRXZlcnNjYWxlU3RhbmRhbG9uZUNsaWVudCh7XG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHt9LFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Db250cm9sbGVyLFxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbkNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB2YWxpZGF0ZU1lc3NhZ2VQcm9wZXJ0aWVzKHBhcmFtcy5tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGtleXN0b3JlOiBwYXJhbXMua2V5c3RvcmUsXG4gICAgICAgICAgICAgICAgYWNjb3VudHNTdG9yYWdlOiBwYXJhbXMuYWNjb3VudHNTdG9yYWdlLFxuICAgICAgICAgICAgICAgIGNsb2NrLFxuICAgICAgICAgICAgICAgIG5vdGlmeSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTk9URTogV2Vha1JlZiBpcyBub3Qgd29ya2luZyBoZXJlLCBzbyBob3BlIGl0IHdpbGwgYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbkNvbnRleHQuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5jbG9jayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNsb2NrWydpbXBscyddLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xvY2suZnJlZSgpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0KHJlcSkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5faGFuZGxlcnNbcmVxLm1ldGhvZF07XG4gICAgICAgIGlmIChoYW5kbGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYE1ldGhvZCAnJHtyZXEubWV0aG9kfScgaXMgbm90IHN1cHBvcnRlZCBieSBzdGFuZGFsb25lIHByb3ZpZGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZXIodGhpcy5fY29udGV4dCwgcmVxKTtcbiAgICB9XG4gICAgYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5vbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBwcmVwZW5kTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBwcmVwZW5kT25jZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnByZXBlbmRPbmNlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxufVxuZXhwb3J0cy5FdmVyc2NhbGVTdGFuZGFsb25lQ2xpZW50ID0gRXZlcnNjYWxlU3RhbmRhbG9uZUNsaWVudDtcbmNvbnN0IHJlcXVlc3RQZXJtaXNzaW9ucyA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IHBlcm1pc3Npb25zIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVBcnJheShyZXEsIHJlcS5wYXJhbXMsICdwZXJtaXNzaW9ucycpO1xuICAgIGNvbnN0IG5ld1Blcm1pc3Npb25zID0geyAuLi5jdHgucGVybWlzc2lvbnMgfTtcbiAgICBmb3IgKGNvbnN0IHBlcm1pc3Npb24gb2YgcGVybWlzc2lvbnMpIHtcbiAgICAgICAgaWYgKHBlcm1pc3Npb24gPT09ICdiYXNpYycgfHwgcGVybWlzc2lvbiA9PT0gJ3RvbkNsaWVudCcpIHtcbiAgICAgICAgICAgIG5ld1Blcm1pc3Npb25zLmJhc2ljID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwZXJtaXNzaW9uID09PSAnYWNjb3VudEludGVyYWN0aW9uJykge1xuICAgICAgICAgICAgaWYgKG5ld1Blcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdQZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb24gPSBhd2FpdCBtYWtlQWNjb3VudEludGVyYWN0aW9uUGVybWlzc2lvbihyZXEsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGBQZXJtaXNzaW9uICcke3Blcm1pc3Npb259JyBpcyBub3Qgc3VwcG9ydGVkIGJ5IHN0YW5kYWxvbmUgcHJvdmlkZXJgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjdHgucGVybWlzc2lvbnMgPSBuZXdQZXJtaXNzaW9ucztcbiAgICAvLyBOT1RFOiBiZSBzdXJlIHRvIHJldHVybiBvYmplY3QgY29weSB0byBwcmV2ZW50IGFkZGluZyBuZXcgcGVybWlzc2lvbnNcbiAgICBjb25zdCBwZXJtaXNzaW9uc0NvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG5ld1Blcm1pc3Npb25zKSk7XG4gICAgY3R4Lm5vdGlmeSgncGVybWlzc2lvbnNDaGFuZ2VkJywge1xuICAgICAgICBwZXJtaXNzaW9uczogcGVybWlzc2lvbnNDb3B5LFxuICAgIH0pO1xuICAgIHJldHVybiBwZXJtaXNzaW9uc0NvcHk7XG59O1xuY29uc3QgY2hhbmdlQWNjb3VudCA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVBY2NvdW50c1N0b3JhZ2UocmVxLCBjdHgpO1xuICAgIGNvbnN0IG5ld1Blcm1pc3Npb25zID0geyAuLi5jdHgucGVybWlzc2lvbnMgfTtcbiAgICBuZXdQZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb24gPSBhd2FpdCBtYWtlQWNjb3VudEludGVyYWN0aW9uUGVybWlzc2lvbihyZXEsIGN0eCk7XG4gICAgY3R4LnBlcm1pc3Npb25zID0gbmV3UGVybWlzc2lvbnM7XG4gICAgLy8gTk9URTogYmUgc3VyZSB0byByZXR1cm4gb2JqZWN0IGNvcHkgdG8gcHJldmVudCBhZGRpbmcgbmV3IHBlcm1pc3Npb25zXG4gICAgY29uc3QgcGVybWlzc2lvbnNDb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShuZXdQZXJtaXNzaW9ucykpO1xuICAgIGN0eC5ub3RpZnkoJ3Blcm1pc3Npb25zQ2hhbmdlZCcsIHtcbiAgICAgICAgcGVybWlzc2lvbnM6IHBlcm1pc3Npb25zQ29weSxcbiAgICB9KTtcbiAgICByZXR1cm4gcGVybWlzc2lvbnNDb3B5O1xufTtcbmNvbnN0IGRpc2Nvbm5lY3QgPSBhc3luYyAoY3R4LCBfcmVxKSA9PiB7XG4gICAgY3R4LnBlcm1pc3Npb25zID0ge307XG4gICAgYXdhaXQgY3R4LnN1YnNjcmlwdGlvbkNvbnRyb2xsZXIudW5zdWJzY3JpYmVGcm9tQWxsQ29udHJhY3RzKCk7XG4gICAgY3R4Lm5vdGlmeSgncGVybWlzc2lvbnNDaGFuZ2VkJywgeyBwZXJtaXNzaW9uczoge30gfSk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5jb25zdCBzdWJzY3JpYmUgPSBhc3luYyAoY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBzdWJzY3JpcHRpb25zIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYWRkcmVzcycpO1xuICAgIHJlcXVpcmVPcHRpb25hbE9iamVjdChyZXEsIHJlcS5wYXJhbXMsICdzdWJzY3JpcHRpb25zJyk7XG4gICAgbGV0IHJlcGFja2VkQWRkcmVzcztcbiAgICB0cnkge1xuICAgICAgICByZXBhY2tlZEFkZHJlc3MgPSBuZWtvdG9uLnJlcGFja0FkZHJlc3MoYWRkcmVzcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGN0eC5zdWJzY3JpcHRpb25Db250cm9sbGVyLnN1YnNjcmliZVRvQ29udHJhY3QocmVwYWNrZWRBZGRyZXNzLCBzdWJzY3JpcHRpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCB1bnN1YnNjcmliZSA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IGFkZHJlc3MgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdhZGRyZXNzJyk7XG4gICAgbGV0IHJlcGFja2VkQWRkcmVzcztcbiAgICB0cnkge1xuICAgICAgICByZXBhY2tlZEFkZHJlc3MgPSBuZWtvdG9uLnJlcGFja0FkZHJlc3MoYWRkcmVzcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgYXdhaXQgY3R4LnN1YnNjcmlwdGlvbkNvbnRyb2xsZXIudW5zdWJzY3JpYmVGcm9tQ29udHJhY3QocmVwYWNrZWRBZGRyZXNzKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmNvbnN0IHVuc3Vic2NyaWJlQWxsID0gYXN5bmMgKGN0eCwgX3JlcSkgPT4ge1xuICAgIGF3YWl0IGN0eC5zdWJzY3JpcHRpb25Db250cm9sbGVyLnVuc3Vic2NyaWJlRnJvbUFsbENvbnRyYWN0cygpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuY29uc3QgZ2V0UHJvdmlkZXJTdGF0ZSA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIGNvbnN0IHRyYW5zcG9ydCA9IGN0eC5jb25uZWN0aW9uQ29udHJvbGxlci5pbml0aWFsaXplZFRyYW5zcG9ydDtcbiAgICBpZiAodHJhbnNwb3J0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCAnQ29ubmVjdGlvbiBjb250cm9sbGVyIHdhcyBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgdmVyc2lvbiA9IGV4cG9ydHMuVkVSU0lPTjtcbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBudW1lcmljVmVyc2lvbjogKDAsIHV0aWxzXzEuY29udmVydFZlcnNpb25Ub0ludDMyKSh2ZXJzaW9uKSxcbiAgICAgICAgbmV0d29ya0lkOiB0cmFuc3BvcnQuaWQsXG4gICAgICAgIHNlbGVjdGVkQ29ubmVjdGlvbjogdHJhbnNwb3J0Lmdyb3VwLFxuICAgICAgICBzdXBwb3J0ZWRQZXJtaXNzaW9uczogWy4uLmV4cG9ydHMuU1VQUE9SVEVEX1BFUk1JU1NJT05TXSxcbiAgICAgICAgcGVybWlzc2lvbnM6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY3R4LnBlcm1pc3Npb25zKSksXG4gICAgICAgIHN1YnNjcmlwdGlvbnM6IGN0eC5zdWJzY3JpcHRpb25Db250cm9sbGVyLnN1YnNjcmlwdGlvblN0YXRlcyxcbiAgICB9O1xufTtcbmNvbnN0IGdldEZ1bGxDb250cmFjdFN0YXRlID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgYWRkcmVzcyB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2FkZHJlc3MnKTtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25Db250cm9sbGVyIH0gPSBjdHg7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25Db250cm9sbGVyLnVzZShhc3luYyAoeyBkYXRhOiB7IHRyYW5zcG9ydCB9IH0pID0+ICh7XG4gICAgICAgICAgICBzdGF0ZTogYXdhaXQgdHJhbnNwb3J0LmdldEZ1bGxDb250cmFjdFN0YXRlKGFkZHJlc3MpLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3QgZ2V0QWNjb3VudHNCeUNvZGVIYXNoID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgY29kZUhhc2gsIGxpbWl0LCBjb250aW51YXRpb24gfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdjb2RlSGFzaCcpO1xuICAgIHJlcXVpcmVPcHRpb25hbE51bWJlcihyZXEsIHJlcS5wYXJhbXMsICdsaW1pdCcpO1xuICAgIHJlcXVpcmVPcHRpb25hbFN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdjb250aW51YXRpb24nKTtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25Db250cm9sbGVyIH0gPSBjdHg7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25Db250cm9sbGVyLnVzZSgoeyBkYXRhOiB7IHRyYW5zcG9ydCB9IH0pID0+IHRyYW5zcG9ydC5nZXRBY2NvdW50c0J5Q29kZUhhc2goY29kZUhhc2gsIGxpbWl0IHx8IDUwLCBjb250aW51YXRpb24pKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBnZXRUcmFuc2FjdGlvbnMgPSBhc3luYyAoY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjb250aW51YXRpb24sIGxpbWl0IH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYWRkcmVzcycpO1xuICAgIHJlcXVpcmVPcHRpb25hbChyZXEsIHJlcS5wYXJhbXMsICdjb250aW51YXRpb24nLCByZXF1aXJlVHJhbnNhY3Rpb25JZCk7XG4gICAgcmVxdWlyZU9wdGlvbmFsTnVtYmVyKHJlcSwgcmVxLnBhcmFtcywgJ2xpbWl0Jyk7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uQ29udHJvbGxlciB9ID0gY3R4O1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uQ29udHJvbGxlci51c2UoKHsgZGF0YTogeyB0cmFuc3BvcnQgfSB9KSA9PiB0cmFuc3BvcnQuZ2V0VHJhbnNhY3Rpb25zKGFkZHJlc3MsIGNvbnRpbnVhdGlvbiA9PT0gbnVsbCB8fCBjb250aW51YXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRpbnVhdGlvbi5sdCwgbGltaXQgfHwgNTApKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBnZXRUcmFuc2FjdGlvbiA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IGhhc2ggfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdoYXNoJyk7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uQ29udHJvbGxlciB9ID0gY3R4O1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogYXdhaXQgY29ubmVjdGlvbkNvbnRyb2xsZXIudXNlKCh7IGRhdGE6IHsgdHJhbnNwb3J0IH0gfSkgPT4gdHJhbnNwb3J0LmdldFRyYW5zYWN0aW9uKGhhc2gpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBmaW5kVHJhbnNhY3Rpb24gPSBhc3luYyAoY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBpbk1lc3NhZ2VIYXNoIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVPcHRpb25hbChyZXEsIHJlcS5wYXJhbXMsICdpbk1lc3NhZ2VIYXNoJywgcmVxdWlyZVN0cmluZyk7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uQ29udHJvbGxlciB9ID0gY3R4O1xuICAgIC8vIFRPRE86IGFkZCBtb3JlIGZpbHRlcnNcbiAgICBpZiAoaW5NZXNzYWdlSGFzaCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246IGF3YWl0IGNvbm5lY3Rpb25Db250cm9sbGVyLnVzZSgoeyBkYXRhOiB7IHRyYW5zcG9ydCB9IH0pID0+IHRyYW5zcG9ydC5nZXREc3RUcmFuc2FjdGlvbihpbk1lc3NhZ2VIYXNoKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3QgcnVuTG9jYWwgPSBhc3luYyAoY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjYWNoZWRTdGF0ZSwgcmVzcG9uc2libGUsIGZ1bmN0aW9uQ2FsbCB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2FkZHJlc3MnKTtcbiAgICByZXF1aXJlT3B0aW9uYWwocmVxLCByZXEucGFyYW1zLCAnY2FjaGVkU3RhdGUnLCByZXF1aXJlQ29udHJhY3RTdGF0ZSk7XG4gICAgcmVxdWlyZU9wdGlvbmFsQm9vbGVhbihyZXEsIHJlcS5wYXJhbXMsICdyZXNwb25zaWJsZScpO1xuICAgIHJlcXVpcmVGdW5jdGlvbkNhbGwocmVxLCByZXEucGFyYW1zLCAnZnVuY3Rpb25DYWxsJyk7XG4gICAgY29uc3QgeyBjbG9jaywgY29ubmVjdGlvbkNvbnRyb2xsZXIgfSA9IGN0eDtcbiAgICBsZXQgY29udHJhY3RTdGF0ZSA9IGNhY2hlZFN0YXRlO1xuICAgIGlmIChjb250cmFjdFN0YXRlID09IG51bGwpIHtcbiAgICAgICAgY29udHJhY3RTdGF0ZSA9IGF3YWl0IGNvbm5lY3Rpb25Db250cm9sbGVyLnVzZShhc3luYyAoeyBkYXRhOiB7IHRyYW5zcG9ydCB9IH0pID0+IHRyYW5zcG9ydC5nZXRGdWxsQ29udHJhY3RTdGF0ZShhZGRyZXNzKSk7XG4gICAgfVxuICAgIGlmIChjb250cmFjdFN0YXRlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCAnQWNjb3VudCBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgaWYgKCFjb250cmFjdFN0YXRlLmlzRGVwbG95ZWQgfHwgY29udHJhY3RTdGF0ZS5sYXN0VHJhbnNhY3Rpb25JZCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgJ0FjY291bnQgaXMgbm90IGRlcGxveWVkJyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgb3V0cHV0LCBjb2RlIH0gPSBuZWtvdG9uLnJ1bkxvY2FsKGNsb2NrLCBjb250cmFjdFN0YXRlLmJvYywgZnVuY3Rpb25DYWxsLmFiaSwgZnVuY3Rpb25DYWxsLm1ldGhvZCwgZnVuY3Rpb25DYWxsLnBhcmFtcywgcmVzcG9uc2libGUgfHwgZmFsc2UpO1xuICAgICAgICByZXR1cm4geyBvdXRwdXQsIGNvZGUgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBnZXRFeHBlY3RlZEFkZHJlc3MgPSBhc3luYyAoX2N0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgdHZjLCBhYmksIHdvcmtjaGFpbiwgcHVibGljS2V5LCBpbml0UGFyYW1zIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAndHZjJyk7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdhYmknKTtcbiAgICByZXF1aXJlT3B0aW9uYWxOdW1iZXIocmVxLCByZXEucGFyYW1zLCAnd29ya2NoYWluJyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3B1YmxpY0tleScpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZWtvdG9uLmdldEV4cGVjdGVkQWRkcmVzcyh0dmMsIGFiaSwgd29ya2NoYWluIHx8IDAsIHB1YmxpY0tleSwgaW5pdFBhcmFtcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3QgZ2V0Qm9jSGFzaCA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBib2MgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdib2MnKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyBoYXNoOiBuZWtvdG9uLmdldEJvY0hhc2goYm9jKSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IHBhY2tJbnRvQ2VsbCA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBzdHJ1Y3R1cmUsIGRhdGEsIGFiaVZlcnNpb24gfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZUFycmF5KHJlcSwgcmVxLnBhcmFtcywgJ3N0cnVjdHVyZScpO1xuICAgIHJlcXVpcmVPcHRpb25hbChyZXEsIHJlcS5wYXJhbXMsICdhYmlWZXJzaW9uJywgcmVxdWlyZVN0cmluZyk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgYm9jOiBuZWtvdG9uLnBhY2tJbnRvQ2VsbChzdHJ1Y3R1cmUsIGRhdGEsIGFiaVZlcnNpb24pIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3QgdW5wYWNrRnJvbUNlbGwgPSBhc3luYyAoX2N0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgc3RydWN0dXJlLCBib2MsIGFsbG93UGFydGlhbCwgYWJpVmVyc2lvbiB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlQXJyYXkocmVxLCByZXEucGFyYW1zLCAnc3RydWN0dXJlJyk7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdib2MnKTtcbiAgICByZXF1aXJlQm9vbGVhbihyZXEsIHJlcS5wYXJhbXMsICdhbGxvd1BhcnRpYWwnKTtcbiAgICByZXF1aXJlT3B0aW9uYWwocmVxLCByZXEucGFyYW1zLCAnYWJpVmVyc2lvbicsIHJlcXVpcmVTdHJpbmcpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG5la290b24udW5wYWNrRnJvbUNlbGwoc3RydWN0dXJlLCBib2MsIGFsbG93UGFydGlhbCwgYWJpVmVyc2lvbikgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBleHRyYWN0UHVibGljS2V5ID0gYXN5bmMgKF9jdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IGJvYyB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2JvYycpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IHB1YmxpY0tleTogbmVrb3Rvbi5leHRyYWN0UHVibGljS2V5KGJvYykgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBjb2RlVG9UdmMgPSBhc3luYyAoX2N0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgY29kZSB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2NvZGUnKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyB0dmM6IG5la290b24uY29kZVRvVHZjKGNvZGUpIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3QgbWVyZ2VUdmMgPSBhc3luYyAoX2N0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgY29kZSwgZGF0YSB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2NvZGUnKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2RhdGEnKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyB0dmM6IG5la290b24ubWVyZ2VUdmMoY29kZSwgZGF0YSkgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBzcGxpdFR2YyA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyB0dmMgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICd0dmMnKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmVrb3Rvbi5zcGxpdFR2Yyh0dmMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IHNldENvZGVTYWx0ID0gYXN5bmMgKF9jdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IGNvZGUsIHNhbHQgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdjb2RlJyk7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdzYWx0Jyk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgY29kZTogbmVrb3Rvbi5zZXRDb2RlU2FsdChjb2RlLCBzYWx0KSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGdldENvZGVTYWx0ID0gYXN5bmMgKF9jdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IGNvZGUgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdjb2RlJyk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgc2FsdDogbmVrb3Rvbi5nZXRDb2RlU2FsdChjb2RlKSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGVuY29kZUludGVybmFsSW5wdXQgPSBhc3luYyAoX2N0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIHJlcXVpcmVGdW5jdGlvbkNhbGwocmVxLCByZXEsICdwYXJhbXMnKTtcbiAgICBjb25zdCB7IGFiaSwgbWV0aG9kLCBwYXJhbXMgfSA9IHJlcS5wYXJhbXM7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgYm9jOiBuZWtvdG9uLmVuY29kZUludGVybmFsSW5wdXQoYWJpLCBtZXRob2QsIHBhcmFtcykgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBkZWNvZGVJbnB1dCA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBib2R5LCBhYmksIG1ldGhvZCwgaW50ZXJuYWwgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdib2R5Jyk7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdhYmknKTtcbiAgICByZXF1aXJlTWV0aG9kT3JBcnJheShyZXEsIHJlcS5wYXJhbXMsICdtZXRob2QnKTtcbiAgICByZXF1aXJlQm9vbGVhbihyZXEsIHJlcS5wYXJhbXMsICdpbnRlcm5hbCcpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZWtvdG9uLmRlY29kZUlucHV0KGJvZHksIGFiaSwgbWV0aG9kLCBpbnRlcm5hbCkgfHwgbnVsbDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBkZWNvZGVPdXRwdXQgPSBhc3luYyAoX2N0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgYm9keSwgYWJpLCBtZXRob2QgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdib2R5Jyk7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdhYmknKTtcbiAgICByZXF1aXJlTWV0aG9kT3JBcnJheShyZXEsIHJlcS5wYXJhbXMsICdtZXRob2QnKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmVrb3Rvbi5kZWNvZGVPdXRwdXQoYm9keSwgYWJpLCBtZXRob2QpIHx8IG51bGw7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3QgZGVjb2RlRXZlbnQgPSBhc3luYyAoX2N0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgYm9keSwgYWJpLCBldmVudCB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2JvZHknKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2FiaScpO1xuICAgIHJlcXVpcmVNZXRob2RPckFycmF5KHJlcSwgcmVxLnBhcmFtcywgJ2V2ZW50Jyk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5la290b24uZGVjb2RlRXZlbnQoYm9keSwgYWJpLCBldmVudCkgfHwgbnVsbDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBkZWNvZGVUcmFuc2FjdGlvbiA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbiwgYWJpLCBtZXRob2QgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdhYmknKTtcbiAgICByZXF1aXJlTWV0aG9kT3JBcnJheShyZXEsIHJlcS5wYXJhbXMsICdtZXRob2QnKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmVrb3Rvbi5kZWNvZGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgYWJpLCBtZXRob2QpIHx8IG51bGw7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3QgZGVjb2RlVHJhbnNhY3Rpb25FdmVudHMgPSBhc3luYyAoX2N0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb24sIGFiaSB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2FiaScpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IGV2ZW50czogbmVrb3Rvbi5kZWNvZGVUcmFuc2FjdGlvbkV2ZW50cyh0cmFuc2FjdGlvbiwgYWJpKSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IHZlcmlmeVNpZ25hdHVyZSA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBwdWJsaWNLZXksIGRhdGFIYXNoLCBzaWduYXR1cmUgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdwdWJsaWNLZXknKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2RhdGFIYXNoJyk7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdzaWduYXR1cmUnKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBuZWtvdG9uLnZlcmlmeVNpZ25hdHVyZShwdWJsaWNLZXksIGRhdGFIYXNoLCBzaWduYXR1cmUpIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3Qgc2VuZFVuc2lnbmVkRXh0ZXJuYWxNZXNzYWdlID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgcmVjaXBpZW50LCBzdGF0ZUluaXQsIHBheWxvYWQsIGxvY2FsIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAncmVjaXBpZW50Jyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3N0YXRlSW5pdCcpO1xuICAgIHJlcXVpcmVPcHRpb25hbFJhd0Z1bmN0aW9uQ2FsbChyZXEsIHJlcS5wYXJhbXMsICdwYXlsb2FkJyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsQm9vbGVhbihyZXEsIHJlcS5wYXJhbXMsICdsb2NhbCcpO1xuICAgIGxldCByZXBhY2tlZFJlY2lwaWVudDtcbiAgICB0cnkge1xuICAgICAgICByZXBhY2tlZFJlY2lwaWVudCA9IG5la290b24ucmVwYWNrQWRkcmVzcyhyZWNpcGllbnQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGNvbnN0IHsgY2xvY2ssIHN1YnNjcmlwdGlvbkNvbnRyb2xsZXIsIHByb3BlcnRpZXMgfSA9IGN0eDtcbiAgICBjb25zdCBtYWtlU2lnbmVkTWVzc2FnZSA9ICh0aW1lb3V0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnIHx8IHBheWxvYWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGlyZUF0ID0gfn4oY2xvY2subm93TXMgLyAxMDAwKSArIHRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5la290b24uY3JlYXRlUmF3RXh0ZXJuYWxNZXNzYWdlKHJlcGFja2VkUmVjaXBpZW50LCBzdGF0ZUluaXQsIHBheWxvYWQsIGV4cGlyZUF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZWtvdG9uLmNyZWF0ZUV4dGVybmFsTWVzc2FnZVdpdGhvdXRTaWduYXR1cmUoY2xvY2ssIHJlcGFja2VkUmVjaXBpZW50LCBwYXlsb2FkLmFiaSwgcGF5bG9hZC5tZXRob2QsIHN0YXRlSW5pdCwgcGF5bG9hZC5wYXJhbXMsIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZVRyYW5zYWN0aW9uID0gKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwYXlsb2FkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVkID0gbmVrb3Rvbi5kZWNvZGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgcGF5bG9hZC5hYmksIHBheWxvYWQubWV0aG9kKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBkZWNvZGVkID09PSBudWxsIHx8IGRlY29kZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlY29kZWQub3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7IC8qIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0cmFuc2FjdGlvbiwgb3V0cHV0IH07XG4gICAgfTtcbiAgICAvLyBGb3JjZSBsb2NhbCBleGVjdXRpb25cbiAgICBpZiAobG9jYWwgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3Qgc2lnbmVkTWVzc2FnZSA9IG1ha2VTaWduZWRNZXNzYWdlKDYwKTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCBzdWJzY3JpcHRpb25Db250cm9sbGVyLnNlbmRNZXNzYWdlTG9jYWxseShyZXBhY2tlZFJlY2lwaWVudCwgc2lnbmVkTWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIC8vIFNlbmQgYW5kIHdhaXQgd2l0aCBzZXZlcmFsIHJldHJpZXNcbiAgICBsZXQgdGltZW91dCA9IHByb3BlcnRpZXMubWVzc2FnZS50aW1lb3V0O1xuICAgIGZvciAobGV0IHJldHJ5ID0gMDsgcmV0cnkgPCBwcm9wZXJ0aWVzLm1lc3NhZ2UucmV0cnlDb3VudDsgKytyZXRyeSkge1xuICAgICAgICBjb25zdCBzaWduZWRNZXNzYWdlID0gbWFrZVNpZ25lZE1lc3NhZ2UodGltZW91dCk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgc3Vic2NyaXB0aW9uQ29udHJvbGxlci5zZW5kTWVzc2FnZShyZXBhY2tlZFJlY2lwaWVudCwgc2lnbmVkTWVzc2FnZSk7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aW1lb3V0ICo9IHByb3BlcnRpZXMubWVzc2FnZS50aW1lb3V0R3Jvd0ZhY3RvcjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIC8vIEV4ZWN1dGUgbG9jYWxseVxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICdNZXNzYWdlIGV4cGlyZWQnO1xuICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2UgPSBtYWtlU2lnbmVkTWVzc2FnZSg2MCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCBzdWJzY3JpcHRpb25Db250cm9sbGVyLnNlbmRNZXNzYWdlTG9jYWxseShyZXBhY2tlZFJlY2lwaWVudCwgc2lnbmVkTWVzc2FnZSlcbiAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYCR7ZXJyb3JNZXNzYWdlfS4gJHtlLnRvU3RyaW5nKCl9YCk7XG4gICAgfSk7XG4gICAgY29uc3QgYWRkaXRpb25hbFRleHQgPSB0cmFuc2FjdGlvbi5leGl0Q29kZSAhPSBudWxsID8gYC4gUG9zc2libGUgZXhpdCBjb2RlOiAke3RyYW5zYWN0aW9uLmV4aXRDb2RlfWAgOiAnJztcbiAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGAke2Vycm9yTWVzc2FnZX0ke2FkZGl0aW9uYWxUZXh0fWApO1xufTtcbmNvbnN0IHNpZ25EYXRhID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZUtleXN0b3JlKHJlcSwgY3R4KTtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBwdWJsaWNLZXksIGRhdGEgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdwdWJsaWNLZXknKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2RhdGEnKTtcbiAgICBjb25zdCB7IGtleXN0b3JlIH0gPSBjdHg7XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQga2V5c3RvcmUuZ2V0U2lnbmVyKHB1YmxpY0tleSk7XG4gICAgaWYgKHNpZ25lciA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgJ1NpZ25lciBub3QgZm91bmQgZm9yIHB1YmxpYyBrZXknKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YUhhc2ggPSBuZWtvdG9uLmdldERhdGFIYXNoKGRhdGEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YUhhc2gsXG4gICAgICAgICAgICAuLi4oYXdhaXQgc2lnbmVyLnNpZ24oZGF0YUhhc2gpLnRoZW4obmVrb3Rvbi5leHRlbmRTaWduYXR1cmUpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBzaWduRGF0YVJhdyA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVLZXlzdG9yZShyZXEsIGN0eCk7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgcHVibGljS2V5LCBkYXRhIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAncHVibGljS2V5Jyk7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdkYXRhJyk7XG4gICAgY29uc3QgeyBrZXlzdG9yZSB9ID0gY3R4O1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IGtleXN0b3JlLmdldFNpZ25lcihwdWJsaWNLZXkpO1xuICAgIGlmIChzaWduZXIgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsICdTaWduZXIgbm90IGZvdW5kIGZvciBwdWJsaWMga2V5Jyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzaWduZXIuc2lnbihkYXRhKS50aGVuKG5la290b24uZXh0ZW5kU2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBzZW5kTWVzc2FnZSA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVLZXlzdG9yZShyZXEsIGN0eCk7XG4gICAgcmVxdWlyZUFjY291bnRzU3RvcmFnZShyZXEsIGN0eCk7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgc2VuZGVyLCByZWNpcGllbnQsIGFtb3VudCwgYm91bmNlLCBwYXlsb2FkIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnc2VuZGVyJyk7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdyZWNpcGllbnQnKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2Ftb3VudCcpO1xuICAgIHJlcXVpcmVCb29sZWFuKHJlcSwgcmVxLnBhcmFtcywgJ2JvdW5jZScpO1xuICAgIHJlcXVpcmVPcHRpb25hbChyZXEsIHJlcS5wYXJhbXMsICdwYXlsb2FkJywgcmVxdWlyZUZ1bmN0aW9uQ2FsbCk7XG4gICAgY29uc3QgeyBjbG9jaywgcHJvcGVydGllcywgc3Vic2NyaXB0aW9uQ29udHJvbGxlciwgY29ubmVjdGlvbkNvbnRyb2xsZXIsIGtleXN0b3JlLCBhY2NvdW50c1N0b3JhZ2UgfSA9IGN0eDtcbiAgICBsZXQgcmVwYWNrZWRTZW5kZXI7XG4gICAgbGV0IHJlcGFja2VkUmVjaXBpZW50O1xuICAgIGxldCBhY2NvdW50O1xuICAgIHRyeSB7XG4gICAgICAgIHJlcGFja2VkU2VuZGVyID0gbmVrb3Rvbi5yZXBhY2tBZGRyZXNzKHNlbmRlcik7XG4gICAgICAgIHJlcGFja2VkUmVjaXBpZW50ID0gbmVrb3Rvbi5yZXBhY2tBZGRyZXNzKHJlY2lwaWVudCk7XG4gICAgICAgIGFjY291bnQgPSBhd2FpdCBhY2NvdW50c1N0b3JhZ2UuZ2V0QWNjb3VudChyZXBhY2tlZFNlbmRlcikudGhlbigoYWNjb3VudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGFjY291bnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZW5kZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGNvbnN0IG1ha2VTaWduZWRNZXNzYWdlID0gYXN5bmMgKHRpbWVvdXQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50LnByZXBhcmVNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICByZWNpcGllbnQ6IHJlcGFja2VkUmVjaXBpZW50LFxuICAgICAgICAgICAgICAgIGFtb3VudCxcbiAgICAgICAgICAgICAgICBib3VuY2UsXG4gICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICBzdGF0ZUluaXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgfSwgbmV3IEFjY291bnRzU3RvcmFnZV8xLkFjY291bnRzU3RvcmFnZUNvbnRleHQoY2xvY2ssIGNvbm5lY3Rpb25Db250cm9sbGVyLCBuZWtvdG9uLCBrZXlzdG9yZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFNlbmQgYW5kIHdhaXQgd2l0aCBzZXZlcmFsIHJldHJpZXNcbiAgICBsZXQgdGltZW91dCA9IHByb3BlcnRpZXMubWVzc2FnZS50aW1lb3V0O1xuICAgIC8vIFNldCBgcmV0cnlDb3VudGAgaWYgbm90IGV4cGxpY2l0bHkgZGlzYWJsZWRcbiAgICBjb25zdCByZXRyeUNvdW50ID0gcHJvcGVydGllcy5tZXNzYWdlLnJldHJ5VHJhbnNmZXJzICE9PSBmYWxzZSA/IHByb3BlcnRpZXMubWVzc2FnZS5yZXRyeUNvdW50IDogMTtcbiAgICBmb3IgKGxldCByZXRyeSA9IDA7IHJldHJ5IDwgcmV0cnlDb3VudDsgKytyZXRyeSkge1xuICAgICAgICBjb25zdCBzaWduZWRNZXNzYWdlID0gYXdhaXQgbWFrZVNpZ25lZE1lc3NhZ2UodGltZW91dCk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgc3Vic2NyaXB0aW9uQ29udHJvbGxlci5zZW5kTWVzc2FnZShyZXBhY2tlZFNlbmRlciwgc2lnbmVkTWVzc2FnZSk7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aW1lb3V0ICo9IHByb3BlcnRpZXMubWVzc2FnZS50aW1lb3V0R3Jvd0ZhY3RvcjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRyYW5zYWN0aW9uIH07XG4gICAgfVxuICAgIC8vIEV4ZWN1dGUgbG9jYWxseVxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICdNZXNzYWdlIGV4cGlyZWQnO1xuICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2UgPSBhd2FpdCBtYWtlU2lnbmVkTWVzc2FnZSg2MCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCBzdWJzY3JpcHRpb25Db250cm9sbGVyLnNlbmRNZXNzYWdlTG9jYWxseShyZXBhY2tlZFNlbmRlciwgc2lnbmVkTWVzc2FnZSlcbiAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYCR7ZXJyb3JNZXNzYWdlfS4gJHtlLnRvU3RyaW5nKCl9YCk7XG4gICAgfSk7XG4gICAgY29uc3QgYWRkaXRpb25hbFRleHQgPSB0cmFuc2FjdGlvbi5leGl0Q29kZSAhPSBudWxsID8gYC4gUG9zc2libGUgZXhpdCBjb2RlOiAke3RyYW5zYWN0aW9uLmV4aXRDb2RlfWAgOiAnJztcbiAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGAke2Vycm9yTWVzc2FnZX0ke2FkZGl0aW9uYWxUZXh0fWApO1xufTtcbmNvbnN0IHNlbmRNZXNzYWdlRGVsYXllZCA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVLZXlzdG9yZShyZXEsIGN0eCk7XG4gICAgcmVxdWlyZUFjY291bnRzU3RvcmFnZShyZXEsIGN0eCk7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgc2VuZGVyLCByZWNpcGllbnQsIGFtb3VudCwgYm91bmNlLCBwYXlsb2FkIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnc2VuZGVyJyk7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdyZWNpcGllbnQnKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2Ftb3VudCcpO1xuICAgIHJlcXVpcmVCb29sZWFuKHJlcSwgcmVxLnBhcmFtcywgJ2JvdW5jZScpO1xuICAgIHJlcXVpcmVPcHRpb25hbChyZXEsIHJlcS5wYXJhbXMsICdwYXlsb2FkJywgcmVxdWlyZUZ1bmN0aW9uQ2FsbCk7XG4gICAgY29uc3QgeyBjbG9jaywgc3Vic2NyaXB0aW9uQ29udHJvbGxlciwgY29ubmVjdGlvbkNvbnRyb2xsZXIsIGtleXN0b3JlLCBhY2NvdW50c1N0b3JhZ2UsIG5vdGlmeSB9ID0gY3R4O1xuICAgIGxldCByZXBhY2tlZFNlbmRlcjtcbiAgICBsZXQgcmVwYWNrZWRSZWNpcGllbnQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVwYWNrZWRTZW5kZXIgPSBuZWtvdG9uLnJlcGFja0FkZHJlc3Moc2VuZGVyKTtcbiAgICAgICAgcmVwYWNrZWRSZWNpcGllbnQgPSBuZWtvdG9uLnJlcGFja0FkZHJlc3MocmVjaXBpZW50KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBsZXQgc2lnbmVkTWVzc2FnZTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgYWNjb3VudHNTdG9yYWdlLmdldEFjY291bnQocmVwYWNrZWRTZW5kZXIpO1xuICAgICAgICBpZiAoYWNjb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBzaWduZWRNZXNzYWdlID0gYXdhaXQgYWNjb3VudC5wcmVwYXJlTWVzc2FnZSh7XG4gICAgICAgICAgICByZWNpcGllbnQ6IHJlcGFja2VkUmVjaXBpZW50LFxuICAgICAgICAgICAgYW1vdW50LFxuICAgICAgICAgICAgYm91bmNlLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIHN0YXRlSW5pdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGltZW91dDogNjAsIC8vIFRFTVBcbiAgICAgICAgfSwgbmV3IEFjY291bnRzU3RvcmFnZV8xLkFjY291bnRzU3RvcmFnZUNvbnRleHQoY2xvY2ssIGNvbm5lY3Rpb25Db250cm9sbGVyLCBuZWtvdG9uLCBrZXlzdG9yZSkpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHN1YnNjcmlwdGlvbkNvbnRyb2xsZXIuc2VuZE1lc3NhZ2UocmVwYWNrZWRTZW5kZXIsIHNpZ25lZE1lc3NhZ2UpXG4gICAgICAgIC50aGVuKHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgbm90aWZ5KCdtZXNzYWdlU3RhdHVzVXBkYXRlZCcsIHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHJlcGFja2VkU2VuZGVyLFxuICAgICAgICAgICAgaGFzaDogc2lnbmVkTWVzc2FnZS5oYXNoLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgICAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICBhY2NvdW50OiByZXBhY2tlZFNlbmRlcixcbiAgICAgICAgICAgIGhhc2g6IHNpZ25lZE1lc3NhZ2UuaGFzaCxcbiAgICAgICAgICAgIGV4cGlyZUF0OiBzaWduZWRNZXNzYWdlLmV4cGlyZUF0LFxuICAgICAgICB9LFxuICAgIH07XG59O1xuY29uc3Qgc2VuZEV4dGVybmFsTWVzc2FnZSA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVLZXlzdG9yZShyZXEsIGN0eCk7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgcHVibGljS2V5LCByZWNpcGllbnQsIHN0YXRlSW5pdCwgcGF5bG9hZCwgbG9jYWwgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdwdWJsaWNLZXknKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3JlY2lwaWVudCcpO1xuICAgIHJlcXVpcmVPcHRpb25hbFN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdzdGF0ZUluaXQnKTtcbiAgICByZXF1aXJlRnVuY3Rpb25DYWxsKHJlcSwgcmVxLnBhcmFtcywgJ3BheWxvYWQnKTtcbiAgICByZXF1aXJlT3B0aW9uYWxCb29sZWFuKHJlcSwgcmVxLnBhcmFtcywgJ2xvY2FsJyk7XG4gICAgbGV0IHJlcGFja2VkUmVjaXBpZW50O1xuICAgIHRyeSB7XG4gICAgICAgIHJlcGFja2VkUmVjaXBpZW50ID0gbmVrb3Rvbi5yZXBhY2tBZGRyZXNzKHJlY2lwaWVudCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgY29uc3QgeyBjbG9jaywgc3Vic2NyaXB0aW9uQ29udHJvbGxlciwga2V5c3RvcmUsIHByb3BlcnRpZXMgfSA9IGN0eDtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBrZXlzdG9yZS5nZXRTaWduZXIocHVibGljS2V5KTtcbiAgICBpZiAoc2lnbmVyID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCAnU2lnbmVyIG5vdCBmb3VuZCBmb3IgcHVibGljIGtleScpO1xuICAgIH1cbiAgICBjb25zdCBtYWtlU2lnbmVkTWVzc2FnZSA9IGFzeW5jICh0aW1lb3V0KSA9PiB7XG4gICAgICAgIGxldCB1bnNpZ25lZE1lc3NhZ2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1bnNpZ25lZE1lc3NhZ2UgPSBuZWtvdG9uLmNyZWF0ZUV4dGVybmFsTWVzc2FnZShjbG9jaywgcmVwYWNrZWRSZWNpcGllbnQsIHBheWxvYWQuYWJpLCBwYXlsb2FkLm1ldGhvZCwgc3RhdGVJbml0LCBwYXlsb2FkLnBhcmFtcywgcHVibGljS2V5LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzaWduZXIuc2lnbih1bnNpZ25lZE1lc3NhZ2UuaGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gdW5zaWduZWRNZXNzYWdlLnNpZ24oc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdW5zaWduZWRNZXNzYWdlLmZyZWUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlVHJhbnNhY3Rpb24gPSAodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgICAgbGV0IG91dHB1dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZWQgPSBuZWtvdG9uLmRlY29kZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBwYXlsb2FkLmFiaSwgcGF5bG9hZC5tZXRob2QpO1xuICAgICAgICAgICAgb3V0cHV0ID0gZGVjb2RlZCA9PT0gbnVsbCB8fCBkZWNvZGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWNvZGVkLm91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykgeyAvKiBkbyBub3RoaW5nICovXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHJhbnNhY3Rpb24sIG91dHB1dCB9O1xuICAgIH07XG4gICAgLy8gRm9yY2UgbG9jYWwgZXhlY3V0aW9uXG4gICAgaWYgKGxvY2FsID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2UgPSBhd2FpdCBtYWtlU2lnbmVkTWVzc2FnZSg2MCk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgc3Vic2NyaXB0aW9uQ29udHJvbGxlci5zZW5kTWVzc2FnZUxvY2FsbHkocmVwYWNrZWRSZWNpcGllbnQsIHNpZ25lZE1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gaGFuZGxlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICAvLyBTZW5kIGFuZCB3YWl0IHdpdGggc2V2ZXJhbCByZXRyaWVzXG4gICAgbGV0IHRpbWVvdXQgPSBwcm9wZXJ0aWVzLm1lc3NhZ2UudGltZW91dDtcbiAgICBmb3IgKGxldCByZXRyeSA9IDA7IHJldHJ5IDwgcHJvcGVydGllcy5tZXNzYWdlLnJldHJ5Q291bnQ7ICsrcmV0cnkpIHtcbiAgICAgICAgY29uc3Qgc2lnbmVkTWVzc2FnZSA9IGF3YWl0IG1ha2VTaWduZWRNZXNzYWdlKHRpbWVvdXQpO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHN1YnNjcmlwdGlvbkNvbnRyb2xsZXIuc2VuZE1lc3NhZ2UocmVwYWNrZWRSZWNpcGllbnQsIHNpZ25lZE1lc3NhZ2UpO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGltZW91dCAqPSBwcm9wZXJ0aWVzLm1lc3NhZ2UudGltZW91dEdyb3dGYWN0b3I7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICAvLyBFeGVjdXRlIGxvY2FsbHlcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAnTWVzc2FnZSBleHBpcmVkJztcbiAgICBjb25zdCBzaWduZWRNZXNzYWdlID0gYXdhaXQgbWFrZVNpZ25lZE1lc3NhZ2UoNjApO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgc3Vic2NyaXB0aW9uQ29udHJvbGxlci5zZW5kTWVzc2FnZUxvY2FsbHkocmVwYWNrZWRSZWNpcGllbnQsIHNpZ25lZE1lc3NhZ2UpXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGAke2Vycm9yTWVzc2FnZX0uICR7ZS50b1N0cmluZygpfWApO1xuICAgIH0pO1xuICAgIGNvbnN0IGFkZGl0aW9uYWxUZXh0ID0gdHJhbnNhY3Rpb24uZXhpdENvZGUgIT0gbnVsbCA/IGAuIFBvc3NpYmxlIGV4aXQgY29kZTogJHt0cmFuc2FjdGlvbi5leGl0Q29kZX1gIDogJyc7XG4gICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgJHtlcnJvck1lc3NhZ2V9JHthZGRpdGlvbmFsVGV4dH1gKTtcbn07XG5jb25zdCBzZW5kRXh0ZXJuYWxNZXNzYWdlRGVsYXllZCA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVLZXlzdG9yZShyZXEsIGN0eCk7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgcHVibGljS2V5LCByZWNpcGllbnQsIHN0YXRlSW5pdCwgcGF5bG9hZCB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3B1YmxpY0tleScpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAncmVjaXBpZW50Jyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3N0YXRlSW5pdCcpO1xuICAgIHJlcXVpcmVGdW5jdGlvbkNhbGwocmVxLCByZXEucGFyYW1zLCAncGF5bG9hZCcpO1xuICAgIGxldCByZXBhY2tlZFJlY2lwaWVudDtcbiAgICB0cnkge1xuICAgICAgICByZXBhY2tlZFJlY2lwaWVudCA9IG5la290b24ucmVwYWNrQWRkcmVzcyhyZWNpcGllbnQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGNvbnN0IHsgY2xvY2ssIHN1YnNjcmlwdGlvbkNvbnRyb2xsZXIsIGtleXN0b3JlLCBwcm9wZXJ0aWVzLCBub3RpZnkgfSA9IGN0eDtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBrZXlzdG9yZS5nZXRTaWduZXIocHVibGljS2V5KTtcbiAgICBpZiAoc2lnbmVyID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCAnU2lnbmVyIG5vdCBmb3VuZCBmb3IgcHVibGljIGtleScpO1xuICAgIH1cbiAgICBsZXQgdW5zaWduZWRNZXNzYWdlO1xuICAgIHRyeSB7XG4gICAgICAgIHVuc2lnbmVkTWVzc2FnZSA9IG5la290b24uY3JlYXRlRXh0ZXJuYWxNZXNzYWdlKGNsb2NrLCByZXBhY2tlZFJlY2lwaWVudCwgcGF5bG9hZC5hYmksIHBheWxvYWQubWV0aG9kLCBzdGF0ZUluaXQsIHBheWxvYWQucGFyYW1zLCBwdWJsaWNLZXksIHByb3BlcnRpZXMubWVzc2FnZS50aW1lb3V0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBsZXQgc2lnbmVkTWVzc2FnZTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzaWduZXIuc2lnbih1bnNpZ25lZE1lc3NhZ2UuaGFzaCk7XG4gICAgICAgIHNpZ25lZE1lc3NhZ2UgPSB1bnNpZ25lZE1lc3NhZ2Uuc2lnbihzaWduYXR1cmUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB1bnNpZ25lZE1lc3NhZ2UuZnJlZSgpO1xuICAgIH1cbiAgICBzdWJzY3JpcHRpb25Db250cm9sbGVyLnNlbmRNZXNzYWdlKHJlcGFja2VkUmVjaXBpZW50LCBzaWduZWRNZXNzYWdlKVxuICAgICAgICAudGhlbih0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIG5vdGlmeSgnbWVzc2FnZVN0YXR1c1VwZGF0ZWQnLCB7XG4gICAgICAgICAgICBhZGRyZXNzOiByZXBhY2tlZFJlY2lwaWVudCxcbiAgICAgICAgICAgIGhhc2g6IHNpZ25lZE1lc3NhZ2UuaGFzaCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICB9KTtcbiAgICB9KVxuICAgICAgICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgYWNjb3VudDogcmVwYWNrZWRSZWNpcGllbnQsXG4gICAgICAgICAgICBoYXNoOiBzaWduZWRNZXNzYWdlLmhhc2gsXG4gICAgICAgICAgICBleHBpcmVBdDogc2lnbmVkTWVzc2FnZS5leHBpcmVBdCxcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmZ1bmN0aW9uIHJlcXVpcmVLZXlzdG9yZShyZXEsIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5rZXlzdG9yZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgJ0tleXN0b3JlIG5vdCBmb3VuZCcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcXVpcmVBY2NvdW50c1N0b3JhZ2UocmVxLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQuYWNjb3VudHNTdG9yYWdlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCAnQWNjb3VudHNTdG9yYWdlIG5vdCBmb3VuZCcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcXVpcmVQYXJhbXMocmVxKSB7XG4gICAgaWYgKHJlcS5wYXJhbXMgPT0gbnVsbCB8fCB0eXBlb2YgcmVxLnBhcmFtcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCAncmVxdWlyZWQgcGFyYW1zIG9iamVjdCcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcXVpcmVPYmplY3QocmVxLCBvYmplY3QsIGtleSkge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgJyR7U3RyaW5nKGtleSl9JyBtdXN0IGJlIGFuIG9iamVjdGApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcXVpcmVPcHRpb25hbE9iamVjdChyZXEsIG9iamVjdCwga2V5KSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBvYmplY3Rba2V5XTtcbiAgICBpZiAocHJvcGVydHkgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcGVydHkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYCcke1N0cmluZyhrZXkpfScgbXVzdCBiZSBhbiBvYmplY3QgaWYgc3BlY2lmaWVkYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZUJvb2xlYW4ocmVxLCBvYmplY3QsIGtleSkge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYCcke1N0cmluZyhrZXkpfScgbXVzdCBiZSBhIGJvb2xlYW5gKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1aXJlT3B0aW9uYWxCb29sZWFuKHJlcSwgb2JqZWN0LCBrZXkpIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IG9iamVjdFtrZXldO1xuICAgIGlmIChwcm9wZXJ0eSAhPSBudWxsICYmIHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYCcke1N0cmluZyhrZXkpfScgbXVzdCBiZSBhIGJvb2xlYW4gaWYgc3BlY2lmaWVkYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZVN0cmluZyhyZXEsIG9iamVjdCwga2V5KSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBvYmplY3Rba2V5XTtcbiAgICBpZiAodHlwZW9mIHByb3BlcnR5ICE9PSAnc3RyaW5nJyB8fCBwcm9wZXJ0eS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgJyR7U3RyaW5nKGtleSl9JyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1aXJlT3B0aW9uYWxTdHJpbmcocmVxLCBvYmplY3QsIGtleSkge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgaWYgKHByb3BlcnR5ICE9IG51bGwgJiYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ3N0cmluZycgfHwgcHJvcGVydHkubGVuZ3RoID09PSAwKSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGAnJHtTdHJpbmcoa2V5KX0nIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIGlmIHByb3ZpZGVkYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZU9wdGlvbmFsTnVtYmVyKHJlcSwgb2JqZWN0LCBrZXkpIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IG9iamVjdFtrZXldO1xuICAgIGlmIChwcm9wZXJ0eSAhPSBudWxsICYmIHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgJyR7U3RyaW5nKGtleSl9JyBtdXN0IGJlIGEgbnVtYmVyIGlmIHByb3ZpZGVyYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZUFycmF5KHJlcSwgb2JqZWN0LCBrZXkpIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IG9iamVjdFtrZXldO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wZXJ0eSkpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgJyR7U3RyaW5nKGtleSl9JyBtdXN0IGJlIGFuIGFycmF5YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZU9wdGlvbmFsKHJlcSwgb2JqZWN0LCBrZXksIHByZWRpY2F0ZSkge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgaWYgKHByb3BlcnR5ICE9IG51bGwpIHtcbiAgICAgICAgcHJlZGljYXRlKHJlcSwgb2JqZWN0LCBrZXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcXVpcmVUcmFuc2FjdGlvbklkKHJlcSwgb2JqZWN0LCBrZXkpIHtcbiAgICByZXF1aXJlT2JqZWN0KHJlcSwgb2JqZWN0LCBrZXkpO1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHByb3BlcnR5LCAnbHQnKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcHJvcGVydHksICdoYXNoJyk7XG59XG5mdW5jdGlvbiByZXF1aXJlTGFzdFRyYW5zYWN0aW9uSWQocmVxLCBvYmplY3QsIGtleSkge1xuICAgIHJlcXVpcmVPYmplY3QocmVxLCBvYmplY3QsIGtleSk7XG4gICAgY29uc3QgcHJvcGVydHkgPSBvYmplY3Rba2V5XTtcbiAgICByZXF1aXJlQm9vbGVhbihyZXEsIHByb3BlcnR5LCAnaXNFeGFjdCcpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCBwcm9wZXJ0eSwgJ2x0Jyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsU3RyaW5nKHJlcSwgcHJvcGVydHksICdoYXNoJyk7XG59XG5mdW5jdGlvbiByZXF1aXJlQ29udHJhY3RTdGF0ZShyZXEsIG9iamVjdCwga2V5KSB7XG4gICAgcmVxdWlyZU9iamVjdChyZXEsIG9iamVjdCwga2V5KTtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IG9iamVjdFtrZXldO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCBwcm9wZXJ0eSwgJ2JhbGFuY2UnKTtcbiAgICByZXF1aXJlT3B0aW9uYWwocmVxLCBwcm9wZXJ0eSwgJ2xhc3RUcmFuc2FjdGlvbklkJywgcmVxdWlyZUxhc3RUcmFuc2FjdGlvbklkKTtcbiAgICByZXF1aXJlQm9vbGVhbihyZXEsIHByb3BlcnR5LCAnaXNEZXBsb3llZCcpO1xufVxuZnVuY3Rpb24gcmVxdWlyZUZ1bmN0aW9uQ2FsbChyZXEsIG9iamVjdCwga2V5KSB7XG4gICAgcmVxdWlyZU9iamVjdChyZXEsIG9iamVjdCwga2V5KTtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IG9iamVjdFtrZXldO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCBwcm9wZXJ0eSwgJ2FiaScpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCBwcm9wZXJ0eSwgJ21ldGhvZCcpO1xuICAgIHJlcXVpcmVPYmplY3QocmVxLCBwcm9wZXJ0eSwgJ3BhcmFtcycpO1xufVxuZnVuY3Rpb24gcmVxdWlyZU9wdGlvbmFsUmF3RnVuY3Rpb25DYWxsKHJlcSwgb2JqZWN0LCBrZXkpIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IG9iamVjdFtrZXldO1xuICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnIHx8IHByb3BlcnR5ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJlcXVpcmVTdHJpbmcocmVxLCBwcm9wZXJ0eSwgJ2FiaScpO1xuICAgICAgICByZXF1aXJlU3RyaW5nKHJlcSwgcHJvcGVydHksICdtZXRob2QnKTtcbiAgICAgICAgcmVxdWlyZU9iamVjdChyZXEsIHByb3BlcnR5LCAncGFyYW1zJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGAnJHtTdHJpbmcoa2V5KX0nIG11c3QgYmUgYSBmdW5jdGlvbiBhbGwgb3Igb3B0aW9uYWwgc3RyaW5nYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZU1ldGhvZE9yQXJyYXkocmVxLCBvYmplY3QsIGtleSkge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgaWYgKHByb3BlcnR5ICE9IG51bGwgJiYgdHlwZW9mIHByb3BlcnR5ICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheShwcm9wZXJ0eSkpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgJyR7U3RyaW5nKGtleSl9JyBtdXN0IGJlIGEgbWV0aG9kIG5hbWUgb3IgYW4gYXJyYXkgb2YgcG9zc2libGUgbmFtZXNgKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBtYWtlQWNjb3VudEludGVyYWN0aW9uUGVybWlzc2lvbihyZXEsIGN0eCkge1xuICAgIHJlcXVpcmVBY2NvdW50c1N0b3JhZ2UocmVxLCBjdHgpO1xuICAgIGNvbnN0IGRlZmF1bHRBY2NvdW50ID0gY3R4LmFjY291bnRzU3RvcmFnZS5kZWZhdWx0QWNjb3VudDtcbiAgICBpZiAoZGVmYXVsdEFjY291bnQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsICdEZWZhdWx0IGFjY291bnQgbm90IHNldCBpbiBhY2NvdW50cyBzdG9yYWdlJyk7XG4gICAgfVxuICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCBjdHguYWNjb3VudHNTdG9yYWdlLmdldEFjY291bnQoZGVmYXVsdEFjY291bnQpO1xuICAgIGlmIChhY2NvdW50ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCAnRGVmYXVsdCBhY2NvdW50IG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNLZXkgPSBhd2FpdCBhY2NvdW50LmZldGNoUHVibGljS2V5KG5ldyBBY2NvdW50c1N0b3JhZ2VfMS5BY2NvdW50c1N0b3JhZ2VDb250ZXh0KGN0eC5jbG9jaywgY3R4LmNvbm5lY3Rpb25Db250cm9sbGVyLCBuZWtvdG9uKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogYWNjb3VudC5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgY29udHJhY3RUeXBlOiAndW5rbm93bicsXG4gICAgfTtcbn1cbmNvbnN0IGludmFsaWRSZXF1ZXN0ID0gKHJlcSwgbWVzc2FnZSwgZGF0YSkgPT4gbmV3IE5la290b25ScGNFcnJvcigyLCBgJHtyZXEubWV0aG9kfTogJHttZXNzYWdlfWAsIGRhdGEpO1xuY2xhc3MgTmVrb3RvblJwY0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVzc2FnZSB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlXCIgbXVzdCBiZSBhIG5vbmVtcHR5IHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2VyaWFsaXplZC5kYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YWNrKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLnN0YWNrID0gdGhpcy5zdGFjaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoMCwgZmFzdF9zYWZlX3N0cmluZ2lmeV8xLmRlZmF1bHQpKHRoaXMuc2VyaWFsaXplKCksIHN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICB9XG59XG5jb25zdCBzdHJpbmdpZnlSZXBsYWNlciA9IChfLCB2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gJ1tDaXJjdWxhcl0nKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/everscale-standalone-client/client/index.js\n");

/***/ }),

/***/ "./node_modules/everscale-standalone-client/client/keystore.js":
/*!*********************************************************************!*\
  !*** ./node_modules/everscale-standalone-client/client/keystore.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SimpleKeystore = void 0;\nconst core_1 = __importDefault(__webpack_require__(/*! ../core */ \"./node_modules/everscale-standalone-client/core.js\"));\nconst { nekoton } = core_1.default;\n/**\n * @category Keystore\n */\nclass SimpleKeystore {\n    constructor(entries = {}) {\n        this.signers = new Map();\n        this.signersByPublicKey = new Map();\n        for (const [id, signer] of Object.entries(entries)) {\n            this.addKeyPair(id, signer);\n        }\n    }\n    static generateKeyPair() {\n        return nekoton.ed25519_generateKeyPair();\n    }\n    addKeyPair(idOrKeypair, rest) {\n        let id;\n        let keyPair;\n        if (typeof idOrKeypair == 'string') {\n            id = idOrKeypair;\n            keyPair = rest;\n        }\n        else {\n            id = idOrKeypair.publicKey;\n            keyPair = idOrKeypair;\n        }\n        const signer = new SimpleSigner(keyPair);\n        this.signers.set(id, signer);\n        this.signersByPublicKey.set(keyPair.publicKey, signer);\n    }\n    removeKeyPair(id) {\n        const signer = this.signers.get(id);\n        if (signer != null) {\n            this.signers.delete(id);\n            this.signersByPublicKey.delete(signer.publicKey);\n        }\n    }\n    /**\n     * Generate and add a new key\n     *\n     * @returns keyId of the new signer\n     */\n    async withNewKey(f, options = {}) {\n        const newKey = SimpleKeystore.generateKeyPair();\n        const keyId = options.keyId != null ? options.keyId : newKey.publicKey;\n        const keepOnError = options.keepOnError || false;\n        this.addKeyPair(keyId, newKey);\n        return f(keyId)\n            .then(retain => {\n            if (retain === false) {\n                this.removeKeyPair(keyId);\n            }\n            return keyId;\n        })\n            .catch((e) => {\n            if (!keepOnError) {\n                this.removeKeyPair(keyId);\n            }\n            throw e;\n        });\n    }\n    async getSigner(id) {\n        return this.signers.get(id) || this.signersByPublicKey.get(id);\n    }\n}\nexports.SimpleKeystore = SimpleKeystore;\nclass SimpleSigner {\n    constructor(keyPair) {\n        this.keyPair = keyPair;\n        this.publicKey = this.keyPair.publicKey;\n    }\n    async sign(rawData) {\n        return nekoton.ed25519_sign(this.keyPair.secretKey, rawData);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9rZXlzdG9yZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9ldmVyc2NhbGUtc3RhbmRhbG9uZS1jbGllbnQvY2xpZW50L2tleXN0b3JlLmpzPzc0M2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpbXBsZUtleXN0b3JlID0gdm9pZCAwO1xuY29uc3QgY29yZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9jb3JlXCIpKTtcbmNvbnN0IHsgbmVrb3RvbiB9ID0gY29yZV8xLmRlZmF1bHQ7XG4vKipcbiAqIEBjYXRlZ29yeSBLZXlzdG9yZVxuICovXG5jbGFzcyBTaW1wbGVLZXlzdG9yZSB7XG4gICAgY29uc3RydWN0b3IoZW50cmllcyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc2lnbmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zaWduZXJzQnlQdWJsaWNLZXkgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2lkLCBzaWduZXJdIG9mIE9iamVjdC5lbnRyaWVzKGVudHJpZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEtleVBhaXIoaWQsIHNpZ25lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdlbmVyYXRlS2V5UGFpcigpIHtcbiAgICAgICAgcmV0dXJuIG5la290b24uZWQyNTUxOV9nZW5lcmF0ZUtleVBhaXIoKTtcbiAgICB9XG4gICAgYWRkS2V5UGFpcihpZE9yS2V5cGFpciwgcmVzdCkge1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGxldCBrZXlQYWlyO1xuICAgICAgICBpZiAodHlwZW9mIGlkT3JLZXlwYWlyID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZCA9IGlkT3JLZXlwYWlyO1xuICAgICAgICAgICAga2V5UGFpciA9IHJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IGlkT3JLZXlwYWlyLnB1YmxpY0tleTtcbiAgICAgICAgICAgIGtleVBhaXIgPSBpZE9yS2V5cGFpcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduZXIgPSBuZXcgU2ltcGxlU2lnbmVyKGtleVBhaXIpO1xuICAgICAgICB0aGlzLnNpZ25lcnMuc2V0KGlkLCBzaWduZXIpO1xuICAgICAgICB0aGlzLnNpZ25lcnNCeVB1YmxpY0tleS5zZXQoa2V5UGFpci5wdWJsaWNLZXksIHNpZ25lcik7XG4gICAgfVxuICAgIHJlbW92ZUtleVBhaXIoaWQpIHtcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gdGhpcy5zaWduZXJzLmdldChpZCk7XG4gICAgICAgIGlmIChzaWduZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zaWduZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICB0aGlzLnNpZ25lcnNCeVB1YmxpY0tleS5kZWxldGUoc2lnbmVyLnB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW5kIGFkZCBhIG5ldyBrZXlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGtleUlkIG9mIHRoZSBuZXcgc2lnbmVyXG4gICAgICovXG4gICAgYXN5bmMgd2l0aE5ld0tleShmLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgbmV3S2V5ID0gU2ltcGxlS2V5c3RvcmUuZ2VuZXJhdGVLZXlQYWlyKCk7XG4gICAgICAgIGNvbnN0IGtleUlkID0gb3B0aW9ucy5rZXlJZCAhPSBudWxsID8gb3B0aW9ucy5rZXlJZCA6IG5ld0tleS5wdWJsaWNLZXk7XG4gICAgICAgIGNvbnN0IGtlZXBPbkVycm9yID0gb3B0aW9ucy5rZWVwT25FcnJvciB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGRLZXlQYWlyKGtleUlkLCBuZXdLZXkpO1xuICAgICAgICByZXR1cm4gZihrZXlJZClcbiAgICAgICAgICAgIC50aGVuKHJldGFpbiA9PiB7XG4gICAgICAgICAgICBpZiAocmV0YWluID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlS2V5UGFpcihrZXlJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5SWQ7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGlmICgha2VlcE9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUtleVBhaXIoa2V5SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFNpZ25lcihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduZXJzLmdldChpZCkgfHwgdGhpcy5zaWduZXJzQnlQdWJsaWNLZXkuZ2V0KGlkKTtcbiAgICB9XG59XG5leHBvcnRzLlNpbXBsZUtleXN0b3JlID0gU2ltcGxlS2V5c3RvcmU7XG5jbGFzcyBTaW1wbGVTaWduZXIge1xuICAgIGNvbnN0cnVjdG9yKGtleVBhaXIpIHtcbiAgICAgICAgdGhpcy5rZXlQYWlyID0ga2V5UGFpcjtcbiAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSB0aGlzLmtleVBhaXIucHVibGljS2V5O1xuICAgIH1cbiAgICBhc3luYyBzaWduKHJhd0RhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5la290b24uZWQyNTUxOV9zaWduKHRoaXMua2V5UGFpci5zZWNyZXRLZXksIHJhd0RhdGEpO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/everscale-standalone-client/client/keystore.js\n");

/***/ }),

/***/ "./node_modules/everscale-standalone-client/client/utils.js":
/*!******************************************************************!*\
  !*** ./node_modules/everscale-standalone-client/client/utils.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getUniqueId = exports.convertVersionToInt32 = exports.SafeEventEmitter = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nfunction safeApply(handler, context, args) {\n    try {\n        Reflect.apply(handler, context, args);\n    }\n    catch (err) {\n        // Throw error after timeout so as not to interrupt the stack\n        setTimeout(() => {\n            throw err;\n        });\n    }\n}\nfunction arrayClone(arr) {\n    const n = arr.length;\n    const copy = new Array(n);\n    for (let i = 0; i < n; i += 1) {\n        copy[i] = arr[i];\n    }\n    return copy;\n}\nclass SafeEventEmitter extends events_1.EventEmitter {\n    emit(type, ...args) {\n        let doError = type === 'error';\n        const events = this._events;\n        if (events !== undefined) {\n            doError = doError && events.error === undefined;\n        }\n        else if (!doError) {\n            return false;\n        }\n        if (doError) {\n            let er;\n            if (args.length > 0) {\n                ;\n                [er] = args;\n            }\n            if (er instanceof Error) {\n                throw er;\n            }\n            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);\n            err.context = er;\n            throw err;\n        }\n        const handler = events[type];\n        if (handler === undefined) {\n            return false;\n        }\n        if (typeof handler === 'function') {\n            safeApply(handler, this, args);\n        }\n        else {\n            const len = handler.length;\n            const listeners = arrayClone(handler);\n            for (let i = 0; i < len; i += 1) {\n                safeApply(listeners[i], this, args);\n            }\n        }\n        return true;\n    }\n}\nexports.SafeEventEmitter = SafeEventEmitter;\n/**\n * @category Utils\n */\nconst convertVersionToInt32 = (version) => {\n    const parts = version.split('.');\n    if (parts.length !== 3) {\n        throw new Error('Received invalid version string');\n    }\n    parts.forEach((part) => {\n        if (~~part > 999) {\n            throw new Error(`Version string invalid, ${part} is too large`);\n        }\n    });\n    let multiplier = 1000000;\n    let numericVersion = 0;\n    for (let i = 0; i < 3; i++) {\n        numericVersion += ~~parts[i] * multiplier;\n        multiplier /= 1000;\n    }\n    return numericVersion;\n};\nexports.convertVersionToInt32 = convertVersionToInt32;\nconst MAX = 4294967295;\nlet idCounter = Math.floor(Math.random() * MAX);\nfunction getUniqueId() {\n    idCounter = (idCounter + 1) % MAX;\n    return idCounter;\n}\nexports.getUniqueId = getUniqueId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC91dGlscy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9ldmVyc2NhbGUtc3RhbmRhbG9uZS1jbGllbnQvY2xpZW50L3V0aWxzLmpzP2VmMmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFVuaXF1ZUlkID0gZXhwb3J0cy5jb252ZXJ0VmVyc2lvblRvSW50MzIgPSBleHBvcnRzLlNhZmVFdmVudEVtaXR0ZXIgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5mdW5jdGlvbiBzYWZlQXBwbHkoaGFuZGxlciwgY29udGV4dCwgYXJncykge1xuICAgIHRyeSB7XG4gICAgICAgIFJlZmxlY3QuYXBwbHkoaGFuZGxlciwgY29udGV4dCwgYXJncyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gVGhyb3cgZXJyb3IgYWZ0ZXIgdGltZW91dCBzbyBhcyBub3QgdG8gaW50ZXJydXB0IHRoZSBzdGFja1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIpIHtcbiAgICBjb25zdCBuID0gYXJyLmxlbmd0aDtcbiAgICBjb25zdCBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSArPSAxKSB7XG4gICAgICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufVxuY2xhc3MgU2FmZUV2ZW50RW1pdHRlciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgZW1pdCh0eXBlLCAuLi5hcmdzKSB7XG4gICAgICAgIGxldCBkb0Vycm9yID0gdHlwZSA9PT0gJ2Vycm9yJztcbiAgICAgICAgY29uc3QgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRvRXJyb3IgPSBkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkb0Vycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvRXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBlcjtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgW2VyXSA9IGFyZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBVbmhhbmRsZWQgZXJyb3IuJHtlciA/IGAgKCR7ZXIubWVzc2FnZX0pYCA6ICcnfWApO1xuICAgICAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlQXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlcik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgc2FmZUFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5TYWZlRXZlbnRFbWl0dGVyID0gU2FmZUV2ZW50RW1pdHRlcjtcbi8qKlxuICogQGNhdGVnb3J5IFV0aWxzXG4gKi9cbmNvbnN0IGNvbnZlcnRWZXJzaW9uVG9JbnQzMiA9ICh2ZXJzaW9uKSA9PiB7XG4gICAgY29uc3QgcGFydHMgPSB2ZXJzaW9uLnNwbGl0KCcuJyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY2VpdmVkIGludmFsaWQgdmVyc2lvbiBzdHJpbmcnKTtcbiAgICB9XG4gICAgcGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgICBpZiAofn5wYXJ0ID4gOTk5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZlcnNpb24gc3RyaW5nIGludmFsaWQsICR7cGFydH0gaXMgdG9vIGxhcmdlYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgbXVsdGlwbGllciA9IDEwMDAwMDA7XG4gICAgbGV0IG51bWVyaWNWZXJzaW9uID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBudW1lcmljVmVyc2lvbiArPSB+fnBhcnRzW2ldICogbXVsdGlwbGllcjtcbiAgICAgICAgbXVsdGlwbGllciAvPSAxMDAwO1xuICAgIH1cbiAgICByZXR1cm4gbnVtZXJpY1ZlcnNpb247XG59O1xuZXhwb3J0cy5jb252ZXJ0VmVyc2lvblRvSW50MzIgPSBjb252ZXJ0VmVyc2lvblRvSW50MzI7XG5jb25zdCBNQVggPSA0Mjk0OTY3Mjk1O1xubGV0IGlkQ291bnRlciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1BWCk7XG5mdW5jdGlvbiBnZXRVbmlxdWVJZCgpIHtcbiAgICBpZENvdW50ZXIgPSAoaWRDb3VudGVyICsgMSkgJSBNQVg7XG4gICAgcmV0dXJuIGlkQ291bnRlcjtcbn1cbmV4cG9ydHMuZ2V0VW5pcXVlSWQgPSBnZXRVbmlxdWVJZDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/everscale-standalone-client/client/utils.js\n");

/***/ }),

/***/ "./node_modules/everscale-standalone-client/core.js":
/*!**********************************************************!*\
  !*** ./node_modules/everscale-standalone-client/core.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst core = {\n    ensureNekotonLoaded: undefined,\n    nekoton: undefined,\n    fetch: undefined,\n    fetchAgent: () => undefined,\n    debugLog: undefined,\n};\nexports.default = core;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NvcmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NvcmUuanM/Yzk4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvcmUgPSB7XG4gICAgZW5zdXJlTmVrb3RvbkxvYWRlZDogdW5kZWZpbmVkLFxuICAgIG5la290b246IHVuZGVmaW5lZCxcbiAgICBmZXRjaDogdW5kZWZpbmVkLFxuICAgIGZldGNoQWdlbnQ6ICgpID0+IHVuZGVmaW5lZCxcbiAgICBkZWJ1Z0xvZzogdW5kZWZpbmVkLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNvcmU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/everscale-standalone-client/core.js\n");

/***/ }),

/***/ "./node_modules/everscale-standalone-client/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/everscale-standalone-client/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst nekoton_wasm_1 = __importStar(__webpack_require__(/*! nekoton-wasm */ \"./node_modules/nekoton-wasm/nekoton_wasm.js\")), nt = nekoton_wasm_1;\nconst core_1 = __importDefault(__webpack_require__(/*! ./core */ \"./node_modules/everscale-standalone-client/core.js\"));\nlet clientInitializationStarted = false;\nlet notifyClientInitialized;\nconst initializationPromise = new Promise((resolve, reject) => {\n    notifyClientInitialized = { resolve, reject };\n});\ncore_1.default.ensureNekotonLoaded = (initInput) => {\n    if (!clientInitializationStarted) {\n        clientInitializationStarted = true;\n        (0, nekoton_wasm_1.default)(initInput).then(notifyClientInitialized.resolve).catch(notifyClientInitialized.reject);\n    }\n    return initializationPromise;\n};\ncore_1.default.nekoton = nt;\ncore_1.default.fetch = fetch;\ncore_1.default.debugLog = console.debug;\n__exportStar(__webpack_require__(/*! ./client */ \"./node_modules/everscale-standalone-client/client/index.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9pbmRleC5qcz8wZTcwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgbmVrb3Rvbl93YXNtXzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIm5la290b24td2FzbVwiKSksIG50ID0gbmVrb3Rvbl93YXNtXzE7XG5jb25zdCBjb3JlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29yZVwiKSk7XG5sZXQgY2xpZW50SW5pdGlhbGl6YXRpb25TdGFydGVkID0gZmFsc2U7XG5sZXQgbm90aWZ5Q2xpZW50SW5pdGlhbGl6ZWQ7XG5jb25zdCBpbml0aWFsaXphdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbm90aWZ5Q2xpZW50SW5pdGlhbGl6ZWQgPSB7IHJlc29sdmUsIHJlamVjdCB9O1xufSk7XG5jb3JlXzEuZGVmYXVsdC5lbnN1cmVOZWtvdG9uTG9hZGVkID0gKGluaXRJbnB1dCkgPT4ge1xuICAgIGlmICghY2xpZW50SW5pdGlhbGl6YXRpb25TdGFydGVkKSB7XG4gICAgICAgIGNsaWVudEluaXRpYWxpemF0aW9uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICgwLCBuZWtvdG9uX3dhc21fMS5kZWZhdWx0KShpbml0SW5wdXQpLnRoZW4obm90aWZ5Q2xpZW50SW5pdGlhbGl6ZWQucmVzb2x2ZSkuY2F0Y2gobm90aWZ5Q2xpZW50SW5pdGlhbGl6ZWQucmVqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGluaXRpYWxpemF0aW9uUHJvbWlzZTtcbn07XG5jb3JlXzEuZGVmYXVsdC5uZWtvdG9uID0gbnQ7XG5jb3JlXzEuZGVmYXVsdC5mZXRjaCA9IGZldGNoO1xuY29yZV8xLmRlZmF1bHQuZGVidWdMb2cgPSBjb25zb2xlLmRlYnVnO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NsaWVudFwiKSwgZXhwb3J0cyk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/everscale-standalone-client/index.js\n");

/***/ }),

/***/ "./node_modules/fast-safe-stringify/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-safe-stringify/index.js ***!
  \***************************************************/
/***/ ((module) => {

eval("module.exports = stringify\nstringify.default = stringify\nstringify.stable = deterministicStringify\nstringify.stableStringify = deterministicStringify\n\nvar LIMIT_REPLACE_NODE = '[...]'\nvar CIRCULAR_REPLACE_NODE = '[Circular]'\n\nvar arr = []\nvar replacerStack = []\n\nfunction defaultOptions () {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER\n  }\n}\n\n// Regular stringify\nfunction stringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  decirc(obj, '', 0, [], undefined, 0, options)\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer)\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction setReplace (replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, { value: replace })\n      arr.push([parent, k, val, propertyDescriptor])\n    } else {\n      replacerStack.push([val, k, replace])\n    }\n  } else {\n    parent[k] = replace\n    arr.push([parent, k, val])\n  }\n}\n\nfunction decirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      var keys = Object.keys(val)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        decirc(val[key], key, i, stack, val, depth, options)\n      }\n    }\n    stack.pop()\n  }\n}\n\n// Stable-stringify\nfunction compareFunction (a, b) {\n  if (a < b) {\n    return -1\n  }\n  if (a > b) {\n    return 1\n  }\n  return 0\n}\n\nfunction deterministicStringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer)\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n    try {\n      if (typeof val.toJSON === 'function') {\n        return\n      }\n    } catch (_) {\n      return\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {}\n      var keys = Object.keys(val).sort(compareFunction)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        deterministicDecirc(val[key], key, i, stack, val, depth, options)\n        tmp[key] = val[key]\n      }\n      if (typeof parent !== 'undefined') {\n        arr.push([parent, k, val])\n        parent[k] = tmp\n      } else {\n        return tmp\n      }\n    }\n    stack.pop()\n  }\n}\n\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues (replacer) {\n  replacer =\n    typeof replacer !== 'undefined'\n      ? replacer\n      : function (k, v) {\n        return v\n      }\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i]\n        if (part[1] === key && part[0] === val) {\n          val = part[2]\n          replacerStack.splice(i, 1)\n          break\n        }\n      }\n    }\n    return replacer.call(this, key, val)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9mYXN0LXNhZmUtc3RyaW5naWZ5L2luZGV4LmpzP2U1ZWMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnlcbnN0cmluZ2lmeS5kZWZhdWx0ID0gc3RyaW5naWZ5XG5zdHJpbmdpZnkuc3RhYmxlID0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeVxuc3RyaW5naWZ5LnN0YWJsZVN0cmluZ2lmeSA9IGRldGVybWluaXN0aWNTdHJpbmdpZnlcblxudmFyIExJTUlUX1JFUExBQ0VfTk9ERSA9ICdbLi4uXSdcbnZhciBDSVJDVUxBUl9SRVBMQUNFX05PREUgPSAnW0NpcmN1bGFyXSdcblxudmFyIGFyciA9IFtdXG52YXIgcmVwbGFjZXJTdGFjayA9IFtdXG5cbmZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zICgpIHtcbiAgcmV0dXJuIHtcbiAgICBkZXB0aExpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICBlZGdlc0xpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICB9XG59XG5cbi8vIFJlZ3VsYXIgc3RyaW5naWZ5XG5mdW5jdGlvbiBzdHJpbmdpZnkgKG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKClcbiAgfVxuXG4gIGRlY2lyYyhvYmosICcnLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKVxuICB2YXIgcmVzXG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcilcbiAgICB9XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJ1t1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV0nKVxuICB9IGZpbmFsbHkge1xuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKVxuICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzZXRSZXBsYWNlIChyZXBsYWNlLCB2YWwsIGssIHBhcmVudCkge1xuICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIGspXG4gIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcmVudCwgaywgeyB2YWx1ZTogcmVwbGFjZSB9KVxuICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsLCBwcm9wZXJ0eURlc2NyaXB0b3JdKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlclN0YWNrLnB1c2goW3ZhbCwgaywgcmVwbGFjZV0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcmVudFtrXSA9IHJlcGxhY2VcbiAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlY2lyYyAodmFsLCBrLCBlZGdlSW5kZXgsIHN0YWNrLCBwYXJlbnQsIGRlcHRoLCBvcHRpb25zKSB7XG4gIGRlcHRoICs9IDFcbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5kZXB0aExpbWl0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXRcbiAgICApIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmVkZ2VzTGltaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0XG4gICAgKSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzdGFjay5wdXNoKHZhbClcbiAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbClcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldXG4gICAgICAgIGRlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sucG9wKClcbiAgfVxufVxuXG4vLyBTdGFibGUtc3RyaW5naWZ5XG5mdW5jdGlvbiBjb21wYXJlRnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljU3RyaW5naWZ5IChvYmosIHJlcGxhY2VyLCBzcGFjZXIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucygpXG4gIH1cblxuICB2YXIgdG1wID0gZGV0ZXJtaW5pc3RpY0RlY2lyYyhvYmosICcnLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKSB8fCBvYmpcbiAgdmFyIHJlc1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlciwgc3BhY2VyKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpXG4gICAgfVxuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KCdbdW5hYmxlIHRvIHNlcmlhbGl6ZSwgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIHRvbyBjb21wbGV4IHRvIGFuYWx5emVdJylcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXN0b3JlIHRoZSBvYmplY3QgYXMgaXQgd2FzLlxuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKVxuICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljRGVjaXJjICh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgZGVwdGggKz0gMVxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RhY2tbaV0gPT09IHZhbCkge1xuICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiB2YWwudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBkZXB0aCA+IG9wdGlvbnMuZGVwdGhMaW1pdFxuICAgICkge1xuICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMuZWRnZXNMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGVkZ2VJbmRleCArIDEgPiBvcHRpb25zLmVkZ2VzTGltaXRcbiAgICApIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHN0YWNrLnB1c2godmFsKVxuICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkgb2JqZWN0IGluIHRoZSByZXF1aXJlZCB3YXlcbiAgICAgIHZhciB0bXAgPSB7fVxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpLnNvcnQoY29tcGFyZUZ1bmN0aW9uKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucylcbiAgICAgICAgdG1wW2tleV0gPSB2YWxba2V5XVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pXG4gICAgICAgIHBhcmVudFtrXSA9IHRtcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRtcFxuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKVxuICB9XG59XG5cbi8vIHdyYXBzIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB2YWx1ZXMgd2UgY291bGRuJ3QgcmVwbGFjZVxuLy8gYW5kIG1hcmsgdGhlbSBhcyByZXBsYWNlZCB2YWx1ZVxuZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyAocmVwbGFjZXIpIHtcbiAgcmVwbGFjZXIgPVxuICAgIHR5cGVvZiByZXBsYWNlciAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gcmVwbGFjZXJcbiAgICAgIDogZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgcmV0dXJuIHZcbiAgICAgIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwbGFjZXJTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IHJlcGxhY2VyU3RhY2tbaV1cbiAgICAgICAgaWYgKHBhcnRbMV0gPT09IGtleSAmJiBwYXJ0WzBdID09PSB2YWwpIHtcbiAgICAgICAgICB2YWwgPSBwYXJ0WzJdXG4gICAgICAgICAgcmVwbGFjZXJTdGFjay5zcGxpY2UoaSwgMSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsKVxuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fast-safe-stringify/index.js\n");

/***/ }),

/***/ "./node_modules/honeycomb-grid/dist/honeycomb-grid.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/honeycomb-grid/dist/honeycomb-grid.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Direction\": () => (/* binding */ f),\n/* harmony export */   \"Grid\": () => (/* binding */ q),\n/* harmony export */   \"Hex\": () => (/* binding */ $),\n/* harmony export */   \"Orientation\": () => (/* binding */ g),\n/* harmony export */   \"Rotation\": () => (/* binding */ L),\n/* harmony export */   \"completeCube\": () => (/* binding */ p),\n/* harmony export */   \"concat\": () => (/* binding */ N),\n/* harmony export */   \"createHexDimensions\": () => (/* binding */ G),\n/* harmony export */   \"createHexOrigin\": () => (/* binding */ D),\n/* harmony export */   \"defaultHexSettings\": () => (/* binding */ T),\n/* harmony export */   \"defineHex\": () => (/* binding */ et),\n/* harmony export */   \"distance\": () => (/* binding */ R),\n/* harmony export */   \"equals\": () => (/* binding */ nt),\n/* harmony export */   \"fromCoordinates\": () => (/* binding */ Tt),\n/* harmony export */   \"hexToOffset\": () => (/* binding */ W),\n/* harmony export */   \"hexToPoint\": () => (/* binding */ J),\n/* harmony export */   \"isAxial\": () => (/* binding */ Ot),\n/* harmony export */   \"isOffset\": () => (/* binding */ S),\n/* harmony export */   \"isPoint\": () => (/* binding */ V),\n/* harmony export */   \"isTuple\": () => (/* binding */ H),\n/* harmony export */   \"line\": () => (/* binding */ v),\n/* harmony export */   \"move\": () => (/* binding */ wt),\n/* harmony export */   \"neighborOf\": () => (/* binding */ I),\n/* harmony export */   \"offsetFromZero\": () => (/* binding */ P),\n/* harmony export */   \"offsetToCube\": () => (/* binding */ j),\n/* harmony export */   \"offsetToCubeFlat\": () => (/* binding */ _),\n/* harmony export */   \"offsetToCubePointy\": () => (/* binding */ z),\n/* harmony export */   \"pointToCube\": () => (/* binding */ it),\n/* harmony export */   \"rectangle\": () => (/* binding */ St),\n/* harmony export */   \"repeat\": () => (/* binding */ pt),\n/* harmony export */   \"repeatWith\": () => (/* binding */ U),\n/* harmony export */   \"ring\": () => (/* binding */ yt),\n/* harmony export */   \"round\": () => (/* binding */ F),\n/* harmony export */   \"spiral\": () => (/* binding */ Ct),\n/* harmony export */   \"toCube\": () => (/* binding */ C),\n/* harmony export */   \"translate\": () => (/* binding */ ct),\n/* harmony export */   \"tupleToCube\": () => (/* binding */ E)\n/* harmony export */ });\nconst l = (r) => Number.isFinite(r) && !Number.isNaN(r), w = (r) => typeof r == \"object\" && r !== null, Ot = (r) => w(r) && l(r.q) && l(r.r), k = (r) => typeof r == \"function\", S = (r) => w(r) && l(r.col) && l(r.row), V = (r) => w(r) && l(r.x) && l(r.y), H = (r) => Array.isArray(r) && l(r[0]) && l(r[1]), P = (r, t) => t + r * (t & 1) >> 1;\nfunction Z(r, t) {\n  return (r % t + t) % t;\n}\nconst X = (r, t) => Z(r + t, 8), E = ([r, t, e = -r - t]) => ({ q: r, r: t, s: e });\nfunction p({ q: r, r: t, s: e }) {\n  const n = l(r), s = l(t), o = l(e);\n  if (n && s && o)\n    return { q: r, r: t, s: e };\n  if (n && s)\n    return { q: r, r: t, s: -r - t };\n  if (n && o)\n    return { q: r, r: -r - e, s: e };\n  if (s && o)\n    return { q: -t - e, r: t, s: e };\n  throw new TypeError(\n    `Can't determine three cube coordinates from less than two coordinates. Received: { q: ${r}, r: ${t}, s: ${e} }.`\n  );\n}\nvar g = /* @__PURE__ */ ((r) => (r.FLAT = \"FLAT\", r.POINTY = \"POINTY\", r))(g || {});\nfunction G(r, t) {\n  if (w(r) && r.xRadius > 0 && r.yRadius > 0)\n    return r;\n  if (w(r) && r.width > 0 && r.height > 0) {\n    const { width: e, height: n } = r;\n    return t === g.POINTY ? { xRadius: e / Math.sqrt(3), yRadius: n / 2 } : { xRadius: e / 2, yRadius: n / Math.sqrt(3) };\n  }\n  if (r > 0)\n    return { xRadius: r, yRadius: r };\n  throw new TypeError(\n    `Invalid dimensions: ${JSON.stringify(\n      r\n    )}. Dimensions must be expressed as an Ellipse ({ xRadius: number, yRadius: number }), a Rectangle ({ width: number, height: number }) or a number.`\n  );\n}\nfunction D(r, t) {\n  if (V(r))\n    return r;\n  if (!t)\n    throw new TypeError(\n      `Supply a bounding box ({ width: number, height: number }). Received: ${JSON.stringify(t)}`\n    );\n  if (r === \"topLeft\")\n    return { x: t.width * -0.5, y: t.height * -0.5 };\n  throw new TypeError(\n    `Invalid origin: ${JSON.stringify(\n      r\n    )}. Origin must be expressed as a Point ({ x: number, y: number }) or the string 'topLeft'.`\n  );\n}\nclass $ {\n  static get settings() {\n    const { dimensions: t, orientation: e, origin: n, offset: s } = this.prototype;\n    return { dimensions: t, orientation: e, origin: n, offset: s };\n  }\n  get center() {\n    const { width: t, height: e, x: n, y: s } = this;\n    return { x: t / 2 - n, y: e / 2 - s };\n  }\n  get col() {\n    return W(this).col;\n  }\n  get corners() {\n    const { orientation: t, width: e, height: n, x: s, y: o } = this;\n    return t === g.POINTY ? tt(e, n, s, o) : rt(e, n, s, o);\n  }\n  get dimensions() {\n    return T.dimensions;\n  }\n  get height() {\n    const {\n      orientation: t,\n      dimensions: { yRadius: e }\n    } = this;\n    return t === g.POINTY ? e * 2 : e * Math.sqrt(3);\n  }\n  get isFlat() {\n    return this.orientation === g.FLAT;\n  }\n  get isPointy() {\n    return this.orientation === g.POINTY;\n  }\n  get orientation() {\n    return T.orientation;\n  }\n  get origin() {\n    return T.origin;\n  }\n  get offset() {\n    return T.offset;\n  }\n  get row() {\n    return W(this).row;\n  }\n  get width() {\n    const {\n      orientation: t,\n      dimensions: { xRadius: e }\n    } = this;\n    return t === g.POINTY ? e * Math.sqrt(3) : e * 2;\n  }\n  get x() {\n    return J(this).x;\n  }\n  get y() {\n    return J(this).y;\n  }\n  get s() {\n    return -this.q - this.r;\n  }\n  q;\n  r;\n  constructor(t = [0, 0]) {\n    const { q: e, r: n } = C(this, t);\n    this.q = e, this.r = n;\n  }\n  clone(t = this) {\n    return new this.constructor(t);\n  }\n  equals(t) {\n    return nt(this, S(t) ? j(this, t) : t);\n  }\n  toString() {\n    return `${this.constructor.name}(${this.q},${this.r})`;\n  }\n  translate(t) {\n    return ct(this, t);\n  }\n}\nconst T = {\n  dimensions: { xRadius: 1, yRadius: 1 },\n  orientation: g.POINTY,\n  origin: { x: 0, y: 0 },\n  offset: -1\n}, tt = (r, t, e, n) => [\n  { x: e + r * 0.5, y: n - t * 0.25 },\n  { x: e + r * 0.5, y: n + t * 0.25 },\n  { x: e, y: n + t * 0.5 },\n  { x: e - r * 0.5, y: n + t * 0.25 },\n  { x: e - r * 0.5, y: n - t * 0.25 },\n  { x: e, y: n - t * 0.5 }\n], rt = (r, t, e, n) => [\n  { x: e + r * 0.25, y: n - t * 0.5 },\n  { x: e + r * 0.5, y: n },\n  { x: e + r * 0.25, y: n + t * 0.5 },\n  { x: e - r * 0.25, y: n + t * 0.5 },\n  { x: e - r * 0.5, y: n },\n  { x: e - r * 0.25, y: n - t * 0.5 }\n];\nfunction et(r) {\n  const { dimensions: t, orientation: e, origin: n, offset: s } = { ...T, ...r };\n  return class extends $ {\n    get dimensions() {\n      return G(t, e);\n    }\n    get orientation() {\n      return e;\n    }\n    get origin() {\n      return D(n, this);\n    }\n    get offset() {\n      return s;\n    }\n  };\n}\nfunction nt(r, t) {\n  if (S(r) && S(t))\n    return r.col === t.col && r.row === t.row;\n  if (Object.hasOwn(r, \"col\") || Object.hasOwn(t, \"col\"))\n    throw new Error(\n      `Can't compare coordinates where one are offset coordinates. Either pass two offset coordinates or two axial/cube coordinates. Received: ${JSON.stringify(\n        r\n      )} and ${JSON.stringify(t)}`\n    );\n  const e = H(r) ? E(r) : r, n = H(t) ? E(t) : t;\n  return e.q === n.q && e.r === n.r;\n}\nconst st = (r, t, e) => ({\n  col: r + P(e, t),\n  row: t\n}), ot = (r, t, e) => ({\n  col: r,\n  row: t + P(e, r)\n}), W = ({ q: r, r: t, offset: e, isPointy: n }) => n ? st(r, t, e) : ot(r, t, e), J = ({ orientation: r, dimensions: { xRadius: t, yRadius: e }, origin: { x: n, y: s }, q: o, r: i }) => r === g.POINTY ? {\n  x: t * Math.sqrt(3) * (o + i / 2) - n,\n  y: e * 3 / 2 * i - s\n} : {\n  x: t * 3 / 2 * o - n,\n  y: e * Math.sqrt(3) * (i + o / 2) - s\n}, z = (r, t, e) => {\n  const n = r - P(e, t), s = t, o = -n - s;\n  return { q: n, r: s, s: o };\n}, _ = (r, t, e) => {\n  const n = r, s = t - P(e, r), o = -n - s;\n  return { q: n, r: s, s: o };\n}, j = ({ offset: r, orientation: t }, { col: e, row: n }) => t === g.POINTY ? z(e, n, r) : _(e, n, r), F = (r) => {\n  const { q: t, r: e, s: n } = p(r);\n  let s = Math.round(t), o = Math.round(e), i = Math.round(n);\n  const c = Math.abs(t - s), u = Math.abs(e - o), h = Math.abs(n - i);\n  return c > u && c > h ? s = -o - i : u > h ? o = -s - i : i = -s - o, { q: s, r: o, s: i };\n}, it = ({ dimensions: { xRadius: r, yRadius: t }, origin: e, orientation: n }, { x: s, y: o }) => (s += e.x, o += e.y, n === g.POINTY ? F({ q: Math.sqrt(3) * s / (3 * r) - o / (3 * t), r: 2 / 3 * (o / t) }) : F({ q: 2 / 3 * (s / r), r: Math.sqrt(3) * o / (3 * t) - s / (3 * r) }));\nfunction C(r, t) {\n  return H(t) ? E(t) : S(t) ? j(r, t) : p(t);\n}\nfunction ct(r, t) {\n  const { q: e, r: n, s } = p(r), { q: o, r: i, s: c } = p(t), u = { q: e + o, r: n + i, s: s + c };\n  return r instanceof $ ? r.clone(u) : u;\n}\nfunction R(r, t, e) {\n  const { q: n, r: s, s: o } = C(r, t), { q: i, r: c, s: u } = C(r, e);\n  return Math.max(Math.abs(n - i), Math.abs(s - c), Math.abs(o - u));\n}\nvar L = /* @__PURE__ */ ((r) => (r.CLOCKWISE = \"CLOCKWISE\", r.COUNTERCLOCKWISE = \"COUNTERCLOCKWISE\", r))(L || {}), f = /* @__PURE__ */ ((r) => (r[r.N = 0] = \"N\", r[r.NE = 1] = \"NE\", r[r.E = 2] = \"E\", r[r.SE = 3] = \"SE\", r[r.S = 4] = \"S\", r[r.SW = 5] = \"SW\", r[r.W = 6] = \"W\", r[r.NW = 7] = \"NW\", r))(f || {});\nconst ut = [\n  null,\n  { q: 1, r: -1 },\n  { q: 1, r: 0 },\n  { q: 0, r: 1 },\n  null,\n  { q: -1, r: 1 },\n  { q: -1, r: 0 },\n  { q: 0, r: -1 }\n], ht = [\n  { q: 0, r: -1 },\n  { q: 1, r: -1 },\n  null,\n  { q: 1, r: 0 },\n  { q: 0, r: 1 },\n  { q: -1, r: 1 },\n  null,\n  { q: -1, r: 0 }\n], ft = ({ offset: r, q: t, r: e, col: n, row: s }, o) => {\n  if (o === f.S || o === f.N) {\n    const c = o === f.S ? s + 1 : s - 1;\n    return z(n, c, r);\n  }\n  const i = ut[o];\n  return { q: t + i.q, r: e + i.r };\n}, at = ({ offset: r, q: t, r: e, col: n, row: s }, o) => {\n  if (o === f.E || o === f.W) {\n    const c = o === f.E ? n + 1 : n - 1;\n    return _(c, s, r);\n  }\n  const i = ht[o];\n  return { q: t + i.q, r: e + i.r };\n}, I = (r, t) => r.clone(r.isPointy ? ft(r, t) : at(r, t));\nfunction N(r) {\n  return Array.isArray(r) ? function(e, n) {\n    const s = [];\n    let o = n;\n    for (const i of r)\n      for (const c of i(e, o))\n        s.push(o = c);\n    return s;\n  } : r;\n}\nconst Tt = (...r) => (t) => r.map(t);\nfunction v(r) {\n  return lt(r) ? gt(r) : xt(r);\n}\nfunction lt(r) {\n  return r.direction in f;\n}\nfunction gt({ start: r, direction: t, length: e }) {\n  return function(s, o) {\n    const i = [];\n    let u = s(r ?? o);\n    !r && o && (u = I(u, t));\n    for (let h = 0; h < e; h++)\n      i.push(u), u = I(u, t);\n    return i;\n  };\n}\nfunction xt({ start: r, stop: t }) {\n  return function(n, s) {\n    const o = [], i = n(r ?? s), c = B(i), u = B(C(i, t)), h = dt(c, u), x = R(i, i, t), y = 1 / Math.max(x, 1);\n    let m = !r && s ? 1 : 0;\n    for (m; m <= x; m++) {\n      const a = F(h(y * m));\n      o.push(n(a));\n    }\n    return o;\n  };\n}\nfunction B({ q: r, r: t, s: e }) {\n  return { q: r + 1e-6, r: t + 1e-6, s: e + -2e-6 };\n}\nfunction dt(r, t) {\n  return (e) => {\n    const n = r.q * (1 - e) + t.q * e, s = r.r * (1 - e) + t.r * e;\n    return { q: n, r: s };\n  };\n}\nconst wt = (r) => (t, e) => [I(t(e), r)];\nfunction U(r, t, { includeSource: e = !0 } = {}) {\n  return function(s, o) {\n    const i = [];\n    for (const c of N(r)(s, o)) {\n      e && i.push(c);\n      for (const u of N(t)(s, c))\n        i.push(u);\n    }\n    return i;\n  };\n}\nfunction St(r, t) {\n  return function(n, s) {\n    const {\n      width: o,\n      height: i,\n      start: c,\n      direction: u = f.E\n    } = t ? mt(r, t, n()) : r, h = c ?? s ?? [0, 0], x = U(\n      v({ start: h, direction: X(u, 2), length: i }),\n      v({ direction: u, length: o - 1 })\n    )(n, h);\n    return !c && s ? x.slice(1) : x;\n  };\n}\nfunction mt(r, t, { isPointy: e, offset: n }) {\n  const { col: s, row: o } = K(r, e, n), { col: i, row: c } = K(t, e, n), u = s < i ? \"A\" : \"B\", h = o < c ? \"A\" : \"B\", x = u + h, { swapWidthHeight: y, direction: m } = qt[x], a = Math.abs(s - i) + 1, b = Math.abs(o - c) + 1;\n  return {\n    width: y ? b : a,\n    height: y ? a : b,\n    start: r,\n    direction: m\n  };\n}\nfunction K(r, t, e) {\n  if (S(r))\n    return r;\n  const { q: n, r: s } = H(r) ? E(r) : p(r);\n  return W({ q: n, r: s, isPointy: t, offset: e });\n}\nconst qt = {\n  AA: {\n    swapWidthHeight: !1,\n    direction: f.E\n  },\n  AB: {\n    swapWidthHeight: !0,\n    direction: f.N\n  },\n  BA: {\n    swapWidthHeight: !0,\n    direction: f.S\n  },\n  BB: {\n    swapWidthHeight: !1,\n    direction: f.W\n  }\n};\nfunction pt(r, t) {\n  return N(Array.from({ length: r }, () => N(t)));\n}\nfunction yt(r) {\n  const { center: t, rotation: e = L.CLOCKWISE } = r;\n  return function(s, o) {\n    const i = e.toUpperCase(), c = [];\n    let { radius: u } = r, h;\n    l(u) ? h = s(t).translate({ q: u, s: -u }) : (h = s(r.start ?? o), u = R(h, t, h));\n    const { q: x, r: y, s: m } = C(h, t);\n    let a = s({ q: x, r: y - u, s: m + u });\n    if (i === L.CLOCKWISE)\n      for (let d = 0; d < 6; d++)\n        for (let O = 0; O < u; O++) {\n          const { q: A, r: M } = Q[d];\n          a = s({ q: a.q + A, r: a.r + M }), c.push(a);\n        }\n    else\n      for (let d = 5; d >= 0; d--)\n        for (let O = 0; O < u; O++) {\n          const { q: A, r: M } = Q[d];\n          a = s({ q: a.q - A, r: a.r - M }), c.push(a);\n        }\n    const b = !r.start && o, Y = c.findIndex((d) => d.equals(h));\n    return c.slice(Y + (b ? 1 : 0)).concat(c.slice(0, Y));\n  };\n}\nconst Q = [\n  { q: 1, r: 0 },\n  { q: 0, r: 1 },\n  { q: -1, r: 1 },\n  { q: -1, r: 0 },\n  { q: 0, r: -1 },\n  { q: 1, r: -1 }\n];\nfunction Ct({ radius: r, start: t, rotation: e }) {\n  return function(s, o) {\n    const i = t ?? o ?? [0, 0], c = !t && o ? r : r + 1;\n    return U(v({ start: t, direction: f.N, length: c }), yt({ center: i, rotation: e }))(s, o);\n  };\n}\nclass q {\n  static fromIterable(t) {\n    const e = t[Symbol.iterator]().next().value;\n    if (!e)\n      throw new TypeError(`Can't create grid from empty iterable: ${JSON.stringify(t)}`);\n    return new q(e.constructor, t);\n  }\n  static fromJSON({ hexSettings: t, coordinates: e }) {\n    const n = et(t);\n    return new q(\n      n,\n      e.map((s) => new n(s))\n    );\n  }\n  get size() {\n    return this.#r.size;\n  }\n  get pixelWidth() {\n    if (this.size === 0)\n      return 0;\n    const { isPointy: t, width: e } = this.hexPrototype, n = this.toArray(), {\n      0: s,\n      length: o,\n      [o - 1]: i\n    } = t ? n.sort((c, u) => u.s - c.s || c.q - u.q) : n.sort((c, u) => c.q - u.q);\n    return i.x - s.x + e;\n  }\n  get pixelHeight() {\n    if (this.size === 0)\n      return 0;\n    const { isPointy: t, height: e } = this.hexPrototype, n = this.toArray(), {\n      0: s,\n      length: o,\n      [o - 1]: i\n    } = t ? n.sort((c, u) => c.r - u.r) : n.sort((c, u) => u.s - c.s || c.r - u.r);\n    return i.y - s.y + e;\n  }\n  [Symbol.iterator]() {\n    return this.#r.values();\n  }\n  get hexPrototype() {\n    return this.#t.prototype;\n  }\n  #t;\n  #r = /* @__PURE__ */ new Map();\n  constructor(t, e = []) {\n    if (t instanceof q) {\n      this.#t = t.#t, this.setHexes(t);\n      return;\n    }\n    this.#t = t, this.setHexes(this.#n(e));\n  }\n  createHex(t) {\n    return new this.#t(t);\n  }\n  getHex(t) {\n    const e = this.createHex(t);\n    return this.#r.get(e.toString());\n  }\n  hasHex(t) {\n    return this.#r.has(t.toString());\n  }\n  setHexes(t) {\n    for (const e of t) {\n      const n = e instanceof $ ? e : new this.#t(e);\n      this.#e(n);\n    }\n    return this;\n  }\n  filter(t) {\n    const e = new q(this.#t);\n    for (const n of this)\n      t(n) && e.#e(n);\n    return e;\n  }\n  map(t) {\n    const e = new q(this.#t);\n    for (const n of this)\n      e.#e(t(n));\n    return e;\n  }\n  traverse(t, { bail: e = !1 } = {}) {\n    const n = new q(this.#t);\n    for (const s of this.#n(t)) {\n      const o = this.getHex(s);\n      if (o)\n        n.#e(o);\n      else if (e)\n        return n;\n    }\n    return n;\n  }\n  forEach(t) {\n    for (const e of this)\n      t(e);\n    return this;\n  }\n  reduce(t, e) {\n    if (e === void 0) {\n      let s, o, i;\n      for (const c of this)\n        o = i, i = c, o && (s = t(o, i));\n      return s;\n    }\n    let n = e;\n    for (const s of this)\n      n = t(n, s);\n    return n;\n  }\n  toArray() {\n    return Array.from(this);\n  }\n  toJSON() {\n    const { dimensions: t, orientation: e, origin: n, offset: s } = this.hexPrototype;\n    return { hexSettings: { dimensions: t, orientation: e, origin: n, offset: s }, coordinates: this.toArray() };\n  }\n  toString() {\n    return `${this.constructor.name}(${this.size})`;\n  }\n  pointToHex(t, { allowOutside: e = !0 } = {}) {\n    const n = it(this.hexPrototype, t), s = this.getHex(n);\n    return e ? s ?? this.createHex(n) : s;\n  }\n  distance(t, e, { allowOutside: n = !0 } = {}) {\n    if (n)\n      return R(this.hexPrototype, t, e);\n    const s = this.getHex(t), o = this.getHex(e);\n    if (!(!s || !o))\n      return R(this.hexPrototype, s, o);\n  }\n  neighborOf(t, e, { allowOutside: n = !0 } = {}) {\n    const s = I(this.createHex(t), e), o = this.getHex(s);\n    return n ? o ?? s : o;\n  }\n  #e(t) {\n    this.#r.set(t.toString(), t);\n  }\n  #n(t) {\n    return this.#s(t) ? this.#o(t) : Array.isArray(t) && this.#s(t[0]) ? this.#o(N(t)) : t;\n  }\n  #s(t) {\n    return k(t);\n  }\n  #o(t) {\n    return t(this.createHex.bind(this));\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaG9uZXljb21iLWdyaWQvZGlzdC9ob25leWNvbWItZ3JpZC5tanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9ub2RlX21vZHVsZXMvaG9uZXljb21iLWdyaWQvZGlzdC9ob25leWNvbWItZ3JpZC5tanM/MmFkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBsID0gKHIpID0+IE51bWJlci5pc0Zpbml0ZShyKSAmJiAhTnVtYmVyLmlzTmFOKHIpLCB3ID0gKHIpID0+IHR5cGVvZiByID09IFwib2JqZWN0XCIgJiYgciAhPT0gbnVsbCwgT3QgPSAocikgPT4gdyhyKSAmJiBsKHIucSkgJiYgbChyLnIpLCBrID0gKHIpID0+IHR5cGVvZiByID09IFwiZnVuY3Rpb25cIiwgUyA9IChyKSA9PiB3KHIpICYmIGwoci5jb2wpICYmIGwoci5yb3cpLCBWID0gKHIpID0+IHcocikgJiYgbChyLngpICYmIGwoci55KSwgSCA9IChyKSA9PiBBcnJheS5pc0FycmF5KHIpICYmIGwoclswXSkgJiYgbChyWzFdKSwgUCA9IChyLCB0KSA9PiB0ICsgciAqICh0ICYgMSkgPj4gMTtcbmZ1bmN0aW9uIFoociwgdCkge1xuICByZXR1cm4gKHIgJSB0ICsgdCkgJSB0O1xufVxuY29uc3QgWCA9IChyLCB0KSA9PiBaKHIgKyB0LCA4KSwgRSA9IChbciwgdCwgZSA9IC1yIC0gdF0pID0+ICh7IHE6IHIsIHI6IHQsIHM6IGUgfSk7XG5mdW5jdGlvbiBwKHsgcTogciwgcjogdCwgczogZSB9KSB7XG4gIGNvbnN0IG4gPSBsKHIpLCBzID0gbCh0KSwgbyA9IGwoZSk7XG4gIGlmIChuICYmIHMgJiYgbylcbiAgICByZXR1cm4geyBxOiByLCByOiB0LCBzOiBlIH07XG4gIGlmIChuICYmIHMpXG4gICAgcmV0dXJuIHsgcTogciwgcjogdCwgczogLXIgLSB0IH07XG4gIGlmIChuICYmIG8pXG4gICAgcmV0dXJuIHsgcTogciwgcjogLXIgLSBlLCBzOiBlIH07XG4gIGlmIChzICYmIG8pXG4gICAgcmV0dXJuIHsgcTogLXQgLSBlLCByOiB0LCBzOiBlIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgYENhbid0IGRldGVybWluZSB0aHJlZSBjdWJlIGNvb3JkaW5hdGVzIGZyb20gbGVzcyB0aGFuIHR3byBjb29yZGluYXRlcy4gUmVjZWl2ZWQ6IHsgcTogJHtyfSwgcjogJHt0fSwgczogJHtlfSB9LmBcbiAgKTtcbn1cbnZhciBnID0gLyogQF9fUFVSRV9fICovICgocikgPT4gKHIuRkxBVCA9IFwiRkxBVFwiLCByLlBPSU5UWSA9IFwiUE9JTlRZXCIsIHIpKShnIHx8IHt9KTtcbmZ1bmN0aW9uIEcociwgdCkge1xuICBpZiAodyhyKSAmJiByLnhSYWRpdXMgPiAwICYmIHIueVJhZGl1cyA+IDApXG4gICAgcmV0dXJuIHI7XG4gIGlmICh3KHIpICYmIHIud2lkdGggPiAwICYmIHIuaGVpZ2h0ID4gMCkge1xuICAgIGNvbnN0IHsgd2lkdGg6IGUsIGhlaWdodDogbiB9ID0gcjtcbiAgICByZXR1cm4gdCA9PT0gZy5QT0lOVFkgPyB7IHhSYWRpdXM6IGUgLyBNYXRoLnNxcnQoMyksIHlSYWRpdXM6IG4gLyAyIH0gOiB7IHhSYWRpdXM6IGUgLyAyLCB5UmFkaXVzOiBuIC8gTWF0aC5zcXJ0KDMpIH07XG4gIH1cbiAgaWYgKHIgPiAwKVxuICAgIHJldHVybiB7IHhSYWRpdXM6IHIsIHlSYWRpdXM6IHIgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICBgSW52YWxpZCBkaW1lbnNpb25zOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgclxuICAgICl9LiBEaW1lbnNpb25zIG11c3QgYmUgZXhwcmVzc2VkIGFzIGFuIEVsbGlwc2UgKHsgeFJhZGl1czogbnVtYmVyLCB5UmFkaXVzOiBudW1iZXIgfSksIGEgUmVjdGFuZ2xlICh7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH0pIG9yIGEgbnVtYmVyLmBcbiAgKTtcbn1cbmZ1bmN0aW9uIEQociwgdCkge1xuICBpZiAoVihyKSlcbiAgICByZXR1cm4gcjtcbiAgaWYgKCF0KVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBgU3VwcGx5IGEgYm91bmRpbmcgYm94ICh7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH0pLiBSZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeSh0KX1gXG4gICAgKTtcbiAgaWYgKHIgPT09IFwidG9wTGVmdFwiKVxuICAgIHJldHVybiB7IHg6IHQud2lkdGggKiAtMC41LCB5OiB0LmhlaWdodCAqIC0wLjUgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICBgSW52YWxpZCBvcmlnaW46ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICByXG4gICAgKX0uIE9yaWdpbiBtdXN0IGJlIGV4cHJlc3NlZCBhcyBhIFBvaW50ICh7IHg6IG51bWJlciwgeTogbnVtYmVyIH0pIG9yIHRoZSBzdHJpbmcgJ3RvcExlZnQnLmBcbiAgKTtcbn1cbmNsYXNzICQge1xuICBzdGF0aWMgZ2V0IHNldHRpbmdzKCkge1xuICAgIGNvbnN0IHsgZGltZW5zaW9uczogdCwgb3JpZW50YXRpb246IGUsIG9yaWdpbjogbiwgb2Zmc2V0OiBzIH0gPSB0aGlzLnByb3RvdHlwZTtcbiAgICByZXR1cm4geyBkaW1lbnNpb25zOiB0LCBvcmllbnRhdGlvbjogZSwgb3JpZ2luOiBuLCBvZmZzZXQ6IHMgfTtcbiAgfVxuICBnZXQgY2VudGVyKCkge1xuICAgIGNvbnN0IHsgd2lkdGg6IHQsIGhlaWdodDogZSwgeDogbiwgeTogcyB9ID0gdGhpcztcbiAgICByZXR1cm4geyB4OiB0IC8gMiAtIG4sIHk6IGUgLyAyIC0gcyB9O1xuICB9XG4gIGdldCBjb2woKSB7XG4gICAgcmV0dXJuIFcodGhpcykuY29sO1xuICB9XG4gIGdldCBjb3JuZXJzKCkge1xuICAgIGNvbnN0IHsgb3JpZW50YXRpb246IHQsIHdpZHRoOiBlLCBoZWlnaHQ6IG4sIHg6IHMsIHk6IG8gfSA9IHRoaXM7XG4gICAgcmV0dXJuIHQgPT09IGcuUE9JTlRZID8gdHQoZSwgbiwgcywgbykgOiBydChlLCBuLCBzLCBvKTtcbiAgfVxuICBnZXQgZGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4gVC5kaW1lbnNpb25zO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3JpZW50YXRpb246IHQsXG4gICAgICBkaW1lbnNpb25zOiB7IHlSYWRpdXM6IGUgfVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiB0ID09PSBnLlBPSU5UWSA/IGUgKiAyIDogZSAqIE1hdGguc3FydCgzKTtcbiAgfVxuICBnZXQgaXNGbGF0KCkge1xuICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSBnLkZMQVQ7XG4gIH1cbiAgZ2V0IGlzUG9pbnR5KCkge1xuICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSBnLlBPSU5UWTtcbiAgfVxuICBnZXQgb3JpZW50YXRpb24oKSB7XG4gICAgcmV0dXJuIFQub3JpZW50YXRpb247XG4gIH1cbiAgZ2V0IG9yaWdpbigpIHtcbiAgICByZXR1cm4gVC5vcmlnaW47XG4gIH1cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gVC5vZmZzZXQ7XG4gIH1cbiAgZ2V0IHJvdygpIHtcbiAgICByZXR1cm4gVyh0aGlzKS5yb3c7XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9yaWVudGF0aW9uOiB0LFxuICAgICAgZGltZW5zaW9uczogeyB4UmFkaXVzOiBlIH1cbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gdCA9PT0gZy5QT0lOVFkgPyBlICogTWF0aC5zcXJ0KDMpIDogZSAqIDI7XG4gIH1cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIEoodGhpcykueDtcbiAgfVxuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gSih0aGlzKS55O1xuICB9XG4gIGdldCBzKCkge1xuICAgIHJldHVybiAtdGhpcy5xIC0gdGhpcy5yO1xuICB9XG4gIHE7XG4gIHI7XG4gIGNvbnN0cnVjdG9yKHQgPSBbMCwgMF0pIHtcbiAgICBjb25zdCB7IHE6IGUsIHI6IG4gfSA9IEModGhpcywgdCk7XG4gICAgdGhpcy5xID0gZSwgdGhpcy5yID0gbjtcbiAgfVxuICBjbG9uZSh0ID0gdGhpcykge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0KTtcbiAgfVxuICBlcXVhbHModCkge1xuICAgIHJldHVybiBudCh0aGlzLCBTKHQpID8gaih0aGlzLCB0KSA6IHQpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9KCR7dGhpcy5xfSwke3RoaXMucn0pYDtcbiAgfVxuICB0cmFuc2xhdGUodCkge1xuICAgIHJldHVybiBjdCh0aGlzLCB0KTtcbiAgfVxufVxuY29uc3QgVCA9IHtcbiAgZGltZW5zaW9uczogeyB4UmFkaXVzOiAxLCB5UmFkaXVzOiAxIH0sXG4gIG9yaWVudGF0aW9uOiBnLlBPSU5UWSxcbiAgb3JpZ2luOiB7IHg6IDAsIHk6IDAgfSxcbiAgb2Zmc2V0OiAtMVxufSwgdHQgPSAociwgdCwgZSwgbikgPT4gW1xuICB7IHg6IGUgKyByICogMC41LCB5OiBuIC0gdCAqIDAuMjUgfSxcbiAgeyB4OiBlICsgciAqIDAuNSwgeTogbiArIHQgKiAwLjI1IH0sXG4gIHsgeDogZSwgeTogbiArIHQgKiAwLjUgfSxcbiAgeyB4OiBlIC0gciAqIDAuNSwgeTogbiArIHQgKiAwLjI1IH0sXG4gIHsgeDogZSAtIHIgKiAwLjUsIHk6IG4gLSB0ICogMC4yNSB9LFxuICB7IHg6IGUsIHk6IG4gLSB0ICogMC41IH1cbl0sIHJ0ID0gKHIsIHQsIGUsIG4pID0+IFtcbiAgeyB4OiBlICsgciAqIDAuMjUsIHk6IG4gLSB0ICogMC41IH0sXG4gIHsgeDogZSArIHIgKiAwLjUsIHk6IG4gfSxcbiAgeyB4OiBlICsgciAqIDAuMjUsIHk6IG4gKyB0ICogMC41IH0sXG4gIHsgeDogZSAtIHIgKiAwLjI1LCB5OiBuICsgdCAqIDAuNSB9LFxuICB7IHg6IGUgLSByICogMC41LCB5OiBuIH0sXG4gIHsgeDogZSAtIHIgKiAwLjI1LCB5OiBuIC0gdCAqIDAuNSB9XG5dO1xuZnVuY3Rpb24gZXQocikge1xuICBjb25zdCB7IGRpbWVuc2lvbnM6IHQsIG9yaWVudGF0aW9uOiBlLCBvcmlnaW46IG4sIG9mZnNldDogcyB9ID0geyAuLi5ULCAuLi5yIH07XG4gIHJldHVybiBjbGFzcyBleHRlbmRzICQge1xuICAgIGdldCBkaW1lbnNpb25zKCkge1xuICAgICAgcmV0dXJuIEcodCwgZSk7XG4gICAgfVxuICAgIGdldCBvcmllbnRhdGlvbigpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBnZXQgb3JpZ2luKCkge1xuICAgICAgcmV0dXJuIEQobiwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBvZmZzZXQoKSB7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBudChyLCB0KSB7XG4gIGlmIChTKHIpICYmIFModCkpXG4gICAgcmV0dXJuIHIuY29sID09PSB0LmNvbCAmJiByLnJvdyA9PT0gdC5yb3c7XG4gIGlmIChPYmplY3QuaGFzT3duKHIsIFwiY29sXCIpIHx8IE9iamVjdC5oYXNPd24odCwgXCJjb2xcIikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbid0IGNvbXBhcmUgY29vcmRpbmF0ZXMgd2hlcmUgb25lIGFyZSBvZmZzZXQgY29vcmRpbmF0ZXMuIEVpdGhlciBwYXNzIHR3byBvZmZzZXQgY29vcmRpbmF0ZXMgb3IgdHdvIGF4aWFsL2N1YmUgY29vcmRpbmF0ZXMuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICByXG4gICAgICApfSBhbmQgJHtKU09OLnN0cmluZ2lmeSh0KX1gXG4gICAgKTtcbiAgY29uc3QgZSA9IEgocikgPyBFKHIpIDogciwgbiA9IEgodCkgPyBFKHQpIDogdDtcbiAgcmV0dXJuIGUucSA9PT0gbi5xICYmIGUuciA9PT0gbi5yO1xufVxuY29uc3Qgc3QgPSAociwgdCwgZSkgPT4gKHtcbiAgY29sOiByICsgUChlLCB0KSxcbiAgcm93OiB0XG59KSwgb3QgPSAociwgdCwgZSkgPT4gKHtcbiAgY29sOiByLFxuICByb3c6IHQgKyBQKGUsIHIpXG59KSwgVyA9ICh7IHE6IHIsIHI6IHQsIG9mZnNldDogZSwgaXNQb2ludHk6IG4gfSkgPT4gbiA/IHN0KHIsIHQsIGUpIDogb3QociwgdCwgZSksIEogPSAoeyBvcmllbnRhdGlvbjogciwgZGltZW5zaW9uczogeyB4UmFkaXVzOiB0LCB5UmFkaXVzOiBlIH0sIG9yaWdpbjogeyB4OiBuLCB5OiBzIH0sIHE6IG8sIHI6IGkgfSkgPT4gciA9PT0gZy5QT0lOVFkgPyB7XG4gIHg6IHQgKiBNYXRoLnNxcnQoMykgKiAobyArIGkgLyAyKSAtIG4sXG4gIHk6IGUgKiAzIC8gMiAqIGkgLSBzXG59IDoge1xuICB4OiB0ICogMyAvIDIgKiBvIC0gbixcbiAgeTogZSAqIE1hdGguc3FydCgzKSAqIChpICsgbyAvIDIpIC0gc1xufSwgeiA9IChyLCB0LCBlKSA9PiB7XG4gIGNvbnN0IG4gPSByIC0gUChlLCB0KSwgcyA9IHQsIG8gPSAtbiAtIHM7XG4gIHJldHVybiB7IHE6IG4sIHI6IHMsIHM6IG8gfTtcbn0sIF8gPSAociwgdCwgZSkgPT4ge1xuICBjb25zdCBuID0gciwgcyA9IHQgLSBQKGUsIHIpLCBvID0gLW4gLSBzO1xuICByZXR1cm4geyBxOiBuLCByOiBzLCBzOiBvIH07XG59LCBqID0gKHsgb2Zmc2V0OiByLCBvcmllbnRhdGlvbjogdCB9LCB7IGNvbDogZSwgcm93OiBuIH0pID0+IHQgPT09IGcuUE9JTlRZID8geihlLCBuLCByKSA6IF8oZSwgbiwgciksIEYgPSAocikgPT4ge1xuICBjb25zdCB7IHE6IHQsIHI6IGUsIHM6IG4gfSA9IHAocik7XG4gIGxldCBzID0gTWF0aC5yb3VuZCh0KSwgbyA9IE1hdGgucm91bmQoZSksIGkgPSBNYXRoLnJvdW5kKG4pO1xuICBjb25zdCBjID0gTWF0aC5hYnModCAtIHMpLCB1ID0gTWF0aC5hYnMoZSAtIG8pLCBoID0gTWF0aC5hYnMobiAtIGkpO1xuICByZXR1cm4gYyA+IHUgJiYgYyA+IGggPyBzID0gLW8gLSBpIDogdSA+IGggPyBvID0gLXMgLSBpIDogaSA9IC1zIC0gbywgeyBxOiBzLCByOiBvLCBzOiBpIH07XG59LCBpdCA9ICh7IGRpbWVuc2lvbnM6IHsgeFJhZGl1czogciwgeVJhZGl1czogdCB9LCBvcmlnaW46IGUsIG9yaWVudGF0aW9uOiBuIH0sIHsgeDogcywgeTogbyB9KSA9PiAocyArPSBlLngsIG8gKz0gZS55LCBuID09PSBnLlBPSU5UWSA/IEYoeyBxOiBNYXRoLnNxcnQoMykgKiBzIC8gKDMgKiByKSAtIG8gLyAoMyAqIHQpLCByOiAyIC8gMyAqIChvIC8gdCkgfSkgOiBGKHsgcTogMiAvIDMgKiAocyAvIHIpLCByOiBNYXRoLnNxcnQoMykgKiBvIC8gKDMgKiB0KSAtIHMgLyAoMyAqIHIpIH0pKTtcbmZ1bmN0aW9uIEMociwgdCkge1xuICByZXR1cm4gSCh0KSA/IEUodCkgOiBTKHQpID8gaihyLCB0KSA6IHAodCk7XG59XG5mdW5jdGlvbiBjdChyLCB0KSB7XG4gIGNvbnN0IHsgcTogZSwgcjogbiwgcyB9ID0gcChyKSwgeyBxOiBvLCByOiBpLCBzOiBjIH0gPSBwKHQpLCB1ID0geyBxOiBlICsgbywgcjogbiArIGksIHM6IHMgKyBjIH07XG4gIHJldHVybiByIGluc3RhbmNlb2YgJCA/IHIuY2xvbmUodSkgOiB1O1xufVxuZnVuY3Rpb24gUihyLCB0LCBlKSB7XG4gIGNvbnN0IHsgcTogbiwgcjogcywgczogbyB9ID0gQyhyLCB0KSwgeyBxOiBpLCByOiBjLCBzOiB1IH0gPSBDKHIsIGUpO1xuICByZXR1cm4gTWF0aC5tYXgoTWF0aC5hYnMobiAtIGkpLCBNYXRoLmFicyhzIC0gYyksIE1hdGguYWJzKG8gLSB1KSk7XG59XG52YXIgTCA9IC8qIEBfX1BVUkVfXyAqLyAoKHIpID0+IChyLkNMT0NLV0lTRSA9IFwiQ0xPQ0tXSVNFXCIsIHIuQ09VTlRFUkNMT0NLV0lTRSA9IFwiQ09VTlRFUkNMT0NLV0lTRVwiLCByKSkoTCB8fCB7fSksIGYgPSAvKiBAX19QVVJFX18gKi8gKChyKSA9PiAocltyLk4gPSAwXSA9IFwiTlwiLCByW3IuTkUgPSAxXSA9IFwiTkVcIiwgcltyLkUgPSAyXSA9IFwiRVwiLCByW3IuU0UgPSAzXSA9IFwiU0VcIiwgcltyLlMgPSA0XSA9IFwiU1wiLCByW3IuU1cgPSA1XSA9IFwiU1dcIiwgcltyLlcgPSA2XSA9IFwiV1wiLCByW3IuTlcgPSA3XSA9IFwiTldcIiwgcikpKGYgfHwge30pO1xuY29uc3QgdXQgPSBbXG4gIG51bGwsXG4gIHsgcTogMSwgcjogLTEgfSxcbiAgeyBxOiAxLCByOiAwIH0sXG4gIHsgcTogMCwgcjogMSB9LFxuICBudWxsLFxuICB7IHE6IC0xLCByOiAxIH0sXG4gIHsgcTogLTEsIHI6IDAgfSxcbiAgeyBxOiAwLCByOiAtMSB9XG5dLCBodCA9IFtcbiAgeyBxOiAwLCByOiAtMSB9LFxuICB7IHE6IDEsIHI6IC0xIH0sXG4gIG51bGwsXG4gIHsgcTogMSwgcjogMCB9LFxuICB7IHE6IDAsIHI6IDEgfSxcbiAgeyBxOiAtMSwgcjogMSB9LFxuICBudWxsLFxuICB7IHE6IC0xLCByOiAwIH1cbl0sIGZ0ID0gKHsgb2Zmc2V0OiByLCBxOiB0LCByOiBlLCBjb2w6IG4sIHJvdzogcyB9LCBvKSA9PiB7XG4gIGlmIChvID09PSBmLlMgfHwgbyA9PT0gZi5OKSB7XG4gICAgY29uc3QgYyA9IG8gPT09IGYuUyA/IHMgKyAxIDogcyAtIDE7XG4gICAgcmV0dXJuIHoobiwgYywgcik7XG4gIH1cbiAgY29uc3QgaSA9IHV0W29dO1xuICByZXR1cm4geyBxOiB0ICsgaS5xLCByOiBlICsgaS5yIH07XG59LCBhdCA9ICh7IG9mZnNldDogciwgcTogdCwgcjogZSwgY29sOiBuLCByb3c6IHMgfSwgbykgPT4ge1xuICBpZiAobyA9PT0gZi5FIHx8IG8gPT09IGYuVykge1xuICAgIGNvbnN0IGMgPSBvID09PSBmLkUgPyBuICsgMSA6IG4gLSAxO1xuICAgIHJldHVybiBfKGMsIHMsIHIpO1xuICB9XG4gIGNvbnN0IGkgPSBodFtvXTtcbiAgcmV0dXJuIHsgcTogdCArIGkucSwgcjogZSArIGkuciB9O1xufSwgSSA9IChyLCB0KSA9PiByLmNsb25lKHIuaXNQb2ludHkgPyBmdChyLCB0KSA6IGF0KHIsIHQpKTtcbmZ1bmN0aW9uIE4ocikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShyKSA/IGZ1bmN0aW9uKGUsIG4pIHtcbiAgICBjb25zdCBzID0gW107XG4gICAgbGV0IG8gPSBuO1xuICAgIGZvciAoY29uc3QgaSBvZiByKVxuICAgICAgZm9yIChjb25zdCBjIG9mIGkoZSwgbykpXG4gICAgICAgIHMucHVzaChvID0gYyk7XG4gICAgcmV0dXJuIHM7XG4gIH0gOiByO1xufVxuY29uc3QgVHQgPSAoLi4ucikgPT4gKHQpID0+IHIubWFwKHQpO1xuZnVuY3Rpb24gdihyKSB7XG4gIHJldHVybiBsdChyKSA/IGd0KHIpIDogeHQocik7XG59XG5mdW5jdGlvbiBsdChyKSB7XG4gIHJldHVybiByLmRpcmVjdGlvbiBpbiBmO1xufVxuZnVuY3Rpb24gZ3QoeyBzdGFydDogciwgZGlyZWN0aW9uOiB0LCBsZW5ndGg6IGUgfSkge1xuICByZXR1cm4gZnVuY3Rpb24ocywgbykge1xuICAgIGNvbnN0IGkgPSBbXTtcbiAgICBsZXQgdSA9IHMociA/PyBvKTtcbiAgICAhciAmJiBvICYmICh1ID0gSSh1LCB0KSk7XG4gICAgZm9yIChsZXQgaCA9IDA7IGggPCBlOyBoKyspXG4gICAgICBpLnB1c2godSksIHUgPSBJKHUsIHQpO1xuICAgIHJldHVybiBpO1xuICB9O1xufVxuZnVuY3Rpb24geHQoeyBzdGFydDogciwgc3RvcDogdCB9KSB7XG4gIHJldHVybiBmdW5jdGlvbihuLCBzKSB7XG4gICAgY29uc3QgbyA9IFtdLCBpID0gbihyID8/IHMpLCBjID0gQihpKSwgdSA9IEIoQyhpLCB0KSksIGggPSBkdChjLCB1KSwgeCA9IFIoaSwgaSwgdCksIHkgPSAxIC8gTWF0aC5tYXgoeCwgMSk7XG4gICAgbGV0IG0gPSAhciAmJiBzID8gMSA6IDA7XG4gICAgZm9yIChtOyBtIDw9IHg7IG0rKykge1xuICAgICAgY29uc3QgYSA9IEYoaCh5ICogbSkpO1xuICAgICAgby5wdXNoKG4oYSkpO1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfTtcbn1cbmZ1bmN0aW9uIEIoeyBxOiByLCByOiB0LCBzOiBlIH0pIHtcbiAgcmV0dXJuIHsgcTogciArIDFlLTYsIHI6IHQgKyAxZS02LCBzOiBlICsgLTJlLTYgfTtcbn1cbmZ1bmN0aW9uIGR0KHIsIHQpIHtcbiAgcmV0dXJuIChlKSA9PiB7XG4gICAgY29uc3QgbiA9IHIucSAqICgxIC0gZSkgKyB0LnEgKiBlLCBzID0gci5yICogKDEgLSBlKSArIHQuciAqIGU7XG4gICAgcmV0dXJuIHsgcTogbiwgcjogcyB9O1xuICB9O1xufVxuY29uc3Qgd3QgPSAocikgPT4gKHQsIGUpID0+IFtJKHQoZSksIHIpXTtcbmZ1bmN0aW9uIFUociwgdCwgeyBpbmNsdWRlU291cmNlOiBlID0gITAgfSA9IHt9KSB7XG4gIHJldHVybiBmdW5jdGlvbihzLCBvKSB7XG4gICAgY29uc3QgaSA9IFtdO1xuICAgIGZvciAoY29uc3QgYyBvZiBOKHIpKHMsIG8pKSB7XG4gICAgICBlICYmIGkucHVzaChjKTtcbiAgICAgIGZvciAoY29uc3QgdSBvZiBOKHQpKHMsIGMpKVxuICAgICAgICBpLnB1c2godSk7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9O1xufVxuZnVuY3Rpb24gU3QociwgdCkge1xuICByZXR1cm4gZnVuY3Rpb24obiwgcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoOiBvLFxuICAgICAgaGVpZ2h0OiBpLFxuICAgICAgc3RhcnQ6IGMsXG4gICAgICBkaXJlY3Rpb246IHUgPSBmLkVcbiAgICB9ID0gdCA/IG10KHIsIHQsIG4oKSkgOiByLCBoID0gYyA/PyBzID8/IFswLCAwXSwgeCA9IFUoXG4gICAgICB2KHsgc3RhcnQ6IGgsIGRpcmVjdGlvbjogWCh1LCAyKSwgbGVuZ3RoOiBpIH0pLFxuICAgICAgdih7IGRpcmVjdGlvbjogdSwgbGVuZ3RoOiBvIC0gMSB9KVxuICAgICkobiwgaCk7XG4gICAgcmV0dXJuICFjICYmIHMgPyB4LnNsaWNlKDEpIDogeDtcbiAgfTtcbn1cbmZ1bmN0aW9uIG10KHIsIHQsIHsgaXNQb2ludHk6IGUsIG9mZnNldDogbiB9KSB7XG4gIGNvbnN0IHsgY29sOiBzLCByb3c6IG8gfSA9IEsociwgZSwgbiksIHsgY29sOiBpLCByb3c6IGMgfSA9IEsodCwgZSwgbiksIHUgPSBzIDwgaSA/IFwiQVwiIDogXCJCXCIsIGggPSBvIDwgYyA/IFwiQVwiIDogXCJCXCIsIHggPSB1ICsgaCwgeyBzd2FwV2lkdGhIZWlnaHQ6IHksIGRpcmVjdGlvbjogbSB9ID0gcXRbeF0sIGEgPSBNYXRoLmFicyhzIC0gaSkgKyAxLCBiID0gTWF0aC5hYnMobyAtIGMpICsgMTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogeSA/IGIgOiBhLFxuICAgIGhlaWdodDogeSA/IGEgOiBiLFxuICAgIHN0YXJ0OiByLFxuICAgIGRpcmVjdGlvbjogbVxuICB9O1xufVxuZnVuY3Rpb24gSyhyLCB0LCBlKSB7XG4gIGlmIChTKHIpKVxuICAgIHJldHVybiByO1xuICBjb25zdCB7IHE6IG4sIHI6IHMgfSA9IEgocikgPyBFKHIpIDogcChyKTtcbiAgcmV0dXJuIFcoeyBxOiBuLCByOiBzLCBpc1BvaW50eTogdCwgb2Zmc2V0OiBlIH0pO1xufVxuY29uc3QgcXQgPSB7XG4gIEFBOiB7XG4gICAgc3dhcFdpZHRoSGVpZ2h0OiAhMSxcbiAgICBkaXJlY3Rpb246IGYuRVxuICB9LFxuICBBQjoge1xuICAgIHN3YXBXaWR0aEhlaWdodDogITAsXG4gICAgZGlyZWN0aW9uOiBmLk5cbiAgfSxcbiAgQkE6IHtcbiAgICBzd2FwV2lkdGhIZWlnaHQ6ICEwLFxuICAgIGRpcmVjdGlvbjogZi5TXG4gIH0sXG4gIEJCOiB7XG4gICAgc3dhcFdpZHRoSGVpZ2h0OiAhMSxcbiAgICBkaXJlY3Rpb246IGYuV1xuICB9XG59O1xuZnVuY3Rpb24gcHQociwgdCkge1xuICByZXR1cm4gTihBcnJheS5mcm9tKHsgbGVuZ3RoOiByIH0sICgpID0+IE4odCkpKTtcbn1cbmZ1bmN0aW9uIHl0KHIpIHtcbiAgY29uc3QgeyBjZW50ZXI6IHQsIHJvdGF0aW9uOiBlID0gTC5DTE9DS1dJU0UgfSA9IHI7XG4gIHJldHVybiBmdW5jdGlvbihzLCBvKSB7XG4gICAgY29uc3QgaSA9IGUudG9VcHBlckNhc2UoKSwgYyA9IFtdO1xuICAgIGxldCB7IHJhZGl1czogdSB9ID0gciwgaDtcbiAgICBsKHUpID8gaCA9IHModCkudHJhbnNsYXRlKHsgcTogdSwgczogLXUgfSkgOiAoaCA9IHMoci5zdGFydCA/PyBvKSwgdSA9IFIoaCwgdCwgaCkpO1xuICAgIGNvbnN0IHsgcTogeCwgcjogeSwgczogbSB9ID0gQyhoLCB0KTtcbiAgICBsZXQgYSA9IHMoeyBxOiB4LCByOiB5IC0gdSwgczogbSArIHUgfSk7XG4gICAgaWYgKGkgPT09IEwuQ0xPQ0tXSVNFKVxuICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCA2OyBkKyspXG4gICAgICAgIGZvciAobGV0IE8gPSAwOyBPIDwgdTsgTysrKSB7XG4gICAgICAgICAgY29uc3QgeyBxOiBBLCByOiBNIH0gPSBRW2RdO1xuICAgICAgICAgIGEgPSBzKHsgcTogYS5xICsgQSwgcjogYS5yICsgTSB9KSwgYy5wdXNoKGEpO1xuICAgICAgICB9XG4gICAgZWxzZVxuICAgICAgZm9yIChsZXQgZCA9IDU7IGQgPj0gMDsgZC0tKVxuICAgICAgICBmb3IgKGxldCBPID0gMDsgTyA8IHU7IE8rKykge1xuICAgICAgICAgIGNvbnN0IHsgcTogQSwgcjogTSB9ID0gUVtkXTtcbiAgICAgICAgICBhID0gcyh7IHE6IGEucSAtIEEsIHI6IGEuciAtIE0gfSksIGMucHVzaChhKTtcbiAgICAgICAgfVxuICAgIGNvbnN0IGIgPSAhci5zdGFydCAmJiBvLCBZID0gYy5maW5kSW5kZXgoKGQpID0+IGQuZXF1YWxzKGgpKTtcbiAgICByZXR1cm4gYy5zbGljZShZICsgKGIgPyAxIDogMCkpLmNvbmNhdChjLnNsaWNlKDAsIFkpKTtcbiAgfTtcbn1cbmNvbnN0IFEgPSBbXG4gIHsgcTogMSwgcjogMCB9LFxuICB7IHE6IDAsIHI6IDEgfSxcbiAgeyBxOiAtMSwgcjogMSB9LFxuICB7IHE6IC0xLCByOiAwIH0sXG4gIHsgcTogMCwgcjogLTEgfSxcbiAgeyBxOiAxLCByOiAtMSB9XG5dO1xuZnVuY3Rpb24gQ3QoeyByYWRpdXM6IHIsIHN0YXJ0OiB0LCByb3RhdGlvbjogZSB9KSB7XG4gIHJldHVybiBmdW5jdGlvbihzLCBvKSB7XG4gICAgY29uc3QgaSA9IHQgPz8gbyA/PyBbMCwgMF0sIGMgPSAhdCAmJiBvID8gciA6IHIgKyAxO1xuICAgIHJldHVybiBVKHYoeyBzdGFydDogdCwgZGlyZWN0aW9uOiBmLk4sIGxlbmd0aDogYyB9KSwgeXQoeyBjZW50ZXI6IGksIHJvdGF0aW9uOiBlIH0pKShzLCBvKTtcbiAgfTtcbn1cbmNsYXNzIHEge1xuICBzdGF0aWMgZnJvbUl0ZXJhYmxlKHQpIHtcbiAgICBjb25zdCBlID0gdFtTeW1ib2wuaXRlcmF0b3JdKCkubmV4dCgpLnZhbHVlO1xuICAgIGlmICghZSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbid0IGNyZWF0ZSBncmlkIGZyb20gZW1wdHkgaXRlcmFibGU6ICR7SlNPTi5zdHJpbmdpZnkodCl9YCk7XG4gICAgcmV0dXJuIG5ldyBxKGUuY29uc3RydWN0b3IsIHQpO1xuICB9XG4gIHN0YXRpYyBmcm9tSlNPTih7IGhleFNldHRpbmdzOiB0LCBjb29yZGluYXRlczogZSB9KSB7XG4gICAgY29uc3QgbiA9IGV0KHQpO1xuICAgIHJldHVybiBuZXcgcShcbiAgICAgIG4sXG4gICAgICBlLm1hcCgocykgPT4gbmV3IG4ocykpXG4gICAgKTtcbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jci5zaXplO1xuICB9XG4gIGdldCBwaXhlbFdpZHRoKCkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApXG4gICAgICByZXR1cm4gMDtcbiAgICBjb25zdCB7IGlzUG9pbnR5OiB0LCB3aWR0aDogZSB9ID0gdGhpcy5oZXhQcm90b3R5cGUsIG4gPSB0aGlzLnRvQXJyYXkoKSwge1xuICAgICAgMDogcyxcbiAgICAgIGxlbmd0aDogbyxcbiAgICAgIFtvIC0gMV06IGlcbiAgICB9ID0gdCA/IG4uc29ydCgoYywgdSkgPT4gdS5zIC0gYy5zIHx8IGMucSAtIHUucSkgOiBuLnNvcnQoKGMsIHUpID0+IGMucSAtIHUucSk7XG4gICAgcmV0dXJuIGkueCAtIHMueCArIGU7XG4gIH1cbiAgZ2V0IHBpeGVsSGVpZ2h0KCkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApXG4gICAgICByZXR1cm4gMDtcbiAgICBjb25zdCB7IGlzUG9pbnR5OiB0LCBoZWlnaHQ6IGUgfSA9IHRoaXMuaGV4UHJvdG90eXBlLCBuID0gdGhpcy50b0FycmF5KCksIHtcbiAgICAgIDA6IHMsXG4gICAgICBsZW5ndGg6IG8sXG4gICAgICBbbyAtIDFdOiBpXG4gICAgfSA9IHQgPyBuLnNvcnQoKGMsIHUpID0+IGMuciAtIHUucikgOiBuLnNvcnQoKGMsIHUpID0+IHUucyAtIGMucyB8fCBjLnIgLSB1LnIpO1xuICAgIHJldHVybiBpLnkgLSBzLnkgKyBlO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLiNyLnZhbHVlcygpO1xuICB9XG4gIGdldCBoZXhQcm90b3R5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3QucHJvdG90eXBlO1xuICB9XG4gICN0O1xuICAjciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSBbXSkge1xuICAgIGlmICh0IGluc3RhbmNlb2YgcSkge1xuICAgICAgdGhpcy4jdCA9IHQuI3QsIHRoaXMuc2V0SGV4ZXModCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3QgPSB0LCB0aGlzLnNldEhleGVzKHRoaXMuI24oZSkpO1xuICB9XG4gIGNyZWF0ZUhleCh0KSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLiN0KHQpO1xuICB9XG4gIGdldEhleCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuY3JlYXRlSGV4KHQpO1xuICAgIHJldHVybiB0aGlzLiNyLmdldChlLnRvU3RyaW5nKCkpO1xuICB9XG4gIGhhc0hleCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuI3IuaGFzKHQudG9TdHJpbmcoKSk7XG4gIH1cbiAgc2V0SGV4ZXModCkge1xuICAgIGZvciAoY29uc3QgZSBvZiB0KSB7XG4gICAgICBjb25zdCBuID0gZSBpbnN0YW5jZW9mICQgPyBlIDogbmV3IHRoaXMuI3QoZSk7XG4gICAgICB0aGlzLiNlKG4pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmaWx0ZXIodCkge1xuICAgIGNvbnN0IGUgPSBuZXcgcSh0aGlzLiN0KTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgdGhpcylcbiAgICAgIHQobikgJiYgZS4jZShuKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBtYXAodCkge1xuICAgIGNvbnN0IGUgPSBuZXcgcSh0aGlzLiN0KTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgdGhpcylcbiAgICAgIGUuI2UodChuKSk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgdHJhdmVyc2UodCwgeyBiYWlsOiBlID0gITEgfSA9IHt9KSB7XG4gICAgY29uc3QgbiA9IG5ldyBxKHRoaXMuI3QpO1xuICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLiNuKHQpKSB7XG4gICAgICBjb25zdCBvID0gdGhpcy5nZXRIZXgocyk7XG4gICAgICBpZiAobylcbiAgICAgICAgbi4jZShvKTtcbiAgICAgIGVsc2UgaWYgKGUpXG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICBmb3JFYWNoKHQpIHtcbiAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcylcbiAgICAgIHQoZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVkdWNlKHQsIGUpIHtcbiAgICBpZiAoZSA9PT0gdm9pZCAwKSB7XG4gICAgICBsZXQgcywgbywgaTtcbiAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzKVxuICAgICAgICBvID0gaSwgaSA9IGMsIG8gJiYgKHMgPSB0KG8sIGkpKTtcbiAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBsZXQgbiA9IGU7XG4gICAgZm9yIChjb25zdCBzIG9mIHRoaXMpXG4gICAgICBuID0gdChuLCBzKTtcbiAgICByZXR1cm4gbjtcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCB7IGRpbWVuc2lvbnM6IHQsIG9yaWVudGF0aW9uOiBlLCBvcmlnaW46IG4sIG9mZnNldDogcyB9ID0gdGhpcy5oZXhQcm90b3R5cGU7XG4gICAgcmV0dXJuIHsgaGV4U2V0dGluZ3M6IHsgZGltZW5zaW9uczogdCwgb3JpZW50YXRpb246IGUsIG9yaWdpbjogbiwgb2Zmc2V0OiBzIH0sIGNvb3JkaW5hdGVzOiB0aGlzLnRvQXJyYXkoKSB9O1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9KCR7dGhpcy5zaXplfSlgO1xuICB9XG4gIHBvaW50VG9IZXgodCwgeyBhbGxvd091dHNpZGU6IGUgPSAhMCB9ID0ge30pIHtcbiAgICBjb25zdCBuID0gaXQodGhpcy5oZXhQcm90b3R5cGUsIHQpLCBzID0gdGhpcy5nZXRIZXgobik7XG4gICAgcmV0dXJuIGUgPyBzID8/IHRoaXMuY3JlYXRlSGV4KG4pIDogcztcbiAgfVxuICBkaXN0YW5jZSh0LCBlLCB7IGFsbG93T3V0c2lkZTogbiA9ICEwIH0gPSB7fSkge1xuICAgIGlmIChuKVxuICAgICAgcmV0dXJuIFIodGhpcy5oZXhQcm90b3R5cGUsIHQsIGUpO1xuICAgIGNvbnN0IHMgPSB0aGlzLmdldEhleCh0KSwgbyA9IHRoaXMuZ2V0SGV4KGUpO1xuICAgIGlmICghKCFzIHx8ICFvKSlcbiAgICAgIHJldHVybiBSKHRoaXMuaGV4UHJvdG90eXBlLCBzLCBvKTtcbiAgfVxuICBuZWlnaGJvck9mKHQsIGUsIHsgYWxsb3dPdXRzaWRlOiBuID0gITAgfSA9IHt9KSB7XG4gICAgY29uc3QgcyA9IEkodGhpcy5jcmVhdGVIZXgodCksIGUpLCBvID0gdGhpcy5nZXRIZXgocyk7XG4gICAgcmV0dXJuIG4gPyBvID8/IHMgOiBvO1xuICB9XG4gICNlKHQpIHtcbiAgICB0aGlzLiNyLnNldCh0LnRvU3RyaW5nKCksIHQpO1xuICB9XG4gICNuKHQpIHtcbiAgICByZXR1cm4gdGhpcy4jcyh0KSA/IHRoaXMuI28odCkgOiBBcnJheS5pc0FycmF5KHQpICYmIHRoaXMuI3ModFswXSkgPyB0aGlzLiNvKE4odCkpIDogdDtcbiAgfVxuICAjcyh0KSB7XG4gICAgcmV0dXJuIGsodCk7XG4gIH1cbiAgI28odCkge1xuICAgIHJldHVybiB0KHRoaXMuY3JlYXRlSGV4LmJpbmQodGhpcykpO1xuICB9XG59XG5leHBvcnQge1xuICBmIGFzIERpcmVjdGlvbixcbiAgcSBhcyBHcmlkLFxuICAkIGFzIEhleCxcbiAgZyBhcyBPcmllbnRhdGlvbixcbiAgTCBhcyBSb3RhdGlvbixcbiAgcCBhcyBjb21wbGV0ZUN1YmUsXG4gIE4gYXMgY29uY2F0LFxuICBHIGFzIGNyZWF0ZUhleERpbWVuc2lvbnMsXG4gIEQgYXMgY3JlYXRlSGV4T3JpZ2luLFxuICBUIGFzIGRlZmF1bHRIZXhTZXR0aW5ncyxcbiAgZXQgYXMgZGVmaW5lSGV4LFxuICBSIGFzIGRpc3RhbmNlLFxuICBudCBhcyBlcXVhbHMsXG4gIFR0IGFzIGZyb21Db29yZGluYXRlcyxcbiAgVyBhcyBoZXhUb09mZnNldCxcbiAgSiBhcyBoZXhUb1BvaW50LFxuICBPdCBhcyBpc0F4aWFsLFxuICBTIGFzIGlzT2Zmc2V0LFxuICBWIGFzIGlzUG9pbnQsXG4gIEggYXMgaXNUdXBsZSxcbiAgdiBhcyBsaW5lLFxuICB3dCBhcyBtb3ZlLFxuICBJIGFzIG5laWdoYm9yT2YsXG4gIFAgYXMgb2Zmc2V0RnJvbVplcm8sXG4gIGogYXMgb2Zmc2V0VG9DdWJlLFxuICBfIGFzIG9mZnNldFRvQ3ViZUZsYXQsXG4gIHogYXMgb2Zmc2V0VG9DdWJlUG9pbnR5LFxuICBpdCBhcyBwb2ludFRvQ3ViZSxcbiAgU3QgYXMgcmVjdGFuZ2xlLFxuICBwdCBhcyByZXBlYXQsXG4gIFUgYXMgcmVwZWF0V2l0aCxcbiAgeXQgYXMgcmluZyxcbiAgRiBhcyByb3VuZCxcbiAgQ3QgYXMgc3BpcmFsLFxuICBDIGFzIHRvQ3ViZSxcbiAgY3QgYXMgdHJhbnNsYXRlLFxuICBFIGFzIHR1cGxlVG9DdWJlXG59O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF1Q0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/honeycomb-grid/dist/honeycomb-grid.mjs\n");

/***/ }),

/***/ "./node_modules/nekoton-wasm/nekoton_wasm.js":
/*!***************************************************!*\
  !*** ./node_modules/nekoton-wasm/nekoton_wasm.js ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"checkAddress\": () => (/* binding */ checkAddress),\n/* harmony export */   \"repackAddress\": () => (/* binding */ repackAddress),\n/* harmony export */   \"runLocal\": () => (/* binding */ runLocal),\n/* harmony export */   \"makeFullAccountBoc\": () => (/* binding */ makeFullAccountBoc),\n/* harmony export */   \"parseFullAccountBoc\": () => (/* binding */ parseFullAccountBoc),\n/* harmony export */   \"executeLocal\": () => (/* binding */ executeLocal),\n/* harmony export */   \"getExpectedAddress\": () => (/* binding */ getExpectedAddress),\n/* harmony export */   \"getBocHash\": () => (/* binding */ getBocHash),\n/* harmony export */   \"packIntoCell\": () => (/* binding */ packIntoCell),\n/* harmony export */   \"unpackFromCell\": () => (/* binding */ unpackFromCell),\n/* harmony export */   \"extractContractData\": () => (/* binding */ extractContractData),\n/* harmony export */   \"extractPublicKey\": () => (/* binding */ extractPublicKey),\n/* harmony export */   \"codeToTvc\": () => (/* binding */ codeToTvc),\n/* harmony export */   \"mergeTvc\": () => (/* binding */ mergeTvc),\n/* harmony export */   \"splitTvc\": () => (/* binding */ splitTvc),\n/* harmony export */   \"setCodeSalt\": () => (/* binding */ setCodeSalt),\n/* harmony export */   \"getCodeSalt\": () => (/* binding */ getCodeSalt),\n/* harmony export */   \"encodeInternalInput\": () => (/* binding */ encodeInternalInput),\n/* harmony export */   \"encodeInternalMessage\": () => (/* binding */ encodeInternalMessage),\n/* harmony export */   \"decodeInput\": () => (/* binding */ decodeInput),\n/* harmony export */   \"decodeEvent\": () => (/* binding */ decodeEvent),\n/* harmony export */   \"decodeOutput\": () => (/* binding */ decodeOutput),\n/* harmony export */   \"decodeTransaction\": () => (/* binding */ decodeTransaction),\n/* harmony export */   \"decodeTransactionEvents\": () => (/* binding */ decodeTransactionEvents),\n/* harmony export */   \"getDataHash\": () => (/* binding */ getDataHash),\n/* harmony export */   \"ed25519_generateKeyPair\": () => (/* binding */ ed25519_generateKeyPair),\n/* harmony export */   \"ed25519_sign\": () => (/* binding */ ed25519_sign),\n/* harmony export */   \"extendSignature\": () => (/* binding */ extendSignature),\n/* harmony export */   \"verifySignature\": () => (/* binding */ verifySignature),\n/* harmony export */   \"createRawExternalMessage\": () => (/* binding */ createRawExternalMessage),\n/* harmony export */   \"createExternalMessageWithoutSignature\": () => (/* binding */ createExternalMessageWithoutSignature),\n/* harmony export */   \"createExternalMessage\": () => (/* binding */ createExternalMessage),\n/* harmony export */   \"ClockWithOffset\": () => (/* binding */ ClockWithOffset),\n/* harmony export */   \"GenericContract\": () => (/* binding */ GenericContract),\n/* harmony export */   \"GqlConnection\": () => (/* binding */ GqlConnection),\n/* harmony export */   \"GqlQuery\": () => (/* binding */ GqlQuery),\n/* harmony export */   \"JrpcConnection\": () => (/* binding */ JrpcConnection),\n/* harmony export */   \"JrpcQuery\": () => (/* binding */ JrpcQuery),\n/* harmony export */   \"Transport\": () => (/* binding */ Transport),\n/* harmony export */   \"UnsignedMessage\": () => (/* binding */ UnsignedMessage),\n/* harmony export */   \"initSync\": () => (/* binding */ initSync),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n\nlet wasm;\n\nconst cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = new Uint8Array();\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedFloat64Memory0 = new Float64Array();\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nlet cachedInt32Memory0 = new Int32Array();\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = new TextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);\n\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_32(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hcb77729c6af9d376(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n/**\n* @param {string} address\n* @returns {boolean}\n*/\nfunction checkAddress(address) {\n    const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.checkAddress(ptr0, len0);\n    return ret !== 0;\n}\n\n/**\n* @param {string} address\n* @returns {string}\n*/\nfunction repackAddress(address) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.repackAddress(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {ClockWithOffset} clock\n* @param {string} account_stuff_boc\n* @param {string} contract_abi\n* @param {string} method\n* @param {TokensObject} input\n* @param {boolean} responsible\n* @returns {ExecutionOutput}\n*/\nfunction runLocal(clock, account_stuff_boc, contract_abi, method, input, responsible) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(clock, ClockWithOffset);\n        const ptr0 = passStringToWasm0(account_stuff_boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(method, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        wasm.runLocal(retptr, clock.ptr, ptr0, len0, ptr1, len1, ptr2, len2, addHeapObject(input), responsible);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} account_stuff_boc\n* @returns {string}\n*/\nfunction makeFullAccountBoc(account_stuff_boc) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(account_stuff_boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.makeFullAccountBoc(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {string} account\n* @returns {FullContractState | undefined}\n*/\nfunction parseFullAccountBoc(account) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(account, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.parseFullAccountBoc(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} config\n* @param {string} account\n* @param {string} message\n* @param {number} utime\n* @param {boolean} disable_signature_check\n* @returns {TransactionExecutorOutput}\n*/\nfunction executeLocal(config, account, message, utime, disable_signature_check) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(config, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(account, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        wasm.executeLocal(retptr, ptr0, len0, ptr1, len1, ptr2, len2, utime, disable_signature_check);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} tvc\n* @param {string} contract_abi\n* @param {number} workchain_id\n* @param {string | undefined} public_key\n* @param {TokensObject} init_data\n* @returns {ExpectedAddress}\n*/\nfunction getExpectedAddress(tvc, contract_abi, workchain_id, public_key, init_data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(tvc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(public_key) ? 0 : passStringToWasm0(public_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        wasm.getExpectedAddress(retptr, ptr0, len0, ptr1, len1, workchain_id, ptr2, len2, addHeapObject(init_data));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} boc\n* @returns {string}\n*/\nfunction getBocHash(boc) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.getBocHash(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {Array<AbiParam>} params\n* @param {TokensObject} tokens\n* @param {string | undefined} abi_version\n* @returns {string}\n*/\nfunction packIntoCell(params, tokens, abi_version) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = isLikeNone(abi_version) ? 0 : passStringToWasm0(abi_version, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.packIntoCell(retptr, addHeapObject(params), addHeapObject(tokens), ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {Array<AbiParam>} params\n* @param {string} boc\n* @param {boolean} allow_partial\n* @param {string | undefined} abi_version\n* @returns {TokensObject}\n*/\nfunction unpackFromCell(params, boc, allow_partial, abi_version) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(abi_version) ? 0 : passStringToWasm0(abi_version, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        wasm.unpackFromCell(retptr, addHeapObject(params), ptr0, len0, allow_partial, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} boc\n* @returns {string | undefined}\n*/\nfunction extractContractData(boc) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.extractContractData(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        let v1;\n        if (r0 !== 0) {\n            v1 = getStringFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n        }\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} boc\n* @returns {string}\n*/\nfunction extractPublicKey(boc) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.extractPublicKey(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {string} code\n* @returns {string}\n*/\nfunction codeToTvc(code) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.codeToTvc(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {string} code\n* @param {string} data\n* @returns {string}\n*/\nfunction mergeTvc(code, data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.mergeTvc(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr2 = r0;\n        var len2 = r1;\n        if (r3) {\n            ptr2 = 0; len2 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr2, len2);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr2, len2);\n    }\n}\n\n/**\n* @param {string} tvc\n* @returns {StateInit}\n*/\nfunction splitTvc(tvc) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(tvc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.splitTvc(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} code\n* @param {string} salt\n* @returns {string}\n*/\nfunction setCodeSalt(code, salt) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(salt, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.setCodeSalt(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr2 = r0;\n        var len2 = r1;\n        if (r3) {\n            ptr2 = 0; len2 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr2, len2);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr2, len2);\n    }\n}\n\n/**\n* @param {string} code\n* @returns {string | undefined}\n*/\nfunction getCodeSalt(code) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.getCodeSalt(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        let v1;\n        if (r0 !== 0) {\n            v1 = getStringFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n        }\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} contract_abi\n* @param {string} method\n* @param {TokensObject} input\n* @returns {string}\n*/\nfunction encodeInternalInput(contract_abi, method, input) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(method, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.encodeInternalInput(retptr, ptr0, len0, ptr1, len1, addHeapObject(input));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr2 = r0;\n        var len2 = r1;\n        if (r3) {\n            ptr2 = 0; len2 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr2, len2);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr2, len2);\n    }\n}\n\n/**\n* @param {string | undefined} src\n* @param {string} dst\n* @param {boolean} bounce\n* @param {string | undefined} state_init\n* @param {string | undefined} body\n* @param {string} amount\n* @returns {string}\n*/\nfunction encodeInternalMessage(src, dst, bounce, state_init, body, amount) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = isLikeNone(src) ? 0 : passStringToWasm0(src, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(dst, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(state_init) ? 0 : passStringToWasm0(state_init, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        var ptr3 = isLikeNone(body) ? 0 : passStringToWasm0(body, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len3 = WASM_VECTOR_LEN;\n        const ptr4 = passStringToWasm0(amount, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len4 = WASM_VECTOR_LEN;\n        wasm.encodeInternalMessage(retptr, ptr0, len0, ptr1, len1, bounce, ptr2, len2, ptr3, len3, ptr4, len4);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr5 = r0;\n        var len5 = r1;\n        if (r3) {\n            ptr5 = 0; len5 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr5, len5);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr5, len5);\n    }\n}\n\n/**\n* @param {string} message_body\n* @param {string} contract_abi\n* @param {MethodName} method\n* @param {boolean} internal\n* @returns {DecodedInput | undefined}\n*/\nfunction decodeInput(message_body, contract_abi, method, internal) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(message_body, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.decodeInput(retptr, ptr0, len0, ptr1, len1, addHeapObject(method), internal);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} message_body\n* @param {string} contract_abi\n* @param {MethodName} event\n* @returns {DecodedEvent | undefined}\n*/\nfunction decodeEvent(message_body, contract_abi, event) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(message_body, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.decodeEvent(retptr, ptr0, len0, ptr1, len1, addHeapObject(event));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} message_body\n* @param {string} contract_abi\n* @param {MethodName} method\n* @returns {DecodedOutput | undefined}\n*/\nfunction decodeOutput(message_body, contract_abi, method) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(message_body, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.decodeOutput(retptr, ptr0, len0, ptr1, len1, addHeapObject(method));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {Transaction} transaction\n* @param {string} contract_abi\n* @param {MethodName} method\n* @returns {DecodedTransaction | undefined}\n*/\nfunction decodeTransaction(transaction, contract_abi, method) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.decodeTransaction(retptr, addHeapObject(transaction), ptr0, len0, addHeapObject(method));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {Transaction} transaction\n* @param {string} contract_abi\n* @returns {DecodedTransactionEvents}\n*/\nfunction decodeTransactionEvents(transaction, contract_abi) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.decodeTransactionEvents(retptr, addHeapObject(transaction), ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} data\n* @returns {string}\n*/\nfunction getDataHash(data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.getDataHash(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @returns {Ed25519KeyPair}\n*/\nfunction ed25519_generateKeyPair() {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.ed25519_generateKeyPair(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} secret_key\n* @param {string} data\n* @returns {string}\n*/\nfunction ed25519_sign(secret_key, data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(secret_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.ed25519_sign(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr2 = r0;\n        var len2 = r1;\n        if (r3) {\n            ptr2 = 0; len2 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr2, len2);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr2, len2);\n    }\n}\n\n/**\n* @param {string} signature\n* @returns {ExtendedSignature}\n*/\nfunction extendSignature(signature) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(signature, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.extendSignature(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} public_key\n* @param {string} data\n* @param {string} signature\n* @returns {boolean}\n*/\nfunction verifySignature(public_key, data, signature) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(public_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(signature, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        wasm.verifySignature(retptr, ptr0, len0, ptr1, len1, ptr2, len2);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return r0 !== 0;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} dst\n* @param {string | undefined} state_init\n* @param {string | undefined} body\n* @param {number} expire_at\n* @returns {SignedMessage}\n*/\nfunction createRawExternalMessage(dst, state_init, body, expire_at) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(dst, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(state_init) ? 0 : passStringToWasm0(state_init, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(body) ? 0 : passStringToWasm0(body, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        wasm.createRawExternalMessage(retptr, ptr0, len0, ptr1, len1, ptr2, len2, expire_at);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {ClockWithOffset} clock\n* @param {string} dst\n* @param {string} contract_abi\n* @param {string} method\n* @param {string | undefined} state_init\n* @param {TokensObject} input\n* @param {number} timeout\n* @returns {SignedMessage}\n*/\nfunction createExternalMessageWithoutSignature(clock, dst, contract_abi, method, state_init, input, timeout) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(clock, ClockWithOffset);\n        const ptr0 = passStringToWasm0(dst, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(method, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        var ptr3 = isLikeNone(state_init) ? 0 : passStringToWasm0(state_init, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len3 = WASM_VECTOR_LEN;\n        wasm.createExternalMessageWithoutSignature(retptr, clock.ptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, addHeapObject(input), timeout);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {ClockWithOffset} clock\n* @param {string} dst\n* @param {string} contract_abi\n* @param {string} method\n* @param {string | undefined} state_init\n* @param {TokensObject} input\n* @param {string} public_key\n* @param {number} timeout\n* @returns {UnsignedMessage}\n*/\nfunction createExternalMessage(clock, dst, contract_abi, method, state_init, input, public_key, timeout) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(clock, ClockWithOffset);\n        const ptr0 = passStringToWasm0(dst, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(method, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        var ptr3 = isLikeNone(state_init) ? 0 : passStringToWasm0(state_init, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len3 = WASM_VECTOR_LEN;\n        const ptr4 = passStringToWasm0(public_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len4 = WASM_VECTOR_LEN;\n        wasm.createExternalMessage(retptr, clock.ptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, addHeapObject(input), ptr4, len4, timeout);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return UnsignedMessage.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\nfunction __wbg_adapter_163(arg0, arg1, arg2, arg3) {\n    wasm.wasm_bindgen__convert__closures__invoke2_mut__hecba896d1563d223(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\n/**\n*/\nclass ClockWithOffset {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ClockWithOffset.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_clockwithoffset_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.clockwithoffset_new();\n        return ClockWithOffset.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    get nowMs() {\n        const ret = wasm.clockwithoffset_nowMs(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} offset_ms\n    */\n    updateOffset(offset_ms) {\n        wasm.clockwithoffset_updateOffset(this.ptr, offset_ms);\n    }\n    /**\n    * @returns {number}\n    */\n    offsetMs() {\n        const ret = wasm.clockwithoffset_offsetMs(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nclass GenericContract {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenericContract.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genericcontract_free(ptr);\n    }\n    /**\n    * @returns {string}\n    */\n    get address() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genericcontract_address(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {SignedMessage} message\n    * @returns {Promise<Transaction>}\n    */\n    sendMessageLocally(message) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genericcontract_sendMessageLocally(retptr, this.ptr, addHeapObject(message));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {SignedMessage} message\n    * @returns {Promise<PendingTransaction>}\n    */\n    sendMessage(message) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genericcontract_sendMessage(retptr, this.ptr, addHeapObject(message));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Promise<void>}\n    */\n    refresh() {\n        const ret = wasm.genericcontract_refresh(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} block_id\n    * @returns {Promise<void>}\n    */\n    handleBlock(block_id) {\n        const ptr0 = passStringToWasm0(block_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.genericcontract_handleBlock(this.ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} lt\n    * @returns {Promise<void>}\n    */\n    preloadTransactions(lt) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(lt, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.genericcontract_preloadTransactions(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {PollingMethod}\n    */\n    get pollingMethod() {\n        const ret = wasm.genericcontract_pollingMethod(this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n*/\nclass GqlConnection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GqlConnection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_gqlconnection_free(ptr);\n    }\n    /**\n    * @param {ClockWithOffset} clock\n    * @param {IGqlSender} sender\n    */\n    constructor(clock, sender) {\n        _assertClass(clock, ClockWithOffset);\n        const ret = wasm.gqlconnection_new(clock.ptr, addHeapObject(sender));\n        return GqlConnection.__wrap(ret);\n    }\n    /**\n    * @param {string} address\n    * @returns {Promise<LatestBlock>}\n    */\n    getLatestBlock(address) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.gqlconnection_getLatestBlock(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} current_block_id\n    * @param {string} address\n    * @param {number} timeout\n    * @returns {Promise<string>}\n    */\n    waitForNextBlock(current_block_id, address, timeout) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(current_block_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.gqlconnection_waitForNextBlock(retptr, this.ptr, ptr0, len0, ptr1, len1, timeout);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass GqlQuery {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GqlQuery.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_gqlquery_free(ptr);\n    }\n    /**\n    * @param {string} data\n    */\n    onReceive(data) {\n        const ptr = this.__destroy_into_raw();\n        const ptr0 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.gqlquery_onReceive(ptr, ptr0, len0);\n    }\n    /**\n    * @param {any} arg0\n    */\n    onError(arg0) {\n        const ptr = this.__destroy_into_raw();\n        wasm.gqlquery_onError(ptr, addHeapObject(arg0));\n    }\n    /**\n    */\n    onTimeout() {\n        const ptr = this.__destroy_into_raw();\n        wasm.gqlquery_onTimeout(ptr);\n    }\n}\n/**\n*/\nclass JrpcConnection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(JrpcConnection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jrpcconnection_free(ptr);\n    }\n    /**\n    * @param {ClockWithOffset} clock\n    * @param {any} sender\n    */\n    constructor(clock, sender) {\n        _assertClass(clock, ClockWithOffset);\n        const ret = wasm.jrpcconnection_new(clock.ptr, addHeapObject(sender));\n        return JrpcConnection.__wrap(ret);\n    }\n}\n/**\n*/\nclass JrpcQuery {\n\n    static __wrap(ptr) {\n        const obj = Object.create(JrpcQuery.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jrpcquery_free(ptr);\n    }\n    /**\n    * @param {string} data\n    */\n    onReceive(data) {\n        const ptr = this.__destroy_into_raw();\n        const ptr0 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.jrpcquery_onReceive(ptr, ptr0, len0);\n    }\n    /**\n    * @param {any} arg0\n    */\n    onError(arg0) {\n        const ptr = this.__destroy_into_raw();\n        wasm.jrpcquery_onError(ptr, addHeapObject(arg0));\n    }\n    /**\n    */\n    onTimeout() {\n        const ptr = this.__destroy_into_raw();\n        wasm.jrpcquery_onTimeout(ptr);\n    }\n}\n/**\n*/\nclass Transport {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Transport.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transport_free(ptr);\n    }\n    /**\n    * @param {GqlConnection} gql\n    * @returns {Transport}\n    */\n    static fromGqlConnection(gql) {\n        _assertClass(gql, GqlConnection);\n        const ret = wasm.transport_fromGqlConnection(gql.ptr);\n        return Transport.__wrap(ret);\n    }\n    /**\n    * @param {JrpcConnection} jrpc\n    * @returns {Transport}\n    */\n    static fromJrpcConnection(jrpc) {\n        _assertClass(jrpc, JrpcConnection);\n        const ret = wasm.transport_fromJrpcConnection(jrpc.ptr);\n        return Transport.__wrap(ret);\n    }\n    /**\n    * @param {string} address\n    * @param {any} handler\n    * @returns {Promise<GenericContract>}\n    */\n    subscribeToGenericContract(address, handler) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transport_subscribeToGenericContract(retptr, this.ptr, ptr0, len0, addHeapObject(handler));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} address\n    * @returns {Promise<FullContractState | undefined>}\n    */\n    getFullContractState(address) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transport_getFullContractState(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} code_hash\n    * @param {number} limit\n    * @param {string | undefined} continuation\n    * @returns {Promise<AccountsList>}\n    */\n    getAccountsByCodeHash(code_hash, limit, continuation) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(code_hash, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            var ptr1 = isLikeNone(continuation) ? 0 : passStringToWasm0(continuation, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.transport_getAccountsByCodeHash(retptr, this.ptr, ptr0, len0, limit, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} address\n    * @param {string | undefined} continuation\n    * @param {number} limit\n    * @returns {Promise<TransactionsList>}\n    */\n    getTransactions(address, continuation, limit) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            var ptr1 = isLikeNone(continuation) ? 0 : passStringToWasm0(continuation, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.transport_getTransactions(retptr, this.ptr, ptr0, len0, ptr1, len1, limit);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} hash\n    * @returns {Promise<Transaction | undefined>}\n    */\n    getTransaction(hash) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hash, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transport_getTransaction(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} message_hash\n    * @returns {Promise<Transaction | undefined>}\n    */\n    getDstTransaction(message_hash) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(message_hash, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transport_getDstTransaction(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass UnsignedMessage {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnsignedMessage.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unsignedmessage_free(ptr);\n    }\n    /**\n    * @param {ClockWithOffset} clock\n    */\n    refreshTimeout(clock) {\n        _assertClass(clock, ClockWithOffset);\n        wasm.unsignedmessage_refreshTimeout(this.ptr, clock.ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    expireAt() {\n        const ret = wasm.unsignedmessage_expireAt(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {string}\n    */\n    get hash() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unsignedmessage_hash(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} signature\n    * @returns {SignedMessage}\n    */\n    sign(signature) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(signature, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.unsignedmessage_sign(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {SignedMessage}\n    */\n    signFake() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unsignedmessage_signFake(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nasync function load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction getImports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_length_6e3bbe7c8bd4dbd8 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'number' ? obj : undefined;\n        getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n    };\n    imports.wbg.__wbindgen_is_null = function(arg0) {\n        const ret = getObject(arg0) === null;\n        return ret;\n    };\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_now_58886682b7e790d7 = function() {\n        const ret = Date.now();\n        return ret;\n    };\n    imports.wbg.__wbg_new_8d2af00bc1e329ee = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_0b9bfdd97583284e = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_send_55c5735308610fc0 = function(arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).send(getStringFromWasm0(arg1, arg2), GqlQuery.__wrap(arg3), arg4 !== 0);\n    };\n    imports.wbg.__wbg_send_c4fe5ef5f4851b5a = function(arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).send(getStringFromWasm0(arg1, arg2), JrpcQuery.__wrap(arg3), arg4 !== 0);\n    };\n    imports.wbg.__wbg_new_1d9a920c6bfc44a8 = function() {\n        const ret = new Array();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_push_740e4b286702d964 = function(arg0, arg1) {\n        const ret = getObject(arg0).push(getObject(arg1));\n        return ret;\n    };\n    imports.wbg.__wbg_genericcontract_new = function(arg0) {\n        const ret = GenericContract.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_onMessageSent_fc2ded3b8153507a = function(arg0, arg1, arg2) {\n        getObject(arg0).onMessageSent(takeObject(arg1), takeObject(arg2));\n    };\n    imports.wbg.__wbg_onMessageExpired_fbdb4b1a8bb0e7c5 = function(arg0, arg1) {\n        getObject(arg0).onMessageExpired(takeObject(arg1));\n    };\n    imports.wbg.__wbg_onStateChanged_e696a7b987dba9ea = function(arg0, arg1) {\n        getObject(arg0).onStateChanged(takeObject(arg1));\n    };\n    imports.wbg.__wbg_onTransactionsFound_33b7b56c770e2e88 = function(arg0, arg1, arg2) {\n        getObject(arg0).onTransactionsFound(takeObject(arg1), takeObject(arg2));\n    };\n    imports.wbg.__wbg_keys_0702294afaeb6044 = function(arg0) {\n        const ret = Object.keys(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_57245cc7d7c7619d = function(arg0, arg1) {\n        const ret = getObject(arg0)[arg1 >>> 0];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = getObject(arg0);\n        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbg_isLocal_0cc0f6258c8cf6ca = function(arg0) {\n        const ret = getObject(arg0).isLocal();\n        return ret;\n    };\n    imports.wbg.__wbg_new_9962f939219f1820 = function(arg0, arg1) {\n        try {\n            var state0 = {a: arg0, b: arg1};\n            var cb0 = (arg0, arg1) => {\n                const a = state0.a;\n                state0.a = 0;\n                try {\n                    return __wbg_adapter_163(a, state0.b, arg0, arg1);\n                } finally {\n                    state0.a = a;\n                }\n            };\n            const ret = new Promise(cb0);\n            return addHeapObject(ret);\n        } finally {\n            state0.a = state0.b = 0;\n        }\n    };\n    imports.wbg.__wbg_static_accessor_NODE_MODULE_cf6401cc1091279e = function() {\n        const ret = module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_process_0cc2ada8524d6f83 = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_versions_c11acceab27a6c87 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_node_7ff1ce49caf23815 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_a746e79b322b9336 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_crypto_2036bed7c44c25e7 = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_msCrypto_a21fc88caf1ecdc8 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_f5933855e4f48a19 = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_765201544a2b6869 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_self_6d479506f72c6a71 = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_window_f2557cc78490aceb = function() { return handleError(function () {\n        const ret = window.window;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_7f206bda628d5286 = function() { return handleError(function () {\n        const ret = globalThis.globalThis;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_global_ba75c50d1cf384f4 = function() { return handleError(function () {\n        const ret = __webpack_require__.g.global;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_newnoargs_b5b063fc6c2f0376 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_call_97ae9d8645dc388b = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_isArray_27c46c67f498e15d = function(arg0) {\n        const ret = Array.isArray(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_call_168da88779e35f61 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_set_bf3f89b92d5a34bf = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_randomFillSync_065afffde01daa66 = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_subarray_58ad4efbb5bcb886 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getRandomValues_b99eec4244a475bb = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_length_9e1ae1900cb0fbd5 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_buffer_3f3d764d4747d564 = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_8c3f0052272a457a = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_83db9690f9353e79 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(getObject(arg1));\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbg_then_11f7a54d67b4bfad = function(arg0, arg1) {\n        const ret = getObject(arg0).then(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cb_drop = function(arg0) {\n        const obj = takeObject(arg0).original;\n        if (obj.cnt-- == 1) {\n            obj.a = 0;\n            return true;\n        }\n        const ret = false;\n        return ret;\n    };\n    imports.wbg.__wbg_resolve_99fe17964f31ffc0 = function(arg0) {\n        const ret = Promise.resolve(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6437 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 925, __wbg_adapter_32);\n        return addHeapObject(ret);\n    };\n\n    return imports;\n}\n\nfunction initMemory(imports, maybe_memory) {\n\n}\n\nfunction finalizeInit(instance, module) {\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n    cachedFloat64Memory0 = new Float64Array();\n    cachedInt32Memory0 = new Int32Array();\n    cachedUint8Memory0 = new Uint8Array();\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    const imports = getImports();\n\n    initMemory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return finalizeInit(instance, module);\n}\n\nasync function init(input) {\n    if (typeof input === 'undefined') {\n        input = new URL(/* asset import */ __webpack_require__(/*! nekoton_wasm_bg.wasm */ \"./node_modules/nekoton-wasm/nekoton_wasm_bg.wasm\"), __webpack_require__.b);\n    }\n    const imports = getImports();\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    initMemory(imports);\n\n    const { instance, module } = await load(await input, imports);\n\n    return finalizeInit(instance, module);\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (init);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmVrb3Rvbi13YXNtL25la290b25fd2FzbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL25vZGVfbW9kdWxlcy9uZWtvdG9uLXdhc20vbmVrb3Rvbl93YXNtLmpzP2Q1MmQiXSwic291cmNlc0NvbnRlbnQiOlsiXG5sZXQgd2FzbTtcblxuY29uc3QgY2FjaGVkVGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBpZ25vcmVCT006IHRydWUsIGZhdGFsOiB0cnVlIH0pO1xuXG5jYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoKTtcblxubGV0IGNhY2hlZFVpbnQ4TWVtb3J5MCA9IG5ldyBVaW50OEFycmF5KCk7XG5cbmZ1bmN0aW9uIGdldFVpbnQ4TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkVWludDhNZW1vcnkwLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FjaGVkVWludDhNZW1vcnkwID0gbmV3IFVpbnQ4QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFVpbnQ4TWVtb3J5MDtcbn1cblxuZnVuY3Rpb24gZ2V0U3RyaW5nRnJvbVdhc20wKHB0ciwgbGVuKSB7XG4gICAgcmV0dXJuIGNhY2hlZFRleHREZWNvZGVyLmRlY29kZShnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIsIHB0ciArIGxlbikpO1xufVxuXG5jb25zdCBoZWFwID0gbmV3IEFycmF5KDMyKS5maWxsKHVuZGVmaW5lZCk7XG5cbmhlYXAucHVzaCh1bmRlZmluZWQsIG51bGwsIHRydWUsIGZhbHNlKTtcblxubGV0IGhlYXBfbmV4dCA9IGhlYXAubGVuZ3RoO1xuXG5mdW5jdGlvbiBhZGRIZWFwT2JqZWN0KG9iaikge1xuICAgIGlmIChoZWFwX25leHQgPT09IGhlYXAubGVuZ3RoKSBoZWFwLnB1c2goaGVhcC5sZW5ndGggKyAxKTtcbiAgICBjb25zdCBpZHggPSBoZWFwX25leHQ7XG4gICAgaGVhcF9uZXh0ID0gaGVhcFtpZHhdO1xuXG4gICAgaGVhcFtpZHhdID0gb2JqO1xuICAgIHJldHVybiBpZHg7XG59XG5cbmZ1bmN0aW9uIGdldE9iamVjdChpZHgpIHsgcmV0dXJuIGhlYXBbaWR4XTsgfVxuXG5mdW5jdGlvbiBpc0xpa2VOb25lKHgpIHtcbiAgICByZXR1cm4geCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGw7XG59XG5cbmxldCBjYWNoZWRGbG9hdDY0TWVtb3J5MCA9IG5ldyBGbG9hdDY0QXJyYXkoKTtcblxuZnVuY3Rpb24gZ2V0RmxvYXQ2NE1lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZEZsb2F0NjRNZW1vcnkwLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FjaGVkRmxvYXQ2NE1lbW9yeTAgPSBuZXcgRmxvYXQ2NEFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRGbG9hdDY0TWVtb3J5MDtcbn1cblxubGV0IGNhY2hlZEludDMyTWVtb3J5MCA9IG5ldyBJbnQzMkFycmF5KCk7XG5cbmZ1bmN0aW9uIGdldEludDMyTWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkSW50MzJNZW1vcnkwLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FjaGVkSW50MzJNZW1vcnkwID0gbmV3IEludDMyQXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZEludDMyTWVtb3J5MDtcbn1cblxubGV0IFdBU01fVkVDVE9SX0xFTiA9IDA7XG5cbmNvbnN0IGNhY2hlZFRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpO1xuXG5jb25zdCBlbmNvZGVTdHJpbmcgPSAodHlwZW9mIGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZUludG8gPT09ICdmdW5jdGlvbidcbiAgICA/IGZ1bmN0aW9uIChhcmcsIHZpZXcpIHtcbiAgICByZXR1cm4gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlSW50byhhcmcsIHZpZXcpO1xufVxuICAgIDogZnVuY3Rpb24gKGFyZywgdmlldykge1xuICAgIGNvbnN0IGJ1ZiA9IGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZShhcmcpO1xuICAgIHZpZXcuc2V0KGJ1Zik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVhZDogYXJnLmxlbmd0aCxcbiAgICAgICAgd3JpdHRlbjogYnVmLmxlbmd0aFxuICAgIH07XG59KTtcblxuZnVuY3Rpb24gcGFzc1N0cmluZ1RvV2FzbTAoYXJnLCBtYWxsb2MsIHJlYWxsb2MpIHtcblxuICAgIGlmIChyZWFsbG9jID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgYnVmID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlKGFyZyk7XG4gICAgICAgIGNvbnN0IHB0ciA9IG1hbGxvYyhidWYubGVuZ3RoKTtcbiAgICAgICAgZ2V0VWludDhNZW1vcnkwKCkuc3ViYXJyYXkocHRyLCBwdHIgKyBidWYubGVuZ3RoKS5zZXQoYnVmKTtcbiAgICAgICAgV0FTTV9WRUNUT1JfTEVOID0gYnVmLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBsZXQgbGVuID0gYXJnLmxlbmd0aDtcbiAgICBsZXQgcHRyID0gbWFsbG9jKGxlbik7XG5cbiAgICBjb25zdCBtZW0gPSBnZXRVaW50OE1lbW9yeTAoKTtcblxuICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgZm9yICg7IG9mZnNldCA8IGxlbjsgb2Zmc2V0KyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGFyZy5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICAgIGlmIChjb2RlID4gMHg3RikgYnJlYWs7XG4gICAgICAgIG1lbVtwdHIgKyBvZmZzZXRdID0gY29kZTtcbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ICE9PSBsZW4pIHtcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcHRyID0gcmVhbGxvYyhwdHIsIGxlbiwgbGVuID0gb2Zmc2V0ICsgYXJnLmxlbmd0aCAqIDMpO1xuICAgICAgICBjb25zdCB2aWV3ID0gZ2V0VWludDhNZW1vcnkwKCkuc3ViYXJyYXkocHRyICsgb2Zmc2V0LCBwdHIgKyBsZW4pO1xuICAgICAgICBjb25zdCByZXQgPSBlbmNvZGVTdHJpbmcoYXJnLCB2aWV3KTtcblxuICAgICAgICBvZmZzZXQgKz0gcmV0LndyaXR0ZW47XG4gICAgfVxuXG4gICAgV0FTTV9WRUNUT1JfTEVOID0gb2Zmc2V0O1xuICAgIHJldHVybiBwdHI7XG59XG5cbmZ1bmN0aW9uIGRyb3BPYmplY3QoaWR4KSB7XG4gICAgaWYgKGlkeCA8IDM2KSByZXR1cm47XG4gICAgaGVhcFtpZHhdID0gaGVhcF9uZXh0O1xuICAgIGhlYXBfbmV4dCA9IGlkeDtcbn1cblxuZnVuY3Rpb24gdGFrZU9iamVjdChpZHgpIHtcbiAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoaWR4KTtcbiAgICBkcm9wT2JqZWN0KGlkeCk7XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZGVidWdTdHJpbmcodmFsKSB7XG4gICAgLy8gcHJpbWl0aXZlIHR5cGVzXG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gICAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICBgJHt2YWx9YDtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGBcIiR7dmFsfVwiYDtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB2YWwuZGVzY3JpcHRpb247XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1N5bWJvbCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYFN5bWJvbCgke2Rlc2NyaXB0aW9ufSlgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHZhbC5uYW1lO1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgJiYgbmFtZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYEZ1bmN0aW9uKCR7bmFtZX0pYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnRnVuY3Rpb24nO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9iamVjdHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHZhbC5sZW5ndGg7XG4gICAgICAgIGxldCBkZWJ1ZyA9ICdbJztcbiAgICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRlYnVnICs9IGRlYnVnU3RyaW5nKHZhbFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkZWJ1ZyArPSAnLCAnICsgZGVidWdTdHJpbmcodmFsW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyArPSAnXSc7XG4gICAgICAgIHJldHVybiBkZWJ1ZztcbiAgICB9XG4gICAgLy8gVGVzdCBmb3IgYnVpbHQtaW5cbiAgICBjb25zdCBidWlsdEluTWF0Y2hlcyA9IC9cXFtvYmplY3QgKFteXFxdXSspXFxdLy5leGVjKHRvU3RyaW5nLmNhbGwodmFsKSk7XG4gICAgbGV0IGNsYXNzTmFtZTtcbiAgICBpZiAoYnVpbHRJbk1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjbGFzc05hbWUgPSBidWlsdEluTWF0Y2hlc1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWlsZWQgdG8gbWF0Y2ggdGhlIHN0YW5kYXJkICdbb2JqZWN0IENsYXNzTmFtZV0nXG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCk7XG4gICAgfVxuICAgIGlmIChjbGFzc05hbWUgPT0gJ09iamVjdCcpIHtcbiAgICAgICAgLy8gd2UncmUgYSB1c2VyIGRlZmluZWQgY2xhc3Mgb3IgT2JqZWN0XG4gICAgICAgIC8vIEpTT04uc3RyaW5naWZ5IGF2b2lkcyBwcm9ibGVtcyB3aXRoIGN5Y2xlcywgYW5kIGlzIGdlbmVyYWxseSBtdWNoXG4gICAgICAgIC8vIGVhc2llciB0aGFuIGxvb3BpbmcgdGhyb3VnaCBvd25Qcm9wZXJ0aWVzIG9mIGB2YWxgLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICdPYmplY3QoJyArIEpTT04uc3RyaW5naWZ5KHZhbCkgKyAnKSc7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiAnT2JqZWN0JztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlcnJvcnNcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGAke3ZhbC5uYW1lfTogJHt2YWwubWVzc2FnZX1cXG4ke3ZhbC5zdGFja31gO1xuICAgIH1cbiAgICAvLyBUT0RPIHdlIGNvdWxkIHRlc3QgZm9yIG1vcmUgdGhpbmdzIGhlcmUsIGxpa2UgYFNldGBzIGFuZCBgTWFwYHMuXG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxuZnVuY3Rpb24gbWFrZU11dENsb3N1cmUoYXJnMCwgYXJnMSwgZHRvciwgZikge1xuICAgIGNvbnN0IHN0YXRlID0geyBhOiBhcmcwLCBiOiBhcmcxLCBjbnQ6IDEsIGR0b3IgfTtcbiAgICBjb25zdCByZWFsID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgLy8gRmlyc3QgdXAgd2l0aCBhIGNsb3N1cmUgd2UgaW5jcmVtZW50IHRoZSBpbnRlcm5hbCByZWZlcmVuY2VcbiAgICAgICAgLy8gY291bnQuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBSdXN0IGNsb3N1cmUgZW52aXJvbm1lbnQgd29uJ3RcbiAgICAgICAgLy8gYmUgZGVhbGxvY2F0ZWQgd2hpbGUgd2UncmUgaW52b2tpbmcgaXQuXG4gICAgICAgIHN0YXRlLmNudCsrO1xuICAgICAgICBjb25zdCBhID0gc3RhdGUuYTtcbiAgICAgICAgc3RhdGUuYSA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZihhLCBzdGF0ZS5iLCAuLi5hcmdzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICgtLXN0YXRlLmNudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfMi5nZXQoc3RhdGUuZHRvcikoYSwgc3RhdGUuYik7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYSA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJlYWwub3JpZ2luYWwgPSBzdGF0ZTtcblxuICAgIHJldHVybiByZWFsO1xufVxuZnVuY3Rpb24gX193YmdfYWRhcHRlcl8zMihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgd2FzbS5fZHluX2NvcmVfX29wc19fZnVuY3Rpb25fX0ZuTXV0X19BX19fX091dHB1dF9fX1JfYXNfd2FzbV9iaW5kZ2VuX19jbG9zdXJlX19XYXNtQ2xvc3VyZV9fX2Rlc2NyaWJlX19pbnZva2VfX2hjYjc3NzI5YzZhZjlkMzc2KGFyZzAsIGFyZzEsIGFkZEhlYXBPYmplY3QoYXJnMikpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0Q2xhc3MoaW5zdGFuY2UsIGtsYXNzKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBrbGFzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBpbnN0YW5jZSBvZiAke2tsYXNzLm5hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZS5wdHI7XG59XG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiogQHJldHVybnMge2Jvb2xlYW59XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFkZHJlc3MsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgIGNvbnN0IHJldCA9IHdhc20uY2hlY2tBZGRyZXNzKHB0cjAsIGxlbjApO1xuICAgIHJldHVybiByZXQgIT09IDA7XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuKiBAcmV0dXJucyB7c3RyaW5nfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBhY2tBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFkZHJlc3MsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5yZXBhY2tBZGRyZXNzKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgdmFyIHB0cjEgPSByMDtcbiAgICAgICAgdmFyIGxlbjEgPSByMTtcbiAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICBwdHIxID0gMDsgbGVuMSA9IDA7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjEsIGxlbjEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHB0cjEsIGxlbjEpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7Q2xvY2tXaXRoT2Zmc2V0fSBjbG9ja1xuKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudF9zdHVmZl9ib2NcbiogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0X2FiaVxuKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4qIEBwYXJhbSB7VG9rZW5zT2JqZWN0fSBpbnB1dFxuKiBAcGFyYW0ge2Jvb2xlYW59IHJlc3BvbnNpYmxlXG4qIEByZXR1cm5zIHtFeGVjdXRpb25PdXRwdXR9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bkxvY2FsKGNsb2NrLCBhY2NvdW50X3N0dWZmX2JvYywgY29udHJhY3RfYWJpLCBtZXRob2QsIGlucHV0LCByZXNwb25zaWJsZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoY2xvY2ssIENsb2NrV2l0aE9mZnNldCk7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhY2NvdW50X3N0dWZmX2JvYywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAoY29udHJhY3RfYWJpLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjIgPSBwYXNzU3RyaW5nVG9XYXNtMChtZXRob2QsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMiA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5ydW5Mb2NhbChyZXRwdHIsIGNsb2NrLnB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgcHRyMiwgbGVuMiwgYWRkSGVhcE9iamVjdChpbnB1dCksIHJlc3BvbnNpYmxlKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudF9zdHVmZl9ib2NcbiogQHJldHVybnMge3N0cmluZ31cbiovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUZ1bGxBY2NvdW50Qm9jKGFjY291bnRfc3R1ZmZfYm9jKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhY2NvdW50X3N0dWZmX2JvYywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLm1ha2VGdWxsQWNjb3VudEJvYyhyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICB2YXIgcjMgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgM107XG4gICAgICAgIHZhciBwdHIxID0gcjA7XG4gICAgICAgIHZhciBsZW4xID0gcjE7XG4gICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgcHRyMSA9IDA7IGxlbjEgPSAwO1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIxLCBsZW4xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShwdHIxLCBsZW4xKTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudFxuKiBAcmV0dXJucyB7RnVsbENvbnRyYWN0U3RhdGUgfCB1bmRlZmluZWR9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRnVsbEFjY291bnRCb2MoYWNjb3VudCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYWNjb3VudCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLnBhcnNlRnVsbEFjY291bnRCb2MocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnXG4qIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50XG4qIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4qIEBwYXJhbSB7bnVtYmVyfSB1dGltZVxuKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVfc2lnbmF0dXJlX2NoZWNrXG4qIEByZXR1cm5zIHtUcmFuc2FjdGlvbkV4ZWN1dG9yT3V0cHV0fVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlTG9jYWwoY29uZmlnLCBhY2NvdW50LCBtZXNzYWdlLCB1dGltZSwgZGlzYWJsZV9zaWduYXR1cmVfY2hlY2spIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGNvbmZpZywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAoYWNjb3VudCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIyID0gcGFzc1N0cmluZ1RvV2FzbTAobWVzc2FnZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmV4ZWN1dGVMb2NhbChyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIHB0cjIsIGxlbjIsIHV0aW1lLCBkaXNhYmxlX3NpZ25hdHVyZV9jaGVjayk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IHR2Y1xuKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RfYWJpXG4qIEBwYXJhbSB7bnVtYmVyfSB3b3JrY2hhaW5faWRcbiogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHB1YmxpY19rZXlcbiogQHBhcmFtIHtUb2tlbnNPYmplY3R9IGluaXRfZGF0YVxuKiBAcmV0dXJucyB7RXhwZWN0ZWRBZGRyZXNzfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFeHBlY3RlZEFkZHJlc3ModHZjLCBjb250cmFjdF9hYmksIHdvcmtjaGFpbl9pZCwgcHVibGljX2tleSwgaW5pdF9kYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMCh0dmMsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKGNvbnRyYWN0X2FiaSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMiA9IGlzTGlrZU5vbmUocHVibGljX2tleSkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAocHVibGljX2tleSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMiA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5nZXRFeHBlY3RlZEFkZHJlc3MocmV0cHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCB3b3JrY2hhaW5faWQsIHB0cjIsIGxlbjIsIGFkZEhlYXBPYmplY3QoaW5pdF9kYXRhKSk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IGJvY1xuKiBAcmV0dXJucyB7c3RyaW5nfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb2NIYXNoKGJvYykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYm9jLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uZ2V0Qm9jSGFzaChyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICB2YXIgcjMgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgM107XG4gICAgICAgIHZhciBwdHIxID0gcjA7XG4gICAgICAgIHZhciBsZW4xID0gcjE7XG4gICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgcHRyMSA9IDA7IGxlbjEgPSAwO1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIxLCBsZW4xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShwdHIxLCBsZW4xKTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge0FycmF5PEFiaVBhcmFtPn0gcGFyYW1zXG4qIEBwYXJhbSB7VG9rZW5zT2JqZWN0fSB0b2tlbnNcbiogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGFiaV92ZXJzaW9uXG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHBhY2tJbnRvQ2VsbChwYXJhbXMsIHRva2VucywgYWJpX3ZlcnNpb24pIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGFiaV92ZXJzaW9uKSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChhYmlfdmVyc2lvbiwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5wYWNrSW50b0NlbGwocmV0cHRyLCBhZGRIZWFwT2JqZWN0KHBhcmFtcyksIGFkZEhlYXBPYmplY3QodG9rZW5zKSwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgdmFyIHB0cjEgPSByMDtcbiAgICAgICAgdmFyIGxlbjEgPSByMTtcbiAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICBwdHIxID0gMDsgbGVuMSA9IDA7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjEsIGxlbjEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHB0cjEsIGxlbjEpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7QXJyYXk8QWJpUGFyYW0+fSBwYXJhbXNcbiogQHBhcmFtIHtzdHJpbmd9IGJvY1xuKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93X3BhcnRpYWxcbiogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGFiaV92ZXJzaW9uXG4qIEByZXR1cm5zIHtUb2tlbnNPYmplY3R9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHVucGFja0Zyb21DZWxsKHBhcmFtcywgYm9jLCBhbGxvd19wYXJ0aWFsLCBhYmlfdmVyc2lvbikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYm9jLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIxID0gaXNMaWtlTm9uZShhYmlfdmVyc2lvbikgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoYWJpX3ZlcnNpb24sIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20udW5wYWNrRnJvbUNlbGwocmV0cHRyLCBhZGRIZWFwT2JqZWN0KHBhcmFtcyksIHB0cjAsIGxlbjAsIGFsbG93X3BhcnRpYWwsIHB0cjEsIGxlbjEpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBib2NcbiogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdENvbnRyYWN0RGF0YShib2MpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGJvYywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmV4dHJhY3RDb250cmFjdERhdGEocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICAgICAgICB2MSA9IGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyMCwgcjEgKiAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjE7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gYm9jXG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQdWJsaWNLZXkoYm9jKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChib2MsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5leHRyYWN0UHVibGljS2V5KHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgdmFyIHB0cjEgPSByMDtcbiAgICAgICAgdmFyIGxlbjEgPSByMTtcbiAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICBwdHIxID0gMDsgbGVuMSA9IDA7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjEsIGxlbjEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHB0cjEsIGxlbjEpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGNvZGVUb1R2Yyhjb2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChjb2RlLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uY29kZVRvVHZjKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgdmFyIHB0cjEgPSByMDtcbiAgICAgICAgdmFyIGxlbjEgPSByMTtcbiAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICBwdHIxID0gMDsgbGVuMSA9IDA7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjEsIGxlbjEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHB0cjEsIGxlbjEpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4qIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlVHZjKGNvZGUsIGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGNvZGUsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKGRhdGEsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5tZXJnZVR2YyhyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICB2YXIgcjMgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgM107XG4gICAgICAgIHZhciBwdHIyID0gcjA7XG4gICAgICAgIHZhciBsZW4yID0gcjE7XG4gICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgcHRyMiA9IDA7IGxlbjIgPSAwO1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIyLCBsZW4yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShwdHIyLCBsZW4yKTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gdHZjXG4qIEByZXR1cm5zIHtTdGF0ZUluaXR9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0VHZjKHR2Yykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAodHZjLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uc3BsaXRUdmMocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuKiBAcGFyYW0ge3N0cmluZ30gc2FsdFxuKiBAcmV0dXJucyB7c3RyaW5nfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb2RlU2FsdChjb2RlLCBzYWx0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChjb2RlLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChzYWx0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uc2V0Q29kZVNhbHQocmV0cHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICB2YXIgcHRyMiA9IHIwO1xuICAgICAgICB2YXIgbGVuMiA9IHIxO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHB0cjIgPSAwOyBsZW4yID0gMDtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMiwgbGVuMik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocHRyMiwgbGVuMik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29kZVNhbHQoY29kZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY29kZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmdldENvZGVTYWx0KHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdjE7XG4gICAgICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgICAgICAgdjEgPSBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocjAsIHIxICogMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYxO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0X2FiaVxuKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4qIEBwYXJhbSB7VG9rZW5zT2JqZWN0fSBpbnB1dFxuKiBAcmV0dXJucyB7c3RyaW5nfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVJbnRlcm5hbElucHV0KGNvbnRyYWN0X2FiaSwgbWV0aG9kLCBpbnB1dCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY29udHJhY3RfYWJpLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChtZXRob2QsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5lbmNvZGVJbnRlcm5hbElucHV0KHJldHB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgYWRkSGVhcE9iamVjdChpbnB1dCkpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICB2YXIgcjMgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgM107XG4gICAgICAgIHZhciBwdHIyID0gcjA7XG4gICAgICAgIHZhciBsZW4yID0gcjE7XG4gICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgcHRyMiA9IDA7IGxlbjIgPSAwO1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIyLCBsZW4yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShwdHIyLCBsZW4yKTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gc3JjXG4qIEBwYXJhbSB7c3RyaW5nfSBkc3RcbiogQHBhcmFtIHtib29sZWFufSBib3VuY2VcbiogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHN0YXRlX2luaXRcbiogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGJvZHlcbiogQHBhcmFtIHtzdHJpbmd9IGFtb3VudFxuKiBAcmV0dXJucyB7c3RyaW5nfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVJbnRlcm5hbE1lc3NhZ2Uoc3JjLCBkc3QsIGJvdW5jZSwgc3RhdGVfaW5pdCwgYm9keSwgYW1vdW50KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShzcmMpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHNyYywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKGRzdCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMiA9IGlzTGlrZU5vbmUoc3RhdGVfaW5pdCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoc3RhdGVfaW5pdCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMiA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgdmFyIHB0cjMgPSBpc0xpa2VOb25lKGJvZHkpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKGJvZHksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjMgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjQgPSBwYXNzU3RyaW5nVG9XYXNtMChhbW91bnQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuNCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5lbmNvZGVJbnRlcm5hbE1lc3NhZ2UocmV0cHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBib3VuY2UsIHB0cjIsIGxlbjIsIHB0cjMsIGxlbjMsIHB0cjQsIGxlbjQpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICB2YXIgcjMgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgM107XG4gICAgICAgIHZhciBwdHI1ID0gcjA7XG4gICAgICAgIHZhciBsZW41ID0gcjE7XG4gICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgcHRyNSA9IDA7IGxlbjUgPSAwO1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHI1LCBsZW41KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShwdHI1LCBsZW41KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZV9ib2R5XG4qIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdF9hYmlcbiogQHBhcmFtIHtNZXRob2ROYW1lfSBtZXRob2RcbiogQHBhcmFtIHtib29sZWFufSBpbnRlcm5hbFxuKiBAcmV0dXJucyB7RGVjb2RlZElucHV0IHwgdW5kZWZpbmVkfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVJbnB1dChtZXNzYWdlX2JvZHksIGNvbnRyYWN0X2FiaSwgbWV0aG9kLCBpbnRlcm5hbCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAobWVzc2FnZV9ib2R5LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChjb250cmFjdF9hYmksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5kZWNvZGVJbnB1dChyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIGFkZEhlYXBPYmplY3QobWV0aG9kKSwgaW50ZXJuYWwpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlX2JvZHlcbiogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0X2FiaVxuKiBAcGFyYW0ge01ldGhvZE5hbWV9IGV2ZW50XG4qIEByZXR1cm5zIHtEZWNvZGVkRXZlbnQgfCB1bmRlZmluZWR9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUV2ZW50KG1lc3NhZ2VfYm9keSwgY29udHJhY3RfYWJpLCBldmVudCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAobWVzc2FnZV9ib2R5LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChjb250cmFjdF9hYmksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5kZWNvZGVFdmVudChyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIGFkZEhlYXBPYmplY3QoZXZlbnQpKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZV9ib2R5XG4qIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdF9hYmlcbiogQHBhcmFtIHtNZXRob2ROYW1lfSBtZXRob2RcbiogQHJldHVybnMge0RlY29kZWRPdXRwdXQgfCB1bmRlZmluZWR9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU91dHB1dChtZXNzYWdlX2JvZHksIGNvbnRyYWN0X2FiaSwgbWV0aG9kKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChtZXNzYWdlX2JvZHksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKGNvbnRyYWN0X2FiaSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmRlY29kZU91dHB1dChyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIGFkZEhlYXBPYmplY3QobWV0aG9kKSk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0X2FiaVxuKiBAcGFyYW0ge01ldGhvZE5hbWV9IG1ldGhvZFxuKiBAcmV0dXJucyB7RGVjb2RlZFRyYW5zYWN0aW9uIHwgdW5kZWZpbmVkfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29udHJhY3RfYWJpLCBtZXRob2QpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGNvbnRyYWN0X2FiaSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmRlY29kZVRyYW5zYWN0aW9uKHJldHB0ciwgYWRkSGVhcE9iamVjdCh0cmFuc2FjdGlvbiksIHB0cjAsIGxlbjAsIGFkZEhlYXBPYmplY3QobWV0aG9kKSk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0X2FiaVxuKiBAcmV0dXJucyB7RGVjb2RlZFRyYW5zYWN0aW9uRXZlbnRzfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUcmFuc2FjdGlvbkV2ZW50cyh0cmFuc2FjdGlvbiwgY29udHJhY3RfYWJpKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChjb250cmFjdF9hYmksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5kZWNvZGVUcmFuc2FjdGlvbkV2ZW50cyhyZXRwdHIsIGFkZEhlYXBPYmplY3QodHJhbnNhY3Rpb24pLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuKiBAcmV0dXJucyB7c3RyaW5nfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhSGFzaChkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChkYXRhLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uZ2V0RGF0YUhhc2gocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICB2YXIgcHRyMSA9IHIwO1xuICAgICAgICB2YXIgbGVuMSA9IHIxO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHB0cjEgPSAwOyBsZW4xID0gMDtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMSwgbGVuMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocHRyMSwgbGVuMSk7XG4gICAgfVxufVxuXG4vKipcbiogQHJldHVybnMge0VkMjU1MTlLZXlQYWlyfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBlZDI1NTE5X2dlbmVyYXRlS2V5UGFpcigpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgd2FzbS5lZDI1NTE5X2dlbmVyYXRlS2V5UGFpcihyZXRwdHIpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBzZWNyZXRfa2V5XG4qIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGVkMjU1MTlfc2lnbihzZWNyZXRfa2V5LCBkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChzZWNyZXRfa2V5LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChkYXRhLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uZWQyNTUxOV9zaWduKHJldHB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgdmFyIHB0cjIgPSByMDtcbiAgICAgICAgdmFyIGxlbjIgPSByMTtcbiAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICBwdHIyID0gMDsgbGVuMiA9IDA7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjIsIGxlbjIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHB0cjIsIGxlbjIpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBzaWduYXR1cmVcbiogQHJldHVybnMge0V4dGVuZGVkU2lnbmF0dXJlfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChzaWduYXR1cmUsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5leHRlbmRTaWduYXR1cmUocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gcHVibGljX2tleVxuKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlXG4qIEByZXR1cm5zIHtib29sZWFufVxuKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUocHVibGljX2tleSwgZGF0YSwgc2lnbmF0dXJlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChwdWJsaWNfa2V5LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChkYXRhLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjIgPSBwYXNzU3RyaW5nVG9XYXNtMChzaWduYXR1cmUsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMiA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS52ZXJpZnlTaWduYXR1cmUocmV0cHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBwdHIyLCBsZW4yKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjAgIT09IDA7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gZHN0XG4qIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBzdGF0ZV9pbml0XG4qIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBib2R5XG4qIEBwYXJhbSB7bnVtYmVyfSBleHBpcmVfYXRcbiogQHJldHVybnMge1NpZ25lZE1lc3NhZ2V9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJhd0V4dGVybmFsTWVzc2FnZShkc3QsIHN0YXRlX2luaXQsIGJvZHksIGV4cGlyZV9hdCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoZHN0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIxID0gaXNMaWtlTm9uZShzdGF0ZV9pbml0KSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChzdGF0ZV9pbml0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMiA9IGlzTGlrZU5vbmUoYm9keSkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoYm9keSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMiA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5jcmVhdGVSYXdFeHRlcm5hbE1lc3NhZ2UocmV0cHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBwdHIyLCBsZW4yLCBleHBpcmVfYXQpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7Q2xvY2tXaXRoT2Zmc2V0fSBjbG9ja1xuKiBAcGFyYW0ge3N0cmluZ30gZHN0XG4qIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdF9hYmlcbiogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gc3RhdGVfaW5pdFxuKiBAcGFyYW0ge1Rva2Vuc09iamVjdH0gaW5wdXRcbiogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiogQHJldHVybnMge1NpZ25lZE1lc3NhZ2V9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV4dGVybmFsTWVzc2FnZVdpdGhvdXRTaWduYXR1cmUoY2xvY2ssIGRzdCwgY29udHJhY3RfYWJpLCBtZXRob2QsIHN0YXRlX2luaXQsIGlucHV0LCB0aW1lb3V0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjbG9jaywgQ2xvY2tXaXRoT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGRzdCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAoY29udHJhY3RfYWJpLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjIgPSBwYXNzU3RyaW5nVG9XYXNtMChtZXRob2QsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMiA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgdmFyIHB0cjMgPSBpc0xpa2VOb25lKHN0YXRlX2luaXQpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHN0YXRlX2luaXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjMgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uY3JlYXRlRXh0ZXJuYWxNZXNzYWdlV2l0aG91dFNpZ25hdHVyZShyZXRwdHIsIGNsb2NrLnB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgcHRyMiwgbGVuMiwgcHRyMywgbGVuMywgYWRkSGVhcE9iamVjdChpbnB1dCksIHRpbWVvdXQpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7Q2xvY2tXaXRoT2Zmc2V0fSBjbG9ja1xuKiBAcGFyYW0ge3N0cmluZ30gZHN0XG4qIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdF9hYmlcbiogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gc3RhdGVfaW5pdFxuKiBAcGFyYW0ge1Rva2Vuc09iamVjdH0gaW5wdXRcbiogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY19rZXlcbiogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiogQHJldHVybnMge1Vuc2lnbmVkTWVzc2FnZX1cbiovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXh0ZXJuYWxNZXNzYWdlKGNsb2NrLCBkc3QsIGNvbnRyYWN0X2FiaSwgbWV0aG9kLCBzdGF0ZV9pbml0LCBpbnB1dCwgcHVibGljX2tleSwgdGltZW91dCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoY2xvY2ssIENsb2NrV2l0aE9mZnNldCk7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChkc3QsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKGNvbnRyYWN0X2FiaSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIyID0gcGFzc1N0cmluZ1RvV2FzbTAobWV0aG9kLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjIgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIzID0gaXNMaWtlTm9uZShzdGF0ZV9pbml0KSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChzdGF0ZV9pbml0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4zID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHI0ID0gcGFzc1N0cmluZ1RvV2FzbTAocHVibGljX2tleSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW40ID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmNyZWF0ZUV4dGVybmFsTWVzc2FnZShyZXRwdHIsIGNsb2NrLnB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgcHRyMiwgbGVuMiwgcHRyMywgbGVuMywgYWRkSGVhcE9iamVjdChpbnB1dCksIHB0cjQsIGxlbjQsIHRpbWVvdXQpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVbnNpZ25lZE1lc3NhZ2UuX193cmFwKHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZiwgYXJncykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4bl9zdG9yZShhZGRIZWFwT2JqZWN0KGUpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5VThGcm9tV2FzbTAocHRyLCBsZW4pIHtcbiAgICByZXR1cm4gZ2V0VWludDhNZW1vcnkwKCkuc3ViYXJyYXkocHRyIC8gMSwgcHRyIC8gMSArIGxlbik7XG59XG5mdW5jdGlvbiBfX3diZ19hZGFwdGVyXzE2MyhhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgd2FzbS53YXNtX2JpbmRnZW5fX2NvbnZlcnRfX2Nsb3N1cmVzX19pbnZva2UyX211dF9faGVjYmE4OTZkMTU2M2QyMjMoYXJnMCwgYXJnMSwgYWRkSGVhcE9iamVjdChhcmcyKSwgYWRkSGVhcE9iamVjdChhcmczKSk7XG59XG5cbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBDbG9ja1dpdGhPZmZzZXQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShDbG9ja1dpdGhPZmZzZXQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLnB0ciA9IHB0cjtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5wdHI7XG4gICAgICAgIHRoaXMucHRyID0gMDtcblxuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfY2xvY2t3aXRob2Zmc2V0X2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5jbG9ja3dpdGhvZmZzZXRfbmV3KCk7XG4gICAgICAgIHJldHVybiBDbG9ja1dpdGhPZmZzZXQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGdldCBub3dNcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5jbG9ja3dpdGhvZmZzZXRfbm93TXModGhpcy5wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRfbXNcbiAgICAqL1xuICAgIHVwZGF0ZU9mZnNldChvZmZzZXRfbXMpIHtcbiAgICAgICAgd2FzbS5jbG9ja3dpdGhvZmZzZXRfdXBkYXRlT2Zmc2V0KHRoaXMucHRyLCBvZmZzZXRfbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBvZmZzZXRNcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5jbG9ja3dpdGhvZmZzZXRfb2Zmc2V0TXModGhpcy5wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBHZW5lcmljQ29udHJhY3Qge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShHZW5lcmljQ29udHJhY3QucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLnB0ciA9IHB0cjtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5wdHI7XG4gICAgICAgIHRoaXMucHRyID0gMDtcblxuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZ2VuZXJpY2NvbnRyYWN0X2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICovXG4gICAgZ2V0IGFkZHJlc3MoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uZ2VuZXJpY2NvbnRyYWN0X2FkZHJlc3MocmV0cHRyLCB0aGlzLnB0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocjAsIHIxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7U2lnbmVkTWVzc2FnZX0gbWVzc2FnZVxuICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb24+fVxuICAgICovXG4gICAgc2VuZE1lc3NhZ2VMb2NhbGx5KG1lc3NhZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5nZW5lcmljY29udHJhY3Rfc2VuZE1lc3NhZ2VMb2NhbGx5KHJldHB0ciwgdGhpcy5wdHIsIGFkZEhlYXBPYmplY3QobWVzc2FnZSkpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtTaWduZWRNZXNzYWdlfSBtZXNzYWdlXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQZW5kaW5nVHJhbnNhY3Rpb24+fVxuICAgICovXG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmdlbmVyaWNjb250cmFjdF9zZW5kTWVzc2FnZShyZXRwdHIsIHRoaXMucHRyLCBhZGRIZWFwT2JqZWN0KG1lc3NhZ2UpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICovXG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5nZW5lcmljY29udHJhY3RfcmVmcmVzaCh0aGlzLnB0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGJsb2NrX2lkXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAqL1xuICAgIGhhbmRsZUJsb2NrKGJsb2NrX2lkKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChibG9ja19pZCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmdlbmVyaWNjb250cmFjdF9oYW5kbGVCbG9jayh0aGlzLnB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGx0XG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAqL1xuICAgIHByZWxvYWRUcmFuc2FjdGlvbnMobHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGx0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5nZW5lcmljY29udHJhY3RfcHJlbG9hZFRyYW5zYWN0aW9ucyhyZXRwdHIsIHRoaXMucHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtQb2xsaW5nTWV0aG9kfVxuICAgICovXG4gICAgZ2V0IHBvbGxpbmdNZXRob2QoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZ2VuZXJpY2NvbnRyYWN0X3BvbGxpbmdNZXRob2QodGhpcy5wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbn1cbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBHcWxDb25uZWN0aW9uIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoR3FsQ29ubmVjdGlvbi5wcm90b3R5cGUpO1xuICAgICAgICBvYmoucHRyID0gcHRyO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLnB0cjtcbiAgICAgICAgdGhpcy5wdHIgPSAwO1xuXG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ncWxjb25uZWN0aW9uX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0Nsb2NrV2l0aE9mZnNldH0gY2xvY2tcbiAgICAqIEBwYXJhbSB7SUdxbFNlbmRlcn0gc2VuZGVyXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbG9jaywgc2VuZGVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjbG9jaywgQ2xvY2tXaXRoT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ncWxjb25uZWN0aW9uX25ldyhjbG9jay5wdHIsIGFkZEhlYXBPYmplY3Qoc2VuZGVyKSk7XG4gICAgICAgIHJldHVybiBHcWxDb25uZWN0aW9uLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTxMYXRlc3RCbG9jaz59XG4gICAgKi9cbiAgICBnZXRMYXRlc3RCbG9jayhhZGRyZXNzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhZGRyZXNzLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5ncWxjb25uZWN0aW9uX2dldExhdGVzdEJsb2NrKHJldHB0ciwgdGhpcy5wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnRfYmxvY2tfaWRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzXG4gICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAgICAqL1xuICAgIHdhaXRGb3JOZXh0QmxvY2soY3VycmVudF9ibG9ja19pZCwgYWRkcmVzcywgdGltZW91dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY3VycmVudF9ibG9ja19pZCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChhZGRyZXNzLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5ncWxjb25uZWN0aW9uX3dhaXRGb3JOZXh0QmxvY2socmV0cHRyLCB0aGlzLnB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgdGltZW91dCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiovXG5leHBvcnQgY2xhc3MgR3FsUXVlcnkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShHcWxRdWVyeS5wcm90b3R5cGUpO1xuICAgICAgICBvYmoucHRyID0gcHRyO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLnB0cjtcbiAgICAgICAgdGhpcy5wdHIgPSAwO1xuXG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ncWxxdWVyeV9mcmVlKHB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAgICAqL1xuICAgIG9uUmVjZWl2ZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChkYXRhLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uZ3FscXVlcnlfb25SZWNlaXZlKHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHthbnl9IGFyZzBcbiAgICAqL1xuICAgIG9uRXJyb3IoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLmdxbHF1ZXJ5X29uRXJyb3IocHRyLCBhZGRIZWFwT2JqZWN0KGFyZzApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKi9cbiAgICBvblRpbWVvdXQoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uZ3FscXVlcnlfb25UaW1lb3V0KHB0cik7XG4gICAgfVxufVxuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIEpycGNDb25uZWN0aW9uIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoSnJwY0Nvbm5lY3Rpb24ucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLnB0ciA9IHB0cjtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5wdHI7XG4gICAgICAgIHRoaXMucHRyID0gMDtcblxuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfanJwY2Nvbm5lY3Rpb25fZnJlZShwdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7Q2xvY2tXaXRoT2Zmc2V0fSBjbG9ja1xuICAgICogQHBhcmFtIHthbnl9IHNlbmRlclxuICAgICovXG4gICAgY29uc3RydWN0b3IoY2xvY2ssIHNlbmRlcikge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoY2xvY2ssIENsb2NrV2l0aE9mZnNldCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uanJwY2Nvbm5lY3Rpb25fbmV3KGNsb2NrLnB0ciwgYWRkSGVhcE9iamVjdChzZW5kZXIpKTtcbiAgICAgICAgcmV0dXJuIEpycGNDb25uZWN0aW9uLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBKcnBjUXVlcnkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShKcnBjUXVlcnkucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLnB0ciA9IHB0cjtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5wdHI7XG4gICAgICAgIHRoaXMucHRyID0gMDtcblxuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfanJwY3F1ZXJ5X2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICAgICovXG4gICAgb25SZWNlaXZlKGRhdGEpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGRhdGEsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5qcnBjcXVlcnlfb25SZWNlaXZlKHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHthbnl9IGFyZzBcbiAgICAqL1xuICAgIG9uRXJyb3IoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLmpycGNxdWVyeV9vbkVycm9yKHB0ciwgYWRkSGVhcE9iamVjdChhcmcwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICovXG4gICAgb25UaW1lb3V0KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLmpycGNxdWVyeV9vblRpbWVvdXQocHRyKTtcbiAgICB9XG59XG4vKipcbiovXG5leHBvcnQgY2xhc3MgVHJhbnNwb3J0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNwb3J0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5wdHIgPSBwdHI7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMucHRyO1xuICAgICAgICB0aGlzLnB0ciA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3RyYW5zcG9ydF9mcmVlKHB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtHcWxDb25uZWN0aW9ufSBncWxcbiAgICAqIEByZXR1cm5zIHtUcmFuc3BvcnR9XG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUdxbENvbm5lY3Rpb24oZ3FsKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhncWwsIEdxbENvbm5lY3Rpb24pO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zcG9ydF9mcm9tR3FsQ29ubmVjdGlvbihncWwucHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zcG9ydC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0pycGNDb25uZWN0aW9ufSBqcnBjXG4gICAgKiBAcmV0dXJucyB7VHJhbnNwb3J0fVxuICAgICovXG4gICAgc3RhdGljIGZyb21KcnBjQ29ubmVjdGlvbihqcnBjKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhqcnBjLCBKcnBjQ29ubmVjdGlvbik7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNwb3J0X2Zyb21KcnBjQ29ubmVjdGlvbihqcnBjLnB0cik7XG4gICAgICAgIHJldHVybiBUcmFuc3BvcnQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAgICAqIEBwYXJhbSB7YW55fSBoYW5kbGVyXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZW5lcmljQ29udHJhY3Q+fVxuICAgICovXG4gICAgc3Vic2NyaWJlVG9HZW5lcmljQ29udHJhY3QoYWRkcmVzcywgaGFuZGxlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYWRkcmVzcywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20udHJhbnNwb3J0X3N1YnNjcmliZVRvR2VuZXJpY0NvbnRyYWN0KHJldHB0ciwgdGhpcy5wdHIsIHB0cjAsIGxlbjAsIGFkZEhlYXBPYmplY3QoaGFuZGxlcikpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZ1bGxDb250cmFjdFN0YXRlIHwgdW5kZWZpbmVkPn1cbiAgICAqL1xuICAgIGdldEZ1bGxDb250cmFjdFN0YXRlKGFkZHJlc3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFkZHJlc3MsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnRyYW5zcG9ydF9nZXRGdWxsQ29udHJhY3RTdGF0ZShyZXRwdHIsIHRoaXMucHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlX2hhc2hcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdFxuICAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGNvbnRpbnVhdGlvblxuICAgICogQHJldHVybnMge1Byb21pc2U8QWNjb3VudHNMaXN0Pn1cbiAgICAqL1xuICAgIGdldEFjY291bnRzQnlDb2RlSGFzaChjb2RlX2hhc2gsIGxpbWl0LCBjb250aW51YXRpb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGNvZGVfaGFzaCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHZhciBwdHIxID0gaXNMaWtlTm9uZShjb250aW51YXRpb24pID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKGNvbnRpbnVhdGlvbiwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICAgICAgdmFyIGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnRyYW5zcG9ydF9nZXRBY2NvdW50c0J5Q29kZUhhc2gocmV0cHRyLCB0aGlzLnB0ciwgcHRyMCwgbGVuMCwgbGltaXQsIHB0cjEsIGxlbjEpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBjb250aW51YXRpb25cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdFxuICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25zTGlzdD59XG4gICAgKi9cbiAgICBnZXRUcmFuc2FjdGlvbnMoYWRkcmVzcywgY29udGludWF0aW9uLCBsaW1pdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYWRkcmVzcywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHZhciBwdHIxID0gaXNMaWtlTm9uZShjb250aW51YXRpb24pID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKGNvbnRpbnVhdGlvbiwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICAgICAgdmFyIGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnRyYW5zcG9ydF9nZXRUcmFuc2FjdGlvbnMocmV0cHRyLCB0aGlzLnB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgbGltaXQpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGhhc2hcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uIHwgdW5kZWZpbmVkPn1cbiAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9uKGhhc2gpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGhhc2gsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnRyYW5zcG9ydF9nZXRUcmFuc2FjdGlvbihyZXRwdHIsIHRoaXMucHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlX2hhc2hcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uIHwgdW5kZWZpbmVkPn1cbiAgICAqL1xuICAgIGdldERzdFRyYW5zYWN0aW9uKG1lc3NhZ2VfaGFzaCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAobWVzc2FnZV9oYXNoLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS50cmFuc3BvcnRfZ2V0RHN0VHJhbnNhY3Rpb24ocmV0cHRyLCB0aGlzLnB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiovXG5leHBvcnQgY2xhc3MgVW5zaWduZWRNZXNzYWdlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVW5zaWduZWRNZXNzYWdlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5wdHIgPSBwdHI7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMucHRyO1xuICAgICAgICB0aGlzLnB0ciA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Vuc2lnbmVkbWVzc2FnZV9mcmVlKHB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtDbG9ja1dpdGhPZmZzZXR9IGNsb2NrXG4gICAgKi9cbiAgICByZWZyZXNoVGltZW91dChjbG9jaykge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoY2xvY2ssIENsb2NrV2l0aE9mZnNldCk7XG4gICAgICAgIHdhc20udW5zaWduZWRtZXNzYWdlX3JlZnJlc2hUaW1lb3V0KHRoaXMucHRyLCBjbG9jay5wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBleHBpcmVBdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS51bnNpZ25lZG1lc3NhZ2VfZXhwaXJlQXQodGhpcy5wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgKi9cbiAgICBnZXQgaGFzaCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS51bnNpZ25lZG1lc3NhZ2VfaGFzaChyZXRwdHIsIHRoaXMucHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyMCwgcjEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZVxuICAgICogQHJldHVybnMge1NpZ25lZE1lc3NhZ2V9XG4gICAgKi9cbiAgICBzaWduKHNpZ25hdHVyZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoc2lnbmF0dXJlLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS51bnNpZ25lZG1lc3NhZ2Vfc2lnbihyZXRwdHIsIHRoaXMucHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtTaWduZWRNZXNzYWdlfVxuICAgICovXG4gICAgc2lnbkZha2UoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udW5zaWduZWRtZXNzYWdlX3NpZ25GYWtlKHJldHB0ciwgdGhpcy5wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBsb2FkKG1vZHVsZSwgaW1wb3J0cykge1xuICAgIGlmICh0eXBlb2YgUmVzcG9uc2UgPT09ICdmdW5jdGlvbicgJiYgbW9kdWxlIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcobW9kdWxlLCBpbXBvcnRzKTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChtb2R1bGUuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpICE9ICdhcHBsaWNhdGlvbi93YXNtJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmdgIGZhaWxlZCBiZWNhdXNlIHlvdXIgc2VydmVyIGRvZXMgbm90IHNlcnZlIHdhc20gd2l0aCBgYXBwbGljYXRpb24vd2FzbWAgTUlNRSB0eXBlLiBGYWxsaW5nIGJhY2sgdG8gYFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlYCB3aGljaCBpcyBzbG93ZXIuIE9yaWdpbmFsIGVycm9yOlxcblwiLCBlKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCBtb2R1bGUuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJ5dGVzLCBpbXBvcnRzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUobW9kdWxlLCBpbXBvcnRzKTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5JbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5zdGFuY2UsIG1vZHVsZSB9O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEltcG9ydHMoKSB7XG4gICAgY29uc3QgaW1wb3J0cyA9IHt9O1xuICAgIGltcG9ydHMud2JnID0ge307XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9zdHJpbmdfbmV3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19sZW5ndGhfNmUzYmJlN2M4YmQ0ZGJkOCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5faXNfdW5kZWZpbmVkID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fbnVtYmVyX2dldCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2Yob2JqKSA9PT0gJ251bWJlcicgPyBvYmogOiB1bmRlZmluZWQ7XG4gICAgICAgIGdldEZsb2F0NjRNZW1vcnkwKClbYXJnMCAvIDggKyAxXSA9IGlzTGlrZU5vbmUocmV0KSA/IDAgOiByZXQ7XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMF0gPSAhaXNMaWtlTm9uZShyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc19udWxsID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkgPT09IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX3N0cmluZ19nZXQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKG9iaikgPT09ICdzdHJpbmcnID8gb2JqIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUocmV0KSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChyZXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gcHRyMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5faXNfb2JqZWN0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCB2YWwgPSBnZXRPYmplY3QoYXJnMCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2lzX3N0cmluZyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKGdldE9iamVjdChhcmcwKSkgPT09ICdzdHJpbmcnO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIHRha2VPYmplY3QoYXJnMCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX251bWJlcl9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGFyZzA7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ub3dfNTg4ODY2ODJiN2U3OTBkNyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzhkMmFmMDBiYzFlMzI5ZWUgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBFcnJvcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzBiOWJmZGQ5NzU4MzI4NGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IE9iamVjdCgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2VuZF81NWM1NzM1MzA4NjEwZmMwID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuc2VuZChnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMiksIEdxbFF1ZXJ5Ll9fd3JhcChhcmczKSwgYXJnNCAhPT0gMCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZW5kX2M0ZmU1ZWY1ZjQ4NTFiNWEgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5zZW5kKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSwgSnJwY1F1ZXJ5Ll9fd3JhcChhcmczKSwgYXJnNCAhPT0gMCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfMWQ5YTkyMGM2YmZjNDRhOCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3B1c2hfNzQwZTRiMjg2NzAyZDk2NCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnB1c2goZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dlbmVyaWNjb250cmFjdF9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEdlbmVyaWNDb250cmFjdC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19vbk1lc3NhZ2VTZW50X2ZjMmRlZDNiODE1MzUwN2EgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbk1lc3NhZ2VTZW50KHRha2VPYmplY3QoYXJnMSksIHRha2VPYmplY3QoYXJnMikpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfb25NZXNzYWdlRXhwaXJlZF9mYmRiNGIxYThiYjBlN2M1ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub25NZXNzYWdlRXhwaXJlZCh0YWtlT2JqZWN0KGFyZzEpKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX29uU3RhdGVDaGFuZ2VkX2U2OTZhN2I5ODdkYmE5ZWEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vblN0YXRlQ2hhbmdlZCh0YWtlT2JqZWN0KGFyZzEpKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX29uVHJhbnNhY3Rpb25zRm91bmRfMzNiN2I1NmM3NzBlMmU4OCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9uVHJhbnNhY3Rpb25zRm91bmQodGFrZU9iamVjdChhcmcxKSwgdGFrZU9iamVjdChhcmcyKSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19rZXlzXzA3MDIyOTRhZmFlYjYwNDQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE9iamVjdC5rZXlzKGdldE9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRfNTcyNDVjYzdkN2M3NjE5ZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApW2FyZzEgPj4+IDBdO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9ib29sZWFuX2dldCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgdiA9IGdldE9iamVjdChhcmcwKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKHYpID09PSAnYm9vbGVhbicgPyAodiA/IDEgOiAwKSA6IDI7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pc0xvY2FsXzBjYzBmNjI1OGM4Y2Y2Y2EgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5pc0xvY2FsKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfOTk2MmY5MzkyMTlmMTgyMCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBzdGF0ZTAgPSB7YTogYXJnMCwgYjogYXJnMX07XG4gICAgICAgICAgICB2YXIgY2IwID0gKGFyZzAsIGFyZzEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gc3RhdGUwLmE7XG4gICAgICAgICAgICAgICAgc3RhdGUwLmEgPSAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX3diZ19hZGFwdGVyXzE2MyhhLCBzdGF0ZTAuYiwgYXJnMCwgYXJnMSk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUwLmEgPSBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZShjYjApO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHN0YXRlMC5hID0gc3RhdGUwLmIgPSAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdGF0aWNfYWNjZXNzb3JfTk9ERV9NT0RVTEVfY2Y2NDAxY2MxMDkxMjc5ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBtb2R1bGU7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX29iamVjdF9jbG9uZV9yZWYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Byb2Nlc3NfMGNjMmFkYTg1MjRkNmY4MyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnByb2Nlc3M7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ192ZXJzaW9uc19jMTFhY2NlYWIyN2E2Yzg3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudmVyc2lvbnM7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ub2RlXzdmZjFjZTQ5Y2FmMjM4MTUgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5ub2RlO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVxdWlyZV9hNzQ2ZTc5YjMyMmI5MzM2ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkucmVxdWlyZShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jcnlwdG9fMjAzNmJlZDdjNDRjMjVlNyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNyeXB0bztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX21zQ3J5cHRvX2EyMWZjODhjYWYxZWNkYzggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5tc0NyeXB0bztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld3dpdGhsZW5ndGhfZjU5MzM4NTVlNGY0OGExOSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoYXJnMCA+Pj4gMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRfNzY1MjAxNTQ0YTJiNjg2OSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gUmVmbGVjdC5nZXQoZ2V0T2JqZWN0KGFyZzApLCBnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZWxmXzZkNDc5NTA2ZjcyYzZhNzEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gc2VsZi5zZWxmO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ193aW5kb3dfZjI1NTdjYzc4NDkwYWNlYiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3aW5kb3cud2luZG93O1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nbG9iYWxUaGlzXzdmMjA2YmRhNjI4ZDUyODYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2xvYmFsVGhpcy5nbG9iYWxUaGlzO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nbG9iYWxfYmE3NWM1MGQxY2YzODRmNCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXQgPSBnbG9iYWwuZ2xvYmFsO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdub2FyZ3NfYjViMDYzZmM2YzJmMDM3NiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEZ1bmN0aW9uKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jYWxsXzk3YWU5ZDg2NDVkYzM4OGIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5jYWxsKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2lzQXJyYXlfMjdjNDZjNjdmNDk4ZTE1ZCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gQXJyYXkuaXNBcnJheShnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY2FsbF8xNjhkYTg4Nzc5ZTM1ZjYxID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuY2FsbChnZXRPYmplY3QoYXJnMSksIGdldE9iamVjdChhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF9iZjNmODliOTJkNWEzNGJmID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBSZWZsZWN0LnNldChnZXRPYmplY3QoYXJnMCksIGdldE9iamVjdChhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmFuZG9tRmlsbFN5bmNfMDY1YWZmZmRlMDFkYWE2NiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnJhbmRvbUZpbGxTeW5jKGdldEFycmF5VThGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdWJhcnJheV81OGFkNGVmYmI1YmNiODg2ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuc3ViYXJyYXkoYXJnMSA+Pj4gMCwgYXJnMiA+Pj4gMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRSYW5kb21WYWx1ZXNfYjk5ZWVjNDI0NGE0NzViYiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmdldFJhbmRvbVZhbHVlcyhnZXRPYmplY3QoYXJnMSkpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19sZW5ndGhfOWUxYWUxOTAwY2IwZmJkNSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fbWVtb3J5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubWVtb3J5O1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYnVmZmVyXzNmM2Q3NjRkNDc0N2Q1NjQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5idWZmZXI7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfOGMzZjAwNTIyNzJhNDU3YSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF84M2RiOTY5MGY5MzUzZTc5ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuc2V0KGdldE9iamVjdChhcmcxKSwgYXJnMiA+Pj4gMCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2RlYnVnX3N0cmluZyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZGVidWdTdHJpbmcoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDFdID0gbGVuMDtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAwXSA9IHB0cjA7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX3Rocm93ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3RoZW5fMTFmN2E1NGQ2N2I0YmZhZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnRoZW4oZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2JfZHJvcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3Qgb2JqID0gdGFrZU9iamVjdChhcmcwKS5vcmlnaW5hbDtcbiAgICAgICAgaWYgKG9iai5jbnQtLSA9PSAxKSB7XG4gICAgICAgICAgICBvYmouYSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Jlc29sdmVfOTlmZTE3OTY0ZjMxZmZjMCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gUHJvbWlzZS5yZXNvbHZlKGdldE9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nsb3N1cmVfd3JhcHBlcjY0MzcgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG1ha2VNdXRDbG9zdXJlKGFyZzAsIGFyZzEsIDkyNSwgX193YmdfYWRhcHRlcl8zMik7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcblxuICAgIHJldHVybiBpbXBvcnRzO1xufVxuXG5mdW5jdGlvbiBpbml0TWVtb3J5KGltcG9ydHMsIG1heWJlX21lbW9yeSkge1xuXG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplSW5pdChpbnN0YW5jZSwgbW9kdWxlKSB7XG4gICAgd2FzbSA9IGluc3RhbmNlLmV4cG9ydHM7XG4gICAgaW5pdC5fX3diaW5kZ2VuX3dhc21fbW9kdWxlID0gbW9kdWxlO1xuICAgIGNhY2hlZEZsb2F0NjRNZW1vcnkwID0gbmV3IEZsb2F0NjRBcnJheSgpO1xuICAgIGNhY2hlZEludDMyTWVtb3J5MCA9IG5ldyBJbnQzMkFycmF5KCk7XG4gICAgY2FjaGVkVWludDhNZW1vcnkwID0gbmV3IFVpbnQ4QXJyYXkoKTtcblxuXG4gICAgcmV0dXJuIHdhc207XG59XG5cbmZ1bmN0aW9uIGluaXRTeW5jKG1vZHVsZSkge1xuICAgIGNvbnN0IGltcG9ydHMgPSBnZXRJbXBvcnRzKCk7XG5cbiAgICBpbml0TWVtb3J5KGltcG9ydHMpO1xuXG4gICAgaWYgKCEobW9kdWxlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTW9kdWxlKSkge1xuICAgICAgICBtb2R1bGUgPSBuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG1vZHVsZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobW9kdWxlLCBpbXBvcnRzKTtcblxuICAgIHJldHVybiBmaW5hbGl6ZUluaXQoaW5zdGFuY2UsIG1vZHVsZSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGluaXQoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpbnB1dCA9IG5ldyBVUkwoJ25la290b25fd2FzbV9iZy53YXNtJywgaW1wb3J0Lm1ldGEudXJsKTtcbiAgICB9XG4gICAgY29uc3QgaW1wb3J0cyA9IGdldEltcG9ydHMoKTtcblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8ICh0eXBlb2YgUmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHx8ICh0eXBlb2YgVVJMID09PSAnZnVuY3Rpb24nICYmIGlucHV0IGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICBpbnB1dCA9IGZldGNoKGlucHV0KTtcbiAgICB9XG5cbiAgICBpbml0TWVtb3J5KGltcG9ydHMpO1xuXG4gICAgY29uc3QgeyBpbnN0YW5jZSwgbW9kdWxlIH0gPSBhd2FpdCBsb2FkKGF3YWl0IGlucHV0LCBpbXBvcnRzKTtcblxuICAgIHJldHVybiBmaW5hbGl6ZUluaXQoaW5zdGFuY2UsIG1vZHVsZSk7XG59XG5cbmV4cG9ydCB7IGluaXRTeW5jIH1cbmV4cG9ydCBkZWZhdWx0IGluaXQ7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/nekoton-wasm/nekoton_wasm.js\n");

/***/ }),

/***/ "./node_modules/nekoton-wasm/nekoton_wasm_bg.wasm":
/*!********************************************************!*\
  !*** ./node_modules/nekoton-wasm/nekoton_wasm_bg.wasm ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "3610d36b17fcc23a1d17.wasm";

/***/ }),

/***/ "./src/styles/main.scss":
/*!******************************!*\
  !*** ./src/styles/main.scss ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_main_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/sass-loader/dist/cjs.js!./main.scss */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/styles/main.scss\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_main_scss__WEBPACK_IMPORTED_MODULE_1__.default, options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_main_scss__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGVzL21haW4uc2Nzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL3NyYy9zdHlsZXMvbWFpbi5zY3NzPzM3NWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFwaSBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbWFpbi5zY3NzXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/styles/main.scss\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : 0;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/NzQ1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbnZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB2YXIgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKS5jb25jYXQob2JqLmNzcywgXCJ9XCIpIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gIH1cblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRG9tW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRvbVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;