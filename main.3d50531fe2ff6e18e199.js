(()=>{var __webpack_modules__={150:g=>{"use strict";g.exports=JSON.parse('{"testnet":{"router":"0:f30cd23aaae8c304ca74ab83e6dcbe9e8c8f2b8efdddd478ff708a7b45e238cf","gameroot":"0:b888e00251dcf9ff1dd7e3c6a0dcd703fb4cfef914b8bcd862cf77730532f557","codeHash":"e5d55e1ca6348a7da5153bfc86ea5db6a808f37c291ebe8a13170e8a894e102c","endpoint":"https://devnet.evercloud.dev/4b0e77393fba46759305e30cea4aaa95/graphql"},"localnet":{"router":"0:5e1f3f2989356edbf5c0956dafea1e07166dc7d1b9abc05110d4f8957f5a6bcb","gameroot":"0:a1314918b104b346e87345cdeeb1907514237e1c289bcfb82429b7aea5f796ec","codeHash":"108dae863892542898ecea0e32999ca2b60c68e133d676fce69b713a7ea6968b","endpoint":"http://localhost/graphql"}}')},579:g=>{"use strict";g.exports=JSON.parse('{"ABI version":2,"version":"2.2","header":["pubkey","time","expire"],"functions":[{"name":"constructor","inputs":[{"name":"router","type":"address"},{"name":"ownerPubkey","type":"uint256"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"color","type":"tuple"},{"name":"energy","type":"uint128"}],"outputs":[]},{"name":"getRouter","inputs":[],"outputs":[{"name":"router","type":"address"}]},{"name":"getDetails","inputs":[],"outputs":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"color","type":"tuple"},{"name":"level","type":"uint128"},{"name":"energy","type":"uint128"},{"name":"energySec","type":"uint128"},{"name":"energyMax","type":"uint128"},{"name":"lastCalcTime","type":"uint128"},{"name":"owner","type":"uint256"}]},{"name":"calculateEnergy","inputs":[],"outputs":[{"name":"energy","type":"uint128"}]},{"name":"markCell","inputs":[{"name":"sendGasTo","type":"address"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"targetCoord","type":"tuple"},{"name":"energy","type":"uint128"}],"outputs":[]},{"name":"helpCell","inputs":[{"name":"sendGasTo","type":"address"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"targetCoord","type":"tuple"},{"name":"energy","type":"uint128"}],"outputs":[]},{"name":"_helpCell","inputs":[{"name":"sendGasTo","type":"address"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"color","type":"tuple"},{"name":"energy","type":"uint128"}],"outputs":[]},{"name":"attkCell","inputs":[{"name":"sendGasTo","type":"address"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"targetCoord","type":"tuple"},{"name":"energy","type":"uint128"}],"outputs":[]},{"name":"_attkCell","inputs":[{"name":"sendGasTo","type":"address"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"color","type":"tuple"},{"name":"energy","type":"uint128"}],"outputs":[]},{"name":"upgradeCell","inputs":[{"name":"sendGasTo","type":"address"}],"outputs":[]},{"name":"_resolveCell","inputs":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"}],"outputs":[{"name":"cellAddress","type":"address"}]},{"name":"getOwner","inputs":[],"outputs":[{"name":"pubkey","type":"uint256"}]},{"name":"owner","inputs":[{"name":"answerId","type":"uint32"}],"outputs":[{"name":"pubkey","type":"uint256"}]},{"name":"transferOwnership","inputs":[{"name":"newOwner","type":"uint256"}],"outputs":[]}],"data":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"key":1,"name":"_coord","type":"tuple"}],"events":[{"name":"OwnershipTransferred","inputs":[{"name":"oldOwner","type":"uint256"},{"name":"newOwner","type":"uint256"}],"outputs":[]}],"fields":[{"name":"_pubkey","type":"uint256"},{"name":"_timestamp","type":"uint64"},{"name":"_constructorFlag","type":"bool"},{"name":"_owner","type":"uint256"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"_coord","type":"tuple"},{"name":"_costPerLevel","type":"uint128[]"},{"name":"_energyPerLevel","type":"uint128[]"},{"name":"_energyPerLevelMax","type":"uint128[]"},{"name":"_router","type":"address"},{"name":"_level","type":"uint128"},{"name":"_energy","type":"uint128"},{"name":"_lastCalcTime","type":"uint128"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"_color","type":"tuple"}]}')},750:g=>{"use strict";g.exports=JSON.parse('{"ABI version":2,"version":"2.2","header":["pubkey","time","expire"],"functions":[{"name":"constructor","inputs":[{"name":"root","type":"address"},{"name":"codeCell","type":"cell"},{"name":"radius","type":"uint64"},{"name":"speed","type":"uint64"},{"name":"name","type":"string"}],"outputs":[]},{"name":"getDetails","inputs":[],"outputs":[{"name":"nonce","type":"uint32"},{"name":"radius","type":"uint64"},{"name":"speed","type":"uint64"},{"name":"name","type":"string"},{"name":"owner","type":"address"}]},{"name":"getAddressCells","inputs":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coords","type":"tuple[]"}],"outputs":[{"name":"addreses","type":"address[]"}]},{"name":"newGame","inputs":[{"name":"sendGasTo","type":"address"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"baseCoord","type":"tuple"}],"outputs":[]},{"name":"_newCell","inputs":[{"name":"sendGasTo","type":"address"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"baseCoord","type":"tuple"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"targetCoord","type":"tuple"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"color","type":"tuple"},{"name":"energy","type":"uint128"}],"outputs":[]},{"name":"_resolveCell","inputs":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"}],"outputs":[{"name":"cellAddress","type":"address"}]},{"name":"owner","inputs":[],"outputs":[{"name":"owner","type":"address"}]},{"name":"transferOwnership","inputs":[{"name":"newOwner","type":"address"}],"outputs":[]}],"data":[{"key":1,"name":"_nonce","type":"uint32"}],"events":[{"name":"CellCreated","inputs":[{"name":"owner","type":"uint256"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"}],"outputs":[]},{"name":"OwnershipTransferred","inputs":[{"name":"oldOwner","type":"address"},{"name":"newOwner","type":"address"}],"outputs":[]}],"fields":[{"name":"_pubkey","type":"uint256"},{"name":"_timestamp","type":"uint64"},{"name":"_constructorFlag","type":"bool"},{"name":"_owner","type":"address"},{"name":"_nonce","type":"uint32"},{"name":"_codeCell","type":"cell"},{"name":"_radius","type":"uint64"},{"name":"_speed","type":"uint64"},{"name":"_name","type":"string"}]}')},68:(__unused_webpack_module,exports)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Mutex = exports.Semaphore = void 0;\nfunction ensureCallable(fn) {\n    if (typeof fn !== 'function')\n        throw new TypeError(fn + \" is not a function\");\n    return fn;\n}\nfunction byObserver(Observer) {\n    const node = document.createTextNode('');\n    let queue, currentQueue, bit = 0, i = 0;\n    new Observer(function () {\n        let callback;\n        if (!queue) {\n            if (!currentQueue)\n                return;\n            queue = currentQueue;\n        }\n        else if (currentQueue) {\n            queue = currentQueue.slice(i).concat(queue);\n        }\n        currentQueue = queue;\n        queue = null;\n        i = 0;\n        if (typeof currentQueue === 'function') {\n            callback = currentQueue;\n            currentQueue = null;\n            callback();\n            return;\n        }\n        node.data = (bit = ++bit % 2); // Invoke other batch, to handle leftover callbacks in case of crash\n        while (i < currentQueue.length) {\n            callback = currentQueue[i];\n            i++;\n            if (i === currentQueue.length)\n                currentQueue = null;\n            callback();\n        }\n    }).observe(node, { characterData: true });\n    return function (fn) {\n        ensureCallable(fn);\n        if (queue) {\n            if (typeof queue === 'function')\n                queue = [queue, fn];\n            else\n                queue.push(fn);\n            return;\n        }\n        queue = fn;\n        node.data = (bit = ++bit % 2);\n    };\n}\nconst nextTick = (function () {\n    // queueMicrotask\n    if (typeof queueMicrotask === \"function\") {\n        return function (cb) {\n            queueMicrotask(ensureCallable(cb));\n        };\n    }\n    // MutationObserver\n    if ((typeof document === 'object') && document) {\n        if (typeof MutationObserver === 'function')\n            return byObserver(MutationObserver);\n        if (typeof window.WebKitMutationObserver === 'function')\n            return byObserver(window.WebKitMutationObserver);\n    }\n    // W3C Draft\n    // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html\n    if (typeof setImmediate === 'function') {\n        return function (cb) {\n            setImmediate(ensureCallable(cb));\n        };\n    }\n    // Wide available standard\n    if ((typeof setTimeout === 'function') || (typeof setTimeout === 'object')) {\n        return function (cb) {\n            setTimeout(ensureCallable(cb), 0);\n        };\n    }\n    throw new Error('No `nextTick` implementation found');\n}());\nclass Semaphore {\n    constructor(count) {\n        this.tasks = [];\n        this.count = count;\n    }\n    sched() {\n        if (this.count > 0 && this.tasks.length > 0) {\n            this.count--;\n            let next = this.tasks.shift();\n            if (next === undefined) {\n                throw \"Unexpected undefined value in tasks list\";\n            }\n            next();\n        }\n    }\n    acquire() {\n        return new Promise((res, _rej) => {\n            const task = () => {\n                let released = false;\n                res(() => {\n                    if (!released) {\n                        released = true;\n                        this.count++;\n                        this.sched();\n                    }\n                });\n            };\n            this.tasks.push(task);\n            nextTick(this.sched.bind(this));\n        });\n    }\n    use(f) {\n        return this.acquire()\n            .then(release => {\n            return f()\n                .then((res) => {\n                release();\n                return res;\n            })\n                .catch((err) => {\n                release();\n                throw err;\n            });\n        });\n    }\n}\nexports.Semaphore = Semaphore;\nclass Mutex extends Semaphore {\n    constructor() {\n        super(1);\n    }\n}\nexports.Mutex = Mutex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9ub2RlX21vZHVsZXMvQGJyb3h1cy9hd2FpdC1zZW1hcGhvcmUvZGlzdC9pbmRleC5qcz83YWNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NdXRleCA9IGV4cG9ydHMuU2VtYXBob3JlID0gdm9pZCAwO1xuZnVuY3Rpb24gZW5zdXJlQ2FsbGFibGUoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgcmV0dXJuIGZuO1xufVxuZnVuY3Rpb24gYnlPYnNlcnZlcihPYnNlcnZlcikge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbGV0IHF1ZXVlLCBjdXJyZW50UXVldWUsIGJpdCA9IDAsIGkgPSAwO1xuICAgIG5ldyBPYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCBjYWxsYmFjaztcbiAgICAgICAgaWYgKCFxdWV1ZSkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50UXVldWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5zbGljZShpKS5jb25jYXQocXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IG51bGw7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRRdWV1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjdXJyZW50UXVldWU7XG4gICAgICAgICAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmRhdGEgPSAoYml0ID0gKytiaXQgJSAyKTsgLy8gSW52b2tlIG90aGVyIGJhdGNoLCB0byBoYW5kbGUgbGVmdG92ZXIgY2FsbGJhY2tzIGluIGNhc2Ugb2YgY3Jhc2hcbiAgICAgICAgd2hpbGUgKGkgPCBjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGN1cnJlbnRRdWV1ZVtpXTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGlmIChpID09PSBjdXJyZW50UXVldWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfSkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICBlbnN1cmVDYWxsYWJsZShmbik7XG4gICAgICAgIGlmIChxdWV1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBxdWV1ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IFtxdWV1ZSwgZm5dO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlID0gZm47XG4gICAgICAgIG5vZGUuZGF0YSA9IChiaXQgPSArK2JpdCAlIDIpO1xuICAgIH07XG59XG5jb25zdCBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgLy8gcXVldWVNaWNyb3Rhc2tcbiAgICBpZiAodHlwZW9mIHF1ZXVlTWljcm90YXNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soZW5zdXJlQ2FsbGFibGUoY2IpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTXV0YXRpb25PYnNlcnZlclxuICAgIGlmICgodHlwZW9mIGRvY3VtZW50ID09PSAnb2JqZWN0JykgJiYgZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuIGJ5T2JzZXJ2ZXIoTXV0YXRpb25PYnNlcnZlcik7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm4gYnlPYnNlcnZlcih3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlcik7XG4gICAgfVxuICAgIC8vIFczQyBEcmFmdFxuICAgIC8vIGh0dHA6Ly9kdmNzLnczLm9yZy9oZy93ZWJwZXJmL3Jhdy1maWxlL3RpcC9zcGVjcy9zZXRJbW1lZGlhdGUvT3ZlcnZpZXcuaHRtbFxuICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZShlbnN1cmVDYWxsYWJsZShjYikpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBXaWRlIGF2YWlsYWJsZSBzdGFuZGFyZFxuICAgIGlmICgodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHx8ICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZW5zdXJlQ2FsbGFibGUoY2IpLCAwKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBgbmV4dFRpY2tgIGltcGxlbWVudGF0aW9uIGZvdW5kJyk7XG59KCkpO1xuY2xhc3MgU2VtYXBob3JlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb3VudCkge1xuICAgICAgICB0aGlzLnRhc2tzID0gW107XG4gICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICB9XG4gICAgc2NoZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvdW50ID4gMCAmJiB0aGlzLnRhc2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQtLTtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy50YXNrcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKG5leHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiVW5leHBlY3RlZCB1bmRlZmluZWQgdmFsdWUgaW4gdGFza3MgbGlzdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFjcXVpcmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCBfcmVqKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByZWxlYXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlcygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVsZWFzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudGFza3MucHVzaCh0YXNrKTtcbiAgICAgICAgICAgIG5leHRUaWNrKHRoaXMuc2NoZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1c2UoZikge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3F1aXJlKClcbiAgICAgICAgICAgIC50aGVuKHJlbGVhc2UgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGYoKVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VtYXBob3JlID0gU2VtYXBob3JlO1xuY2xhc3MgTXV0ZXggZXh0ZW5kcyBTZW1hcGhvcmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigxKTtcbiAgICB9XG59XG5leHBvcnRzLk11dGV4ID0gTXV0ZXg7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///68\n")},534:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.DefaultGiverContract = exports.Account = exports.AccountType = exports.AccountError = void 0;\nconst core_1 = __webpack_require__(206);\nvar ERR_CODES;\n(function (ERR_CODES) {\n    ERR_CODES[ERR_CODES["MISSING_TVC"] = 0] = "MISSING_TVC";\n    ERR_CODES[ERR_CODES["ACC_NOT_EXISTS"] = 1] = "ACC_NOT_EXISTS";\n})(ERR_CODES || (ERR_CODES = {}));\nclass AccountError extends Error {\n    constructor(opt) {\n        super(opt.message);\n        this.code = opt.code;\n    }\n    static missingTVC() {\n        return new AccountError({\n            code: ERR_CODES.MISSING_TVC,\n            message: "Can\'t calculate deploy params: missing required TVC.",\n        });\n    }\n    static missingBOC() {\n        return new AccountError({\n            code: ERR_CODES.ACC_NOT_EXISTS,\n            message: \'Account has an empty BOC. Possible reason is: account was deleted (has account type "NonExist")\',\n        });\n    }\n}\nexports.AccountError = AccountError;\n/**\n * Current type of the account.\n */\nvar AccountType;\n(function (AccountType) {\n    /**\n     * Account exists in the blockchain but without smart contract.\n     */\n    AccountType[AccountType["uninit"] = 0] = "uninit";\n    /**\n     * Account exists in the blockchain with smart contract.\n     */\n    AccountType[AccountType["active"] = 1] = "active";\n    /**\n     * Account exists in the blockchain but it had frozen.\n     */\n    AccountType[AccountType["frozen"] = 2] = "frozen";\n    /**\n     * Account is missing in the blockchain.\n     */\n    AccountType[AccountType["nonExist"] = 3] = "nonExist";\n})(AccountType = exports.AccountType || (exports.AccountType = {}));\n/**\n * Object to deal with specified account using specified signer (owner).\n *\n * Account instance can be bound to account address\n * or account deploy parameters that uniquely identifies\n * account address.\n */\nclass Account {\n    /**\n     * Constructs account instance.\n     *\n     * @param contract Contract package containing abi and optional tvc data.\n     * @param options Account instance options.\n     */\n    constructor(contract, options) {\n        var _a, _b, _c, _d, _e;\n        this.syncLastTransLt = null;\n        this.cachedBoc = null;\n        this.subscriptions = null;\n        this.contract = contract;\n        this.client = (_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : core_1.TonClient.default;\n        this.abi = (0, core_1.abiContract)(contract.abi);\n        this.signer = (_b = options === null || options === void 0 ? void 0 : options.signer) !== null && _b !== void 0 ? _b : (0, core_1.signerNone)();\n        this.address = (_c = options === null || options === void 0 ? void 0 : options.address) !== null && _c !== void 0 ? _c : null;\n        this.initData = (_d = options === null || options === void 0 ? void 0 : options.initData) !== null && _d !== void 0 ? _d : null;\n        this.useCachedState = (_e = options === null || options === void 0 ? void 0 : options.useCachedState) !== null && _e !== void 0 ? _e : false;\n    }\n    /**\n     * Returns the giver instance assigned for specified client instance.\n     * Or `null` if no giver is associated with this client yet.\n     *\n     * @param client Client instance looking for.\n     */\n    static findGiverForClient(client) {\n        var _a;\n        return (_a = this.giversByClient.find(x => x.client === client)) === null || _a === void 0 ? void 0 : _a.giver;\n    }\n    /**\n     * Assigns specified giver as a default for specified client instance.\n     * If client already has default giver it will be reassigned.\n     *\n     * @param client Client instance.\n     * @param giver New giver instance or `null` if the default giver for\n     * this client must be removed.\n     */\n    static setGiverForClient(client, giver) {\n        const i = this.giversByClient.findIndex(x => x.client === client);\n        if (i >= 0) {\n            if (giver) {\n                this.giversByClient[i].giver = giver;\n            }\n            else {\n                this.giversByClient.splice(i, 1);\n            }\n        }\n        else if (giver) {\n            this.giversByClient.push({\n                client,\n                giver,\n            });\n        }\n    }\n    static createGiver(client) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const giverKeys = yield getDefaultGiverKeys(client);\n            const giverAddress = yield getDefaultGiverAddress(client, giverKeys);\n            const giver = new Account(exports.DefaultGiverContract, {\n                client,\n                address: giverAddress,\n                signer: (0, core_1.signerKeys)(giverKeys),\n            });\n            return {\n                address: giverAddress,\n                sendTo: (address, value) => __awaiter(this, void 0, void 0, function* () {\n                    yield giver.run("sendTransaction", {\n                        dest: address,\n                        value,\n                        bounce: false,\n                    });\n                }),\n            };\n        });\n    }\n    /**\n     * Returns the default giver for specified client instance.\n     * If no giver assigned yet then new one will be created,\n     * assigned and returned.\n     *\n     * @param client Client instance.\n     */\n    static getGiverForClient(client) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const existing = this.findGiverForClient(client);\n            if (existing) {\n                return existing;\n            }\n            const giver = yield this.createGiver(client);\n            this.giversByClient.push({\n                client,\n                giver,\n            });\n            return giver;\n        });\n    }\n    /**\n     * Returns address of the account.\n     *\n     * Uses address specified in constructor options\n     * or calculates it from deploy data provided in constructor.\n     */\n    getAddress() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let address = this.address;\n            if (address === null) {\n                const deployParams = this.getParamsOfDeployMessage({\n                    initFunctionName: null,\n                });\n                address = (yield this.client.abi.encode_message(deployParams)).address;\n                this.address = address;\n            }\n            return address;\n        });\n    }\n    /**\n     * Returns params for encoding deploy message.\n     * @param options Message encoding options.\n     */\n    getParamsOfDeployMessage(options) {\n        var _a;\n        if (!this.contract.tvc) {\n            throw AccountError.missingTVC();\n        }\n        const params = {\n            abi: this.abi,\n            signer: this.signer,\n            deploy_set: {\n                tvc: this.contract.tvc,\n            },\n        };\n        if (this.initData) {\n            params.deploy_set.initial_data = this.initData;\n        }\n        if ((options === null || options === void 0 ? void 0 : options.initFunctionName) !== null) {\n            params.call_set = {\n                function_name: (_a = options === null || options === void 0 ? void 0 : options.initFunctionName) !== null && _a !== void 0 ? _a : "constructor",\n            };\n            if ((options === null || options === void 0 ? void 0 : options.initInput) !== undefined) {\n                params.call_set.input = options.initInput;\n            }\n        }\n        return params;\n    }\n    /**\n     * Calculates detailed deploy fees.\n     */\n    calcDeployFees(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const deployParams = yield this.getParamsOfDeployMessage(options);\n            const message = yield this.client.abi.encode_message(deployParams);\n            const result = yield this.client.tvm.run_executor({\n                account: (0, core_1.accountForExecutorUninit)(),\n                abi: this.abi,\n                message: message.message,\n            });\n            return result.fees;\n        });\n    }\n    /**\n     * Deploys account into network\n     * @param options\n     */\n    deploy(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const deployParams = this.getParamsOfDeployMessage(options);\n            const useGiver = options === null || options === void 0 ? void 0 : options.useGiver;\n            const giver = useGiver === true ? (yield Account.getGiverForClient(this.client)) : useGiver;\n            this.address = (yield this.client.abi.encode_message(deployParams)).address;\n            if (giver) {\n                yield giver.sendTo(this.address, 10000000000);\n            }\n            const result = yield this.client.processing.process_message({\n                message_encode_params: deployParams,\n                send_events: false,\n            });\n            this.needSyncWithTransaction(result.transaction);\n            return result;\n        });\n    }\n    /**\n     * Emulate deploy\n     * @param options\n     */\n    deployLocal(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const deployParams = this.getParamsOfDeployMessage(options);\n            const { address, message, } = yield this.client.abi.encode_message(deployParams);\n            const result = yield this.client.tvm.run_executor({\n                account: (0, core_1.accountForExecutorUninit)(),\n                abi: this.abi,\n                message,\n                return_updated_account: true,\n            });\n            this.address = address;\n            this.cachedBoc = result.account;\n            return result;\n        });\n    }\n    /**\n     * Calculates detailed fees for specified run parameters.\n     *\n     * @param functionName Name of the function according to the ABI.\n     * @param input Object with function parameters (function parameters).\n     */\n    calcRunFees(functionName, input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const message = yield this.client.abi.encode_message({\n                address: yield this.getAddress(),\n                abi: this.abi,\n                signer: this.signer,\n                call_set: {\n                    function_name: functionName,\n                    input,\n                },\n            });\n            let result;\n            result = yield this.client.tvm.run_executor({\n                account: (0, core_1.accountForExecutorAccount)(yield this.boc()),\n                abi: this.abi,\n                message: message.message,\n            });\n            return result.fees;\n        });\n    }\n    /**\n     * Process message on network and returns detailed information\n     * about results including produced transaction and messages.\n     *\n     * @param functionName Name of the function according to the ABI.\n     * @param input Object with function parameters (function parameters).\n     * @param options Run options.\n     */\n    run(functionName, input, options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = (yield this.client.processing.process_message({\n                message_encode_params: {\n                    address: yield this.getAddress(),\n                    abi: this.abi,\n                    signer: (_a = options === null || options === void 0 ? void 0 : options.signer) !== null && _a !== void 0 ? _a : this.signer,\n                    call_set: {\n                        function_name: functionName,\n                        input,\n                    },\n                },\n                send_events: false,\n            }));\n            this.needSyncWithTransaction(result.transaction);\n            return result;\n        });\n    }\n    /**\n     * Evaluates message on local TVM and returns decoded output.\n     *\n     * @param functionName Name of the function according to the ABI.\n     * @param input Object with function parameters (function input).\n     * @param options Run options.\n     */\n    runLocal(functionName, input, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const message = yield this.client.abi.encode_message({\n                address: yield this.getAddress(),\n                abi: this.abi,\n                signer: this.signer,\n                call_set: {\n                    function_name: functionName,\n                    input,\n                },\n            });\n            let result;\n            if (options === null || options === void 0 ? void 0 : options.performAllChecks) {\n                result = yield this.client.tvm.run_executor({\n                    account: (0, core_1.accountForExecutorAccount)(yield this.boc()),\n                    abi: this.abi,\n                    message: message.message,\n                    return_updated_account: true,\n                });\n            }\n            else {\n                result = (yield this.client.tvm.run_tvm({\n                    account: yield this.boc(),\n                    abi: this.abi,\n                    message: message.message,\n                    return_updated_account: true,\n                }));\n            }\n            if (result.account) {\n                this.cachedBoc = result.account;\n            }\n            return result;\n        });\n    }\n    needSyncWithTransaction(transaction) {\n        if (!transaction.aborted && transaction.lt) {\n            this.syncLastTransLt = transaction.lt;\n            this.cachedBoc = null;\n        }\n    }\n    /**\n     * Returns raw data of the account in form of BOC.\n     * Fetches boc data from network and caches it in private field.\n     * `runLocal` updates cached boc.\n     * `run` drops cached boc.\n     * This function syncs fetching boc with last `run` or `deploy`\n     * so fetched boc\n     */\n    boc() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.cachedBoc && this.useCachedState) {\n                return this.cachedBoc;\n            }\n            const address = yield this.getAddress();\n            const net = this.client.net;\n            if (this.syncLastTransLt) {\n                const accounts = yield net.query_collection({\n                    collection: "accounts",\n                    filter: {\n                        id: { eq: address },\n                        last_trans_lt: { ge: this.syncLastTransLt },\n                    },\n                    result: "boc",\n                });\n                if (accounts.result.length > 0) {\n                    const boc = accounts.result[0].boc;\n                    this.syncLastTransLt = null;\n                    if (boc) {\n                        this.cachedBoc = boc;\n                        return boc;\n                    }\n                    throw AccountError.missingBOC();\n                }\n            }\n            try {\n                const boc = (\n                // Returns BOC or null if account was found in DB, but has "NotExists" status\n                // Throws if:\n                //  - account NOT found in DB (err.code 603) \n                //  - some network error occured\n                yield net.wait_for_collection({\n                    collection: "accounts",\n                    filter: { id: { eq: this.address } },\n                    result: "boc",\n                    timeout: 1000,\n                })).result.boc;\n                if (boc) {\n                    this.cachedBoc = boc;\n                    return boc;\n                }\n                throw AccountError.missingBOC();\n            }\n            catch (error) {\n                if (error.code === 603) {\n                    throw AccountError.missingBOC();\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Drops all cached and local data.\n     */\n    refresh() {\n        this.cachedBoc = null;\n    }\n    /**\n     * Returns parsed data of the account.\n     */\n    getAccount() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const boc = yield this.boc();\n                return (yield this.client.boc.parse_account({ boc })).parsed;\n            }\n            catch (err) {\n                if (err.code === ERR_CODES.ACC_NOT_EXISTS) {\n                    return {\n                        acc_type: AccountType.nonExist,\n                    };\n                }\n            }\n        });\n    }\n    subscribeAccount(fields, listener) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.subscribe("accounts", { id: { eq: yield this.getAddress() } }, fields, listener);\n        });\n    }\n    subscribeTransactions(fields, listener) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const address = yield this.getAddress();\n            yield this.subscribe("transactions", {\n                account_addr: { eq: address },\n                status: { eq: 5 },\n            }, fields, listener);\n        });\n    }\n    subscribeMessages(fields, listener) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const address = yield this.getAddress();\n            yield this.subscribe("messages", {\n                status: { eq: 5 },\n                src: { eq: address },\n                OR: {\n                    status: { eq: 5 },\n                    dst: { eq: address },\n                },\n            }, fields, listener);\n        });\n    }\n    decodeMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield core_1.TonClient.default.abi.decode_message({\n                abi: this.abi,\n                message,\n            });\n        });\n    }\n    decodeMessageBody(body, isInternal) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield core_1.TonClient.default.abi.decode_message_body({\n                abi: this.abi,\n                body,\n                is_internal: isInternal,\n            });\n        });\n    }\n    getBalance() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return (yield this.getAccount()).balance;\n        });\n    }\n    subscribe(collection, filter, fields, listener) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const prevSubscription = this.subscriptions && this.subscriptions.get(collection);\n            if (prevSubscription) {\n                (_a = this.subscriptions) === null || _a === void 0 ? void 0 : _a.delete(collection);\n                yield this.client.net.unsubscribe(prevSubscription);\n            }\n            else if (!this.subscriptions) {\n                this.subscriptions = new Map();\n            }\n            const subscription = yield this.client.net.subscribe_collection({\n                collection,\n                filter,\n                result: fields,\n            }, ((params, responseType) => {\n                if (responseType === 100) {\n                    listener(params.result);\n                }\n            }));\n            (_b = this.subscriptions) === null || _b === void 0 ? void 0 : _b.set(collection, subscription);\n        });\n    }\n    /**\n     * Free all internal resources related to this instance\n     * and allocated inside core.\n     *\n     * It is a good practice to call this method when you have finished\n     * with this Account object.\n     *\n     * Note that this instance still fully operable.\n     * So you can continue to work with this instance.\n     */\n    free() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.subscriptions) {\n                const subscriptions = this.subscriptions.values();\n                this.subscriptions = null;\n                for (const subscription of subscriptions) {\n                    yield this.client.net.unsubscribe(subscription);\n                }\n            }\n        });\n    }\n}\nexports.Account = Account;\nAccount.giversByClient = [];\nfunction getEnv(name) {\n    const globalEval = eval;\n    try {\n        return globalEval(`process.env.${name}`);\n    }\n    catch (_a) {\n        return undefined;\n    }\n}\nfunction getDefaultGiverKeys(client) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const definedSecret = getEnv("TON_GIVER_SECRET");\n        if (definedSecret) {\n            const definedKeys = yield client.crypto.nacl_sign_keypair_from_secret_key({\n                secret: definedSecret,\n            });\n            definedKeys.secret = definedKeys.secret.substr(0, 64);\n            return definedKeys;\n        }\n        // noinspection SpellCheckingInspection\n        return {\n            "public": "2ada2e65ab8eeab09490e3521415f45b6e42df9c760a639bcf53957550b25a16",\n            "secret": "172af540e43a524763dd53b26a066d472a97c4de37d5498170564510608250c3",\n        };\n    });\n}\nfunction getDefaultGiverAddress(client, keys) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        const definedAddress = getEnv("TON_GIVER_ADDRESS");\n        if (definedAddress) {\n            return definedAddress;\n        }\n        return (yield client.abi.encode_message({\n            abi: (0, core_1.abiContract)(exports.DefaultGiverContract.abi),\n            deploy_set: {\n                tvc: (_a = exports.DefaultGiverContract.tvc) !== null && _a !== void 0 ? _a : "",\n            },\n            signer: (0, core_1.signerKeys)(keys),\n        })).address;\n    });\n}\n// noinspection SpellCheckingInspection\nexports.DefaultGiverContract = {\n    abi: {\n        "ABI version": 2,\n        header: ["time", "expire"],\n        functions: [\n            {\n                name: "sendTransaction",\n                inputs: [\n                    {\n                        "name": "dest",\n                        "type": "address",\n                    },\n                    {\n                        "name": "value",\n                        "type": "uint128",\n                    },\n                    {\n                        "name": "bounce",\n                        "type": "bool",\n                    },\n                ],\n                outputs: [],\n            },\n            {\n                name: "getMessages",\n                inputs: [],\n                outputs: [\n                    {\n                        components: [\n                            {\n                                name: "hash",\n                                type: "uint256",\n                            },\n                            {\n                                name: "expireAt",\n                                type: "uint64",\n                            },\n                        ],\n                        name: "messages",\n                        type: "tuple[]",\n                    },\n                ],\n            },\n            {\n                name: "upgrade",\n                inputs: [\n                    {\n                        name: "newcode",\n                        type: "cell",\n                    },\n                ],\n                outputs: [],\n            },\n            {\n                name: "constructor",\n                inputs: [],\n                outputs: [],\n            },\n        ],\n        data: [],\n        events: [],\n    },\n    tvc: "te6ccgECGgEAA9sAAgE0BgEBAcACAgPPIAUDAQHeBAAD0CAAQdgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAIm/wD0pCAiwAGS9KDhiu1TWDD0oQkHAQr0pCD0oQgAAAIBIAwKAfz/fyHtRNAg10nCAZ/T/9MA9AX4an/4Yfhm+GKOG/QFbfhqcAGAQPQO8r3XC//4YnD4Y3D4Zn/4YeLTAAGOEoECANcYIPkBWPhCIPhl+RDyqN4j+EL4RSBukjBw3rry4GUh0z/THzQx+CMhAb7yuSH5ACD4SoEBAPQOIJEx3rMLAE7y4Gb4ACH4SiIBVQHIyz9ZgQEA9EP4aiMEXwTTHwHwAfhHbpLyPN4CASASDQIBWBEOAQm46Jj8UA8B/vhBbo4S7UTQ0//TAPQF+Gp/+GH4Zvhi3tFwbW8C+EqBAQD0hpUB1ws/f5NwcHDikSCONyMjI28CbyLIIs8L/yHPCz8xMQFvIiGkA1mAIPRDbwI0IvhKgQEA9HyVAdcLP3+TcHBw4gI1MzHoXwPIghB3RMfighCAAAAAsc8LHyEQAKJvIgLLH/QAyIJYYAAAAAAAAAAAAAAAAM8LZoEDmCLPMQG5lnHPQCHPF5Vxz0EhzeIgyXH7AFswwP+OEvhCyMv/+EbPCwD4SgH0AMntVN5/+GcAxbkWq+f/CC3Rxt2omgQa6ThAM/p/+mAegL8NT/8MPwzfDFHDfoCtvw1OADAIHoHeV7rhf/8MTh8Mbh8Mz/8MPFvfCNJeRnJuPwzcXwAaPwhZGX//CNnhYB8JQD6AGT2qj/8M8AIBIBUTAde7Fe+TX4QW6OEu1E0NP/0wD0Bfhqf/hh+Gb4Yt76QNcNf5XU0dDTf9/XDACV1NHQ0gDf0SIiInPIcc8LASLPCgBzz0AkzxYj+gKAac9Acs9AIMki+wBfBfhKgQEA9IaVAdcLP3+TcHBw4pEggUAJKOLfgjIgG7n/hKIwEhAYEBAPRbMDH4at4i+EqBAQD0fJUB1ws/f5NwcHDiAjUzMehfA18D+ELIy//4Rs8LAPhKAfQAye1Uf/hnAgEgFxYAx7jkYYdfCC3Rwl2omhp/+mAegL8NT/8MPwzfDFvamj8IXwikDdJGDhvXXlwMvwAfCFkZf/8I2eFgHwlAPoAZPaqfAeQfYIQaHaPdqn4ARh8IWRl//wjZ4WAfCUA+gBk9qo//DPACAtoZGAAtr4QsjL//hGzwsA+EoB9ADJ7VT4D/IAgAdacCHHAJ0i0HPXIdcLAMABkJDi4CHXDR+S8jzhUxHAAJDgwQMighD////9vLGS8jzgAfAB+EdukvI83o",\n};\n//# sourceMappingURL=account.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL0BldmVyc2RrL2FwcGtpdC9kaXN0L2FjY291bnQuanM/MzEyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZWZhdWx0R2l2ZXJDb250cmFjdCA9IGV4cG9ydHMuQWNjb3VudCA9IGV4cG9ydHMuQWNjb3VudFR5cGUgPSBleHBvcnRzLkFjY291bnRFcnJvciA9IHZvaWQgMDtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCJAZXZlcnNkay9jb3JlXCIpO1xudmFyIEVSUl9DT0RFUztcbihmdW5jdGlvbiAoRVJSX0NPREVTKSB7XG4gICAgRVJSX0NPREVTW0VSUl9DT0RFU1tcIk1JU1NJTkdfVFZDXCJdID0gMF0gPSBcIk1JU1NJTkdfVFZDXCI7XG4gICAgRVJSX0NPREVTW0VSUl9DT0RFU1tcIkFDQ19OT1RfRVhJU1RTXCJdID0gMV0gPSBcIkFDQ19OT1RfRVhJU1RTXCI7XG59KShFUlJfQ09ERVMgfHwgKEVSUl9DT0RFUyA9IHt9KSk7XG5jbGFzcyBBY2NvdW50RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgIHN1cGVyKG9wdC5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gb3B0LmNvZGU7XG4gICAgfVxuICAgIHN0YXRpYyBtaXNzaW5nVFZDKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFjY291bnRFcnJvcih7XG4gICAgICAgICAgICBjb2RlOiBFUlJfQ09ERVMuTUlTU0lOR19UVkMsXG4gICAgICAgICAgICBtZXNzYWdlOiBcIkNhbid0IGNhbGN1bGF0ZSBkZXBsb3kgcGFyYW1zOiBtaXNzaW5nIHJlcXVpcmVkIFRWQy5cIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBtaXNzaW5nQk9DKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFjY291bnRFcnJvcih7XG4gICAgICAgICAgICBjb2RlOiBFUlJfQ09ERVMuQUNDX05PVF9FWElTVFMsXG4gICAgICAgICAgICBtZXNzYWdlOiAnQWNjb3VudCBoYXMgYW4gZW1wdHkgQk9DLiBQb3NzaWJsZSByZWFzb24gaXM6IGFjY291bnQgd2FzIGRlbGV0ZWQgKGhhcyBhY2NvdW50IHR5cGUgXCJOb25FeGlzdFwiKScsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQWNjb3VudEVycm9yID0gQWNjb3VudEVycm9yO1xuLyoqXG4gKiBDdXJyZW50IHR5cGUgb2YgdGhlIGFjY291bnQuXG4gKi9cbnZhciBBY2NvdW50VHlwZTtcbihmdW5jdGlvbiAoQWNjb3VudFR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBBY2NvdW50IGV4aXN0cyBpbiB0aGUgYmxvY2tjaGFpbiBidXQgd2l0aG91dCBzbWFydCBjb250cmFjdC5cbiAgICAgKi9cbiAgICBBY2NvdW50VHlwZVtBY2NvdW50VHlwZVtcInVuaW5pdFwiXSA9IDBdID0gXCJ1bmluaXRcIjtcbiAgICAvKipcbiAgICAgKiBBY2NvdW50IGV4aXN0cyBpbiB0aGUgYmxvY2tjaGFpbiB3aXRoIHNtYXJ0IGNvbnRyYWN0LlxuICAgICAqL1xuICAgIEFjY291bnRUeXBlW0FjY291bnRUeXBlW1wiYWN0aXZlXCJdID0gMV0gPSBcImFjdGl2ZVwiO1xuICAgIC8qKlxuICAgICAqIEFjY291bnQgZXhpc3RzIGluIHRoZSBibG9ja2NoYWluIGJ1dCBpdCBoYWQgZnJvemVuLlxuICAgICAqL1xuICAgIEFjY291bnRUeXBlW0FjY291bnRUeXBlW1wiZnJvemVuXCJdID0gMl0gPSBcImZyb3plblwiO1xuICAgIC8qKlxuICAgICAqIEFjY291bnQgaXMgbWlzc2luZyBpbiB0aGUgYmxvY2tjaGFpbi5cbiAgICAgKi9cbiAgICBBY2NvdW50VHlwZVtBY2NvdW50VHlwZVtcIm5vbkV4aXN0XCJdID0gM10gPSBcIm5vbkV4aXN0XCI7XG59KShBY2NvdW50VHlwZSA9IGV4cG9ydHMuQWNjb3VudFR5cGUgfHwgKGV4cG9ydHMuQWNjb3VudFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBPYmplY3QgdG8gZGVhbCB3aXRoIHNwZWNpZmllZCBhY2NvdW50IHVzaW5nIHNwZWNpZmllZCBzaWduZXIgKG93bmVyKS5cbiAqXG4gKiBBY2NvdW50IGluc3RhbmNlIGNhbiBiZSBib3VuZCB0byBhY2NvdW50IGFkZHJlc3NcbiAqIG9yIGFjY291bnQgZGVwbG95IHBhcmFtZXRlcnMgdGhhdCB1bmlxdWVseSBpZGVudGlmaWVzXG4gKiBhY2NvdW50IGFkZHJlc3MuXG4gKi9cbmNsYXNzIEFjY291bnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYWNjb3VudCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cmFjdCBDb250cmFjdCBwYWNrYWdlIGNvbnRhaW5pbmcgYWJpIGFuZCBvcHRpb25hbCB0dmMgZGF0YS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBY2NvdW50IGluc3RhbmNlIG9wdGlvbnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgdGhpcy5zeW5jTGFzdFRyYW5zTHQgPSBudWxsO1xuICAgICAgICB0aGlzLmNhY2hlZEJvYyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udHJhY3QgPSBjb250cmFjdDtcbiAgICAgICAgdGhpcy5jbGllbnQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb3JlXzEuVG9uQ2xpZW50LmRlZmF1bHQ7XG4gICAgICAgIHRoaXMuYWJpID0gKDAsIGNvcmVfMS5hYmlDb250cmFjdCkoY29udHJhY3QuYWJpKTtcbiAgICAgICAgdGhpcy5zaWduZXIgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoMCwgY29yZV8xLnNpZ25lck5vbmUpKCk7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hZGRyZXNzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsO1xuICAgICAgICB0aGlzLmluaXREYXRhID0gKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmluaXREYXRhKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBudWxsO1xuICAgICAgICB0aGlzLnVzZUNhY2hlZFN0YXRlID0gKF9lID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVzZUNhY2hlZFN0YXRlKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZ2l2ZXIgaW5zdGFuY2UgYXNzaWduZWQgZm9yIHNwZWNpZmllZCBjbGllbnQgaW5zdGFuY2UuXG4gICAgICogT3IgYG51bGxgIGlmIG5vIGdpdmVyIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNsaWVudCB5ZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xpZW50IENsaWVudCBpbnN0YW5jZSBsb29raW5nIGZvci5cbiAgICAgKi9cbiAgICBzdGF0aWMgZmluZEdpdmVyRm9yQ2xpZW50KGNsaWVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmdpdmVyc0J5Q2xpZW50LmZpbmQoeCA9PiB4LmNsaWVudCA9PT0gY2xpZW50KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdpdmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIHNwZWNpZmllZCBnaXZlciBhcyBhIGRlZmF1bHQgZm9yIHNwZWNpZmllZCBjbGllbnQgaW5zdGFuY2UuXG4gICAgICogSWYgY2xpZW50IGFscmVhZHkgaGFzIGRlZmF1bHQgZ2l2ZXIgaXQgd2lsbCBiZSByZWFzc2lnbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNsaWVudCBDbGllbnQgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIGdpdmVyIE5ldyBnaXZlciBpbnN0YW5jZSBvciBgbnVsbGAgaWYgdGhlIGRlZmF1bHQgZ2l2ZXIgZm9yXG4gICAgICogdGhpcyBjbGllbnQgbXVzdCBiZSByZW1vdmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRHaXZlckZvckNsaWVudChjbGllbnQsIGdpdmVyKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLmdpdmVyc0J5Q2xpZW50LmZpbmRJbmRleCh4ID0+IHguY2xpZW50ID09PSBjbGllbnQpO1xuICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoZ2l2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdpdmVyc0J5Q2xpZW50W2ldLmdpdmVyID0gZ2l2ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdpdmVyc0J5Q2xpZW50LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChnaXZlcikge1xuICAgICAgICAgICAgdGhpcy5naXZlcnNCeUNsaWVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgICAgICAgZ2l2ZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlR2l2ZXIoY2xpZW50KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBnaXZlcktleXMgPSB5aWVsZCBnZXREZWZhdWx0R2l2ZXJLZXlzKGNsaWVudCk7XG4gICAgICAgICAgICBjb25zdCBnaXZlckFkZHJlc3MgPSB5aWVsZCBnZXREZWZhdWx0R2l2ZXJBZGRyZXNzKGNsaWVudCwgZ2l2ZXJLZXlzKTtcbiAgICAgICAgICAgIGNvbnN0IGdpdmVyID0gbmV3IEFjY291bnQoZXhwb3J0cy5EZWZhdWx0R2l2ZXJDb250cmFjdCwge1xuICAgICAgICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBnaXZlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgc2lnbmVyOiAoMCwgY29yZV8xLnNpZ25lcktleXMpKGdpdmVyS2V5cyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogZ2l2ZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgIHNlbmRUbzogKGFkZHJlc3MsIHZhbHVlKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGdpdmVyLnJ1bihcInNlbmRUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0OiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGdpdmVyIGZvciBzcGVjaWZpZWQgY2xpZW50IGluc3RhbmNlLlxuICAgICAqIElmIG5vIGdpdmVyIGFzc2lnbmVkIHlldCB0aGVuIG5ldyBvbmUgd2lsbCBiZSBjcmVhdGVkLFxuICAgICAqIGFzc2lnbmVkIGFuZCByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbGllbnQgQ2xpZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRHaXZlckZvckNsaWVudChjbGllbnQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5maW5kR2l2ZXJGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGdpdmVyID0geWllbGQgdGhpcy5jcmVhdGVHaXZlcihjbGllbnQpO1xuICAgICAgICAgICAgdGhpcy5naXZlcnNCeUNsaWVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgICAgICAgZ2l2ZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBnaXZlcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWRkcmVzcyBvZiB0aGUgYWNjb3VudC5cbiAgICAgKlxuICAgICAqIFVzZXMgYWRkcmVzcyBzcGVjaWZpZWQgaW4gY29uc3RydWN0b3Igb3B0aW9uc1xuICAgICAqIG9yIGNhbGN1bGF0ZXMgaXQgZnJvbSBkZXBsb3kgZGF0YSBwcm92aWRlZCBpbiBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG4gICAgICAgICAgICBpZiAoYWRkcmVzcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlcGxveVBhcmFtcyA9IHRoaXMuZ2V0UGFyYW1zT2ZEZXBsb3lNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdEZ1bmN0aW9uTmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gKHlpZWxkIHRoaXMuY2xpZW50LmFiaS5lbmNvZGVfbWVzc2FnZShkZXBsb3lQYXJhbXMpKS5hZGRyZXNzO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcGFyYW1zIGZvciBlbmNvZGluZyBkZXBsb3kgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBNZXNzYWdlIGVuY29kaW5nIG9wdGlvbnMuXG4gICAgICovXG4gICAgZ2V0UGFyYW1zT2ZEZXBsb3lNZXNzYWdlKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuY29udHJhY3QudHZjKSB7XG4gICAgICAgICAgICB0aHJvdyBBY2NvdW50RXJyb3IubWlzc2luZ1RWQygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGFiaTogdGhpcy5hYmksXG4gICAgICAgICAgICBzaWduZXI6IHRoaXMuc2lnbmVyLFxuICAgICAgICAgICAgZGVwbG95X3NldDoge1xuICAgICAgICAgICAgICAgIHR2YzogdGhpcy5jb250cmFjdC50dmMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5pbml0RGF0YSkge1xuICAgICAgICAgICAgcGFyYW1zLmRlcGxveV9zZXQuaW5pdGlhbF9kYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pbml0RnVuY3Rpb25OYW1lKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyYW1zLmNhbGxfc2V0ID0ge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uX25hbWU6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pbml0RnVuY3Rpb25OYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaW5pdElucHV0KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNhbGxfc2V0LmlucHV0ID0gb3B0aW9ucy5pbml0SW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBkZXRhaWxlZCBkZXBsb3kgZmVlcy5cbiAgICAgKi9cbiAgICBjYWxjRGVwbG95RmVlcyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBkZXBsb3lQYXJhbXMgPSB5aWVsZCB0aGlzLmdldFBhcmFtc09mRGVwbG95TWVzc2FnZShvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB5aWVsZCB0aGlzLmNsaWVudC5hYmkuZW5jb2RlX21lc3NhZ2UoZGVwbG95UGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMuY2xpZW50LnR2bS5ydW5fZXhlY3V0b3Ioe1xuICAgICAgICAgICAgICAgIGFjY291bnQ6ICgwLCBjb3JlXzEuYWNjb3VudEZvckV4ZWN1dG9yVW5pbml0KSgpLFxuICAgICAgICAgICAgICAgIGFiaTogdGhpcy5hYmksXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZS5tZXNzYWdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmZlZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXBsb3lzIGFjY291bnQgaW50byBuZXR3b3JrXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBkZXBsb3kob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGVwbG95UGFyYW1zID0gdGhpcy5nZXRQYXJhbXNPZkRlcGxveU1lc3NhZ2Uob3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCB1c2VHaXZlciA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51c2VHaXZlcjtcbiAgICAgICAgICAgIGNvbnN0IGdpdmVyID0gdXNlR2l2ZXIgPT09IHRydWUgPyAoeWllbGQgQWNjb3VudC5nZXRHaXZlckZvckNsaWVudCh0aGlzLmNsaWVudCkpIDogdXNlR2l2ZXI7XG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MgPSAoeWllbGQgdGhpcy5jbGllbnQuYWJpLmVuY29kZV9tZXNzYWdlKGRlcGxveVBhcmFtcykpLmFkZHJlc3M7XG4gICAgICAgICAgICBpZiAoZ2l2ZXIpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBnaXZlci5zZW5kVG8odGhpcy5hZGRyZXNzLCAxMDAwMDAwMDAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLmNsaWVudC5wcm9jZXNzaW5nLnByb2Nlc3NfbWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZV9lbmNvZGVfcGFyYW1zOiBkZXBsb3lQYXJhbXMsXG4gICAgICAgICAgICAgICAgc2VuZF9ldmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm5lZWRTeW5jV2l0aFRyYW5zYWN0aW9uKHJlc3VsdC50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW11bGF0ZSBkZXBsb3lcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIGRlcGxveUxvY2FsKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlcGxveVBhcmFtcyA9IHRoaXMuZ2V0UGFyYW1zT2ZEZXBsb3lNZXNzYWdlKG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgeyBhZGRyZXNzLCBtZXNzYWdlLCB9ID0geWllbGQgdGhpcy5jbGllbnQuYWJpLmVuY29kZV9tZXNzYWdlKGRlcGxveVBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLmNsaWVudC50dm0ucnVuX2V4ZWN1dG9yKHtcbiAgICAgICAgICAgICAgICBhY2NvdW50OiAoMCwgY29yZV8xLmFjY291bnRGb3JFeGVjdXRvclVuaW5pdCkoKSxcbiAgICAgICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgcmV0dXJuX3VwZGF0ZWRfYWNjb3VudDogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkQm9jID0gcmVzdWx0LmFjY291bnQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBkZXRhaWxlZCBmZWVzIGZvciBzcGVjaWZpZWQgcnVuIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnVuY3Rpb25OYW1lIE5hbWUgb2YgdGhlIGZ1bmN0aW9uIGFjY29yZGluZyB0byB0aGUgQUJJLlxuICAgICAqIEBwYXJhbSBpbnB1dCBPYmplY3Qgd2l0aCBmdW5jdGlvbiBwYXJhbWV0ZXJzIChmdW5jdGlvbiBwYXJhbWV0ZXJzKS5cbiAgICAgKi9cbiAgICBjYWxjUnVuRmVlcyhmdW5jdGlvbk5hbWUsIGlucHV0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0geWllbGQgdGhpcy5jbGllbnQuYWJpLmVuY29kZV9tZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB5aWVsZCB0aGlzLmdldEFkZHJlc3MoKSxcbiAgICAgICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgICAgIHNpZ25lcjogdGhpcy5zaWduZXIsXG4gICAgICAgICAgICAgICAgY2FsbF9zZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fbmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgdGhpcy5jbGllbnQudHZtLnJ1bl9leGVjdXRvcih7XG4gICAgICAgICAgICAgICAgYWNjb3VudDogKDAsIGNvcmVfMS5hY2NvdW50Rm9yRXhlY3V0b3JBY2NvdW50KSh5aWVsZCB0aGlzLmJvYygpKSxcbiAgICAgICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UubWVzc2FnZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5mZWVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBtZXNzYWdlIG9uIG5ldHdvcmsgYW5kIHJldHVybnMgZGV0YWlsZWQgaW5mb3JtYXRpb25cbiAgICAgKiBhYm91dCByZXN1bHRzIGluY2x1ZGluZyBwcm9kdWNlZCB0cmFuc2FjdGlvbiBhbmQgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnVuY3Rpb25OYW1lIE5hbWUgb2YgdGhlIGZ1bmN0aW9uIGFjY29yZGluZyB0byB0aGUgQUJJLlxuICAgICAqIEBwYXJhbSBpbnB1dCBPYmplY3Qgd2l0aCBmdW5jdGlvbiBwYXJhbWV0ZXJzIChmdW5jdGlvbiBwYXJhbWV0ZXJzKS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBSdW4gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBydW4oZnVuY3Rpb25OYW1lLCBpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoeWllbGQgdGhpcy5jbGllbnQucHJvY2Vzc2luZy5wcm9jZXNzX21lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VfZW5jb2RlX3BhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB5aWVsZCB0aGlzLmdldEFkZHJlc3MoKSxcbiAgICAgICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVyOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnNpZ25lcixcbiAgICAgICAgICAgICAgICAgICAgY2FsbF9zZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX25hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2VuZF9ldmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5uZWVkU3luY1dpdGhUcmFuc2FjdGlvbihyZXN1bHQudHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyBtZXNzYWdlIG9uIGxvY2FsIFRWTSBhbmQgcmV0dXJucyBkZWNvZGVkIG91dHB1dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmdW5jdGlvbk5hbWUgTmFtZSBvZiB0aGUgZnVuY3Rpb24gYWNjb3JkaW5nIHRvIHRoZSBBQkkuXG4gICAgICogQHBhcmFtIGlucHV0IE9iamVjdCB3aXRoIGZ1bmN0aW9uIHBhcmFtZXRlcnMgKGZ1bmN0aW9uIGlucHV0KS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBSdW4gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBydW5Mb2NhbChmdW5jdGlvbk5hbWUsIGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0geWllbGQgdGhpcy5jbGllbnQuYWJpLmVuY29kZV9tZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB5aWVsZCB0aGlzLmdldEFkZHJlc3MoKSxcbiAgICAgICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgICAgIHNpZ25lcjogdGhpcy5zaWduZXIsXG4gICAgICAgICAgICAgICAgY2FsbF9zZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fbmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wZXJmb3JtQWxsQ2hlY2tzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgdGhpcy5jbGllbnQudHZtLnJ1bl9leGVjdXRvcih7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnQ6ICgwLCBjb3JlXzEuYWNjb3VudEZvckV4ZWN1dG9yQWNjb3VudCkoeWllbGQgdGhpcy5ib2MoKSksXG4gICAgICAgICAgICAgICAgICAgIGFiaTogdGhpcy5hYmksXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuX3VwZGF0ZWRfYWNjb3VudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICh5aWVsZCB0aGlzLmNsaWVudC50dm0ucnVuX3R2bSh7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnQ6IHlpZWxkIHRoaXMuYm9jKCksXG4gICAgICAgICAgICAgICAgICAgIGFiaTogdGhpcy5hYmksXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuX3VwZGF0ZWRfYWNjb3VudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LmFjY291bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZEJvYyA9IHJlc3VsdC5hY2NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5lZWRTeW5jV2l0aFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGlmICghdHJhbnNhY3Rpb24uYWJvcnRlZCAmJiB0cmFuc2FjdGlvbi5sdCkge1xuICAgICAgICAgICAgdGhpcy5zeW5jTGFzdFRyYW5zTHQgPSB0cmFuc2FjdGlvbi5sdDtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkQm9jID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJhdyBkYXRhIG9mIHRoZSBhY2NvdW50IGluIGZvcm0gb2YgQk9DLlxuICAgICAqIEZldGNoZXMgYm9jIGRhdGEgZnJvbSBuZXR3b3JrIGFuZCBjYWNoZXMgaXQgaW4gcHJpdmF0ZSBmaWVsZC5cbiAgICAgKiBgcnVuTG9jYWxgIHVwZGF0ZXMgY2FjaGVkIGJvYy5cbiAgICAgKiBgcnVuYCBkcm9wcyBjYWNoZWQgYm9jLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc3luY3MgZmV0Y2hpbmcgYm9jIHdpdGggbGFzdCBgcnVuYCBvciBgZGVwbG95YFxuICAgICAqIHNvIGZldGNoZWQgYm9jXG4gICAgICovXG4gICAgYm9jKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGVkQm9jICYmIHRoaXMudXNlQ2FjaGVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRCb2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICBjb25zdCBuZXQgPSB0aGlzLmNsaWVudC5uZXQ7XG4gICAgICAgICAgICBpZiAodGhpcy5zeW5jTGFzdFRyYW5zTHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IHlpZWxkIG5ldC5xdWVyeV9jb2xsZWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogXCJhY2NvdW50c1wiLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB7IGVxOiBhZGRyZXNzIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0X3RyYW5zX2x0OiB7IGdlOiB0aGlzLnN5bmNMYXN0VHJhbnNMdCB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IFwiYm9jXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGFjY291bnRzLnJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvYyA9IGFjY291bnRzLnJlc3VsdFswXS5ib2M7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3luY0xhc3RUcmFuc0x0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRCb2MgPSBib2M7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9jO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEFjY291bnRFcnJvci5taXNzaW5nQk9DKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBib2MgPSAoXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJucyBCT0Mgb3IgbnVsbCBpZiBhY2NvdW50IHdhcyBmb3VuZCBpbiBEQiwgYnV0IGhhcyBcIk5vdEV4aXN0c1wiIHN0YXR1c1xuICAgICAgICAgICAgICAgIC8vIFRocm93cyBpZjpcbiAgICAgICAgICAgICAgICAvLyAgLSBhY2NvdW50IE5PVCBmb3VuZCBpbiBEQiAoZXJyLmNvZGUgNjAzKSBcbiAgICAgICAgICAgICAgICAvLyAgLSBzb21lIG5ldHdvcmsgZXJyb3Igb2NjdXJlZFxuICAgICAgICAgICAgICAgIHlpZWxkIG5ldC53YWl0X2Zvcl9jb2xsZWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogXCJhY2NvdW50c1wiLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IHsgaWQ6IHsgZXE6IHRoaXMuYWRkcmVzcyB9IH0sXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogXCJib2NcIixcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dDogMTAwMCxcbiAgICAgICAgICAgICAgICB9KSkucmVzdWx0LmJvYztcbiAgICAgICAgICAgICAgICBpZiAoYm9jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkQm9jID0gYm9jO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9jO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBBY2NvdW50RXJyb3IubWlzc2luZ0JPQygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IDYwMykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBBY2NvdW50RXJyb3IubWlzc2luZ0JPQygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyb3BzIGFsbCBjYWNoZWQgYW5kIGxvY2FsIGRhdGEuXG4gICAgICovXG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5jYWNoZWRCb2MgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHBhcnNlZCBkYXRhIG9mIHRoZSBhY2NvdW50LlxuICAgICAqL1xuICAgIGdldEFjY291bnQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvYyA9IHlpZWxkIHRoaXMuYm9jKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh5aWVsZCB0aGlzLmNsaWVudC5ib2MucGFyc2VfYWNjb3VudCh7IGJvYyB9KSkucGFyc2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gRVJSX0NPREVTLkFDQ19OT1RfRVhJU1RTKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NfdHlwZTogQWNjb3VudFR5cGUubm9uRXhpc3QsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3Vic2NyaWJlQWNjb3VudChmaWVsZHMsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnN1YnNjcmliZShcImFjY291bnRzXCIsIHsgaWQ6IHsgZXE6IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpIH0gfSwgZmllbGRzLCBsaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdWJzY3JpYmVUcmFuc2FjdGlvbnMoZmllbGRzLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zdWJzY3JpYmUoXCJ0cmFuc2FjdGlvbnNcIiwge1xuICAgICAgICAgICAgICAgIGFjY291bnRfYWRkcjogeyBlcTogYWRkcmVzcyB9LFxuICAgICAgICAgICAgICAgIHN0YXR1czogeyBlcTogNSB9LFxuICAgICAgICAgICAgfSwgZmllbGRzLCBsaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdWJzY3JpYmVNZXNzYWdlcyhmaWVsZHMsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnN1YnNjcmliZShcIm1lc3NhZ2VzXCIsIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHsgZXE6IDUgfSxcbiAgICAgICAgICAgICAgICBzcmM6IHsgZXE6IGFkZHJlc3MgfSxcbiAgICAgICAgICAgICAgICBPUjoge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHsgZXE6IDUgfSxcbiAgICAgICAgICAgICAgICAgICAgZHN0OiB7IGVxOiBhZGRyZXNzIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sIGZpZWxkcywgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVjb2RlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgY29yZV8xLlRvbkNsaWVudC5kZWZhdWx0LmFiaS5kZWNvZGVfbWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWNvZGVNZXNzYWdlQm9keShib2R5LCBpc0ludGVybmFsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgY29yZV8xLlRvbkNsaWVudC5kZWZhdWx0LmFiaS5kZWNvZGVfbWVzc2FnZV9ib2R5KHtcbiAgICAgICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgaXNfaW50ZXJuYWw6IGlzSW50ZXJuYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEJhbGFuY2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHlpZWxkIHRoaXMuZ2V0QWNjb3VudCgpKS5iYWxhbmNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKGNvbGxlY3Rpb24sIGZpbHRlciwgZmllbGRzLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJldlN1YnNjcmlwdGlvbiA9IHRoaXMuc3Vic2NyaXB0aW9ucyAmJiB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KGNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHByZXZTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnN1YnNjcmlwdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWxldGUoY29sbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jbGllbnQubmV0LnVuc3Vic2NyaWJlKHByZXZTdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHlpZWxkIHRoaXMuY2xpZW50Lm5ldC5zdWJzY3JpYmVfY29sbGVjdGlvbih7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiBmaWVsZHMsXG4gICAgICAgICAgICB9LCAoKHBhcmFtcywgcmVzcG9uc2VUeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKHBhcmFtcy5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIChfYiA9IHRoaXMuc3Vic2NyaXB0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNldChjb2xsZWN0aW9uLCBzdWJzY3JpcHRpb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnJlZSBhbGwgaW50ZXJuYWwgcmVzb3VyY2VzIHJlbGF0ZWQgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAqIGFuZCBhbGxvY2F0ZWQgaW5zaWRlIGNvcmUuXG4gICAgICpcbiAgICAgKiBJdCBpcyBhIGdvb2QgcHJhY3RpY2UgdG8gY2FsbCB0aGlzIG1ldGhvZCB3aGVuIHlvdSBoYXZlIGZpbmlzaGVkXG4gICAgICogd2l0aCB0aGlzIEFjY291bnQgb2JqZWN0LlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgaW5zdGFuY2Ugc3RpbGwgZnVsbHkgb3BlcmFibGUuXG4gICAgICogU28geW91IGNhbiBjb250aW51ZSB0byB3b3JrIHdpdGggdGhpcyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmcmVlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMudmFsdWVzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN1YnNjcmlwdGlvbiBvZiBzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY2xpZW50Lm5ldC51bnN1YnNjcmliZShzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5BY2NvdW50ID0gQWNjb3VudDtcbkFjY291bnQuZ2l2ZXJzQnlDbGllbnQgPSBbXTtcbmZ1bmN0aW9uIGdldEVudihuYW1lKSB7XG4gICAgY29uc3QgZ2xvYmFsRXZhbCA9IGV2YWw7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbEV2YWwoYHByb2Nlc3MuZW52LiR7bmFtZX1gKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdEdpdmVyS2V5cyhjbGllbnQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBkZWZpbmVkU2VjcmV0ID0gZ2V0RW52KFwiVE9OX0dJVkVSX1NFQ1JFVFwiKTtcbiAgICAgICAgaWYgKGRlZmluZWRTZWNyZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmluZWRLZXlzID0geWllbGQgY2xpZW50LmNyeXB0by5uYWNsX3NpZ25fa2V5cGFpcl9mcm9tX3NlY3JldF9rZXkoe1xuICAgICAgICAgICAgICAgIHNlY3JldDogZGVmaW5lZFNlY3JldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVmaW5lZEtleXMuc2VjcmV0ID0gZGVmaW5lZEtleXMuc2VjcmV0LnN1YnN0cigwLCA2NCk7XG4gICAgICAgICAgICByZXR1cm4gZGVmaW5lZEtleXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFNwZWxsQ2hlY2tpbmdJbnNwZWN0aW9uXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcInB1YmxpY1wiOiBcIjJhZGEyZTY1YWI4ZWVhYjA5NDkwZTM1MjE0MTVmNDViNmU0MmRmOWM3NjBhNjM5YmNmNTM5NTc1NTBiMjVhMTZcIixcbiAgICAgICAgICAgIFwic2VjcmV0XCI6IFwiMTcyYWY1NDBlNDNhNTI0NzYzZGQ1M2IyNmEwNjZkNDcyYTk3YzRkZTM3ZDU0OTgxNzA1NjQ1MTA2MDgyNTBjM1wiLFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdEdpdmVyQWRkcmVzcyhjbGllbnQsIGtleXMpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgZGVmaW5lZEFkZHJlc3MgPSBnZXRFbnYoXCJUT05fR0lWRVJfQUREUkVTU1wiKTtcbiAgICAgICAgaWYgKGRlZmluZWRBZGRyZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmaW5lZEFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh5aWVsZCBjbGllbnQuYWJpLmVuY29kZV9tZXNzYWdlKHtcbiAgICAgICAgICAgIGFiaTogKDAsIGNvcmVfMS5hYmlDb250cmFjdCkoZXhwb3J0cy5EZWZhdWx0R2l2ZXJDb250cmFjdC5hYmkpLFxuICAgICAgICAgICAgZGVwbG95X3NldDoge1xuICAgICAgICAgICAgICAgIHR2YzogKF9hID0gZXhwb3J0cy5EZWZhdWx0R2l2ZXJDb250cmFjdC50dmMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lnbmVyOiAoMCwgY29yZV8xLnNpZ25lcktleXMpKGtleXMpLFxuICAgICAgICB9KSkuYWRkcmVzcztcbiAgICB9KTtcbn1cbi8vIG5vaW5zcGVjdGlvbiBTcGVsbENoZWNraW5nSW5zcGVjdGlvblxuZXhwb3J0cy5EZWZhdWx0R2l2ZXJDb250cmFjdCA9IHtcbiAgICBhYmk6IHtcbiAgICAgICAgXCJBQkkgdmVyc2lvblwiOiAyLFxuICAgICAgICBoZWFkZXI6IFtcInRpbWVcIiwgXCJleHBpcmVcIl0sXG4gICAgICAgIGZ1bmN0aW9uczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImRlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVpbnQxMjhcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYm91bmNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJnZXRNZXNzYWdlc1wiLFxuICAgICAgICAgICAgICAgIGlucHV0czogW10sXG4gICAgICAgICAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImhhc2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiZXhwaXJlQXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50NjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwibWVzc2FnZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidHVwbGVbXVwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidXBncmFkZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm5ld2NvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGV2ZW50czogW10sXG4gICAgfSxcbiAgICB0dmM6IFwidGU2Y2NnRUNHZ0VBQTlzQUFnRTBCZ0VCQWNBQ0FnUFBJQVVEQVFIZUJBQUQwQ0FBUWRnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUltL3dEMHBDQWl3QUdTOUtEaGl1MVRXREQwb1FrSEFRcjBwQ0Qwb1FnQUFBSUJJQXdLQWZ6L2Z5SHRSTkFnMTBuQ0FaL1QvOU1BOUFYNGFuLzRZZmhtK0dLT0cvUUZiZmhxY0FHQVFQUU84cjNYQy8vNFluRDRZM0Q0Wm4vNFllTFRBQUdPRW9FQ0FOY1lJUGtCV1BoQ0lQaGwrUkR5cU40aitFTDRSU0J1a2pCdzNycnk0R1VoMHovVEh6UXgrQ01oQWI3eXVTSDVBQ0Q0U29FQkFQUU9JSkV4M3JNTEFFN3k0R2I0QUNINFNpSUJWUUhJeXo5WmdRRUE5RVA0YWlNRVh3VFRId0h3QWZoSGJwTHlQTjRDQVNBU0RRSUJXQkVPQVFtNDZKajhVQThCL3ZoQmJvNFM3VVRRMC8vVEFQUUYrR3AvK0dINFp2aGkzdEZ3Ylc4QytFcUJBUUQwaHBVQjF3cy9mNU53Y0hEaWtTQ09OeU1qSTI4Q2J5TElJczhML3lIUEN6OHhNUUZ2SWlHa0ExbUFJUFJEYndJMEl2aEtnUUVBOUh5VkFkY0xQMytUY0hCdzRnSTFNekhvWHdQSWdoQjNSTWZpZ2hDQUFBQUFzYzhMSHlFUUFLSnZJZ0xMSC9RQXlJSllZQUFBQUFBQUFBQUFBQUFBQU04TFpvRURtQ0xQTVFHNWxuSFBRQ0hQRjVWeHowRWh6ZUlneVhIN0FGc3d3UCtPRXZoQ3lNdi8rRWJQQ3dENFNnSDBBTW50Vk41LytHY0F4YmtXcStmL0NDM1J4dDJvbWdRYTZUaEFNL3AvK21BZWdMOE5ULzhNUHd6ZkRGSERmb0N0dncxT0FEQUlIb0hlVjdyaGYvOE1UaDhNYmg4TXovOE1QRnZmQ05KZVJuSnVQd3pjWHdBYVB3aFpHWC8vQ05uaFlCOEpRRDZBR1QycWovOE04QUlCSUJVVEFkZTdGZStUWDRRVzZPRXUxRTBOUC8wd0QwQmZocWYvaGgrR2I0WXQ3NlFOY05mNVhVMGREVGY5L1hEQUNWMU5IUTBnRGYwU0lpSW5QSWNjOExBU0xQQ2dCenowQWt6eFlqK2dLQWFjOUFjczlBSU1raSt3QmZCZmhLZ1FFQTlJYVZBZGNMUDMrVGNIQnc0cEVnZ1VBSktPTGZnaklnRzduL2hLSXdFaEFZRUJBUFJiTURINGF0NGkrRXFCQVFEMGZKVUIxd3MvZjVOd2NIRGlBalV6TWVoZkExOEQrRUxJeS8vNFJzOExBUGhLQWZRQXllMVVmL2huQWdFZ0Z4WUF4N2prWVlkZkNDM1J3bDJvbWhwLyttQWVnTDhOVC84TVB3emZERnZhbWo4SVh3aWtEZEpHRGh2WFhsd012d0FmQ0ZrWmYvOEkyZUZnSHdsQVBvQVpQYXFmQWVRZllJUWFIYVBkcW40QVJoOElXUmwvL3dqWjRXQWZDVUErZ0JrOXFvLy9EUEFDQXRvWkdBQXRyNFFzakwvL2hHendzQStFb0I5QURKN1ZUNEQvSUFnQWRhY0NISEFKMGkwSFBYSWRjTEFNQUJrSkRpNENIWERSK1M4anpoVXhIQUFKRGd3UU1pZ2hELy8vLzl2TEdTOGp6Z0FmQUIrRWR1a3ZJODNvXCIsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjb3VudC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///534\n')},253:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n__exportStar(__webpack_require__(534), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL0BldmVyc2RrL2FwcGtpdC9kaXN0L2luZGV4LmpzP2Q1NzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hY2NvdW50XCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///253\n')},819:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.CommonBinaryBridge = exports.useLibrary = exports.getBridge = exports.ResponseType = void 0;\nconst errors_1 = __webpack_require__(504);\nvar ResponseType;\n(function (ResponseType) {\n    ResponseType[ResponseType["Success"] = 0] = "Success";\n    ResponseType[ResponseType["Error"] = 1] = "Error";\n    ResponseType[ResponseType["Nop"] = 2] = "Nop";\n    ResponseType[ResponseType["AppRequest"] = 3] = "AppRequest";\n    ResponseType[ResponseType["AppNotify"] = 4] = "AppNotify";\n    ResponseType[ResponseType["Custom"] = 100] = "Custom";\n})(ResponseType = exports.ResponseType || (exports.ResponseType = {}));\nlet bridge = undefined;\nfunction getBridge() {\n    if (!bridge) {\n        throw new errors_1.TonClientError(1, "TON Client binary bridge isn\'t set.");\n    }\n    return bridge;\n}\nexports.getBridge = getBridge;\nfunction useLibrary(loader) {\n    if ("createContext" in loader) {\n        bridge = loader;\n    }\n    else {\n        bridge = new CommonBinaryBridge(loader);\n    }\n}\nexports.useLibrary = useLibrary;\nclass BinaryLibraryAdapter {\n    constructor(library) {\n        this.library = library;\n    }\n    setResponseParamsHandler(handler) {\n        if (handler === undefined) {\n            this.library.setResponseHandler(undefined);\n        }\n        else {\n            this.library.setResponseHandler((requestId, paramsJson, responseType, finished) => handler(requestId, paramsJson !== "" ? JSON.parse(paramsJson) : undefined, responseType, finished));\n        }\n    }\n    sendRequestParams(context, requestId, functionName, functionParams) {\n        const paramsJson = (functionParams === undefined) || (functionParams === null)\n            ? ""\n            : JSON.stringify(functionParams, (_, value) => typeof value === "bigint"\n                ? (value < Number.MAX_SAFE_INTEGER && value > Number.MIN_SAFE_INTEGER\n                    ? Number(value)\n                    : value.toString())\n                : value);\n        this.library.sendRequest(context, requestId, functionName, paramsJson);\n    }\n    createContext(configJson) {\n        return this.library.createContext(configJson);\n    }\n    destroyContext(context) {\n        this.library.destroyContext(context);\n    }\n}\nclass CommonBinaryBridge {\n    constructor(loader) {\n        this.loading = undefined;\n        this.loadError = undefined;\n        this.library = undefined;\n        this.requests = new Map();\n        this.nextRequestId = 1;\n        this.contextCount = 0;\n        this.responseHandlerAssigned = false;\n        this.loading = [];\n        loader().then((library) => {\n            const saveLoading = this.loading;\n            this.loading = undefined;\n            let libraryWithParams = "setResponseParamsHandler" in library\n                ? library\n                : new BinaryLibraryAdapter(library);\n            this.library = libraryWithParams;\n            saveLoading === null || saveLoading === void 0 ? void 0 : saveLoading.forEach(x => x.resolve(libraryWithParams));\n        }, (reason) => {\n            const saveLoading = this.loading;\n            this.loading = undefined;\n            this.loadError = reason !== null && reason !== void 0 ? reason : undefined;\n            saveLoading === null || saveLoading === void 0 ? void 0 : saveLoading.forEach(x => x.reject(reason));\n        });\n    }\n    checkResponseHandler() {\n        var _a, _b;\n        const mustBeAssigned = (this.contextCount > 0) || (this.requests.size > 0);\n        if (this.responseHandlerAssigned !== mustBeAssigned) {\n            if (mustBeAssigned) {\n                (_a = this.library) === null || _a === void 0 ? void 0 : _a.setResponseParamsHandler((requestId, params, responseType, finished) => this.handleLibraryResponse(requestId, params, responseType, finished));\n            }\n            else {\n                (_b = this.library) === null || _b === void 0 ? void 0 : _b.setResponseParamsHandler();\n            }\n            this.responseHandlerAssigned = mustBeAssigned;\n        }\n    }\n    createContext(config) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const lib = this.library || (yield this.loadRequired());\n            this.contextCount += 1;\n            return CommonBinaryBridge.parseResult(yield lib.createContext(JSON.stringify(config)));\n        });\n    }\n    destroyContext(context) {\n        var _a;\n        this.contextCount = Math.max(this.contextCount - 1, 0);\n        this.checkResponseHandler();\n        (_a = this.library) === null || _a === void 0 ? void 0 : _a.destroyContext(context);\n    }\n    request(context, functionName, functionParams, responseHandler) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const lib = (_a = this.library) !== null && _a !== void 0 ? _a : yield this.loadRequired();\n            return new Promise((resolve, reject) => {\n                const request = {\n                    resolve,\n                    reject,\n                    responseHandler,\n                };\n                const requestId = this.generateRequestId();\n                this.requests.set(requestId, request);\n                this.checkResponseHandler();\n                lib.sendRequestParams(context, requestId, functionName, functionParams);\n            });\n        });\n    }\n    loadRequired() {\n        if (this.library !== undefined) {\n            return Promise.resolve(this.library);\n        }\n        if (this.loadError !== undefined) {\n            return Promise.reject(this.loadError);\n        }\n        if (this.loading === undefined) {\n            return Promise.reject(new errors_1.TonClientError(1, "TON Client binary library isn\'t set."));\n        }\n        return new Promise((resolve, reject) => {\n            var _a;\n            (_a = this.loading) === null || _a === void 0 ? void 0 : _a.push({\n                resolve,\n                reject,\n            });\n        });\n    }\n    generateRequestId() {\n        const id = this.nextRequestId;\n        do {\n            this.nextRequestId += 1;\n            if (this.nextRequestId >= Number.MAX_SAFE_INTEGER) {\n                this.nextRequestId = 1;\n            }\n        } while (this.requests.has(this.nextRequestId));\n        return id;\n    }\n    handleLibraryResponse(requestId, params, responseType, finished) {\n        const request = this.requests.get(requestId);\n        if (!request) {\n            return;\n        }\n        if (finished) {\n            this.requests.delete(requestId);\n            this.checkResponseHandler();\n        }\n        switch (responseType) {\n            case ResponseType.Success:\n                request.resolve(params);\n                break;\n            case ResponseType.Error:\n                request.reject(params);\n                break;\n            default:\n                const isAppObjectOrCustom = responseType === ResponseType.AppNotify\n                    || responseType === ResponseType.AppRequest\n                    || responseType >= ResponseType.Custom;\n                if (isAppObjectOrCustom && request.responseHandler) {\n                    request.responseHandler(params, responseType);\n                }\n        }\n    }\n    static parseResult(resultJson) {\n        const result = JSON.parse(resultJson);\n        if ("error" in result) {\n            throw new errors_1.TonClientError(result.error.code, result.error.message, result.error.data);\n        }\n        return result.result;\n    }\n}\nexports.CommonBinaryBridge = CommonBinaryBridge;\n//# sourceMappingURL=bin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL0BldmVyc2RrL2NvcmUvZGlzdC9iaW4uanM/MGQ4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21tb25CaW5hcnlCcmlkZ2UgPSBleHBvcnRzLnVzZUxpYnJhcnkgPSBleHBvcnRzLmdldEJyaWRnZSA9IGV4cG9ydHMuUmVzcG9uc2VUeXBlID0gdm9pZCAwO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG52YXIgUmVzcG9uc2VUeXBlO1xuKGZ1bmN0aW9uIChSZXNwb25zZVR5cGUpIHtcbiAgICBSZXNwb25zZVR5cGVbUmVzcG9uc2VUeXBlW1wiU3VjY2Vzc1wiXSA9IDBdID0gXCJTdWNjZXNzXCI7XG4gICAgUmVzcG9uc2VUeXBlW1Jlc3BvbnNlVHlwZVtcIkVycm9yXCJdID0gMV0gPSBcIkVycm9yXCI7XG4gICAgUmVzcG9uc2VUeXBlW1Jlc3BvbnNlVHlwZVtcIk5vcFwiXSA9IDJdID0gXCJOb3BcIjtcbiAgICBSZXNwb25zZVR5cGVbUmVzcG9uc2VUeXBlW1wiQXBwUmVxdWVzdFwiXSA9IDNdID0gXCJBcHBSZXF1ZXN0XCI7XG4gICAgUmVzcG9uc2VUeXBlW1Jlc3BvbnNlVHlwZVtcIkFwcE5vdGlmeVwiXSA9IDRdID0gXCJBcHBOb3RpZnlcIjtcbiAgICBSZXNwb25zZVR5cGVbUmVzcG9uc2VUeXBlW1wiQ3VzdG9tXCJdID0gMTAwXSA9IFwiQ3VzdG9tXCI7XG59KShSZXNwb25zZVR5cGUgPSBleHBvcnRzLlJlc3BvbnNlVHlwZSB8fCAoZXhwb3J0cy5SZXNwb25zZVR5cGUgPSB7fSkpO1xubGV0IGJyaWRnZSA9IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGdldEJyaWRnZSgpIHtcbiAgICBpZiAoIWJyaWRnZSkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVG9uQ2xpZW50RXJyb3IoMSwgXCJUT04gQ2xpZW50IGJpbmFyeSBicmlkZ2UgaXNuJ3Qgc2V0LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJyaWRnZTtcbn1cbmV4cG9ydHMuZ2V0QnJpZGdlID0gZ2V0QnJpZGdlO1xuZnVuY3Rpb24gdXNlTGlicmFyeShsb2FkZXIpIHtcbiAgICBpZiAoXCJjcmVhdGVDb250ZXh0XCIgaW4gbG9hZGVyKSB7XG4gICAgICAgIGJyaWRnZSA9IGxvYWRlcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJyaWRnZSA9IG5ldyBDb21tb25CaW5hcnlCcmlkZ2UobG9hZGVyKTtcbiAgICB9XG59XG5leHBvcnRzLnVzZUxpYnJhcnkgPSB1c2VMaWJyYXJ5O1xuY2xhc3MgQmluYXJ5TGlicmFyeUFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGxpYnJhcnkpIHtcbiAgICAgICAgdGhpcy5saWJyYXJ5ID0gbGlicmFyeTtcbiAgICB9XG4gICAgc2V0UmVzcG9uc2VQYXJhbXNIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5saWJyYXJ5LnNldFJlc3BvbnNlSGFuZGxlcih1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5saWJyYXJ5LnNldFJlc3BvbnNlSGFuZGxlcigocmVxdWVzdElkLCBwYXJhbXNKc29uLCByZXNwb25zZVR5cGUsIGZpbmlzaGVkKSA9PiBoYW5kbGVyKHJlcXVlc3RJZCwgcGFyYW1zSnNvbiAhPT0gXCJcIiA/IEpTT04ucGFyc2UocGFyYW1zSnNvbikgOiB1bmRlZmluZWQsIHJlc3BvbnNlVHlwZSwgZmluaXNoZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kUmVxdWVzdFBhcmFtcyhjb250ZXh0LCByZXF1ZXN0SWQsIGZ1bmN0aW9uTmFtZSwgZnVuY3Rpb25QYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zSnNvbiA9IChmdW5jdGlvblBhcmFtcyA9PT0gdW5kZWZpbmVkKSB8fCAoZnVuY3Rpb25QYXJhbXMgPT09IG51bGwpXG4gICAgICAgICAgICA/IFwiXCJcbiAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoZnVuY3Rpb25QYXJhbXMsIChfLCB2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiXG4gICAgICAgICAgICAgICAgPyAodmFsdWUgPCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJiB2YWx1ZSA+IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG4gICAgICAgICAgICAgICAgICAgID8gTnVtYmVyKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA6IHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgOiB2YWx1ZSk7XG4gICAgICAgIHRoaXMubGlicmFyeS5zZW5kUmVxdWVzdChjb250ZXh0LCByZXF1ZXN0SWQsIGZ1bmN0aW9uTmFtZSwgcGFyYW1zSnNvbik7XG4gICAgfVxuICAgIGNyZWF0ZUNvbnRleHQoY29uZmlnSnNvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5saWJyYXJ5LmNyZWF0ZUNvbnRleHQoY29uZmlnSnNvbik7XG4gICAgfVxuICAgIGRlc3Ryb3lDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5saWJyYXJ5LmRlc3Ryb3lDb250ZXh0KGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIENvbW1vbkJpbmFyeUJyaWRnZSB7XG4gICAgY29uc3RydWN0b3IobG9hZGVyKSB7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sb2FkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubGlicmFyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5uZXh0UmVxdWVzdElkID0gMTtcbiAgICAgICAgdGhpcy5jb250ZXh0Q291bnQgPSAwO1xuICAgICAgICB0aGlzLnJlc3BvbnNlSGFuZGxlckFzc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IFtdO1xuICAgICAgICBsb2FkZXIoKS50aGVuKChsaWJyYXJ5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzYXZlTG9hZGluZyA9IHRoaXMubG9hZGluZztcbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBsaWJyYXJ5V2l0aFBhcmFtcyA9IFwic2V0UmVzcG9uc2VQYXJhbXNIYW5kbGVyXCIgaW4gbGlicmFyeVxuICAgICAgICAgICAgICAgID8gbGlicmFyeVxuICAgICAgICAgICAgICAgIDogbmV3IEJpbmFyeUxpYnJhcnlBZGFwdGVyKGxpYnJhcnkpO1xuICAgICAgICAgICAgdGhpcy5saWJyYXJ5ID0gbGlicmFyeVdpdGhQYXJhbXM7XG4gICAgICAgICAgICBzYXZlTG9hZGluZyA9PT0gbnVsbCB8fCBzYXZlTG9hZGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2F2ZUxvYWRpbmcuZm9yRWFjaCh4ID0+IHgucmVzb2x2ZShsaWJyYXJ5V2l0aFBhcmFtcykpO1xuICAgICAgICB9LCAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzYXZlTG9hZGluZyA9IHRoaXMubG9hZGluZztcbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMubG9hZEVycm9yID0gcmVhc29uICE9PSBudWxsICYmIHJlYXNvbiAhPT0gdm9pZCAwID8gcmVhc29uIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgc2F2ZUxvYWRpbmcgPT09IG51bGwgfHwgc2F2ZUxvYWRpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNhdmVMb2FkaW5nLmZvckVhY2goeCA9PiB4LnJlamVjdChyZWFzb24pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNoZWNrUmVzcG9uc2VIYW5kbGVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtdXN0QmVBc3NpZ25lZCA9ICh0aGlzLmNvbnRleHRDb3VudCA+IDApIHx8ICh0aGlzLnJlcXVlc3RzLnNpemUgPiAwKTtcbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2VIYW5kbGVyQXNzaWduZWQgIT09IG11c3RCZUFzc2lnbmVkKSB7XG4gICAgICAgICAgICBpZiAobXVzdEJlQXNzaWduZWQpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmxpYnJhcnkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRSZXNwb25zZVBhcmFtc0hhbmRsZXIoKHJlcXVlc3RJZCwgcGFyYW1zLCByZXNwb25zZVR5cGUsIGZpbmlzaGVkKSA9PiB0aGlzLmhhbmRsZUxpYnJhcnlSZXNwb25zZShyZXF1ZXN0SWQsIHBhcmFtcywgcmVzcG9uc2VUeXBlLCBmaW5pc2hlZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy5saWJyYXJ5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2V0UmVzcG9uc2VQYXJhbXNIYW5kbGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlSGFuZGxlckFzc2lnbmVkID0gbXVzdEJlQXNzaWduZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlQ29udGV4dChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpYiA9IHRoaXMubGlicmFyeSB8fCAoeWllbGQgdGhpcy5sb2FkUmVxdWlyZWQoKSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRDb3VudCArPSAxO1xuICAgICAgICAgICAgcmV0dXJuIENvbW1vbkJpbmFyeUJyaWRnZS5wYXJzZVJlc3VsdCh5aWVsZCBsaWIuY3JlYXRlQ29udGV4dChKU09OLnN0cmluZ2lmeShjb25maWcpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXN0cm95Q29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5jb250ZXh0Q291bnQgPSBNYXRoLm1heCh0aGlzLmNvbnRleHRDb3VudCAtIDEsIDApO1xuICAgICAgICB0aGlzLmNoZWNrUmVzcG9uc2VIYW5kbGVyKCk7XG4gICAgICAgIChfYSA9IHRoaXMubGlicmFyeSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3lDb250ZXh0KGNvbnRleHQpO1xuICAgIH1cbiAgICByZXF1ZXN0KGNvbnRleHQsIGZ1bmN0aW9uTmFtZSwgZnVuY3Rpb25QYXJhbXMsIHJlc3BvbnNlSGFuZGxlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBsaWIgPSAoX2EgPSB0aGlzLmxpYnJhcnkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHlpZWxkIHRoaXMubG9hZFJlcXVpcmVkKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VIYW5kbGVyLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdElkID0gdGhpcy5nZW5lcmF0ZVJlcXVlc3RJZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdHMuc2V0KHJlcXVlc3RJZCwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1Jlc3BvbnNlSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIGxpYi5zZW5kUmVxdWVzdFBhcmFtcyhjb250ZXh0LCByZXF1ZXN0SWQsIGZ1bmN0aW9uTmFtZSwgZnVuY3Rpb25QYXJhbXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb2FkUmVxdWlyZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpYnJhcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmxpYnJhcnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvYWRFcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5sb2FkRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvYWRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvcnNfMS5Ub25DbGllbnRFcnJvcigxLCBcIlRPTiBDbGllbnQgYmluYXJ5IGxpYnJhcnkgaXNuJ3Qgc2V0LlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMubG9hZGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZW5lcmF0ZVJlcXVlc3RJZCgpIHtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLm5leHRSZXF1ZXN0SWQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFJlcXVlc3RJZCArPSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dFJlcXVlc3RJZCA+PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFJlcXVlc3RJZCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRoaXMucmVxdWVzdHMuaGFzKHRoaXMubmV4dFJlcXVlc3RJZCkpO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIGhhbmRsZUxpYnJhcnlSZXNwb25zZShyZXF1ZXN0SWQsIHBhcmFtcywgcmVzcG9uc2VUeXBlLCBmaW5pc2hlZCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1Jlc3BvbnNlSGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFJlc3BvbnNlVHlwZS5TdWNjZXNzOlxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzb2x2ZShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSZXNwb25zZVR5cGUuRXJyb3I6XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZWplY3QocGFyYW1zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBcHBPYmplY3RPckN1c3RvbSA9IHJlc3BvbnNlVHlwZSA9PT0gUmVzcG9uc2VUeXBlLkFwcE5vdGlmeVxuICAgICAgICAgICAgICAgICAgICB8fCByZXNwb25zZVR5cGUgPT09IFJlc3BvbnNlVHlwZS5BcHBSZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIHx8IHJlc3BvbnNlVHlwZSA+PSBSZXNwb25zZVR5cGUuQ3VzdG9tO1xuICAgICAgICAgICAgICAgIGlmIChpc0FwcE9iamVjdE9yQ3VzdG9tICYmIHJlcXVlc3QucmVzcG9uc2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VIYW5kbGVyKHBhcmFtcywgcmVzcG9uc2VUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhcnNlUmVzdWx0KHJlc3VsdEpzb24pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHRKc29uKTtcbiAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ub25DbGllbnRFcnJvcihyZXN1bHQuZXJyb3IuY29kZSwgcmVzdWx0LmVycm9yLm1lc3NhZ2UsIHJlc3VsdC5lcnJvci5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLkNvbW1vbkJpbmFyeUJyaWRnZSA9IENvbW1vbkJpbmFyeUJyaWRnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbi5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///819\n')},243:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n/*\n * Copyright 2018-2020 TON Labs LTD.\n *\n * Licensed under the SOFTWARE EVALUATION License (the "License"); you may not use\n * this file except in compliance with the License.\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific TON DEV software governing permissions and\n * limitations under the License.\n *\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.TonClient = void 0;\nconst modules_1 = __webpack_require__(691);\nconst bin_1 = __webpack_require__(819);\nclass TonClient {\n    constructor(config) {\n        this.context = undefined;\n        this.contextCreation = undefined;\n        this.contextError = undefined;\n        this.config = config !== null && config !== void 0 ? config : {};\n        this.client = new modules_1.ClientModule(this);\n        this.crypto = new modules_1.CryptoModule(this);\n        this.abi = new modules_1.AbiModule(this);\n        this.boc = new modules_1.BocModule(this);\n        this.processing = new modules_1.ProcessingModule(this);\n        this.utils = new modules_1.UtilsModule(this);\n        this.net = new modules_1.NetModule(this);\n        this.tvm = new modules_1.TvmModule(this);\n        this.proofs = new modules_1.ProofsModule(this);\n    }\n    static set default(client) {\n        this._default = client;\n    }\n    static get default() {\n        if (this._default === null) {\n            this._default = new TonClient(this._defaultConfig);\n        }\n        return this._default;\n    }\n    static set defaultConfig(config) {\n        this._defaultConfig = config;\n    }\n    static get defaultConfig() {\n        return this._defaultConfig;\n    }\n    static useBinaryLibrary(loader) {\n        (0, bin_1.useLibrary)(loader);\n    }\n    static toKey(d) {\n        return toHex(d, 256);\n    }\n    static toHash64(d) {\n        return toHex(d, 64);\n    }\n    static toHash128(d) {\n        return toHex(d, 128);\n    }\n    static toHash256(d) {\n        return toHex(d, 256);\n    }\n    static toHash512(d) {\n        return toHex(d, 512);\n    }\n    static toHex(dec, bits = 0) {\n        return toHex(dec, bits);\n    }\n    close() {\n        const context = this.context;\n        if (context !== undefined) {\n            this.context = undefined;\n            (0, bin_1.getBridge)().destroyContext(context);\n        }\n    }\n    resolveError(functionName, params, err) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (err.code !== 23 || !((_a = err.data) === null || _a === void 0 ? void 0 : _a.suggest_use_helper_for)) {\n                return err;\n            }\n            try {\n                const [modName, funcName] = functionName.split(".");\n                const api = (yield this.client.get_api_reference()).api;\n                const allTypesArray = api.modules.reduce((accumulator, element) => accumulator.concat(element.types), []);\n                const allTypesDict = {};\n                allTypesArray.forEach((element) => allTypesDict[element.name] = element);\n                const module = api.modules.find((x) => x.name === modName);\n                const func = module.functions.find((x) => x.name === funcName);\n                const param = func.params[1];\n                // If there is only context param (or AppObject second param), there is nothing to analyze\n                if (!param || param.generic_name == "AppObject") {\n                    return err;\n                }\n                const paramTypeInfo = allTypesDict[param.ref_name];\n                walkParameters(paramTypeInfo, params, "");\n                function walkParameters(valueTypeInfo, value, path) {\n                    switch (valueTypeInfo.type) {\n                        case "Array":\n                            if (Array.isArray(value)) {\n                                value.forEach(v => walkParameters(valueTypeInfo.array_item, v, `${path}[i]`));\n                            }\n                            break;\n                        case "Struct":\n                            valueTypeInfo.struct_fields.forEach((sf) => walkParameters(sf, value[sf.name], path ? `${path}.${sf.name}` : sf.name));\n                            break;\n                        case "Optional":\n                            if (value) {\n                                walkParameters(valueTypeInfo.optional_inner, value, path);\n                            }\n                            break;\n                        case "Ref":\n                            if (valueTypeInfo.ref_name != "Value" &&\n                                valueTypeInfo.ref_name != "API" &&\n                                valueTypeInfo.ref_name != "AbiParam") {\n                                walkParameters(allTypesDict[valueTypeInfo.ref_name], value, path);\n                            }\n                            break;\n                        case "EnumOfTypes":\n                            if (valueTypeInfo.enum_types.some((et) => et.name == value.type)) {\n                                return;\n                            }\n                            let parameterName = valueTypeInfo.name.toLowerCase();\n                            let helperFunctions = [];\n                            valueTypeInfo.enum_types.forEach((et) => helperFunctions.push(parameterName + et.name));\n                            err.message = `Consider using one of the helper methods (${helperFunctions.join(", ")}) for the \\"${path}\\" parameter\\n` + err.message;\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n            catch (e) {\n                err.message = (_b = e.message) !== null && _b !== void 0 ? _b : `${e}`;\n            }\n            return err;\n        });\n    }\n    contextRequired() {\n        if (this.context !== undefined) {\n            return Promise.resolve(this.context);\n        }\n        if (this.contextError !== undefined) {\n            return Promise.reject(this.contextError);\n        }\n        if (this.contextCreation === undefined) {\n            this.contextCreation = [];\n            (0, bin_1.getBridge)().createContext(this.config).then((context) => {\n                const creation = this.contextCreation;\n                this.contextCreation = undefined;\n                this.context = context;\n                creation === null || creation === void 0 ? void 0 : creation.forEach(x => x.resolve(context));\n            }, (reason) => {\n                const creation = this.contextCreation;\n                this.contextCreation = undefined;\n                this.contextError = reason !== null && reason !== void 0 ? reason : undefined;\n                creation === null || creation === void 0 ? void 0 : creation.forEach(x => x.reject(reason));\n            });\n        }\n        return new Promise((resolve, reject) => {\n            var _a;\n            (_a = this.contextCreation) === null || _a === void 0 ? void 0 : _a.push({\n                resolve,\n                reject,\n            });\n        });\n    }\n    request(functionName, functionParams, responseHandler) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const context = (_a = this.context) !== null && _a !== void 0 ? _a : yield this.contextRequired();\n            return (0, bin_1.getBridge)()\n                .request(context, functionName, functionParams, responseHandler !== null && responseHandler !== void 0 ? responseHandler : (() => {\n            }))\n                .catch((reason) => __awaiter(this, void 0, void 0, function* () {\n                throw yield this.resolveError(functionName, functionParams, reason);\n            }));\n        });\n    }\n    resolve_app_request(app_request_id, result) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (app_request_id) {\n                yield this.client.resolve_app_request({\n                    app_request_id,\n                    result: {\n                        type: "Ok",\n                        result,\n                    },\n                });\n            }\n        });\n    }\n    reject_app_request(app_request_id, error) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (app_request_id) {\n                yield this.client.resolve_app_request({\n                    app_request_id,\n                    result: {\n                        type: "Error",\n                        text: error.message,\n                    },\n                });\n            }\n        });\n    }\n}\nexports.TonClient = TonClient;\nTonClient._defaultConfig = {};\nTonClient._default = null;\n// Converts value to hex\nfunction toHex(value, bits) {\n    let hex;\n    if (typeof value === "number" || typeof value === "bigint") {\n        hex = value.toString(16);\n    }\n    else if (typeof value === "string") {\n        if (value.startsWith("0x")) {\n            hex = value.substring(2);\n        }\n        else {\n            hex = decToHex(value);\n        }\n    }\n    else {\n        hex = value.toString();\n    }\n    let len = bits / 4;\n    while (hex.length > len && hex.startsWith("0")) {\n        hex = hex.substring(1);\n    }\n    return hex.padStart(len, "0");\n}\nfunction decToHex(dec) {\n    var _a;\n    let bigNum = [];\n    for (let i = 0; i < dec.length; i += 1) {\n        const d = ((_a = dec.codePointAt(i)) !== null && _a !== void 0 ? _a : 0) - 48;\n        const mul8 = shl(bigNum, 3);\n        const mul2 = shl(bigNum, 1);\n        const mul10 = add(mul8, mul2);\n        bigNum = add(mul10, [d]);\n    }\n    let hex = "";\n    for (let i = bigNum.length - 1; i >= 0; i -= 1) {\n        hex += bigNum[i].toString(16).padStart(4, "0");\n    }\n    return hex;\n}\nfunction shl(bigNum, bits) {\n    let rest = 0;\n    const result = [];\n    for (let i = 0; i < bigNum.length; i += 1) {\n        let v = (bigNum[i] << bits) + rest;\n        result.push(v & 0xFFFF);\n        rest = (v >> 16) & 0xFFFF;\n    }\n    if (rest > 0) {\n        result.push(rest);\n    }\n    return result;\n}\nfunction add(a, b) {\n    let rest = 0;\n    const result = [];\n    const len = Math.max(a.length, b.length);\n    for (let i = 0; i < len; i += 1) {\n        let v = (i < a.length ? a[i] : 0) + (i < b.length ? b[i] : 0) + rest;\n        result.push(v & 0xFFFF);\n        rest = (v >> 16) & 0xFFFF;\n    }\n    if (rest > 0) {\n        result.push(rest);\n    }\n    return result;\n}\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL0BldmVyc2RrL2NvcmUvZGlzdC9jbGllbnQuanM/YmY4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOC0yMDIwIFRPTiBMYWJzIExURC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgU09GVFdBUkUgRVZBTFVBVElPTiBMaWNlbnNlICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcbiAqIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgVE9OIERFViBzb2Z0d2FyZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ub25DbGllbnQgPSB2b2lkIDA7XG5jb25zdCBtb2R1bGVzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGVzXCIpO1xuY29uc3QgYmluXzEgPSByZXF1aXJlKFwiLi9iaW5cIik7XG5jbGFzcyBUb25DbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29udGV4dENyZWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbnRleHRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWcgIT09IG51bGwgJiYgY29uZmlnICE9PSB2b2lkIDAgPyBjb25maWcgOiB7fTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBuZXcgbW9kdWxlc18xLkNsaWVudE1vZHVsZSh0aGlzKTtcbiAgICAgICAgdGhpcy5jcnlwdG8gPSBuZXcgbW9kdWxlc18xLkNyeXB0b01vZHVsZSh0aGlzKTtcbiAgICAgICAgdGhpcy5hYmkgPSBuZXcgbW9kdWxlc18xLkFiaU1vZHVsZSh0aGlzKTtcbiAgICAgICAgdGhpcy5ib2MgPSBuZXcgbW9kdWxlc18xLkJvY01vZHVsZSh0aGlzKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nID0gbmV3IG1vZHVsZXNfMS5Qcm9jZXNzaW5nTW9kdWxlKHRoaXMpO1xuICAgICAgICB0aGlzLnV0aWxzID0gbmV3IG1vZHVsZXNfMS5VdGlsc01vZHVsZSh0aGlzKTtcbiAgICAgICAgdGhpcy5uZXQgPSBuZXcgbW9kdWxlc18xLk5ldE1vZHVsZSh0aGlzKTtcbiAgICAgICAgdGhpcy50dm0gPSBuZXcgbW9kdWxlc18xLlR2bU1vZHVsZSh0aGlzKTtcbiAgICAgICAgdGhpcy5wcm9vZnMgPSBuZXcgbW9kdWxlc18xLlByb29mc01vZHVsZSh0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIHNldCBkZWZhdWx0KGNsaWVudCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0ID0gY2xpZW50O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGRlZmF1bHQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWZhdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0ID0gbmV3IFRvbkNsaWVudCh0aGlzLl9kZWZhdWx0Q29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdDtcbiAgICB9XG4gICAgc3RhdGljIHNldCBkZWZhdWx0Q29uZmlnKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9kZWZhdWx0Q29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGRlZmF1bHRDb25maWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0Q29uZmlnO1xuICAgIH1cbiAgICBzdGF0aWMgdXNlQmluYXJ5TGlicmFyeShsb2FkZXIpIHtcbiAgICAgICAgKDAsIGJpbl8xLnVzZUxpYnJhcnkpKGxvYWRlcik7XG4gICAgfVxuICAgIHN0YXRpYyB0b0tleShkKSB7XG4gICAgICAgIHJldHVybiB0b0hleChkLCAyNTYpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9IYXNoNjQoZCkge1xuICAgICAgICByZXR1cm4gdG9IZXgoZCwgNjQpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9IYXNoMTI4KGQpIHtcbiAgICAgICAgcmV0dXJuIHRvSGV4KGQsIDEyOCk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0hhc2gyNTYoZCkge1xuICAgICAgICByZXR1cm4gdG9IZXgoZCwgMjU2KTtcbiAgICB9XG4gICAgc3RhdGljIHRvSGFzaDUxMihkKSB7XG4gICAgICAgIHJldHVybiB0b0hleChkLCA1MTIpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9IZXgoZGVjLCBiaXRzID0gMCkge1xuICAgICAgICByZXR1cm4gdG9IZXgoZGVjLCBiaXRzKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICgwLCBiaW5fMS5nZXRCcmlkZ2UpKCkuZGVzdHJveUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzb2x2ZUVycm9yKGZ1bmN0aW9uTmFtZSwgcGFyYW1zLCBlcnIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChlcnIuY29kZSAhPT0gMjMgfHwgISgoX2EgPSBlcnIuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN1Z2dlc3RfdXNlX2hlbHBlcl9mb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW21vZE5hbWUsIGZ1bmNOYW1lXSA9IGZ1bmN0aW9uTmFtZS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBpID0gKHlpZWxkIHRoaXMuY2xpZW50LmdldF9hcGlfcmVmZXJlbmNlKCkpLmFwaTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxUeXBlc0FycmF5ID0gYXBpLm1vZHVsZXMucmVkdWNlKChhY2N1bXVsYXRvciwgZWxlbWVudCkgPT4gYWNjdW11bGF0b3IuY29uY2F0KGVsZW1lbnQudHlwZXMpLCBbXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsVHlwZXNEaWN0ID0ge307XG4gICAgICAgICAgICAgICAgYWxsVHlwZXNBcnJheS5mb3JFYWNoKChlbGVtZW50KSA9PiBhbGxUeXBlc0RpY3RbZWxlbWVudC5uYW1lXSA9IGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IGFwaS5tb2R1bGVzLmZpbmQoKHgpID0+IHgubmFtZSA9PT0gbW9kTmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVuYyA9IG1vZHVsZS5mdW5jdGlvbnMuZmluZCgoeCkgPT4geC5uYW1lID09PSBmdW5jTmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW0gPSBmdW5jLnBhcmFtc1sxXTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IGNvbnRleHQgcGFyYW0gKG9yIEFwcE9iamVjdCBzZWNvbmQgcGFyYW0pLCB0aGVyZSBpcyBub3RoaW5nIHRvIGFuYWx5emVcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtIHx8IHBhcmFtLmdlbmVyaWNfbmFtZSA9PSBcIkFwcE9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtVHlwZUluZm8gPSBhbGxUeXBlc0RpY3RbcGFyYW0ucmVmX25hbWVdO1xuICAgICAgICAgICAgICAgIHdhbGtQYXJhbWV0ZXJzKHBhcmFtVHlwZUluZm8sIHBhcmFtcywgXCJcIik7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gd2Fsa1BhcmFtZXRlcnModmFsdWVUeXBlSW5mbywgdmFsdWUsIHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZVR5cGVJbmZvLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKHYgPT4gd2Fsa1BhcmFtZXRlcnModmFsdWVUeXBlSW5mby5hcnJheV9pdGVtLCB2LCBgJHtwYXRofVtpXWApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiU3RydWN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVUeXBlSW5mby5zdHJ1Y3RfZmllbGRzLmZvckVhY2goKHNmKSA9PiB3YWxrUGFyYW1ldGVycyhzZiwgdmFsdWVbc2YubmFtZV0sIHBhdGggPyBgJHtwYXRofS4ke3NmLm5hbWV9YCA6IHNmLm5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJPcHRpb25hbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxrUGFyYW1ldGVycyh2YWx1ZVR5cGVJbmZvLm9wdGlvbmFsX2lubmVyLCB2YWx1ZSwgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlJlZlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVR5cGVJbmZvLnJlZl9uYW1lICE9IFwiVmFsdWVcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVR5cGVJbmZvLnJlZl9uYW1lICE9IFwiQVBJXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVUeXBlSW5mby5yZWZfbmFtZSAhPSBcIkFiaVBhcmFtXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Fsa1BhcmFtZXRlcnMoYWxsVHlwZXNEaWN0W3ZhbHVlVHlwZUluZm8ucmVmX25hbWVdLCB2YWx1ZSwgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkVudW1PZlR5cGVzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlVHlwZUluZm8uZW51bV90eXBlcy5zb21lKChldCkgPT4gZXQubmFtZSA9PSB2YWx1ZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJhbWV0ZXJOYW1lID0gdmFsdWVUeXBlSW5mby5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhlbHBlckZ1bmN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlVHlwZUluZm8uZW51bV90eXBlcy5mb3JFYWNoKChldCkgPT4gaGVscGVyRnVuY3Rpb25zLnB1c2gocGFyYW1ldGVyTmFtZSArIGV0Lm5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBDb25zaWRlciB1c2luZyBvbmUgb2YgdGhlIGhlbHBlciBtZXRob2RzICgke2hlbHBlckZ1bmN0aW9ucy5qb2luKFwiLCBcIil9KSBmb3IgdGhlIFxcXCIke3BhdGh9XFxcIiBwYXJhbWV0ZXJcXG5gICsgZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IChfYiA9IGUubWVzc2FnZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogYCR7ZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnRleHRSZXF1aXJlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dEVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmNvbnRleHRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dENyZWF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dENyZWF0aW9uID0gW107XG4gICAgICAgICAgICAoMCwgYmluXzEuZ2V0QnJpZGdlKSgpLmNyZWF0ZUNvbnRleHQodGhpcy5jb25maWcpLnRoZW4oKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcmVhdGlvbiA9IHRoaXMuY29udGV4dENyZWF0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dENyZWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgY3JlYXRpb24gPT09IG51bGwgfHwgY3JlYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWF0aW9uLmZvckVhY2goeCA9PiB4LnJlc29sdmUoY29udGV4dCkpO1xuICAgICAgICAgICAgfSwgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0aW9uID0gdGhpcy5jb250ZXh0Q3JlYXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0Q3JlYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0RXJyb3IgPSByZWFzb24gIT09IG51bGwgJiYgcmVhc29uICE9PSB2b2lkIDAgPyByZWFzb24gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY3JlYXRpb24gPT09IG51bGwgfHwgY3JlYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWF0aW9uLmZvckVhY2goeCA9PiB4LnJlamVjdChyZWFzb24pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmNvbnRleHRDcmVhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXF1ZXN0KGZ1bmN0aW9uTmFtZSwgZnVuY3Rpb25QYXJhbXMsIHJlc3BvbnNlSGFuZGxlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gKF9hID0gdGhpcy5jb250ZXh0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB5aWVsZCB0aGlzLmNvbnRleHRSZXF1aXJlZCgpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBiaW5fMS5nZXRCcmlkZ2UpKClcbiAgICAgICAgICAgICAgICAucmVxdWVzdChjb250ZXh0LCBmdW5jdGlvbk5hbWUsIGZ1bmN0aW9uUGFyYW1zLCByZXNwb25zZUhhbmRsZXIgIT09IG51bGwgJiYgcmVzcG9uc2VIYW5kbGVyICE9PSB2b2lkIDAgPyByZXNwb25zZUhhbmRsZXIgOiAoKCkgPT4ge1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChyZWFzb24pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB5aWVsZCB0aGlzLnJlc29sdmVFcnJvcihmdW5jdGlvbk5hbWUsIGZ1bmN0aW9uUGFyYW1zLCByZWFzb24pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzb2x2ZV9hcHBfcmVxdWVzdChhcHBfcmVxdWVzdF9pZCwgcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoYXBwX3JlcXVlc3RfaWQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNsaWVudC5yZXNvbHZlX2FwcF9yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgYXBwX3JlcXVlc3RfaWQsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJPa1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVqZWN0X2FwcF9yZXF1ZXN0KGFwcF9yZXF1ZXN0X2lkLCBlcnJvcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGFwcF9yZXF1ZXN0X2lkKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jbGllbnQucmVzb2x2ZV9hcHBfcmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIGFwcF9yZXF1ZXN0X2lkLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuVG9uQ2xpZW50ID0gVG9uQ2xpZW50O1xuVG9uQ2xpZW50Ll9kZWZhdWx0Q29uZmlnID0ge307XG5Ub25DbGllbnQuX2RlZmF1bHQgPSBudWxsO1xuLy8gQ29udmVydHMgdmFsdWUgdG8gaGV4XG5mdW5jdGlvbiB0b0hleCh2YWx1ZSwgYml0cykge1xuICAgIGxldCBoZXg7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgaGV4ID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgICAgICAgaGV4ID0gdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGV4ID0gZGVjVG9IZXgodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoZXggPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICBsZXQgbGVuID0gYml0cyAvIDQ7XG4gICAgd2hpbGUgKGhleC5sZW5ndGggPiBsZW4gJiYgaGV4LnN0YXJ0c1dpdGgoXCIwXCIpKSB7XG4gICAgICAgIGhleCA9IGhleC5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIHJldHVybiBoZXgucGFkU3RhcnQobGVuLCBcIjBcIik7XG59XG5mdW5jdGlvbiBkZWNUb0hleChkZWMpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGJpZ051bSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGQgPSAoKF9hID0gZGVjLmNvZGVQb2ludEF0KGkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSAtIDQ4O1xuICAgICAgICBjb25zdCBtdWw4ID0gc2hsKGJpZ051bSwgMyk7XG4gICAgICAgIGNvbnN0IG11bDIgPSBzaGwoYmlnTnVtLCAxKTtcbiAgICAgICAgY29uc3QgbXVsMTAgPSBhZGQobXVsOCwgbXVsMik7XG4gICAgICAgIGJpZ051bSA9IGFkZChtdWwxMCwgW2RdKTtcbiAgICB9XG4gICAgbGV0IGhleCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IGJpZ051bS5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBoZXggKz0gYmlnTnVtW2ldLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg0LCBcIjBcIik7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5mdW5jdGlvbiBzaGwoYmlnTnVtLCBiaXRzKSB7XG4gICAgbGV0IHJlc3QgPSAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmlnTnVtLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCB2ID0gKGJpZ051bVtpXSA8PCBiaXRzKSArIHJlc3Q7XG4gICAgICAgIHJlc3VsdC5wdXNoKHYgJiAweEZGRkYpO1xuICAgICAgICByZXN0ID0gKHYgPj4gMTYpICYgMHhGRkZGO1xuICAgIH1cbiAgICBpZiAocmVzdCA+IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocmVzdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhZGQoYSwgYikge1xuICAgIGxldCByZXN0ID0gMDtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBsZW4gPSBNYXRoLm1heChhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IHYgPSAoaSA8IGEubGVuZ3RoID8gYVtpXSA6IDApICsgKGkgPCBiLmxlbmd0aCA/IGJbaV0gOiAwKSArIHJlc3Q7XG4gICAgICAgIHJlc3VsdC5wdXNoKHYgJiAweEZGRkYpO1xuICAgICAgICByZXN0ID0gKHYgPj4gMTYpICYgMHhGRkZGO1xuICAgIH1cbiAgICBpZiAocmVzdCA+IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocmVzdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///243\n')},504:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.TonClientError = void 0;\nclass TonClientError extends Error {\n    constructor(code, message, data) {\n        super(message);\n        this.code = code;\n        this.data = data;\n    }\n}\nexports.TonClientError = TonClientError;\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL0BldmVyc2RrL2NvcmUvZGlzdC9lcnJvcnMuanM/MTE4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVG9uQ2xpZW50RXJyb3IgPSB2b2lkIDA7XG5jbGFzcyBUb25DbGllbnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbmV4cG9ydHMuVG9uQ2xpZW50RXJyb3IgPSBUb25DbGllbnRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///504\n')},206:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n__exportStar(__webpack_require__(691), exports);\n__exportStar(__webpack_require__(243), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL0BldmVyc2RrL2NvcmUvZGlzdC9pbmRleC5qcz8xYTM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kdWxlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2xpZW50XCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///206\n')},691:function(__unused_webpack_module,exports){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.builderOpInteger = exports.BocErrorCode = exports.bocCacheTypeUnpinned = exports.bocCacheTypePinned = exports.AbiModule = exports.messageSourceEncodingParams = exports.messageSourceEncoded = exports.stateInitSourceTvc = exports.stateInitSourceStateInit = exports.stateInitSourceMessage = exports.MessageBodyType = exports.signerSigningBox = exports.signerKeys = exports.signerExternal = exports.signerNone = exports.abiSerialized = exports.abiHandle = exports.abiJson = exports.abiContract = exports.AbiErrorCode = exports.CryptoModule = exports.resultOfAppEncryptionBoxDecrypt = exports.resultOfAppEncryptionBoxEncrypt = exports.resultOfAppEncryptionBoxGetInfo = exports.paramsOfAppEncryptionBoxDecrypt = exports.paramsOfAppEncryptionBoxEncrypt = exports.paramsOfAppEncryptionBoxGetInfo = exports.resultOfAppSigningBoxSign = exports.resultOfAppSigningBoxGetPublicKey = exports.paramsOfAppSigningBoxSign = exports.paramsOfAppSigningBoxGetPublicKey = exports.resultOfAppPasswordProviderGetPassword = exports.paramsOfAppPasswordProviderGetPassword = exports.boxEncryptionAlgorithmNaclSecretBox = exports.boxEncryptionAlgorithmNaclBox = exports.boxEncryptionAlgorithmChaCha20 = exports.cryptoBoxSecretEncryptedSecret = exports.cryptoBoxSecretPredefinedSeedPhrase = exports.cryptoBoxSecretRandomSeedPhrase = exports.CipherMode = exports.encryptionAlgorithmNaclSecretBox = exports.encryptionAlgorithmNaclBox = exports.encryptionAlgorithmChaCha20 = exports.encryptionAlgorithmAES = exports.CryptoErrorCode = exports.ClientModule = exports.appRequestResultOk = exports.appRequestResultError = exports.NetworkQueriesProtocol = exports.ClientErrorCode = void 0;\nexports.resultOfAppDebotBrowserInput = exports.paramsOfAppDebotBrowserApprove = exports.paramsOfAppDebotBrowserSend = exports.paramsOfAppDebotBrowserInvokeDebot = exports.paramsOfAppDebotBrowserGetSigningBox = exports.paramsOfAppDebotBrowserInput = exports.paramsOfAppDebotBrowserShowAction = exports.paramsOfAppDebotBrowserSwitchCompleted = exports.paramsOfAppDebotBrowserSwitch = exports.paramsOfAppDebotBrowserLog = exports.debotActivityTransaction = exports.DebotErrorCode = exports.NetModule = exports.AggregationFn = exports.paramsOfQueryOperationQueryCounterparties = exports.paramsOfQueryOperationAggregateCollection = exports.paramsOfQueryOperationWaitForCollection = exports.paramsOfQueryOperationQueryCollection = exports.SortDirection = exports.NetErrorCode = exports.TvmModule = exports.accountForExecutorAccount = exports.accountForExecutorUninit = exports.accountForExecutorNone = exports.TvmErrorCode = exports.UtilsModule = exports.AccountAddressType = exports.addressStringFormatBase64 = exports.addressStringFormatHex = exports.addressStringFormatAccountId = exports.ProcessingModule = exports.processingEventRempError = exports.processingEventRempOther = exports.processingEventRempIncludedIntoAcceptedBlock = exports.processingEventRempIncludedIntoBlock = exports.processingEventRempSentToValidators = exports.processingEventMessageExpired = exports.processingEventFetchNextBlockFailed = exports.processingEventWillFetchNextBlock = exports.processingEventSendFailed = exports.processingEventDidSend = exports.processingEventWillSend = exports.processingEventFetchFirstBlockFailed = exports.processingEventWillFetchFirstBlock = exports.ProcessingErrorCode = exports.BocModule = exports.builderOpAddress = exports.builderOpCellBoc = exports.builderOpCell = exports.builderOpBitString = void 0;\nexports.ProofsModule = exports.ProofsErrorCode = exports.DebotModule = exports.resultOfAppDebotBrowserApprove = exports.resultOfAppDebotBrowserInvokeDebot = exports.resultOfAppDebotBrowserGetSigningBox = void 0;\n// client module\nvar ClientErrorCode;\n(function (ClientErrorCode) {\n    ClientErrorCode[ClientErrorCode["NotImplemented"] = 1] = "NotImplemented";\n    ClientErrorCode[ClientErrorCode["InvalidHex"] = 2] = "InvalidHex";\n    ClientErrorCode[ClientErrorCode["InvalidBase64"] = 3] = "InvalidBase64";\n    ClientErrorCode[ClientErrorCode["InvalidAddress"] = 4] = "InvalidAddress";\n    ClientErrorCode[ClientErrorCode["CallbackParamsCantBeConvertedToJson"] = 5] = "CallbackParamsCantBeConvertedToJson";\n    ClientErrorCode[ClientErrorCode["WebsocketConnectError"] = 6] = "WebsocketConnectError";\n    ClientErrorCode[ClientErrorCode["WebsocketReceiveError"] = 7] = "WebsocketReceiveError";\n    ClientErrorCode[ClientErrorCode["WebsocketSendError"] = 8] = "WebsocketSendError";\n    ClientErrorCode[ClientErrorCode["HttpClientCreateError"] = 9] = "HttpClientCreateError";\n    ClientErrorCode[ClientErrorCode["HttpRequestCreateError"] = 10] = "HttpRequestCreateError";\n    ClientErrorCode[ClientErrorCode["HttpRequestSendError"] = 11] = "HttpRequestSendError";\n    ClientErrorCode[ClientErrorCode["HttpRequestParseError"] = 12] = "HttpRequestParseError";\n    ClientErrorCode[ClientErrorCode["CallbackNotRegistered"] = 13] = "CallbackNotRegistered";\n    ClientErrorCode[ClientErrorCode["NetModuleNotInit"] = 14] = "NetModuleNotInit";\n    ClientErrorCode[ClientErrorCode["InvalidConfig"] = 15] = "InvalidConfig";\n    ClientErrorCode[ClientErrorCode["CannotCreateRuntime"] = 16] = "CannotCreateRuntime";\n    ClientErrorCode[ClientErrorCode["InvalidContextHandle"] = 17] = "InvalidContextHandle";\n    ClientErrorCode[ClientErrorCode["CannotSerializeResult"] = 18] = "CannotSerializeResult";\n    ClientErrorCode[ClientErrorCode["CannotSerializeError"] = 19] = "CannotSerializeError";\n    ClientErrorCode[ClientErrorCode["CannotConvertJsValueToJson"] = 20] = "CannotConvertJsValueToJson";\n    ClientErrorCode[ClientErrorCode["CannotReceiveSpawnedResult"] = 21] = "CannotReceiveSpawnedResult";\n    ClientErrorCode[ClientErrorCode["SetTimerError"] = 22] = "SetTimerError";\n    ClientErrorCode[ClientErrorCode["InvalidParams"] = 23] = "InvalidParams";\n    ClientErrorCode[ClientErrorCode["ContractsAddressConversionFailed"] = 24] = "ContractsAddressConversionFailed";\n    ClientErrorCode[ClientErrorCode["UnknownFunction"] = 25] = "UnknownFunction";\n    ClientErrorCode[ClientErrorCode["AppRequestError"] = 26] = "AppRequestError";\n    ClientErrorCode[ClientErrorCode["NoSuchRequest"] = 27] = "NoSuchRequest";\n    ClientErrorCode[ClientErrorCode["CanNotSendRequestResult"] = 28] = "CanNotSendRequestResult";\n    ClientErrorCode[ClientErrorCode["CanNotReceiveRequestResult"] = 29] = "CanNotReceiveRequestResult";\n    ClientErrorCode[ClientErrorCode["CanNotParseRequestResult"] = 30] = "CanNotParseRequestResult";\n    ClientErrorCode[ClientErrorCode["UnexpectedCallbackResponse"] = 31] = "UnexpectedCallbackResponse";\n    ClientErrorCode[ClientErrorCode["CanNotParseNumber"] = 32] = "CanNotParseNumber";\n    ClientErrorCode[ClientErrorCode["InternalError"] = 33] = "InternalError";\n    ClientErrorCode[ClientErrorCode["InvalidHandle"] = 34] = "InvalidHandle";\n    ClientErrorCode[ClientErrorCode["LocalStorageError"] = 35] = "LocalStorageError";\n})(ClientErrorCode = exports.ClientErrorCode || (exports.ClientErrorCode = {}));\n/**\n * Network protocol used to perform GraphQL queries.\n */\nvar NetworkQueriesProtocol;\n(function (NetworkQueriesProtocol) {\n    NetworkQueriesProtocol["HTTP"] = "HTTP";\n    NetworkQueriesProtocol["WS"] = "WS";\n})(NetworkQueriesProtocol = exports.NetworkQueriesProtocol || (exports.NetworkQueriesProtocol = {}));\nfunction appRequestResultError(text) {\n    return {\n        type: \'Error\',\n        text,\n    };\n}\nexports.appRequestResultError = appRequestResultError;\nfunction appRequestResultOk(result) {\n    return {\n        type: \'Ok\',\n        result,\n    };\n}\nexports.appRequestResultOk = appRequestResultOk;\n/**\n * Provides information about library.\n */\nclass ClientModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Returns Core Library API reference\n     * @returns ResultOfGetApiReference\n     */\n    get_api_reference() {\n        return this.client.request(\'client.get_api_reference\');\n    }\n    /**\n     * Returns Core Library version\n     * @returns ResultOfVersion\n     */\n    version() {\n        return this.client.request(\'client.version\');\n    }\n    /**\n     * Returns Core Library API reference\n     * @returns ClientConfig\n     */\n    config() {\n        return this.client.request(\'client.config\');\n    }\n    /**\n     * Returns detailed information about this build.\n     * @returns ResultOfBuildInfo\n     */\n    build_info() {\n        return this.client.request(\'client.build_info\');\n    }\n    /**\n     * Resolves application request processing result\n     *\n     * @param {ParamsOfResolveAppRequest} params\n     * @returns\n     */\n    resolve_app_request(params) {\n        return this.client.request(\'client.resolve_app_request\', params);\n    }\n}\nexports.ClientModule = ClientModule;\n// crypto module\nvar CryptoErrorCode;\n(function (CryptoErrorCode) {\n    CryptoErrorCode[CryptoErrorCode["InvalidPublicKey"] = 100] = "InvalidPublicKey";\n    CryptoErrorCode[CryptoErrorCode["InvalidSecretKey"] = 101] = "InvalidSecretKey";\n    CryptoErrorCode[CryptoErrorCode["InvalidKey"] = 102] = "InvalidKey";\n    CryptoErrorCode[CryptoErrorCode["InvalidFactorizeChallenge"] = 106] = "InvalidFactorizeChallenge";\n    CryptoErrorCode[CryptoErrorCode["InvalidBigInt"] = 107] = "InvalidBigInt";\n    CryptoErrorCode[CryptoErrorCode["ScryptFailed"] = 108] = "ScryptFailed";\n    CryptoErrorCode[CryptoErrorCode["InvalidKeySize"] = 109] = "InvalidKeySize";\n    CryptoErrorCode[CryptoErrorCode["NaclSecretBoxFailed"] = 110] = "NaclSecretBoxFailed";\n    CryptoErrorCode[CryptoErrorCode["NaclBoxFailed"] = 111] = "NaclBoxFailed";\n    CryptoErrorCode[CryptoErrorCode["NaclSignFailed"] = 112] = "NaclSignFailed";\n    CryptoErrorCode[CryptoErrorCode["Bip39InvalidEntropy"] = 113] = "Bip39InvalidEntropy";\n    CryptoErrorCode[CryptoErrorCode["Bip39InvalidPhrase"] = 114] = "Bip39InvalidPhrase";\n    CryptoErrorCode[CryptoErrorCode["Bip32InvalidKey"] = 115] = "Bip32InvalidKey";\n    CryptoErrorCode[CryptoErrorCode["Bip32InvalidDerivePath"] = 116] = "Bip32InvalidDerivePath";\n    CryptoErrorCode[CryptoErrorCode["Bip39InvalidDictionary"] = 117] = "Bip39InvalidDictionary";\n    CryptoErrorCode[CryptoErrorCode["Bip39InvalidWordCount"] = 118] = "Bip39InvalidWordCount";\n    CryptoErrorCode[CryptoErrorCode["MnemonicGenerationFailed"] = 119] = "MnemonicGenerationFailed";\n    CryptoErrorCode[CryptoErrorCode["MnemonicFromEntropyFailed"] = 120] = "MnemonicFromEntropyFailed";\n    CryptoErrorCode[CryptoErrorCode["SigningBoxNotRegistered"] = 121] = "SigningBoxNotRegistered";\n    CryptoErrorCode[CryptoErrorCode["InvalidSignature"] = 122] = "InvalidSignature";\n    CryptoErrorCode[CryptoErrorCode["EncryptionBoxNotRegistered"] = 123] = "EncryptionBoxNotRegistered";\n    CryptoErrorCode[CryptoErrorCode["InvalidIvSize"] = 124] = "InvalidIvSize";\n    CryptoErrorCode[CryptoErrorCode["UnsupportedCipherMode"] = 125] = "UnsupportedCipherMode";\n    CryptoErrorCode[CryptoErrorCode["CannotCreateCipher"] = 126] = "CannotCreateCipher";\n    CryptoErrorCode[CryptoErrorCode["EncryptDataError"] = 127] = "EncryptDataError";\n    CryptoErrorCode[CryptoErrorCode["DecryptDataError"] = 128] = "DecryptDataError";\n    CryptoErrorCode[CryptoErrorCode["IvRequired"] = 129] = "IvRequired";\n    CryptoErrorCode[CryptoErrorCode["CryptoBoxNotRegistered"] = 130] = "CryptoBoxNotRegistered";\n    CryptoErrorCode[CryptoErrorCode["InvalidCryptoBoxType"] = 131] = "InvalidCryptoBoxType";\n    CryptoErrorCode[CryptoErrorCode["CryptoBoxSecretSerializationError"] = 132] = "CryptoBoxSecretSerializationError";\n    CryptoErrorCode[CryptoErrorCode["CryptoBoxSecretDeserializationError"] = 133] = "CryptoBoxSecretDeserializationError";\n    CryptoErrorCode[CryptoErrorCode["InvalidNonceSize"] = 134] = "InvalidNonceSize";\n})(CryptoErrorCode = exports.CryptoErrorCode || (exports.CryptoErrorCode = {}));\nfunction encryptionAlgorithmAES(value) {\n    return {\n        type: \'AES\',\n        value,\n    };\n}\nexports.encryptionAlgorithmAES = encryptionAlgorithmAES;\nfunction encryptionAlgorithmChaCha20(value) {\n    return {\n        type: \'ChaCha20\',\n        value,\n    };\n}\nexports.encryptionAlgorithmChaCha20 = encryptionAlgorithmChaCha20;\nfunction encryptionAlgorithmNaclBox(value) {\n    return {\n        type: \'NaclBox\',\n        value,\n    };\n}\nexports.encryptionAlgorithmNaclBox = encryptionAlgorithmNaclBox;\nfunction encryptionAlgorithmNaclSecretBox(value) {\n    return {\n        type: \'NaclSecretBox\',\n        value,\n    };\n}\nexports.encryptionAlgorithmNaclSecretBox = encryptionAlgorithmNaclSecretBox;\nvar CipherMode;\n(function (CipherMode) {\n    CipherMode["CBC"] = "CBC";\n    CipherMode["CFB"] = "CFB";\n    CipherMode["CTR"] = "CTR";\n    CipherMode["ECB"] = "ECB";\n    CipherMode["OFB"] = "OFB";\n})(CipherMode = exports.CipherMode || (exports.CipherMode = {}));\nfunction cryptoBoxSecretRandomSeedPhrase(dictionary, wordcount) {\n    return {\n        type: \'RandomSeedPhrase\',\n        dictionary,\n        wordcount,\n    };\n}\nexports.cryptoBoxSecretRandomSeedPhrase = cryptoBoxSecretRandomSeedPhrase;\nfunction cryptoBoxSecretPredefinedSeedPhrase(phrase, dictionary, wordcount) {\n    return {\n        type: \'PredefinedSeedPhrase\',\n        phrase,\n        dictionary,\n        wordcount,\n    };\n}\nexports.cryptoBoxSecretPredefinedSeedPhrase = cryptoBoxSecretPredefinedSeedPhrase;\nfunction cryptoBoxSecretEncryptedSecret(encrypted_secret) {\n    return {\n        type: \'EncryptedSecret\',\n        encrypted_secret,\n    };\n}\nexports.cryptoBoxSecretEncryptedSecret = cryptoBoxSecretEncryptedSecret;\nfunction boxEncryptionAlgorithmChaCha20(value) {\n    return {\n        type: \'ChaCha20\',\n        value,\n    };\n}\nexports.boxEncryptionAlgorithmChaCha20 = boxEncryptionAlgorithmChaCha20;\nfunction boxEncryptionAlgorithmNaclBox(value) {\n    return {\n        type: \'NaclBox\',\n        value,\n    };\n}\nexports.boxEncryptionAlgorithmNaclBox = boxEncryptionAlgorithmNaclBox;\nfunction boxEncryptionAlgorithmNaclSecretBox(value) {\n    return {\n        type: \'NaclSecretBox\',\n        value,\n    };\n}\nexports.boxEncryptionAlgorithmNaclSecretBox = boxEncryptionAlgorithmNaclSecretBox;\nfunction paramsOfAppPasswordProviderGetPassword(encryption_public_key) {\n    return {\n        type: \'GetPassword\',\n        encryption_public_key,\n    };\n}\nexports.paramsOfAppPasswordProviderGetPassword = paramsOfAppPasswordProviderGetPassword;\nfunction resultOfAppPasswordProviderGetPassword(encrypted_password, app_encryption_pubkey) {\n    return {\n        type: \'GetPassword\',\n        encrypted_password,\n        app_encryption_pubkey,\n    };\n}\nexports.resultOfAppPasswordProviderGetPassword = resultOfAppPasswordProviderGetPassword;\nfunction paramsOfAppSigningBoxGetPublicKey() {\n    return {\n        type: \'GetPublicKey\',\n    };\n}\nexports.paramsOfAppSigningBoxGetPublicKey = paramsOfAppSigningBoxGetPublicKey;\nfunction paramsOfAppSigningBoxSign(unsigned) {\n    return {\n        type: \'Sign\',\n        unsigned,\n    };\n}\nexports.paramsOfAppSigningBoxSign = paramsOfAppSigningBoxSign;\nfunction resultOfAppSigningBoxGetPublicKey(public_key) {\n    return {\n        type: \'GetPublicKey\',\n        public_key,\n    };\n}\nexports.resultOfAppSigningBoxGetPublicKey = resultOfAppSigningBoxGetPublicKey;\nfunction resultOfAppSigningBoxSign(signature) {\n    return {\n        type: \'Sign\',\n        signature,\n    };\n}\nexports.resultOfAppSigningBoxSign = resultOfAppSigningBoxSign;\nfunction paramsOfAppEncryptionBoxGetInfo() {\n    return {\n        type: \'GetInfo\',\n    };\n}\nexports.paramsOfAppEncryptionBoxGetInfo = paramsOfAppEncryptionBoxGetInfo;\nfunction paramsOfAppEncryptionBoxEncrypt(data) {\n    return {\n        type: \'Encrypt\',\n        data,\n    };\n}\nexports.paramsOfAppEncryptionBoxEncrypt = paramsOfAppEncryptionBoxEncrypt;\nfunction paramsOfAppEncryptionBoxDecrypt(data) {\n    return {\n        type: \'Decrypt\',\n        data,\n    };\n}\nexports.paramsOfAppEncryptionBoxDecrypt = paramsOfAppEncryptionBoxDecrypt;\nfunction resultOfAppEncryptionBoxGetInfo(info) {\n    return {\n        type: \'GetInfo\',\n        info,\n    };\n}\nexports.resultOfAppEncryptionBoxGetInfo = resultOfAppEncryptionBoxGetInfo;\nfunction resultOfAppEncryptionBoxEncrypt(data) {\n    return {\n        type: \'Encrypt\',\n        data,\n    };\n}\nexports.resultOfAppEncryptionBoxEncrypt = resultOfAppEncryptionBoxEncrypt;\nfunction resultOfAppEncryptionBoxDecrypt(data) {\n    return {\n        type: \'Decrypt\',\n        data,\n    };\n}\nexports.resultOfAppEncryptionBoxDecrypt = resultOfAppEncryptionBoxDecrypt;\nfunction dispatchAppPasswordProvider(obj, params, app_request_id, client) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let result = {};\n            switch (params.type) {\n                case \'GetPassword\':\n                    result = yield obj.get_password(params);\n                    break;\n            }\n            client.resolve_app_request(app_request_id, Object.assign({ type: params.type }, result));\n        }\n        catch (error) {\n            client.reject_app_request(app_request_id, error);\n        }\n    });\n}\nfunction dispatchAppSigningBox(obj, params, app_request_id, client) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let result = {};\n            switch (params.type) {\n                case \'GetPublicKey\':\n                    result = yield obj.get_public_key();\n                    break;\n                case \'Sign\':\n                    result = yield obj.sign(params);\n                    break;\n            }\n            client.resolve_app_request(app_request_id, Object.assign({ type: params.type }, result));\n        }\n        catch (error) {\n            client.reject_app_request(app_request_id, error);\n        }\n    });\n}\nfunction dispatchAppEncryptionBox(obj, params, app_request_id, client) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let result = {};\n            switch (params.type) {\n                case \'GetInfo\':\n                    result = yield obj.get_info();\n                    break;\n                case \'Encrypt\':\n                    result = yield obj.encrypt(params);\n                    break;\n                case \'Decrypt\':\n                    result = yield obj.decrypt(params);\n                    break;\n            }\n            client.resolve_app_request(app_request_id, Object.assign({ type: params.type }, result));\n        }\n        catch (error) {\n            client.reject_app_request(app_request_id, error);\n        }\n    });\n}\n/**\n * Crypto functions.\n */\nclass CryptoModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Integer factorization\n     *\n     * @remarks\n     * Performs prime factorization  decomposition of a composite number\n     * into a product of smaller prime integers (factors).\n     * See [https://en.wikipedia.org/wiki/Integer_factorization]\n     *\n     * @param {ParamsOfFactorize} params\n     * @returns ResultOfFactorize\n     */\n    factorize(params) {\n        return this.client.request(\'crypto.factorize\', params);\n    }\n    /**\n     * Modular exponentiation\n     *\n     * @remarks\n     * Performs modular exponentiation for big integers (`base`^`exponent` mod `modulus`).\n     * See [https://en.wikipedia.org/wiki/Modular_exponentiation]\n     *\n     * @param {ParamsOfModularPower} params\n     * @returns ResultOfModularPower\n     */\n    modular_power(params) {\n        return this.client.request(\'crypto.modular_power\', params);\n    }\n    /**\n     * Calculates CRC16 using TON algorithm.\n     *\n     * @param {ParamsOfTonCrc16} params\n     * @returns ResultOfTonCrc16\n     */\n    ton_crc16(params) {\n        return this.client.request(\'crypto.ton_crc16\', params);\n    }\n    /**\n     * Generates random byte array of the specified length and returns it in `base64` format\n     *\n     * @param {ParamsOfGenerateRandomBytes} params\n     * @returns ResultOfGenerateRandomBytes\n     */\n    generate_random_bytes(params) {\n        return this.client.request(\'crypto.generate_random_bytes\', params);\n    }\n    /**\n     * Converts public key to ton safe_format\n     *\n     * @param {ParamsOfConvertPublicKeyToTonSafeFormat} params\n     * @returns ResultOfConvertPublicKeyToTonSafeFormat\n     */\n    convert_public_key_to_ton_safe_format(params) {\n        return this.client.request(\'crypto.convert_public_key_to_ton_safe_format\', params);\n    }\n    /**\n     * Generates random ed25519 key pair.\n     * @returns KeyPair\n     */\n    generate_random_sign_keys() {\n        return this.client.request(\'crypto.generate_random_sign_keys\');\n    }\n    /**\n     * Signs a data using the provided keys.\n     *\n     * @param {ParamsOfSign} params\n     * @returns ResultOfSign\n     */\n    sign(params) {\n        return this.client.request(\'crypto.sign\', params);\n    }\n    /**\n     * Verifies signed data using the provided public key. Raises error if verification is failed.\n     *\n     * @param {ParamsOfVerifySignature} params\n     * @returns ResultOfVerifySignature\n     */\n    verify_signature(params) {\n        return this.client.request(\'crypto.verify_signature\', params);\n    }\n    /**\n     * Calculates SHA256 hash of the specified data.\n     *\n     * @param {ParamsOfHash} params\n     * @returns ResultOfHash\n     */\n    sha256(params) {\n        return this.client.request(\'crypto.sha256\', params);\n    }\n    /**\n     * Calculates SHA512 hash of the specified data.\n     *\n     * @param {ParamsOfHash} params\n     * @returns ResultOfHash\n     */\n    sha512(params) {\n        return this.client.request(\'crypto.sha512\', params);\n    }\n    /**\n     * Perform `scrypt` encryption\n     *\n     * @remarks\n     * Derives key from `password` and `key` using `scrypt` algorithm.\n     * See [https://en.wikipedia.org/wiki/Scrypt].\n     *\n     * # Arguments\n     * - `log_n` - The log2 of the Scrypt parameter `N`\n     * - `r` - The Scrypt parameter `r`\n     * - `p` - The Scrypt parameter `p`\n     * # Conditions\n     * - `log_n` must be less than `64`\n     * - `r` must be greater than `0` and less than or equal to `4294967295`\n     * - `p` must be greater than `0` and less than `4294967295`\n     * # Recommended values sufficient for most use-cases\n     * - `log_n = 15` (`n = 32768`)\n     * - `r = 8`\n     * - `p = 1`\n     *\n     * @param {ParamsOfScrypt} params\n     * @returns ResultOfScrypt\n     */\n    scrypt(params) {\n        return this.client.request(\'crypto.scrypt\', params);\n    }\n    /**\n     * Generates a key pair for signing from the secret key\n     *\n     * @remarks\n     * **NOTE:** In the result the secret key is actually the concatenation\n     * of secret and public keys (128 symbols hex string) by design of [NaCL](http://nacl.cr.yp.to/sign.html).\n     * See also [the stackexchange question](https://crypto.stackexchange.com/questions/54353/).\n     *\n     * @param {ParamsOfNaclSignKeyPairFromSecret} params\n     * @returns KeyPair\n     */\n    nacl_sign_keypair_from_secret_key(params) {\n        return this.client.request(\'crypto.nacl_sign_keypair_from_secret_key\', params);\n    }\n    /**\n     * Signs data using the signer\'s secret key.\n     *\n     * @param {ParamsOfNaclSign} params\n     * @returns ResultOfNaclSign\n     */\n    nacl_sign(params) {\n        return this.client.request(\'crypto.nacl_sign\', params);\n    }\n    /**\n     * Verifies the signature and returns the unsigned message\n     *\n     * @remarks\n     * Verifies the signature in `signed` using the signer\'s public key `public`\n     * and returns the message `unsigned`.\n     *\n     * If the signature fails verification, crypto_sign_open raises an exception.\n     *\n     * @param {ParamsOfNaclSignOpen} params\n     * @returns ResultOfNaclSignOpen\n     */\n    nacl_sign_open(params) {\n        return this.client.request(\'crypto.nacl_sign_open\', params);\n    }\n    /**\n     * Signs the message using the secret key and returns a signature.\n     *\n     * @remarks\n     * Signs the message `unsigned` using the secret key `secret`\n     * and returns a signature `signature`.\n     *\n     * @param {ParamsOfNaclSign} params\n     * @returns ResultOfNaclSignDetached\n     */\n    nacl_sign_detached(params) {\n        return this.client.request(\'crypto.nacl_sign_detached\', params);\n    }\n    /**\n     * Verifies the signature with public key and `unsigned` data.\n     *\n     * @param {ParamsOfNaclSignDetachedVerify} params\n     * @returns ResultOfNaclSignDetachedVerify\n     */\n    nacl_sign_detached_verify(params) {\n        return this.client.request(\'crypto.nacl_sign_detached_verify\', params);\n    }\n    /**\n     * Generates a random NaCl key pair\n     * @returns KeyPair\n     */\n    nacl_box_keypair() {\n        return this.client.request(\'crypto.nacl_box_keypair\');\n    }\n    /**\n     * Generates key pair from a secret key\n     *\n     * @param {ParamsOfNaclBoxKeyPairFromSecret} params\n     * @returns KeyPair\n     */\n    nacl_box_keypair_from_secret_key(params) {\n        return this.client.request(\'crypto.nacl_box_keypair_from_secret_key\', params);\n    }\n    /**\n     * Public key authenticated encryption\n     *\n     * @remarks\n     * Encrypt and authenticate a message using the senders secret key, the receivers public\n     * key, and a nonce.\n     *\n     * @param {ParamsOfNaclBox} params\n     * @returns ResultOfNaclBox\n     */\n    nacl_box(params) {\n        return this.client.request(\'crypto.nacl_box\', params);\n    }\n    /**\n     * Decrypt and verify the cipher text using the receivers secret key, the senders public key, and the nonce.\n     *\n     * @param {ParamsOfNaclBoxOpen} params\n     * @returns ResultOfNaclBoxOpen\n     */\n    nacl_box_open(params) {\n        return this.client.request(\'crypto.nacl_box_open\', params);\n    }\n    /**\n     * Encrypt and authenticate message using nonce and secret key.\n     *\n     * @param {ParamsOfNaclSecretBox} params\n     * @returns ResultOfNaclBox\n     */\n    nacl_secret_box(params) {\n        return this.client.request(\'crypto.nacl_secret_box\', params);\n    }\n    /**\n     * Decrypts and verifies cipher text using `nonce` and secret `key`.\n     *\n     * @param {ParamsOfNaclSecretBoxOpen} params\n     * @returns ResultOfNaclBoxOpen\n     */\n    nacl_secret_box_open(params) {\n        return this.client.request(\'crypto.nacl_secret_box_open\', params);\n    }\n    /**\n     * Prints the list of words from the specified dictionary\n     *\n     * @param {ParamsOfMnemonicWords} params\n     * @returns ResultOfMnemonicWords\n     */\n    mnemonic_words(params) {\n        return this.client.request(\'crypto.mnemonic_words\', params);\n    }\n    /**\n     * Generates a random mnemonic\n     *\n     * @remarks\n     * Generates a random mnemonic from the specified dictionary and word count\n     *\n     * @param {ParamsOfMnemonicFromRandom} params\n     * @returns ResultOfMnemonicFromRandom\n     */\n    mnemonic_from_random(params) {\n        return this.client.request(\'crypto.mnemonic_from_random\', params);\n    }\n    /**\n     * Generates mnemonic from pre-generated entropy\n     *\n     * @param {ParamsOfMnemonicFromEntropy} params\n     * @returns ResultOfMnemonicFromEntropy\n     */\n    mnemonic_from_entropy(params) {\n        return this.client.request(\'crypto.mnemonic_from_entropy\', params);\n    }\n    /**\n     * Validates a mnemonic phrase\n     *\n     * @remarks\n     * The phrase supplied will be checked for word length and validated according to the checksum\n     * specified in BIP0039.\n     *\n     * @param {ParamsOfMnemonicVerify} params\n     * @returns ResultOfMnemonicVerify\n     */\n    mnemonic_verify(params) {\n        return this.client.request(\'crypto.mnemonic_verify\', params);\n    }\n    /**\n     * Derives a key pair for signing from the seed phrase\n     *\n     * @remarks\n     * Validates the seed phrase, generates master key and then derives\n     * the key pair from the master key and the specified path\n     *\n     * @param {ParamsOfMnemonicDeriveSignKeys} params\n     * @returns KeyPair\n     */\n    mnemonic_derive_sign_keys(params) {\n        return this.client.request(\'crypto.mnemonic_derive_sign_keys\', params);\n    }\n    /**\n     * Generates an extended master private key that will be the root for all the derived keys\n     *\n     * @param {ParamsOfHDKeyXPrvFromMnemonic} params\n     * @returns ResultOfHDKeyXPrvFromMnemonic\n     */\n    hdkey_xprv_from_mnemonic(params) {\n        return this.client.request(\'crypto.hdkey_xprv_from_mnemonic\', params);\n    }\n    /**\n     * Returns extended private key derived from the specified extended private key and child index\n     *\n     * @param {ParamsOfHDKeyDeriveFromXPrv} params\n     * @returns ResultOfHDKeyDeriveFromXPrv\n     */\n    hdkey_derive_from_xprv(params) {\n        return this.client.request(\'crypto.hdkey_derive_from_xprv\', params);\n    }\n    /**\n     * Derives the extended private key from the specified key and path\n     *\n     * @param {ParamsOfHDKeyDeriveFromXPrvPath} params\n     * @returns ResultOfHDKeyDeriveFromXPrvPath\n     */\n    hdkey_derive_from_xprv_path(params) {\n        return this.client.request(\'crypto.hdkey_derive_from_xprv_path\', params);\n    }\n    /**\n     * Extracts the private key from the serialized extended private key\n     *\n     * @param {ParamsOfHDKeySecretFromXPrv} params\n     * @returns ResultOfHDKeySecretFromXPrv\n     */\n    hdkey_secret_from_xprv(params) {\n        return this.client.request(\'crypto.hdkey_secret_from_xprv\', params);\n    }\n    /**\n     * Extracts the public key from the serialized extended private key\n     *\n     * @param {ParamsOfHDKeyPublicFromXPrv} params\n     * @returns ResultOfHDKeyPublicFromXPrv\n     */\n    hdkey_public_from_xprv(params) {\n        return this.client.request(\'crypto.hdkey_public_from_xprv\', params);\n    }\n    /**\n     * Performs symmetric `chacha20` encryption.\n     *\n     * @param {ParamsOfChaCha20} params\n     * @returns ResultOfChaCha20\n     */\n    chacha20(params) {\n        return this.client.request(\'crypto.chacha20\', params);\n    }\n    /**\n     * Creates a Crypto Box instance.\n     *\n     * @remarks\n     * Crypto Box is a root crypto object, that encapsulates some secret (seed phrase usually)\n     * in encrypted form and acts as a factory for all crypto primitives used in SDK:\n     * keys for signing and encryption, derived from this secret.\n     *\n     * Crypto Box encrypts original Seed Phrase with salt and password that is retrieved\n     * from `password_provider` callback, implemented on Application side.\n     *\n     * When used, decrypted secret shows up in core library\'s memory for a very short period\n     * of time and then is immediately overwritten with zeroes.\n     *\n     * @param {ParamsOfCreateCryptoBox} params\n     * @returns RegisteredCryptoBox\n     */\n    create_crypto_box(params, obj) {\n        return this.client.request(\'crypto.create_crypto_box\', params, (params, responseType) => {\n            if (responseType === 3) {\n                dispatchAppPasswordProvider(obj, params.request_data, params.app_request_id, this.client);\n            }\n            else if (responseType === 4) {\n                dispatchAppPasswordProvider(obj, params, null, this.client);\n            }\n        });\n    }\n    /**\n     * Removes Crypto Box. Clears all secret data.\n     *\n     * @param {RegisteredCryptoBox} params\n     * @returns\n     */\n    remove_crypto_box(params) {\n        return this.client.request(\'crypto.remove_crypto_box\', params);\n    }\n    /**\n     * Get Crypto Box Info. Used to get `encrypted_secret` that should be used for all the cryptobox initializations except the first one.\n     *\n     * @param {RegisteredCryptoBox} params\n     * @returns ResultOfGetCryptoBoxInfo\n     */\n    get_crypto_box_info(params) {\n        return this.client.request(\'crypto.get_crypto_box_info\', params);\n    }\n    /**\n     * Get Crypto Box Seed Phrase.\n     *\n     * @remarks\n     * Attention! Store this data in your application for a very short period of time and overwrite it with zeroes ASAP.\n     *\n     * @param {RegisteredCryptoBox} params\n     * @returns ResultOfGetCryptoBoxSeedPhrase\n     */\n    get_crypto_box_seed_phrase(params) {\n        return this.client.request(\'crypto.get_crypto_box_seed_phrase\', params);\n    }\n    /**\n     * Get handle of Signing Box derived from Crypto Box.\n     *\n     * @param {ParamsOfGetSigningBoxFromCryptoBox} params\n     * @returns RegisteredSigningBox\n     */\n    get_signing_box_from_crypto_box(params) {\n        return this.client.request(\'crypto.get_signing_box_from_crypto_box\', params);\n    }\n    /**\n     * Gets Encryption Box from Crypto Box.\n     *\n     * @remarks\n     * Derives encryption keypair from cryptobox secret and hdpath and\n     * stores it in cache for `secret_lifetime`\n     * or until explicitly cleared by `clear_crypto_box_secret_cache` method.\n     * If `secret_lifetime` is not specified - overwrites encryption secret with zeroes immediately after\n     * encryption operation.\n     *\n     * @param {ParamsOfGetEncryptionBoxFromCryptoBox} params\n     * @returns RegisteredEncryptionBox\n     */\n    get_encryption_box_from_crypto_box(params) {\n        return this.client.request(\'crypto.get_encryption_box_from_crypto_box\', params);\n    }\n    /**\n     * Removes cached secrets (overwrites with zeroes) from all signing and encryption boxes, derived from crypto box.\n     *\n     * @param {RegisteredCryptoBox} params\n     * @returns\n     */\n    clear_crypto_box_secret_cache(params) {\n        return this.client.request(\'crypto.clear_crypto_box_secret_cache\', params);\n    }\n    /**\n     * Register an application implemented signing box.\n     * @returns RegisteredSigningBox\n     */\n    register_signing_box(obj) {\n        return this.client.request(\'crypto.register_signing_box\', undefined, (params, responseType) => {\n            if (responseType === 3) {\n                dispatchAppSigningBox(obj, params.request_data, params.app_request_id, this.client);\n            }\n            else if (responseType === 4) {\n                dispatchAppSigningBox(obj, params, null, this.client);\n            }\n        });\n    }\n    /**\n     * Creates a default signing box implementation.\n     *\n     * @param {KeyPair} params\n     * @returns RegisteredSigningBox\n     */\n    get_signing_box(params) {\n        return this.client.request(\'crypto.get_signing_box\', params);\n    }\n    /**\n     * Returns public key of signing key pair.\n     *\n     * @param {RegisteredSigningBox} params\n     * @returns ResultOfSigningBoxGetPublicKey\n     */\n    signing_box_get_public_key(params) {\n        return this.client.request(\'crypto.signing_box_get_public_key\', params);\n    }\n    /**\n     * Returns signed user data.\n     *\n     * @param {ParamsOfSigningBoxSign} params\n     * @returns ResultOfSigningBoxSign\n     */\n    signing_box_sign(params) {\n        return this.client.request(\'crypto.signing_box_sign\', params);\n    }\n    /**\n     * Removes signing box from SDK.\n     *\n     * @param {RegisteredSigningBox} params\n     * @returns\n     */\n    remove_signing_box(params) {\n        return this.client.request(\'crypto.remove_signing_box\', params);\n    }\n    /**\n     * Register an application implemented encryption box.\n     * @returns RegisteredEncryptionBox\n     */\n    register_encryption_box(obj) {\n        return this.client.request(\'crypto.register_encryption_box\', undefined, (params, responseType) => {\n            if (responseType === 3) {\n                dispatchAppEncryptionBox(obj, params.request_data, params.app_request_id, this.client);\n            }\n            else if (responseType === 4) {\n                dispatchAppEncryptionBox(obj, params, null, this.client);\n            }\n        });\n    }\n    /**\n     * Removes encryption box from SDK\n     *\n     * @param {RegisteredEncryptionBox} params\n     * @returns\n     */\n    remove_encryption_box(params) {\n        return this.client.request(\'crypto.remove_encryption_box\', params);\n    }\n    /**\n     * Queries info from the given encryption box\n     *\n     * @param {ParamsOfEncryptionBoxGetInfo} params\n     * @returns ResultOfEncryptionBoxGetInfo\n     */\n    encryption_box_get_info(params) {\n        return this.client.request(\'crypto.encryption_box_get_info\', params);\n    }\n    /**\n     * Encrypts data using given encryption box Note.\n     *\n     * @remarks\n     * Block cipher algorithms pad data to cipher block size so encrypted data can be longer then original data. Client should store the original data size after encryption and use it after\n     * decryption to retrieve the original data from decrypted data.\n     *\n     * @param {ParamsOfEncryptionBoxEncrypt} params\n     * @returns ResultOfEncryptionBoxEncrypt\n     */\n    encryption_box_encrypt(params) {\n        return this.client.request(\'crypto.encryption_box_encrypt\', params);\n    }\n    /**\n     * Decrypts data using given encryption box Note.\n     *\n     * @remarks\n     * Block cipher algorithms pad data to cipher block size so encrypted data can be longer then original data. Client should store the original data size after encryption and use it after\n     * decryption to retrieve the original data from decrypted data.\n     *\n     * @param {ParamsOfEncryptionBoxDecrypt} params\n     * @returns ResultOfEncryptionBoxDecrypt\n     */\n    encryption_box_decrypt(params) {\n        return this.client.request(\'crypto.encryption_box_decrypt\', params);\n    }\n    /**\n     * Creates encryption box with specified algorithm\n     *\n     * @param {ParamsOfCreateEncryptionBox} params\n     * @returns RegisteredEncryptionBox\n     */\n    create_encryption_box(params) {\n        return this.client.request(\'crypto.create_encryption_box\', params);\n    }\n}\nexports.CryptoModule = CryptoModule;\n// abi module\nvar AbiErrorCode;\n(function (AbiErrorCode) {\n    AbiErrorCode[AbiErrorCode["RequiredAddressMissingForEncodeMessage"] = 301] = "RequiredAddressMissingForEncodeMessage";\n    AbiErrorCode[AbiErrorCode["RequiredCallSetMissingForEncodeMessage"] = 302] = "RequiredCallSetMissingForEncodeMessage";\n    AbiErrorCode[AbiErrorCode["InvalidJson"] = 303] = "InvalidJson";\n    AbiErrorCode[AbiErrorCode["InvalidMessage"] = 304] = "InvalidMessage";\n    AbiErrorCode[AbiErrorCode["EncodeDeployMessageFailed"] = 305] = "EncodeDeployMessageFailed";\n    AbiErrorCode[AbiErrorCode["EncodeRunMessageFailed"] = 306] = "EncodeRunMessageFailed";\n    AbiErrorCode[AbiErrorCode["AttachSignatureFailed"] = 307] = "AttachSignatureFailed";\n    AbiErrorCode[AbiErrorCode["InvalidTvcImage"] = 308] = "InvalidTvcImage";\n    AbiErrorCode[AbiErrorCode["RequiredPublicKeyMissingForFunctionHeader"] = 309] = "RequiredPublicKeyMissingForFunctionHeader";\n    AbiErrorCode[AbiErrorCode["InvalidSigner"] = 310] = "InvalidSigner";\n    AbiErrorCode[AbiErrorCode["InvalidAbi"] = 311] = "InvalidAbi";\n    AbiErrorCode[AbiErrorCode["InvalidFunctionId"] = 312] = "InvalidFunctionId";\n    AbiErrorCode[AbiErrorCode["InvalidData"] = 313] = "InvalidData";\n    AbiErrorCode[AbiErrorCode["EncodeInitialDataFailed"] = 314] = "EncodeInitialDataFailed";\n    AbiErrorCode[AbiErrorCode["InvalidFunctionName"] = 315] = "InvalidFunctionName";\n})(AbiErrorCode = exports.AbiErrorCode || (exports.AbiErrorCode = {}));\nfunction abiContract(value) {\n    return {\n        type: \'Contract\',\n        value,\n    };\n}\nexports.abiContract = abiContract;\nfunction abiJson(value) {\n    return {\n        type: \'Json\',\n        value,\n    };\n}\nexports.abiJson = abiJson;\nfunction abiHandle(value) {\n    return {\n        type: \'Handle\',\n        value,\n    };\n}\nexports.abiHandle = abiHandle;\nfunction abiSerialized(value) {\n    return {\n        type: \'Serialized\',\n        value,\n    };\n}\nexports.abiSerialized = abiSerialized;\nfunction signerNone() {\n    return {\n        type: \'None\',\n    };\n}\nexports.signerNone = signerNone;\nfunction signerExternal(public_key) {\n    return {\n        type: \'External\',\n        public_key,\n    };\n}\nexports.signerExternal = signerExternal;\nfunction signerKeys(keys) {\n    return {\n        type: \'Keys\',\n        keys,\n    };\n}\nexports.signerKeys = signerKeys;\nfunction signerSigningBox(handle) {\n    return {\n        type: \'SigningBox\',\n        handle,\n    };\n}\nexports.signerSigningBox = signerSigningBox;\nvar MessageBodyType;\n(function (MessageBodyType) {\n    MessageBodyType["Input"] = "Input";\n    MessageBodyType["Output"] = "Output";\n    MessageBodyType["InternalOutput"] = "InternalOutput";\n    MessageBodyType["Event"] = "Event";\n})(MessageBodyType = exports.MessageBodyType || (exports.MessageBodyType = {}));\nfunction stateInitSourceMessage(source) {\n    return {\n        type: \'Message\',\n        source,\n    };\n}\nexports.stateInitSourceMessage = stateInitSourceMessage;\nfunction stateInitSourceStateInit(code, data, library) {\n    return {\n        type: \'StateInit\',\n        code,\n        data,\n        library,\n    };\n}\nexports.stateInitSourceStateInit = stateInitSourceStateInit;\nfunction stateInitSourceTvc(tvc, public_key, init_params) {\n    return {\n        type: \'Tvc\',\n        tvc,\n        public_key,\n        init_params,\n    };\n}\nexports.stateInitSourceTvc = stateInitSourceTvc;\nfunction messageSourceEncoded(message, abi) {\n    return {\n        type: \'Encoded\',\n        message,\n        abi,\n    };\n}\nexports.messageSourceEncoded = messageSourceEncoded;\nfunction messageSourceEncodingParams(params) {\n    return Object.assign({ type: \'EncodingParams\' }, params);\n}\nexports.messageSourceEncodingParams = messageSourceEncodingParams;\n/**\n * Provides message encoding and decoding according to the ABI specification.\n */\nclass AbiModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Encodes message body according to ABI function call.\n     *\n     * @param {ParamsOfEncodeMessageBody} params\n     * @returns ResultOfEncodeMessageBody\n     */\n    encode_message_body(params) {\n        return this.client.request(\'abi.encode_message_body\', params);\n    }\n    /**\n     *\n     * @param {ParamsOfAttachSignatureToMessageBody} params\n     * @returns ResultOfAttachSignatureToMessageBody\n     */\n    attach_signature_to_message_body(params) {\n        return this.client.request(\'abi.attach_signature_to_message_body\', params);\n    }\n    /**\n     * Encodes an ABI-compatible message\n     *\n     * @remarks\n     * Allows to encode deploy and function call messages,\n     * both signed and unsigned.\n     *\n     * Use cases include messages of any possible type:\n     * - deploy with initial function call (i.e. `constructor` or any other function that is used for some kind\n     * of initialization);\n     * - deploy without initial function call;\n     * - signed/unsigned + data for signing.\n     *\n     * `Signer` defines how the message should or shouldn\'t be signed:\n     *\n     * `Signer::None` creates an unsigned message. This may be needed in case of some public methods,\n     * that do not require authorization by pubkey.\n     *\n     * `Signer::External` takes public key and returns `data_to_sign` for later signing.\n     * Use `attach_signature` method with the result signature to get the signed message.\n     *\n     * `Signer::Keys` creates a signed message with provided key pair.\n     *\n     * [SOON] `Signer::SigningBox` Allows using a special interface to implement signing\n     * without private key disclosure to SDK. For instance, in case of using a cold wallet or HSM,\n     * when application calls some API to sign data.\n     *\n     * There is an optional public key can be provided in deploy set in order to substitute one\n     * in TVM file.\n     *\n     * Public key resolving priority:\n     * 1. Public key from deploy set.\n     * 2. Public key, specified in TVM file.\n     * 3. Public key, provided by signer.\n     *\n     * @param {ParamsOfEncodeMessage} params\n     * @returns ResultOfEncodeMessage\n     */\n    encode_message(params) {\n        return this.client.request(\'abi.encode_message\', params);\n    }\n    /**\n     * Encodes an internal ABI-compatible message\n     *\n     * @remarks\n     * Allows to encode deploy and function call messages.\n     *\n     * Use cases include messages of any possible type:\n     * - deploy with initial function call (i.e. `constructor` or any other function that is used for some kind\n     * of initialization);\n     * - deploy without initial function call;\n     * - simple function call\n     *\n     * There is an optional public key can be provided in deploy set in order to substitute one\n     * in TVM file.\n     *\n     * Public key resolving priority:\n     * 1. Public key from deploy set.\n     * 2. Public key, specified in TVM file.\n     *\n     * @param {ParamsOfEncodeInternalMessage} params\n     * @returns ResultOfEncodeInternalMessage\n     */\n    encode_internal_message(params) {\n        return this.client.request(\'abi.encode_internal_message\', params);\n    }\n    /**\n     * Combines `hex`-encoded `signature` with `base64`-encoded `unsigned_message`. Returns signed message encoded in `base64`.\n     *\n     * @param {ParamsOfAttachSignature} params\n     * @returns ResultOfAttachSignature\n     */\n    attach_signature(params) {\n        return this.client.request(\'abi.attach_signature\', params);\n    }\n    /**\n     * Decodes message body using provided message BOC and ABI.\n     *\n     * @param {ParamsOfDecodeMessage} params\n     * @returns DecodedMessageBody\n     */\n    decode_message(params) {\n        return this.client.request(\'abi.decode_message\', params);\n    }\n    /**\n     * Decodes message body using provided body BOC and ABI.\n     *\n     * @param {ParamsOfDecodeMessageBody} params\n     * @returns DecodedMessageBody\n     */\n    decode_message_body(params) {\n        return this.client.request(\'abi.decode_message_body\', params);\n    }\n    /**\n     * Creates account state BOC\n     *\n     * @remarks\n     * Creates account state provided with one of these sets of data :\n     * 1. BOC of code, BOC of data, BOC of library\n     * 2. TVC (string in `base64`), keys, init params\n     *\n     * @param {ParamsOfEncodeAccount} params\n     * @returns ResultOfEncodeAccount\n     */\n    encode_account(params) {\n        return this.client.request(\'abi.encode_account\', params);\n    }\n    /**\n     * Decodes account data using provided data BOC and ABI.\n     *\n     * @remarks\n     * Note: this feature requires ABI 2.1 or higher.\n     *\n     * @param {ParamsOfDecodeAccountData} params\n     * @returns ResultOfDecodeAccountData\n     */\n    decode_account_data(params) {\n        return this.client.request(\'abi.decode_account_data\', params);\n    }\n    /**\n     * Updates initial account data with initial values for the contract\'s static variables and owner\'s public key. This operation is applicable only for initial account data (before deploy). If the contract is already deployed, its data doesn\'t contain this data section any more.\n     *\n     * @param {ParamsOfUpdateInitialData} params\n     * @returns ResultOfUpdateInitialData\n     */\n    update_initial_data(params) {\n        return this.client.request(\'abi.update_initial_data\', params);\n    }\n    /**\n     * Encodes initial account data with initial values for the contract\'s static variables and owner\'s public key into a data BOC that can be passed to `encode_tvc` function afterwards.\n     *\n     * @remarks\n     * This function is analogue of `tvm.buildDataInit` function in Solidity.\n     *\n     * @param {ParamsOfEncodeInitialData} params\n     * @returns ResultOfEncodeInitialData\n     */\n    encode_initial_data(params) {\n        return this.client.request(\'abi.encode_initial_data\', params);\n    }\n    /**\n     * Decodes initial values of a contract\'s static variables and owner\'s public key from account initial data This operation is applicable only for initial account data (before deploy). If the contract is already deployed, its data doesn\'t contain this data section any more.\n     *\n     * @param {ParamsOfDecodeInitialData} params\n     * @returns ResultOfDecodeInitialData\n     */\n    decode_initial_data(params) {\n        return this.client.request(\'abi.decode_initial_data\', params);\n    }\n    /**\n     * Decodes BOC into JSON as a set of provided parameters.\n     *\n     * @remarks\n     * Solidity functions use ABI types for [builder encoding](https://github.com/tonlabs/TON-Solidity-Compiler/blob/master/API.md#tvmbuilderstore).\n     * The simplest way to decode such a BOC is to use ABI decoding.\n     * ABI has it own rules for fields layout in cells so manually encoded\n     * BOC can not be described in terms of ABI rules.\n     *\n     * To solve this problem we introduce a new ABI type `Ref(<ParamType>)`\n     * which allows to store `ParamType` ABI parameter in cell reference and, thus,\n     * decode manually encoded BOCs. This type is available only in `decode_boc` function\n     * and will not be available in ABI messages encoding until it is included into some ABI revision.\n     *\n     * Such BOC descriptions covers most users needs. If someone wants to decode some BOC which\n     * can not be described by these rules (i.e. BOC with TLB containing constructors of flags\n     * defining some parsing conditions) then they can decode the fields up to fork condition,\n     * check the parsed data manually, expand the parsing schema and then decode the whole BOC\n     * with the full schema.\n     *\n     * @param {ParamsOfDecodeBoc} params\n     * @returns ResultOfDecodeBoc\n     */\n    decode_boc(params) {\n        return this.client.request(\'abi.decode_boc\', params);\n    }\n    /**\n     * Encodes given parameters in JSON into a BOC using param types from ABI.\n     *\n     * @param {ParamsOfAbiEncodeBoc} params\n     * @returns ResultOfAbiEncodeBoc\n     */\n    encode_boc(params) {\n        return this.client.request(\'abi.encode_boc\', params);\n    }\n    /**\n     * Calculates contract function ID by contract ABI\n     *\n     * @param {ParamsOfCalcFunctionId} params\n     * @returns ResultOfCalcFunctionId\n     */\n    calc_function_id(params) {\n        return this.client.request(\'abi.calc_function_id\', params);\n    }\n}\nexports.AbiModule = AbiModule;\nfunction bocCacheTypePinned(pin) {\n    return {\n        type: \'Pinned\',\n        pin,\n    };\n}\nexports.bocCacheTypePinned = bocCacheTypePinned;\nfunction bocCacheTypeUnpinned() {\n    return {\n        type: \'Unpinned\',\n    };\n}\nexports.bocCacheTypeUnpinned = bocCacheTypeUnpinned;\nvar BocErrorCode;\n(function (BocErrorCode) {\n    BocErrorCode[BocErrorCode["InvalidBoc"] = 201] = "InvalidBoc";\n    BocErrorCode[BocErrorCode["SerializationError"] = 202] = "SerializationError";\n    BocErrorCode[BocErrorCode["InappropriateBlock"] = 203] = "InappropriateBlock";\n    BocErrorCode[BocErrorCode["MissingSourceBoc"] = 204] = "MissingSourceBoc";\n    BocErrorCode[BocErrorCode["InsufficientCacheSize"] = 205] = "InsufficientCacheSize";\n    BocErrorCode[BocErrorCode["BocRefNotFound"] = 206] = "BocRefNotFound";\n    BocErrorCode[BocErrorCode["InvalidBocRef"] = 207] = "InvalidBocRef";\n})(BocErrorCode = exports.BocErrorCode || (exports.BocErrorCode = {}));\nfunction builderOpInteger(size, value) {\n    return {\n        type: \'Integer\',\n        size,\n        value,\n    };\n}\nexports.builderOpInteger = builderOpInteger;\nfunction builderOpBitString(value) {\n    return {\n        type: \'BitString\',\n        value,\n    };\n}\nexports.builderOpBitString = builderOpBitString;\nfunction builderOpCell(builder) {\n    return {\n        type: \'Cell\',\n        builder,\n    };\n}\nexports.builderOpCell = builderOpCell;\nfunction builderOpCellBoc(boc) {\n    return {\n        type: \'CellBoc\',\n        boc,\n    };\n}\nexports.builderOpCellBoc = builderOpCellBoc;\nfunction builderOpAddress(address) {\n    return {\n        type: \'Address\',\n        address,\n    };\n}\nexports.builderOpAddress = builderOpAddress;\n/**\n * BOC manipulation module.\n */\nclass BocModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Parses message boc into a JSON\n     *\n     * @remarks\n     * JSON structure is compatible with GraphQL API message object\n     *\n     * @param {ParamsOfParse} params\n     * @returns ResultOfParse\n     */\n    parse_message(params) {\n        return this.client.request(\'boc.parse_message\', params);\n    }\n    /**\n     * Parses transaction boc into a JSON\n     *\n     * @remarks\n     * JSON structure is compatible with GraphQL API transaction object\n     *\n     * @param {ParamsOfParse} params\n     * @returns ResultOfParse\n     */\n    parse_transaction(params) {\n        return this.client.request(\'boc.parse_transaction\', params);\n    }\n    /**\n     * Parses account boc into a JSON\n     *\n     * @remarks\n     * JSON structure is compatible with GraphQL API account object\n     *\n     * @param {ParamsOfParse} params\n     * @returns ResultOfParse\n     */\n    parse_account(params) {\n        return this.client.request(\'boc.parse_account\', params);\n    }\n    /**\n     * Parses block boc into a JSON\n     *\n     * @remarks\n     * JSON structure is compatible with GraphQL API block object\n     *\n     * @param {ParamsOfParse} params\n     * @returns ResultOfParse\n     */\n    parse_block(params) {\n        return this.client.request(\'boc.parse_block\', params);\n    }\n    /**\n     * Parses shardstate boc into a JSON\n     *\n     * @remarks\n     * JSON structure is compatible with GraphQL API shardstate object\n     *\n     * @param {ParamsOfParseShardstate} params\n     * @returns ResultOfParse\n     */\n    parse_shardstate(params) {\n        return this.client.request(\'boc.parse_shardstate\', params);\n    }\n    /**\n     * Extract blockchain configuration from key block and also from zerostate.\n     *\n     * @param {ParamsOfGetBlockchainConfig} params\n     * @returns ResultOfGetBlockchainConfig\n     */\n    get_blockchain_config(params) {\n        return this.client.request(\'boc.get_blockchain_config\', params);\n    }\n    /**\n     * Calculates BOC root hash\n     *\n     * @param {ParamsOfGetBocHash} params\n     * @returns ResultOfGetBocHash\n     */\n    get_boc_hash(params) {\n        return this.client.request(\'boc.get_boc_hash\', params);\n    }\n    /**\n     * Calculates BOC depth\n     *\n     * @param {ParamsOfGetBocDepth} params\n     * @returns ResultOfGetBocDepth\n     */\n    get_boc_depth(params) {\n        return this.client.request(\'boc.get_boc_depth\', params);\n    }\n    /**\n     * Extracts code from TVC contract image\n     *\n     * @param {ParamsOfGetCodeFromTvc} params\n     * @returns ResultOfGetCodeFromTvc\n     */\n    get_code_from_tvc(params) {\n        return this.client.request(\'boc.get_code_from_tvc\', params);\n    }\n    /**\n     * Get BOC from cache\n     *\n     * @param {ParamsOfBocCacheGet} params\n     * @returns ResultOfBocCacheGet\n     */\n    cache_get(params) {\n        return this.client.request(\'boc.cache_get\', params);\n    }\n    /**\n     * Save BOC into cache or increase pin counter for existing pinned BOC\n     *\n     * @param {ParamsOfBocCacheSet} params\n     * @returns ResultOfBocCacheSet\n     */\n    cache_set(params) {\n        return this.client.request(\'boc.cache_set\', params);\n    }\n    /**\n     * Unpin BOCs with specified pin defined in the `cache_set`. Decrease pin reference counter for BOCs with specified pin defined in the `cache_set`. BOCs which have only 1 pin and its reference counter become 0 will be removed from cache\n     *\n     * @param {ParamsOfBocCacheUnpin} params\n     * @returns\n     */\n    cache_unpin(params) {\n        return this.client.request(\'boc.cache_unpin\', params);\n    }\n    /**\n     * Encodes bag of cells (BOC) with builder operations. This method provides the same functionality as Solidity TvmBuilder. Resulting BOC of this method can be passed into Solidity and C++ contracts as TvmCell type.\n     *\n     * @param {ParamsOfEncodeBoc} params\n     * @returns ResultOfEncodeBoc\n     */\n    encode_boc(params) {\n        return this.client.request(\'boc.encode_boc\', params);\n    }\n    /**\n     * Returns the contract code\'s salt if it is present.\n     *\n     * @param {ParamsOfGetCodeSalt} params\n     * @returns ResultOfGetCodeSalt\n     */\n    get_code_salt(params) {\n        return this.client.request(\'boc.get_code_salt\', params);\n    }\n    /**\n     * Sets new salt to contract code.\n     *\n     * @remarks\n     * Returns the new contract code with salt.\n     *\n     * @param {ParamsOfSetCodeSalt} params\n     * @returns ResultOfSetCodeSalt\n     */\n    set_code_salt(params) {\n        return this.client.request(\'boc.set_code_salt\', params);\n    }\n    /**\n     * Decodes tvc into code, data, libraries and special options.\n     *\n     * @param {ParamsOfDecodeTvc} params\n     * @returns ResultOfDecodeTvc\n     */\n    decode_tvc(params) {\n        return this.client.request(\'boc.decode_tvc\', params);\n    }\n    /**\n     * Encodes tvc from code, data, libraries ans special options (see input params)\n     *\n     * @param {ParamsOfEncodeTvc} params\n     * @returns ResultOfEncodeTvc\n     */\n    encode_tvc(params) {\n        return this.client.request(\'boc.encode_tvc\', params);\n    }\n    /**\n     * Encodes a message\n     *\n     * @remarks\n     * Allows to encode any external inbound message.\n     *\n     * @param {ParamsOfEncodeExternalInMessage} params\n     * @returns ResultOfEncodeExternalInMessage\n     */\n    encode_external_in_message(params) {\n        return this.client.request(\'boc.encode_external_in_message\', params);\n    }\n    /**\n     * Returns the compiler version used to compile the code.\n     *\n     * @param {ParamsOfGetCompilerVersion} params\n     * @returns ResultOfGetCompilerVersion\n     */\n    get_compiler_version(params) {\n        return this.client.request(\'boc.get_compiler_version\', params);\n    }\n}\nexports.BocModule = BocModule;\n// processing module\nvar ProcessingErrorCode;\n(function (ProcessingErrorCode) {\n    ProcessingErrorCode[ProcessingErrorCode["MessageAlreadyExpired"] = 501] = "MessageAlreadyExpired";\n    ProcessingErrorCode[ProcessingErrorCode["MessageHasNotDestinationAddress"] = 502] = "MessageHasNotDestinationAddress";\n    ProcessingErrorCode[ProcessingErrorCode["CanNotBuildMessageCell"] = 503] = "CanNotBuildMessageCell";\n    ProcessingErrorCode[ProcessingErrorCode["FetchBlockFailed"] = 504] = "FetchBlockFailed";\n    ProcessingErrorCode[ProcessingErrorCode["SendMessageFailed"] = 505] = "SendMessageFailed";\n    ProcessingErrorCode[ProcessingErrorCode["InvalidMessageBoc"] = 506] = "InvalidMessageBoc";\n    ProcessingErrorCode[ProcessingErrorCode["MessageExpired"] = 507] = "MessageExpired";\n    ProcessingErrorCode[ProcessingErrorCode["TransactionWaitTimeout"] = 508] = "TransactionWaitTimeout";\n    ProcessingErrorCode[ProcessingErrorCode["InvalidBlockReceived"] = 509] = "InvalidBlockReceived";\n    ProcessingErrorCode[ProcessingErrorCode["CanNotCheckBlockShard"] = 510] = "CanNotCheckBlockShard";\n    ProcessingErrorCode[ProcessingErrorCode["BlockNotFound"] = 511] = "BlockNotFound";\n    ProcessingErrorCode[ProcessingErrorCode["InvalidData"] = 512] = "InvalidData";\n    ProcessingErrorCode[ProcessingErrorCode["ExternalSignerMustNotBeUsed"] = 513] = "ExternalSignerMustNotBeUsed";\n    ProcessingErrorCode[ProcessingErrorCode["MessageRejected"] = 514] = "MessageRejected";\n    ProcessingErrorCode[ProcessingErrorCode["InvalidRempStatus"] = 515] = "InvalidRempStatus";\n    ProcessingErrorCode[ProcessingErrorCode["NextRempStatusTimeout"] = 516] = "NextRempStatusTimeout";\n})(ProcessingErrorCode = exports.ProcessingErrorCode || (exports.ProcessingErrorCode = {}));\nfunction processingEventWillFetchFirstBlock() {\n    return {\n        type: \'WillFetchFirstBlock\',\n    };\n}\nexports.processingEventWillFetchFirstBlock = processingEventWillFetchFirstBlock;\nfunction processingEventFetchFirstBlockFailed(error) {\n    return {\n        type: \'FetchFirstBlockFailed\',\n        error,\n    };\n}\nexports.processingEventFetchFirstBlockFailed = processingEventFetchFirstBlockFailed;\nfunction processingEventWillSend(shard_block_id, message_id, message) {\n    return {\n        type: \'WillSend\',\n        shard_block_id,\n        message_id,\n        message,\n    };\n}\nexports.processingEventWillSend = processingEventWillSend;\nfunction processingEventDidSend(shard_block_id, message_id, message) {\n    return {\n        type: \'DidSend\',\n        shard_block_id,\n        message_id,\n        message,\n    };\n}\nexports.processingEventDidSend = processingEventDidSend;\nfunction processingEventSendFailed(shard_block_id, message_id, message, error) {\n    return {\n        type: \'SendFailed\',\n        shard_block_id,\n        message_id,\n        message,\n        error,\n    };\n}\nexports.processingEventSendFailed = processingEventSendFailed;\nfunction processingEventWillFetchNextBlock(shard_block_id, message_id, message) {\n    return {\n        type: \'WillFetchNextBlock\',\n        shard_block_id,\n        message_id,\n        message,\n    };\n}\nexports.processingEventWillFetchNextBlock = processingEventWillFetchNextBlock;\nfunction processingEventFetchNextBlockFailed(shard_block_id, message_id, message, error) {\n    return {\n        type: \'FetchNextBlockFailed\',\n        shard_block_id,\n        message_id,\n        message,\n        error,\n    };\n}\nexports.processingEventFetchNextBlockFailed = processingEventFetchNextBlockFailed;\nfunction processingEventMessageExpired(message_id, message, error) {\n    return {\n        type: \'MessageExpired\',\n        message_id,\n        message,\n        error,\n    };\n}\nexports.processingEventMessageExpired = processingEventMessageExpired;\nfunction processingEventRempSentToValidators(message_id, timestamp, json) {\n    return {\n        type: \'RempSentToValidators\',\n        message_id,\n        timestamp,\n        json,\n    };\n}\nexports.processingEventRempSentToValidators = processingEventRempSentToValidators;\nfunction processingEventRempIncludedIntoBlock(message_id, timestamp, json) {\n    return {\n        type: \'RempIncludedIntoBlock\',\n        message_id,\n        timestamp,\n        json,\n    };\n}\nexports.processingEventRempIncludedIntoBlock = processingEventRempIncludedIntoBlock;\nfunction processingEventRempIncludedIntoAcceptedBlock(message_id, timestamp, json) {\n    return {\n        type: \'RempIncludedIntoAcceptedBlock\',\n        message_id,\n        timestamp,\n        json,\n    };\n}\nexports.processingEventRempIncludedIntoAcceptedBlock = processingEventRempIncludedIntoAcceptedBlock;\nfunction processingEventRempOther(message_id, timestamp, json) {\n    return {\n        type: \'RempOther\',\n        message_id,\n        timestamp,\n        json,\n    };\n}\nexports.processingEventRempOther = processingEventRempOther;\nfunction processingEventRempError(error) {\n    return {\n        type: \'RempError\',\n        error,\n    };\n}\nexports.processingEventRempError = processingEventRempError;\n/**\n * Message processing module.\n *\n * @remarks\n * This module incorporates functions related to complex message\n * processing scenarios.\n */\nclass ProcessingModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Sends message to the network\n     *\n     * @remarks\n     * Sends message to the network and returns the last generated shard block of the destination account\n     * before the message was sent. It will be required later for message processing.\n     *\n     * @param {ParamsOfSendMessage} params\n     * @returns ResultOfSendMessage\n     */\n    send_message(params, responseHandler) {\n        return this.client.request(\'processing.send_message\', params, responseHandler);\n    }\n    /**\n     * Performs monitoring of the network for the result transaction of the external inbound message processing.\n     *\n     * @remarks\n     * `send_events` enables intermediate events, such as `WillFetchNextBlock`,\n     * `FetchNextBlockFailed` that may be useful for logging of new shard blocks creation\n     * during message processing.\n     *\n     * Note, that presence of the `abi` parameter is critical for ABI\n     * compliant contracts. Message processing uses drastically\n     * different strategy for processing message for contracts which\n     * ABI includes "expire" header.\n     *\n     * When the ABI header `expire` is present, the processing uses\n     * `message expiration` strategy:\n     * - The maximum block gen time is set to\n     *   `message_expiration_timeout + transaction_wait_timeout`.\n     * - When maximum block gen time is reached, the processing will\n     *   be finished with `MessageExpired` error.\n     *\n     * When the ABI header `expire` isn\'t present or `abi` parameter\n     * isn\'t specified, the processing uses `transaction waiting`\n     * strategy:\n     * - The maximum block gen time is set to\n     *   `now() + transaction_wait_timeout`.\n     *\n     * - If maximum block gen time is reached and no result transaction is found,\n     * the processing will exit with an error.\n     *\n     * @param {ParamsOfWaitForTransaction} params\n     * @returns ResultOfProcessMessage\n     */\n    wait_for_transaction(params, responseHandler) {\n        return this.client.request(\'processing.wait_for_transaction\', params, responseHandler);\n    }\n    /**\n     * Creates message, sends it to the network and monitors its processing.\n     *\n     * @remarks\n     * Creates ABI-compatible message,\n     * sends it to the network and monitors for the result transaction.\n     * Decodes the output messages\' bodies.\n     *\n     * If contract\'s ABI includes "expire" header, then\n     * SDK implements retries in case of unsuccessful message delivery within the expiration\n     * timeout: SDK recreates the message, sends it and processes it again.\n     *\n     * The intermediate events, such as `WillFetchFirstBlock`, `WillSend`, `DidSend`,\n     * `WillFetchNextBlock`, etc - are switched on/off by `send_events` flag\n     * and logged into the supplied callback function.\n     *\n     * The retry configuration parameters are defined in the client\'s `NetworkConfig` and `AbiConfig`.\n     *\n     * If contract\'s ABI does not include "expire" header\n     * then, if no transaction is found within the network timeout (see config parameter ), exits with error.\n     *\n     * @param {ParamsOfProcessMessage} params\n     * @returns ResultOfProcessMessage\n     */\n    process_message(params, responseHandler) {\n        return this.client.request(\'processing.process_message\', params, responseHandler);\n    }\n}\nexports.ProcessingModule = ProcessingModule;\nfunction addressStringFormatAccountId() {\n    return {\n        type: \'AccountId\',\n    };\n}\nexports.addressStringFormatAccountId = addressStringFormatAccountId;\nfunction addressStringFormatHex() {\n    return {\n        type: \'Hex\',\n    };\n}\nexports.addressStringFormatHex = addressStringFormatHex;\nfunction addressStringFormatBase64(url, test, bounce) {\n    return {\n        type: \'Base64\',\n        url,\n        test,\n        bounce,\n    };\n}\nexports.addressStringFormatBase64 = addressStringFormatBase64;\nvar AccountAddressType;\n(function (AccountAddressType) {\n    AccountAddressType["AccountId"] = "AccountId";\n    AccountAddressType["Hex"] = "Hex";\n    AccountAddressType["Base64"] = "Base64";\n})(AccountAddressType = exports.AccountAddressType || (exports.AccountAddressType = {}));\n/**\n * Misc utility Functions.\n */\nclass UtilsModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Converts address from any TON format to any TON format\n     *\n     * @param {ParamsOfConvertAddress} params\n     * @returns ResultOfConvertAddress\n     */\n    convert_address(params) {\n        return this.client.request(\'utils.convert_address\', params);\n    }\n    /**\n     * Validates and returns the type of any TON address.\n     *\n     * @remarks\n     * Address types are the following\n     *\n     * `0:919db8e740d50bf349df2eea03fa30c385d846b991ff5542e67098ee833fc7f7` - standard TON address most\n     * commonly used in all cases. Also called as hex address\n     * `919db8e740d50bf349df2eea03fa30c385d846b991ff5542e67098ee833fc7f7` - account ID. A part of full\n     * address. Identifies account inside particular workchain\n     * `EQCRnbjnQNUL80nfLuoD+jDDhdhGuZH/VULmcJjugz/H9wam` - base64 address. Also called "user-friendly".\n     * Was used at the beginning of TON. Now it is supported for compatibility\n     *\n     * @param {ParamsOfGetAddressType} params\n     * @returns ResultOfGetAddressType\n     */\n    get_address_type(params) {\n        return this.client.request(\'utils.get_address_type\', params);\n    }\n    /**\n     * Calculates storage fee for an account over a specified time period\n     *\n     * @param {ParamsOfCalcStorageFee} params\n     * @returns ResultOfCalcStorageFee\n     */\n    calc_storage_fee(params) {\n        return this.client.request(\'utils.calc_storage_fee\', params);\n    }\n    /**\n     * Compresses data using Zstandard algorithm\n     *\n     * @param {ParamsOfCompressZstd} params\n     * @returns ResultOfCompressZstd\n     */\n    compress_zstd(params) {\n        return this.client.request(\'utils.compress_zstd\', params);\n    }\n    /**\n     * Decompresses data using Zstandard algorithm\n     *\n     * @param {ParamsOfDecompressZstd} params\n     * @returns ResultOfDecompressZstd\n     */\n    decompress_zstd(params) {\n        return this.client.request(\'utils.decompress_zstd\', params);\n    }\n}\nexports.UtilsModule = UtilsModule;\n// tvm module\nvar TvmErrorCode;\n(function (TvmErrorCode) {\n    TvmErrorCode[TvmErrorCode["CanNotReadTransaction"] = 401] = "CanNotReadTransaction";\n    TvmErrorCode[TvmErrorCode["CanNotReadBlockchainConfig"] = 402] = "CanNotReadBlockchainConfig";\n    TvmErrorCode[TvmErrorCode["TransactionAborted"] = 403] = "TransactionAborted";\n    TvmErrorCode[TvmErrorCode["InternalError"] = 404] = "InternalError";\n    TvmErrorCode[TvmErrorCode["ActionPhaseFailed"] = 405] = "ActionPhaseFailed";\n    TvmErrorCode[TvmErrorCode["AccountCodeMissing"] = 406] = "AccountCodeMissing";\n    TvmErrorCode[TvmErrorCode["LowBalance"] = 407] = "LowBalance";\n    TvmErrorCode[TvmErrorCode["AccountFrozenOrDeleted"] = 408] = "AccountFrozenOrDeleted";\n    TvmErrorCode[TvmErrorCode["AccountMissing"] = 409] = "AccountMissing";\n    TvmErrorCode[TvmErrorCode["UnknownExecutionError"] = 410] = "UnknownExecutionError";\n    TvmErrorCode[TvmErrorCode["InvalidInputStack"] = 411] = "InvalidInputStack";\n    TvmErrorCode[TvmErrorCode["InvalidAccountBoc"] = 412] = "InvalidAccountBoc";\n    TvmErrorCode[TvmErrorCode["InvalidMessageType"] = 413] = "InvalidMessageType";\n    TvmErrorCode[TvmErrorCode["ContractExecutionError"] = 414] = "ContractExecutionError";\n})(TvmErrorCode = exports.TvmErrorCode || (exports.TvmErrorCode = {}));\nfunction accountForExecutorNone() {\n    return {\n        type: \'None\',\n    };\n}\nexports.accountForExecutorNone = accountForExecutorNone;\nfunction accountForExecutorUninit() {\n    return {\n        type: \'Uninit\',\n    };\n}\nexports.accountForExecutorUninit = accountForExecutorUninit;\nfunction accountForExecutorAccount(boc, unlimited_balance) {\n    return {\n        type: \'Account\',\n        boc,\n        unlimited_balance,\n    };\n}\nexports.accountForExecutorAccount = accountForExecutorAccount;\nclass TvmModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Emulates all the phases of contract execution locally\n     *\n     * @remarks\n     * Performs all the phases of contract execution on Transaction Executor -\n     * the same component that is used on Validator Nodes.\n     *\n     * Can be used for contract debugging, to find out the reason why a message was not delivered successfully.\n     * Validators throw away the failed external inbound messages (if they failed bedore `ACCEPT`) in the real network.\n     * This is why these messages are impossible to debug in the real network.\n     * With the help of run_executor you can do that. In fact, `process_message` function\n     * performs local check with `run_executor` if there was no transaction as a result of processing\n     * and returns the error, if there is one.\n     *\n     * Another use case to use `run_executor` is to estimate fees for message execution.\n     * Set  `AccountForExecutor::Account.unlimited_balance`\n     * to `true` so that emulation will not depend on the actual balance.\n     * This may be needed to calculate deploy fees for an account that does not exist yet.\n     * JSON with fees is in `fees` field of the result.\n     *\n     * One more use case - you can produce the sequence of operations,\n     * thus emulating the sequential contract calls locally.\n     * And so on.\n     *\n     * Transaction executor requires account BOC (bag of cells) as a parameter.\n     * To get the account BOC - use `net.query` method to download it from GraphQL API\n     * (field `boc` of `account`) or generate it with `abi.encode_account` method.\n     *\n     * Also it requires message BOC. To get the message BOC - use `abi.encode_message` or `abi.encode_internal_message`.\n     *\n     * If you need this emulation to be as precise as possible (for instance - emulate transaction\n     * with particular lt in particular block or use particular blockchain config,\n     * downloaded from a particular key block - then specify `execution_options` parameter.\n     *\n     * If you need to see the aborted transaction as a result, not as an error, set `skip_transaction_check` to `true`.\n     *\n     * @param {ParamsOfRunExecutor} params\n     * @returns ResultOfRunExecutor\n     */\n    run_executor(params) {\n        return this.client.request(\'tvm.run_executor\', params);\n    }\n    /**\n     * Executes get-methods of ABI-compatible contracts\n     *\n     * @remarks\n     * Performs only a part of compute phase of transaction execution\n     * that is used to run get-methods of ABI-compatible contracts.\n     *\n     * If you try to run get-methods with `run_executor` you will get an error, because it checks ACCEPT and exits\n     * if there is none, which is actually true for get-methods.\n     *\n     *  To get the account BOC (bag of cells) - use `net.query` method to download it from GraphQL API\n     * (field `boc` of `account`) or generate it with `abi.encode_account method`.\n     * To get the message BOC - use `abi.encode_message` or prepare it any other way, for instance, with FIFT script.\n     *\n     * Attention! Updated account state is produces as well, but only\n     * `account_state.storage.state.data`  part of the BOC is updated.\n     *\n     * @param {ParamsOfRunTvm} params\n     * @returns ResultOfRunTvm\n     */\n    run_tvm(params) {\n        return this.client.request(\'tvm.run_tvm\', params);\n    }\n    /**\n     * Executes a get-method of FIFT contract\n     *\n     * @remarks\n     * Executes a get-method of FIFT contract that fulfills the smc-guidelines https://test.ton.org/smc-guidelines.txt\n     * and returns the result data from TVM\'s stack\n     *\n     * @param {ParamsOfRunGet} params\n     * @returns ResultOfRunGet\n     */\n    run_get(params) {\n        return this.client.request(\'tvm.run_get\', params);\n    }\n}\nexports.TvmModule = TvmModule;\n// net module\nvar NetErrorCode;\n(function (NetErrorCode) {\n    NetErrorCode[NetErrorCode["QueryFailed"] = 601] = "QueryFailed";\n    NetErrorCode[NetErrorCode["SubscribeFailed"] = 602] = "SubscribeFailed";\n    NetErrorCode[NetErrorCode["WaitForFailed"] = 603] = "WaitForFailed";\n    NetErrorCode[NetErrorCode["GetSubscriptionResultFailed"] = 604] = "GetSubscriptionResultFailed";\n    NetErrorCode[NetErrorCode["InvalidServerResponse"] = 605] = "InvalidServerResponse";\n    NetErrorCode[NetErrorCode["ClockOutOfSync"] = 606] = "ClockOutOfSync";\n    NetErrorCode[NetErrorCode["WaitForTimeout"] = 607] = "WaitForTimeout";\n    NetErrorCode[NetErrorCode["GraphqlError"] = 608] = "GraphqlError";\n    NetErrorCode[NetErrorCode["NetworkModuleSuspended"] = 609] = "NetworkModuleSuspended";\n    NetErrorCode[NetErrorCode["WebsocketDisconnected"] = 610] = "WebsocketDisconnected";\n    NetErrorCode[NetErrorCode["NotSupported"] = 611] = "NotSupported";\n    NetErrorCode[NetErrorCode["NoEndpointsProvided"] = 612] = "NoEndpointsProvided";\n    NetErrorCode[NetErrorCode["GraphqlWebsocketInitError"] = 613] = "GraphqlWebsocketInitError";\n    NetErrorCode[NetErrorCode["NetworkModuleResumed"] = 614] = "NetworkModuleResumed";\n    NetErrorCode[NetErrorCode["Unauthorized"] = 615] = "Unauthorized";\n})(NetErrorCode = exports.NetErrorCode || (exports.NetErrorCode = {}));\nvar SortDirection;\n(function (SortDirection) {\n    SortDirection["ASC"] = "ASC";\n    SortDirection["DESC"] = "DESC";\n})(SortDirection = exports.SortDirection || (exports.SortDirection = {}));\nfunction paramsOfQueryOperationQueryCollection(params) {\n    return Object.assign({ type: \'QueryCollection\' }, params);\n}\nexports.paramsOfQueryOperationQueryCollection = paramsOfQueryOperationQueryCollection;\nfunction paramsOfQueryOperationWaitForCollection(params) {\n    return Object.assign({ type: \'WaitForCollection\' }, params);\n}\nexports.paramsOfQueryOperationWaitForCollection = paramsOfQueryOperationWaitForCollection;\nfunction paramsOfQueryOperationAggregateCollection(params) {\n    return Object.assign({ type: \'AggregateCollection\' }, params);\n}\nexports.paramsOfQueryOperationAggregateCollection = paramsOfQueryOperationAggregateCollection;\nfunction paramsOfQueryOperationQueryCounterparties(params) {\n    return Object.assign({ type: \'QueryCounterparties\' }, params);\n}\nexports.paramsOfQueryOperationQueryCounterparties = paramsOfQueryOperationQueryCounterparties;\nvar AggregationFn;\n(function (AggregationFn) {\n    AggregationFn["COUNT"] = "COUNT";\n    AggregationFn["MIN"] = "MIN";\n    AggregationFn["MAX"] = "MAX";\n    AggregationFn["SUM"] = "SUM";\n    AggregationFn["AVERAGE"] = "AVERAGE";\n})(AggregationFn = exports.AggregationFn || (exports.AggregationFn = {}));\n/**\n * Network access.\n */\nclass NetModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Performs DAppServer GraphQL query.\n     *\n     * @param {ParamsOfQuery} params\n     * @returns ResultOfQuery\n     */\n    query(params) {\n        return this.client.request(\'net.query\', params);\n    }\n    /**\n     * Performs multiple queries per single fetch.\n     *\n     * @param {ParamsOfBatchQuery} params\n     * @returns ResultOfBatchQuery\n     */\n    batch_query(params) {\n        return this.client.request(\'net.batch_query\', params);\n    }\n    /**\n     * Queries collection data\n     *\n     * @remarks\n     * Queries data that satisfies the `filter` conditions,\n     * limits the number of returned records and orders them.\n     * The projection fields are limited to `result` fields\n     *\n     * @param {ParamsOfQueryCollection} params\n     * @returns ResultOfQueryCollection\n     */\n    query_collection(params) {\n        return this.client.request(\'net.query_collection\', params);\n    }\n    /**\n     * Aggregates collection data.\n     *\n     * @remarks\n     * Aggregates values from the specified `fields` for records\n     * that satisfies the `filter` conditions,\n     *\n     * @param {ParamsOfAggregateCollection} params\n     * @returns ResultOfAggregateCollection\n     */\n    aggregate_collection(params) {\n        return this.client.request(\'net.aggregate_collection\', params);\n    }\n    /**\n     * Returns an object that fulfills the conditions or waits for its appearance\n     *\n     * @remarks\n     * Triggers only once.\n     * If object that satisfies the `filter` conditions\n     * already exists - returns it immediately.\n     * If not - waits for insert/update of data within the specified `timeout`,\n     * and returns it.\n     * The projection fields are limited to `result` fields\n     *\n     * @param {ParamsOfWaitForCollection} params\n     * @returns ResultOfWaitForCollection\n     */\n    wait_for_collection(params) {\n        return this.client.request(\'net.wait_for_collection\', params);\n    }\n    /**\n     * Cancels a subscription\n     *\n     * @remarks\n     * Cancels a subscription specified by its handle.\n     *\n     * @param {ResultOfSubscribeCollection} params\n     * @returns\n     */\n    unsubscribe(params) {\n        return this.client.request(\'net.unsubscribe\', params);\n    }\n    /**\n     * Creates a collection subscription\n     *\n     * @remarks\n     * Triggers for each insert/update of data that satisfies\n     * the `filter` conditions.\n     * The projection fields are limited to `result` fields.\n     *\n     * The subscription is a persistent communication channel between\n     * client and Free TON Network.\n     * All changes in the blockchain will be reflected in realtime.\n     * Changes means inserts and updates of the blockchain entities.\n     *\n     * ### Important Notes on Subscriptions\n     *\n     * Unfortunately sometimes the connection with the network brakes down.\n     * In this situation the library attempts to reconnect to the network.\n     * This reconnection sequence can take significant time.\n     * All of this time the client is disconnected from the network.\n     *\n     * Bad news is that all blockchain changes that happened while\n     * the client was disconnected are lost.\n     *\n     * Good news is that the client report errors to the callback when\n     * it loses and resumes connection.\n     *\n     * So, if the lost changes are important to the application then\n     * the application must handle these error reports.\n     *\n     * Library reports errors with `responseType` == 101\n     * and the error object passed via `params`.\n     *\n     * When the library has successfully reconnected\n     * the application receives callback with\n     * `responseType` == 101 and `params.code` == 614 (NetworkModuleResumed).\n     *\n     * Application can use several ways to handle this situation:\n     * - If application monitors changes for the single blockchain\n     * object (for example specific account):  application\n     * can perform a query for this object and handle actual data as a\n     * regular data from the subscription.\n     * - If application monitors sequence of some blockchain objects\n     * (for example transactions of the specific account): application must\n     * refresh all cached (or visible to user) lists where this sequences presents.\n     *\n     * @param {ParamsOfSubscribeCollection} params\n     * @returns ResultOfSubscribeCollection\n     */\n    subscribe_collection(params, responseHandler) {\n        return this.client.request(\'net.subscribe_collection\', params, responseHandler);\n    }\n    /**\n     * Creates a subscription\n     *\n     * @remarks\n     * The subscription is a persistent communication channel between\n     * client and Everscale Network.\n     *\n     * ### Important Notes on Subscriptions\n     *\n     * Unfortunately sometimes the connection with the network breakes down.\n     * In this situation the library attempts to reconnect to the network.\n     * This reconnection sequence can take significant time.\n     * All of this time the client is disconnected from the network.\n     *\n     * Bad news is that all changes that happened while\n     * the client was disconnected are lost.\n     *\n     * Good news is that the client report errors to the callback when\n     * it loses and resumes connection.\n     *\n     * So, if the lost changes are important to the application then\n     * the application must handle these error reports.\n     *\n     * Library reports errors with `responseType` == 101\n     * and the error object passed via `params`.\n     *\n     * When the library has successfully reconnected\n     * the application receives callback with\n     * `responseType` == 101 and `params.code` == 614 (NetworkModuleResumed).\n     *\n     * Application can use several ways to handle this situation:\n     * - If application monitors changes for the single\n     * object (for example specific account):  application\n     * can perform a query for this object and handle actual data as a\n     * regular data from the subscription.\n     * - If application monitors sequence of some objects\n     * (for example transactions of the specific account): application must\n     * refresh all cached (or visible to user) lists where this sequences presents.\n     *\n     * @param {ParamsOfSubscribe} params\n     * @returns ResultOfSubscribeCollection\n     */\n    subscribe(params, responseHandler) {\n        return this.client.request(\'net.subscribe\', params, responseHandler);\n    }\n    /**\n     * Suspends network module to stop any network activity\n     * @returns\n     */\n    suspend() {\n        return this.client.request(\'net.suspend\');\n    }\n    /**\n     * Resumes network module to enable network activity\n     * @returns\n     */\n    resume() {\n        return this.client.request(\'net.resume\');\n    }\n    /**\n     * Returns ID of the last block in a specified account shard\n     *\n     * @param {ParamsOfFindLastShardBlock} params\n     * @returns ResultOfFindLastShardBlock\n     */\n    find_last_shard_block(params) {\n        return this.client.request(\'net.find_last_shard_block\', params);\n    }\n    /**\n     * Requests the list of alternative endpoints from server\n     * @returns EndpointsSet\n     */\n    fetch_endpoints() {\n        return this.client.request(\'net.fetch_endpoints\');\n    }\n    /**\n     * Sets the list of endpoints to use on reinit\n     *\n     * @param {EndpointsSet} params\n     * @returns\n     */\n    set_endpoints(params) {\n        return this.client.request(\'net.set_endpoints\', params);\n    }\n    /**\n     * Requests the list of alternative endpoints from server\n     * @returns ResultOfGetEndpoints\n     */\n    get_endpoints() {\n        return this.client.request(\'net.get_endpoints\');\n    }\n    /**\n     * Allows to query and paginate through the list of accounts that the specified account has interacted with, sorted by the time of the last internal message between accounts\n     *\n     * @remarks\n     * *Attention* this query retrieves data from \'Counterparties\' service which is not supported in\n     * the opensource version of DApp Server (and will not be supported) as well as in Evernode SE (will be supported in SE in future),\n     * but is always accessible via [EVER OS Clouds](../ton-os-api/networks.md)\n     *\n     * @param {ParamsOfQueryCounterparties} params\n     * @returns ResultOfQueryCollection\n     */\n    query_counterparties(params) {\n        return this.client.request(\'net.query_counterparties\', params);\n    }\n    /**\n     * Returns a tree of transactions triggered by a specific message.\n     *\n     * @remarks\n     * Performs recursive retrieval of a transactions tree produced by a specific message:\n     * in_msg -> dst_transaction -> out_messages -> dst_transaction -> ...\n     * If the chain of transactions execution is in progress while the function is running,\n     * it will wait for the next transactions to appear until the full tree or more than 50 transactions\n     * are received.\n     *\n     * All the retrieved messages and transactions are included\n     * into `result.messages` and `result.transactions` respectively.\n     *\n     * Function reads transactions layer by layer, by pages of 20 transactions.\n     *\n     * The retrieval prosess goes like this:\n     * Let\'s assume we have an infinite chain of transactions and each transaction generates 5 messages.\n     * 1. Retrieve 1st message (input parameter) and corresponding transaction - put it into result.\n     * It is the first level of the tree of transactions - its root.\n     * Retrieve 5 out message ids from the transaction for next steps.\n     * 2. Retrieve 5 messages and corresponding transactions on the 2nd layer. Put them into result.\n     * Retrieve 5*5 out message ids from these transactions for next steps\n     * 3. Retrieve 20 (size of the page) messages and transactions (3rd layer) and 20*5=100 message ids (4th layer).\n     * 4. Retrieve the last 5 messages and 5 transactions on the 3rd layer + 15 messages and transactions (of 100) from the 4th layer\n     * + 25 message ids of the 4th layer + 75 message ids of the 5th layer.\n     * 5. Retrieve 20 more messages and 20 more transactions of the 4th layer + 100 more message ids of the 5th layer.\n     * 6. Now we have 1+5+20+20+20 = 66 transactions, which is more than 50. Function exits with the tree of\n     * 1m->1t->5m->5t->25m->25t->35m->35t. If we see any message ids in the last transactions out_msgs, which don\'t have\n     * corresponding messages in the function result, it means that the full tree was not received and we need to continue iteration.\n     *\n     * To summarize, it is guaranteed that each message in `result.messages` has the corresponding transaction\n     * in the `result.transactions`.\n     * But there is no guarantee that all messages from transactions `out_msgs` are\n     * presented in `result.messages`.\n     * So the application has to continue retrieval for missing messages if it requires.\n     *\n     * @param {ParamsOfQueryTransactionTree} params\n     * @returns ResultOfQueryTransactionTree\n     */\n    query_transaction_tree(params) {\n        return this.client.request(\'net.query_transaction_tree\', params);\n    }\n    /**\n     * Creates block iterator.\n     *\n     * @remarks\n     * Block iterator uses robust iteration methods that guaranties that every\n     * block in the specified range isn\'t missed or iterated twice.\n     *\n     * Iterated range can be reduced with some filters:\n     * - `start_time`  the bottom time range. Only blocks with `gen_utime`\n     * more or equal to this value is iterated. If this parameter is omitted then there is\n     * no bottom time edge, so all blocks since zero state is iterated.\n     * - `end_time`  the upper time range. Only blocks with `gen_utime`\n     * less then this value is iterated. If this parameter is omitted then there is\n     * no upper time edge, so iterator never finishes.\n     * - `shard_filter`  workchains and shard prefixes that reduce the set of interesting\n     * blocks. Block conforms to the shard filter if it belongs to the filter workchain\n     * and the first bits of block\'s `shard` fields matches to the shard prefix.\n     * Only blocks with suitable shard are iterated.\n     *\n     * Items iterated is a JSON objects with block data. The minimal set of returned\n     * fields is:\n     * ```text\n     * id\n     * gen_utime\n     * workchain_id\n     * shard\n     * after_split\n     * after_merge\n     * prev_ref {\n     *     root_hash\n     * }\n     * prev_alt_ref {\n     *     root_hash\n     * }\n     * ```\n     * Application can request additional fields in the `result` parameter.\n     *\n     * Application should call the `remove_iterator` when iterator is no longer required.\n     *\n     * @param {ParamsOfCreateBlockIterator} params\n     * @returns RegisteredIterator\n     */\n    create_block_iterator(params) {\n        return this.client.request(\'net.create_block_iterator\', params);\n    }\n    /**\n     * Resumes block iterator.\n     *\n     * @remarks\n     * The iterator stays exactly at the same position where the `resume_state` was catched.\n     *\n     * Application should call the `remove_iterator` when iterator is no longer required.\n     *\n     * @param {ParamsOfResumeBlockIterator} params\n     * @returns RegisteredIterator\n     */\n    resume_block_iterator(params) {\n        return this.client.request(\'net.resume_block_iterator\', params);\n    }\n    /**\n     * Creates transaction iterator.\n     *\n     * @remarks\n     * Transaction iterator uses robust iteration methods that guaranty that every\n     * transaction in the specified range isn\'t missed or iterated twice.\n     *\n     * Iterated range can be reduced with some filters:\n     * - `start_time`  the bottom time range. Only transactions with `now`\n     * more or equal to this value are iterated. If this parameter is omitted then there is\n     * no bottom time edge, so all the transactions since zero state are iterated.\n     * - `end_time`  the upper time range. Only transactions with `now`\n     * less then this value are iterated. If this parameter is omitted then there is\n     * no upper time edge, so iterator never finishes.\n     * - `shard_filter`  workchains and shard prefixes that reduce the set of interesting\n     * accounts. Account address conforms to the shard filter if\n     * it belongs to the filter workchain and the first bits of address match to\n     * the shard prefix. Only transactions with suitable account addresses are iterated.\n     * - `accounts_filter`  set of account addresses whose transactions must be iterated.\n     * Note that accounts filter can conflict with shard filter so application must combine\n     * these filters carefully.\n     *\n     * Iterated item is a JSON objects with transaction data. The minimal set of returned\n     * fields is:\n     * ```text\n     * id\n     * account_addr\n     * now\n     * balance_delta(format:DEC)\n     * bounce { bounce_type }\n     * in_message {\n     *     id\n     *     value(format:DEC)\n     *     msg_type\n     *     src\n     * }\n     * out_messages {\n     *     id\n     *     value(format:DEC)\n     *     msg_type\n     *     dst\n     * }\n     * ```\n     * Application can request an additional fields in the `result` parameter.\n     *\n     * Another parameter that affects on the returned fields is the `include_transfers`.\n     * When this parameter is `true` the iterator computes and adds `transfer` field containing\n     * list of the useful `TransactionTransfer` objects.\n     * Each transfer is calculated from the particular message related to the transaction\n     * and has the following structure:\n     * - message  source message identifier.\n     * - isBounced  indicates that the transaction is bounced, which means the value will be returned back to the sender.\n     * - isDeposit  indicates that this transfer is the deposit (true) or withdraw (false).\n     * - counterparty  account address of the transfer source or destination depending on `isDeposit`.\n     * - value  amount of nano tokens transferred. The value is represented as a decimal string\n     * because the actual value can be more precise than the JSON number can represent. Application\n     * must use this string carefully  conversion to number can follow to loose of precision.\n     *\n     * Application should call the `remove_iterator` when iterator is no longer required.\n     *\n     * @param {ParamsOfCreateTransactionIterator} params\n     * @returns RegisteredIterator\n     */\n    create_transaction_iterator(params) {\n        return this.client.request(\'net.create_transaction_iterator\', params);\n    }\n    /**\n     * Resumes transaction iterator.\n     *\n     * @remarks\n     * The iterator stays exactly at the same position where the `resume_state` was caught.\n     * Note that `resume_state` doesn\'t store the account filter. If the application requires\n     * to use the same account filter as it was when the iterator was created then the application\n     * must pass the account filter again in `accounts_filter` parameter.\n     *\n     * Application should call the `remove_iterator` when iterator is no longer required.\n     *\n     * @param {ParamsOfResumeTransactionIterator} params\n     * @returns RegisteredIterator\n     */\n    resume_transaction_iterator(params) {\n        return this.client.request(\'net.resume_transaction_iterator\', params);\n    }\n    /**\n     * Returns next available items.\n     *\n     * @remarks\n     * In addition to available items this function returns the `has_more` flag\n     * indicating that the iterator isn\'t reach the end of the iterated range yet.\n     *\n     * This function can return the empty list of available items but\n     * indicates that there are more items is available.\n     * This situation appears when the iterator doesn\'t reach iterated range\n     * but database doesn\'t contains available items yet.\n     *\n     * If application requests resume state in `return_resume_state` parameter\n     * then this function returns `resume_state` that can be used later to\n     * resume the iteration from the position after returned items.\n     *\n     * The structure of the items returned depends on the iterator used.\n     * See the description to the appropriated iterator creation function.\n     *\n     * @param {ParamsOfIteratorNext} params\n     * @returns ResultOfIteratorNext\n     */\n    iterator_next(params) {\n        return this.client.request(\'net.iterator_next\', params);\n    }\n    /**\n     * Removes an iterator\n     *\n     * @remarks\n     * Frees all resources allocated in library to serve iterator.\n     *\n     * Application always should call the `remove_iterator` when iterator\n     * is no longer required.\n     *\n     * @param {RegisteredIterator} params\n     * @returns\n     */\n    remove_iterator(params) {\n        return this.client.request(\'net.remove_iterator\', params);\n    }\n}\nexports.NetModule = NetModule;\n// debot module\nvar DebotErrorCode;\n(function (DebotErrorCode) {\n    DebotErrorCode[DebotErrorCode["DebotStartFailed"] = 801] = "DebotStartFailed";\n    DebotErrorCode[DebotErrorCode["DebotFetchFailed"] = 802] = "DebotFetchFailed";\n    DebotErrorCode[DebotErrorCode["DebotExecutionFailed"] = 803] = "DebotExecutionFailed";\n    DebotErrorCode[DebotErrorCode["DebotInvalidHandle"] = 804] = "DebotInvalidHandle";\n    DebotErrorCode[DebotErrorCode["DebotInvalidJsonParams"] = 805] = "DebotInvalidJsonParams";\n    DebotErrorCode[DebotErrorCode["DebotInvalidFunctionId"] = 806] = "DebotInvalidFunctionId";\n    DebotErrorCode[DebotErrorCode["DebotInvalidAbi"] = 807] = "DebotInvalidAbi";\n    DebotErrorCode[DebotErrorCode["DebotGetMethodFailed"] = 808] = "DebotGetMethodFailed";\n    DebotErrorCode[DebotErrorCode["DebotInvalidMsg"] = 809] = "DebotInvalidMsg";\n    DebotErrorCode[DebotErrorCode["DebotExternalCallFailed"] = 810] = "DebotExternalCallFailed";\n    DebotErrorCode[DebotErrorCode["DebotBrowserCallbackFailed"] = 811] = "DebotBrowserCallbackFailed";\n    DebotErrorCode[DebotErrorCode["DebotOperationRejected"] = 812] = "DebotOperationRejected";\n    DebotErrorCode[DebotErrorCode["DebotNoCode"] = 813] = "DebotNoCode";\n})(DebotErrorCode = exports.DebotErrorCode || (exports.DebotErrorCode = {}));\nfunction debotActivityTransaction(msg, dst, out, fee, setcode, signkey, signing_box_handle) {\n    return {\n        type: \'Transaction\',\n        msg,\n        dst,\n        out,\n        fee,\n        setcode,\n        signkey,\n        signing_box_handle,\n    };\n}\nexports.debotActivityTransaction = debotActivityTransaction;\nfunction paramsOfAppDebotBrowserLog(msg) {\n    return {\n        type: \'Log\',\n        msg,\n    };\n}\nexports.paramsOfAppDebotBrowserLog = paramsOfAppDebotBrowserLog;\nfunction paramsOfAppDebotBrowserSwitch(context_id) {\n    return {\n        type: \'Switch\',\n        context_id,\n    };\n}\nexports.paramsOfAppDebotBrowserSwitch = paramsOfAppDebotBrowserSwitch;\nfunction paramsOfAppDebotBrowserSwitchCompleted() {\n    return {\n        type: \'SwitchCompleted\',\n    };\n}\nexports.paramsOfAppDebotBrowserSwitchCompleted = paramsOfAppDebotBrowserSwitchCompleted;\nfunction paramsOfAppDebotBrowserShowAction(action) {\n    return {\n        type: \'ShowAction\',\n        action,\n    };\n}\nexports.paramsOfAppDebotBrowserShowAction = paramsOfAppDebotBrowserShowAction;\nfunction paramsOfAppDebotBrowserInput(prompt) {\n    return {\n        type: \'Input\',\n        prompt,\n    };\n}\nexports.paramsOfAppDebotBrowserInput = paramsOfAppDebotBrowserInput;\nfunction paramsOfAppDebotBrowserGetSigningBox() {\n    return {\n        type: \'GetSigningBox\',\n    };\n}\nexports.paramsOfAppDebotBrowserGetSigningBox = paramsOfAppDebotBrowserGetSigningBox;\nfunction paramsOfAppDebotBrowserInvokeDebot(debot_addr, action) {\n    return {\n        type: \'InvokeDebot\',\n        debot_addr,\n        action,\n    };\n}\nexports.paramsOfAppDebotBrowserInvokeDebot = paramsOfAppDebotBrowserInvokeDebot;\nfunction paramsOfAppDebotBrowserSend(message) {\n    return {\n        type: \'Send\',\n        message,\n    };\n}\nexports.paramsOfAppDebotBrowserSend = paramsOfAppDebotBrowserSend;\nfunction paramsOfAppDebotBrowserApprove(activity) {\n    return {\n        type: \'Approve\',\n        activity,\n    };\n}\nexports.paramsOfAppDebotBrowserApprove = paramsOfAppDebotBrowserApprove;\nfunction resultOfAppDebotBrowserInput(value) {\n    return {\n        type: \'Input\',\n        value,\n    };\n}\nexports.resultOfAppDebotBrowserInput = resultOfAppDebotBrowserInput;\nfunction resultOfAppDebotBrowserGetSigningBox(signing_box) {\n    return {\n        type: \'GetSigningBox\',\n        signing_box,\n    };\n}\nexports.resultOfAppDebotBrowserGetSigningBox = resultOfAppDebotBrowserGetSigningBox;\nfunction resultOfAppDebotBrowserInvokeDebot() {\n    return {\n        type: \'InvokeDebot\',\n    };\n}\nexports.resultOfAppDebotBrowserInvokeDebot = resultOfAppDebotBrowserInvokeDebot;\nfunction resultOfAppDebotBrowserApprove(approved) {\n    return {\n        type: \'Approve\',\n        approved,\n    };\n}\nexports.resultOfAppDebotBrowserApprove = resultOfAppDebotBrowserApprove;\nfunction dispatchAppDebotBrowser(obj, params, app_request_id, client) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let result = {};\n            switch (params.type) {\n                case \'Log\':\n                    obj.log(params);\n                    break;\n                case \'Switch\':\n                    obj.switch(params);\n                    break;\n                case \'SwitchCompleted\':\n                    obj.switch_completed();\n                    break;\n                case \'ShowAction\':\n                    obj.show_action(params);\n                    break;\n                case \'Input\':\n                    result = yield obj.input(params);\n                    break;\n                case \'GetSigningBox\':\n                    result = yield obj.get_signing_box();\n                    break;\n                case \'InvokeDebot\':\n                    yield obj.invoke_debot(params);\n                    break;\n                case \'Send\':\n                    obj.send(params);\n                    break;\n                case \'Approve\':\n                    result = yield obj.approve(params);\n                    break;\n            }\n            client.resolve_app_request(app_request_id, Object.assign({ type: params.type }, result));\n        }\n        catch (error) {\n            client.reject_app_request(app_request_id, error);\n        }\n    });\n}\n/**\n * [UNSTABLE](UNSTABLE.md) Module for working with debot.\n */\nclass DebotModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * [UNSTABLE](UNSTABLE.md) Creates and instance of DeBot.\n     *\n     * @remarks\n     * Downloads debot smart contract (code and data) from blockchain and creates\n     * an instance of Debot Engine for it.\n     *\n     * # Remarks\n     * It does not switch debot to context 0. Browser Callbacks are not called.\n     *\n     * @param {ParamsOfInit} params\n     * @returns RegisteredDebot\n     */\n    init(params, obj) {\n        return this.client.request(\'debot.init\', params, (params, responseType) => {\n            if (responseType === 3) {\n                dispatchAppDebotBrowser(obj, params.request_data, params.app_request_id, this.client);\n            }\n            else if (responseType === 4) {\n                dispatchAppDebotBrowser(obj, params, null, this.client);\n            }\n        });\n    }\n    /**\n     * [UNSTABLE](UNSTABLE.md) Starts the DeBot.\n     *\n     * @remarks\n     * Downloads debot smart contract from blockchain and switches it to\n     * context zero.\n     *\n     * This function must be used by Debot Browser to start a dialog with debot.\n     * While the function is executing, several Browser Callbacks can be called,\n     * since the debot tries to display all actions from the context 0 to the user.\n     *\n     * When the debot starts SDK registers `BrowserCallbacks` AppObject.\n     * Therefore when `debote.remove` is called the debot is being deleted and the callback is called\n     * with `finish`=`true` which indicates that it will never be used again.\n     *\n     * @param {ParamsOfStart} params\n     * @returns\n     */\n    start(params) {\n        return this.client.request(\'debot.start\', params);\n    }\n    /**\n     * [UNSTABLE](UNSTABLE.md) Fetches DeBot metadata from blockchain.\n     *\n     * @remarks\n     * Downloads DeBot from blockchain and creates and fetches its metadata.\n     *\n     * @param {ParamsOfFetch} params\n     * @returns ResultOfFetch\n     */\n    fetch(params) {\n        return this.client.request(\'debot.fetch\', params);\n    }\n    /**\n     * [UNSTABLE](UNSTABLE.md) Executes debot action.\n     *\n     * @remarks\n     * Calls debot engine referenced by debot handle to execute input action.\n     * Calls Debot Browser Callbacks if needed.\n     *\n     * # Remarks\n     * Chain of actions can be executed if input action generates a list of subactions.\n     *\n     * @param {ParamsOfExecute} params\n     * @returns\n     */\n    execute(params) {\n        return this.client.request(\'debot.execute\', params);\n    }\n    /**\n     * [UNSTABLE](UNSTABLE.md) Sends message to Debot.\n     *\n     * @remarks\n     * Used by Debot Browser to send response on Dinterface call or from other Debots.\n     *\n     * @param {ParamsOfSend} params\n     * @returns\n     */\n    send(params) {\n        return this.client.request(\'debot.send\', params);\n    }\n    /**\n     * [UNSTABLE](UNSTABLE.md) Destroys debot handle.\n     *\n     * @remarks\n     * Removes handle from Client Context and drops debot engine referenced by that handle.\n     *\n     * @param {ParamsOfRemove} params\n     * @returns\n     */\n    remove(params) {\n        return this.client.request(\'debot.remove\', params);\n    }\n}\nexports.DebotModule = DebotModule;\n// proofs module\nvar ProofsErrorCode;\n(function (ProofsErrorCode) {\n    ProofsErrorCode[ProofsErrorCode["InvalidData"] = 901] = "InvalidData";\n    ProofsErrorCode[ProofsErrorCode["ProofCheckFailed"] = 902] = "ProofCheckFailed";\n    ProofsErrorCode[ProofsErrorCode["InternalError"] = 903] = "InternalError";\n    ProofsErrorCode[ProofsErrorCode["DataDiffersFromProven"] = 904] = "DataDiffersFromProven";\n})(ProofsErrorCode = exports.ProofsErrorCode || (exports.ProofsErrorCode = {}));\n/**\n * [UNSTABLE](UNSTABLE.md) Module for proving data, retrieved from TONOS API.\n */\nclass ProofsModule {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Proves that a given block\'s data, which is queried from TONOS API, can be trusted.\n     *\n     * @remarks\n     * This function checks block proofs and compares given data with the proven.\n     * If the given data differs from the proven, the exception will be thrown.\n     * The input param is a single block\'s JSON object, which was queried from DApp server using\n     * functions such as `net.query`, `net.query_collection` or `net.wait_for_collection`.\n     * If block\'s BOC is not provided in the JSON, it will be queried from DApp server\n     * (in this case it is required to provide at least `id` of block).\n     *\n     * Please note, that joins (like `signatures` in `Block`) are separated entities and not supported,\n     * so function will throw an exception in a case if JSON being checked has such entities in it.\n     *\n     * If `cache_in_local_storage` in config is set to `true` (default), downloaded proofs and\n     * master-chain BOCs are saved into the persistent local storage (e.g. file system for native\n     * environments or browser\'s IndexedDB for the web); otherwise all the data is cached only in\n     * memory in current client\'s context and will be lost after destruction of the client.\n     *\n     * **Why Proofs are needed**\n     *\n     * Proofs are needed to ensure that the data downloaded from a DApp server is real blockchain\n     * data. Checking proofs can protect from the malicious DApp server which can potentially provide\n     * fake data, or also from "Man in the Middle" attacks class.\n     *\n     * **What Proofs are**\n     *\n     * Simply, proof is a list of signatures of validators\', which have signed this particular master-\n     * block.\n     *\n     * The very first validator set\'s public keys are included in the zero-state. Whe know a root hash\n     * of the zero-state, because it is stored in the network configuration file, it is our authority\n     * root. For proving zero-state it is enough to calculate and compare its root hash.\n     *\n     * In each new validator cycle the validator set is changed. The new one is stored in a key-block,\n     * which is signed by the validator set, which we already trust, the next validator set will be\n     * stored to the new key-block and signed by the current validator set, and so on.\n     *\n     * In order to prove any block in the master-chain we need to check, that it has been signed by\n     * a trusted validator set. So we need to check all key-blocks\' proofs, started from the zero-state\n     * and until the block, which we want to prove. But it can take a lot of time and traffic to\n     * download and prove all key-blocks on a client. For solving this, special trusted blocks are used\n     * in Ever-SDK.\n     *\n     * The trusted block is the authority root, as well, as the zero-state. Each trusted block is the\n     * `id` (e.g. `root_hash`) of the already proven key-block. There can be plenty of trusted\n     * blocks, so there can be a lot of authority roots. The hashes of trusted blocks for MainNet\n     * and DevNet are hardcoded in SDK in a separated binary file (trusted_key_blocks.bin) and is\n     * being updated for each release by using `update_trusted_blocks` utility.\n     *\n     * See [update_trusted_blocks](../../../tools/update_trusted_blocks) directory for more info.\n     *\n     * In future SDK releases, one will also be able to provide their hashes of trusted blocks for\n     * other networks, besides for MainNet and DevNet.\n     * By using trusted key-blocks, in order to prove any block, we can prove chain of key-blocks to\n     * the closest previous trusted key-block, not only to the zero-state.\n     *\n     * But shard-blocks don\'t have proofs on DApp server. In this case, in order to prove any shard-\n     * block data, we search for a corresponding master-block, which contains the root hash of this\n     * shard-block, or some shard block which is linked to that block in shard-chain. After proving\n     * this master-block, we traverse through each link and calculate and compare hashes with links,\n     * one-by-one. After that we can ensure that this shard-block has also been proven.\n     *\n     * @param {ParamsOfProofBlockData} params\n     * @returns\n     */\n    proof_block_data(params) {\n        return this.client.request(\'proofs.proof_block_data\', params);\n    }\n    /**\n     * Proves that a given transaction\'s data, which is queried from TONOS API, can be trusted.\n     *\n     * @remarks\n     * This function requests the corresponding block, checks block proofs, ensures that given\n     * transaction exists in the proven block and compares given data with the proven.\n     * If the given data differs from the proven, the exception will be thrown.\n     * The input parameter is a single transaction\'s JSON object (see params description),\n     * which was queried from TONOS API using functions such as `net.query`, `net.query_collection`\n     * or `net.wait_for_collection`.\n     *\n     * If transaction\'s BOC and/or `block_id` are not provided in the JSON, they will be queried from\n     * TONOS API.\n     *\n     * Please note, that joins (like `account`, `in_message`, `out_messages`, etc. in `Transaction`\n     * entity) are separated entities and not supported, so function will throw an exception in a case\n     * if JSON being checked has such entities in it.\n     *\n     * For more information about proofs checking, see description of `proof_block_data` function.\n     *\n     * @param {ParamsOfProofTransactionData} params\n     * @returns\n     */\n    proof_transaction_data(params) {\n        return this.client.request(\'proofs.proof_transaction_data\', params);\n    }\n    /**\n     * Proves that a given message\'s data, which is queried from TONOS API, can be trusted.\n     *\n     * @remarks\n     * This function first proves the corresponding transaction, ensures that the proven transaction\n     * refers to the given message and compares given data with the proven.\n     * If the given data differs from the proven, the exception will be thrown.\n     * The input parameter is a single message\'s JSON object (see params description),\n     * which was queried from TONOS API using functions such as `net.query`, `net.query_collection`\n     * or `net.wait_for_collection`.\n     *\n     * If message\'s BOC and/or non-null `src_transaction.id` or `dst_transaction.id` are not provided\n     * in the JSON, they will be queried from TONOS API.\n     *\n     * Please note, that joins (like `block`, `dst_account`, `dst_transaction`, `src_account`,\n     * `src_transaction`, etc. in `Message` entity) are separated entities and not supported,\n     * so function will throw an exception in a case if JSON being checked has such entities in it.\n     *\n     * For more information about proofs checking, see description of `proof_block_data` function.\n     *\n     * @param {ParamsOfProofMessageData} params\n     * @returns\n     */\n    proof_message_data(params) {\n        return this.client.request(\'proofs.proof_message_data\', params);\n    }\n}\nexports.ProofsModule = ProofsModule;\n//# sourceMappingURL=modules.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjkxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL0BldmVyc2RrL2NvcmUvZGlzdC9tb2R1bGVzLmpzP2U4ODkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnVpbGRlck9wSW50ZWdlciA9IGV4cG9ydHMuQm9jRXJyb3JDb2RlID0gZXhwb3J0cy5ib2NDYWNoZVR5cGVVbnBpbm5lZCA9IGV4cG9ydHMuYm9jQ2FjaGVUeXBlUGlubmVkID0gZXhwb3J0cy5BYmlNb2R1bGUgPSBleHBvcnRzLm1lc3NhZ2VTb3VyY2VFbmNvZGluZ1BhcmFtcyA9IGV4cG9ydHMubWVzc2FnZVNvdXJjZUVuY29kZWQgPSBleHBvcnRzLnN0YXRlSW5pdFNvdXJjZVR2YyA9IGV4cG9ydHMuc3RhdGVJbml0U291cmNlU3RhdGVJbml0ID0gZXhwb3J0cy5zdGF0ZUluaXRTb3VyY2VNZXNzYWdlID0gZXhwb3J0cy5NZXNzYWdlQm9keVR5cGUgPSBleHBvcnRzLnNpZ25lclNpZ25pbmdCb3ggPSBleHBvcnRzLnNpZ25lcktleXMgPSBleHBvcnRzLnNpZ25lckV4dGVybmFsID0gZXhwb3J0cy5zaWduZXJOb25lID0gZXhwb3J0cy5hYmlTZXJpYWxpemVkID0gZXhwb3J0cy5hYmlIYW5kbGUgPSBleHBvcnRzLmFiaUpzb24gPSBleHBvcnRzLmFiaUNvbnRyYWN0ID0gZXhwb3J0cy5BYmlFcnJvckNvZGUgPSBleHBvcnRzLkNyeXB0b01vZHVsZSA9IGV4cG9ydHMucmVzdWx0T2ZBcHBFbmNyeXB0aW9uQm94RGVjcnlwdCA9IGV4cG9ydHMucmVzdWx0T2ZBcHBFbmNyeXB0aW9uQm94RW5jcnlwdCA9IGV4cG9ydHMucmVzdWx0T2ZBcHBFbmNyeXB0aW9uQm94R2V0SW5mbyA9IGV4cG9ydHMucGFyYW1zT2ZBcHBFbmNyeXB0aW9uQm94RGVjcnlwdCA9IGV4cG9ydHMucGFyYW1zT2ZBcHBFbmNyeXB0aW9uQm94RW5jcnlwdCA9IGV4cG9ydHMucGFyYW1zT2ZBcHBFbmNyeXB0aW9uQm94R2V0SW5mbyA9IGV4cG9ydHMucmVzdWx0T2ZBcHBTaWduaW5nQm94U2lnbiA9IGV4cG9ydHMucmVzdWx0T2ZBcHBTaWduaW5nQm94R2V0UHVibGljS2V5ID0gZXhwb3J0cy5wYXJhbXNPZkFwcFNpZ25pbmdCb3hTaWduID0gZXhwb3J0cy5wYXJhbXNPZkFwcFNpZ25pbmdCb3hHZXRQdWJsaWNLZXkgPSBleHBvcnRzLnJlc3VsdE9mQXBwUGFzc3dvcmRQcm92aWRlckdldFBhc3N3b3JkID0gZXhwb3J0cy5wYXJhbXNPZkFwcFBhc3N3b3JkUHJvdmlkZXJHZXRQYXNzd29yZCA9IGV4cG9ydHMuYm94RW5jcnlwdGlvbkFsZ29yaXRobU5hY2xTZWNyZXRCb3ggPSBleHBvcnRzLmJveEVuY3J5cHRpb25BbGdvcml0aG1OYWNsQm94ID0gZXhwb3J0cy5ib3hFbmNyeXB0aW9uQWxnb3JpdGhtQ2hhQ2hhMjAgPSBleHBvcnRzLmNyeXB0b0JveFNlY3JldEVuY3J5cHRlZFNlY3JldCA9IGV4cG9ydHMuY3J5cHRvQm94U2VjcmV0UHJlZGVmaW5lZFNlZWRQaHJhc2UgPSBleHBvcnRzLmNyeXB0b0JveFNlY3JldFJhbmRvbVNlZWRQaHJhc2UgPSBleHBvcnRzLkNpcGhlck1vZGUgPSBleHBvcnRzLmVuY3J5cHRpb25BbGdvcml0aG1OYWNsU2VjcmV0Qm94ID0gZXhwb3J0cy5lbmNyeXB0aW9uQWxnb3JpdGhtTmFjbEJveCA9IGV4cG9ydHMuZW5jcnlwdGlvbkFsZ29yaXRobUNoYUNoYTIwID0gZXhwb3J0cy5lbmNyeXB0aW9uQWxnb3JpdGhtQUVTID0gZXhwb3J0cy5DcnlwdG9FcnJvckNvZGUgPSBleHBvcnRzLkNsaWVudE1vZHVsZSA9IGV4cG9ydHMuYXBwUmVxdWVzdFJlc3VsdE9rID0gZXhwb3J0cy5hcHBSZXF1ZXN0UmVzdWx0RXJyb3IgPSBleHBvcnRzLk5ldHdvcmtRdWVyaWVzUHJvdG9jb2wgPSBleHBvcnRzLkNsaWVudEVycm9yQ29kZSA9IHZvaWQgMDtcbmV4cG9ydHMucmVzdWx0T2ZBcHBEZWJvdEJyb3dzZXJJbnB1dCA9IGV4cG9ydHMucGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJBcHByb3ZlID0gZXhwb3J0cy5wYXJhbXNPZkFwcERlYm90QnJvd3NlclNlbmQgPSBleHBvcnRzLnBhcmFtc09mQXBwRGVib3RCcm93c2VySW52b2tlRGVib3QgPSBleHBvcnRzLnBhcmFtc09mQXBwRGVib3RCcm93c2VyR2V0U2lnbmluZ0JveCA9IGV4cG9ydHMucGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJJbnB1dCA9IGV4cG9ydHMucGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJTaG93QWN0aW9uID0gZXhwb3J0cy5wYXJhbXNPZkFwcERlYm90QnJvd3NlclN3aXRjaENvbXBsZXRlZCA9IGV4cG9ydHMucGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJTd2l0Y2ggPSBleHBvcnRzLnBhcmFtc09mQXBwRGVib3RCcm93c2VyTG9nID0gZXhwb3J0cy5kZWJvdEFjdGl2aXR5VHJhbnNhY3Rpb24gPSBleHBvcnRzLkRlYm90RXJyb3JDb2RlID0gZXhwb3J0cy5OZXRNb2R1bGUgPSBleHBvcnRzLkFnZ3JlZ2F0aW9uRm4gPSBleHBvcnRzLnBhcmFtc09mUXVlcnlPcGVyYXRpb25RdWVyeUNvdW50ZXJwYXJ0aWVzID0gZXhwb3J0cy5wYXJhbXNPZlF1ZXJ5T3BlcmF0aW9uQWdncmVnYXRlQ29sbGVjdGlvbiA9IGV4cG9ydHMucGFyYW1zT2ZRdWVyeU9wZXJhdGlvbldhaXRGb3JDb2xsZWN0aW9uID0gZXhwb3J0cy5wYXJhbXNPZlF1ZXJ5T3BlcmF0aW9uUXVlcnlDb2xsZWN0aW9uID0gZXhwb3J0cy5Tb3J0RGlyZWN0aW9uID0gZXhwb3J0cy5OZXRFcnJvckNvZGUgPSBleHBvcnRzLlR2bU1vZHVsZSA9IGV4cG9ydHMuYWNjb3VudEZvckV4ZWN1dG9yQWNjb3VudCA9IGV4cG9ydHMuYWNjb3VudEZvckV4ZWN1dG9yVW5pbml0ID0gZXhwb3J0cy5hY2NvdW50Rm9yRXhlY3V0b3JOb25lID0gZXhwb3J0cy5Udm1FcnJvckNvZGUgPSBleHBvcnRzLlV0aWxzTW9kdWxlID0gZXhwb3J0cy5BY2NvdW50QWRkcmVzc1R5cGUgPSBleHBvcnRzLmFkZHJlc3NTdHJpbmdGb3JtYXRCYXNlNjQgPSBleHBvcnRzLmFkZHJlc3NTdHJpbmdGb3JtYXRIZXggPSBleHBvcnRzLmFkZHJlc3NTdHJpbmdGb3JtYXRBY2NvdW50SWQgPSBleHBvcnRzLlByb2Nlc3NpbmdNb2R1bGUgPSBleHBvcnRzLnByb2Nlc3NpbmdFdmVudFJlbXBFcnJvciA9IGV4cG9ydHMucHJvY2Vzc2luZ0V2ZW50UmVtcE90aGVyID0gZXhwb3J0cy5wcm9jZXNzaW5nRXZlbnRSZW1wSW5jbHVkZWRJbnRvQWNjZXB0ZWRCbG9jayA9IGV4cG9ydHMucHJvY2Vzc2luZ0V2ZW50UmVtcEluY2x1ZGVkSW50b0Jsb2NrID0gZXhwb3J0cy5wcm9jZXNzaW5nRXZlbnRSZW1wU2VudFRvVmFsaWRhdG9ycyA9IGV4cG9ydHMucHJvY2Vzc2luZ0V2ZW50TWVzc2FnZUV4cGlyZWQgPSBleHBvcnRzLnByb2Nlc3NpbmdFdmVudEZldGNoTmV4dEJsb2NrRmFpbGVkID0gZXhwb3J0cy5wcm9jZXNzaW5nRXZlbnRXaWxsRmV0Y2hOZXh0QmxvY2sgPSBleHBvcnRzLnByb2Nlc3NpbmdFdmVudFNlbmRGYWlsZWQgPSBleHBvcnRzLnByb2Nlc3NpbmdFdmVudERpZFNlbmQgPSBleHBvcnRzLnByb2Nlc3NpbmdFdmVudFdpbGxTZW5kID0gZXhwb3J0cy5wcm9jZXNzaW5nRXZlbnRGZXRjaEZpcnN0QmxvY2tGYWlsZWQgPSBleHBvcnRzLnByb2Nlc3NpbmdFdmVudFdpbGxGZXRjaEZpcnN0QmxvY2sgPSBleHBvcnRzLlByb2Nlc3NpbmdFcnJvckNvZGUgPSBleHBvcnRzLkJvY01vZHVsZSA9IGV4cG9ydHMuYnVpbGRlck9wQWRkcmVzcyA9IGV4cG9ydHMuYnVpbGRlck9wQ2VsbEJvYyA9IGV4cG9ydHMuYnVpbGRlck9wQ2VsbCA9IGV4cG9ydHMuYnVpbGRlck9wQml0U3RyaW5nID0gdm9pZCAwO1xuZXhwb3J0cy5Qcm9vZnNNb2R1bGUgPSBleHBvcnRzLlByb29mc0Vycm9yQ29kZSA9IGV4cG9ydHMuRGVib3RNb2R1bGUgPSBleHBvcnRzLnJlc3VsdE9mQXBwRGVib3RCcm93c2VyQXBwcm92ZSA9IGV4cG9ydHMucmVzdWx0T2ZBcHBEZWJvdEJyb3dzZXJJbnZva2VEZWJvdCA9IGV4cG9ydHMucmVzdWx0T2ZBcHBEZWJvdEJyb3dzZXJHZXRTaWduaW5nQm94ID0gdm9pZCAwO1xuLy8gY2xpZW50IG1vZHVsZVxudmFyIENsaWVudEVycm9yQ29kZTtcbihmdW5jdGlvbiAoQ2xpZW50RXJyb3JDb2RlKSB7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIk5vdEltcGxlbWVudGVkXCJdID0gMV0gPSBcIk5vdEltcGxlbWVudGVkXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkludmFsaWRIZXhcIl0gPSAyXSA9IFwiSW52YWxpZEhleFwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJJbnZhbGlkQmFzZTY0XCJdID0gM10gPSBcIkludmFsaWRCYXNlNjRcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiSW52YWxpZEFkZHJlc3NcIl0gPSA0XSA9IFwiSW52YWxpZEFkZHJlc3NcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiQ2FsbGJhY2tQYXJhbXNDYW50QmVDb252ZXJ0ZWRUb0pzb25cIl0gPSA1XSA9IFwiQ2FsbGJhY2tQYXJhbXNDYW50QmVDb252ZXJ0ZWRUb0pzb25cIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiV2Vic29ja2V0Q29ubmVjdEVycm9yXCJdID0gNl0gPSBcIldlYnNvY2tldENvbm5lY3RFcnJvclwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJXZWJzb2NrZXRSZWNlaXZlRXJyb3JcIl0gPSA3XSA9IFwiV2Vic29ja2V0UmVjZWl2ZUVycm9yXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIldlYnNvY2tldFNlbmRFcnJvclwiXSA9IDhdID0gXCJXZWJzb2NrZXRTZW5kRXJyb3JcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiSHR0cENsaWVudENyZWF0ZUVycm9yXCJdID0gOV0gPSBcIkh0dHBDbGllbnRDcmVhdGVFcnJvclwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJIdHRwUmVxdWVzdENyZWF0ZUVycm9yXCJdID0gMTBdID0gXCJIdHRwUmVxdWVzdENyZWF0ZUVycm9yXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkh0dHBSZXF1ZXN0U2VuZEVycm9yXCJdID0gMTFdID0gXCJIdHRwUmVxdWVzdFNlbmRFcnJvclwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJIdHRwUmVxdWVzdFBhcnNlRXJyb3JcIl0gPSAxMl0gPSBcIkh0dHBSZXF1ZXN0UGFyc2VFcnJvclwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJDYWxsYmFja05vdFJlZ2lzdGVyZWRcIl0gPSAxM10gPSBcIkNhbGxiYWNrTm90UmVnaXN0ZXJlZFwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJOZXRNb2R1bGVOb3RJbml0XCJdID0gMTRdID0gXCJOZXRNb2R1bGVOb3RJbml0XCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkludmFsaWRDb25maWdcIl0gPSAxNV0gPSBcIkludmFsaWRDb25maWdcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiQ2Fubm90Q3JlYXRlUnVudGltZVwiXSA9IDE2XSA9IFwiQ2Fubm90Q3JlYXRlUnVudGltZVwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJJbnZhbGlkQ29udGV4dEhhbmRsZVwiXSA9IDE3XSA9IFwiSW52YWxpZENvbnRleHRIYW5kbGVcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiQ2Fubm90U2VyaWFsaXplUmVzdWx0XCJdID0gMThdID0gXCJDYW5ub3RTZXJpYWxpemVSZXN1bHRcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiQ2Fubm90U2VyaWFsaXplRXJyb3JcIl0gPSAxOV0gPSBcIkNhbm5vdFNlcmlhbGl6ZUVycm9yXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkNhbm5vdENvbnZlcnRKc1ZhbHVlVG9Kc29uXCJdID0gMjBdID0gXCJDYW5ub3RDb252ZXJ0SnNWYWx1ZVRvSnNvblwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJDYW5ub3RSZWNlaXZlU3Bhd25lZFJlc3VsdFwiXSA9IDIxXSA9IFwiQ2Fubm90UmVjZWl2ZVNwYXduZWRSZXN1bHRcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiU2V0VGltZXJFcnJvclwiXSA9IDIyXSA9IFwiU2V0VGltZXJFcnJvclwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJJbnZhbGlkUGFyYW1zXCJdID0gMjNdID0gXCJJbnZhbGlkUGFyYW1zXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkNvbnRyYWN0c0FkZHJlc3NDb252ZXJzaW9uRmFpbGVkXCJdID0gMjRdID0gXCJDb250cmFjdHNBZGRyZXNzQ29udmVyc2lvbkZhaWxlZFwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJVbmtub3duRnVuY3Rpb25cIl0gPSAyNV0gPSBcIlVua25vd25GdW5jdGlvblwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJBcHBSZXF1ZXN0RXJyb3JcIl0gPSAyNl0gPSBcIkFwcFJlcXVlc3RFcnJvclwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJOb1N1Y2hSZXF1ZXN0XCJdID0gMjddID0gXCJOb1N1Y2hSZXF1ZXN0XCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkNhbk5vdFNlbmRSZXF1ZXN0UmVzdWx0XCJdID0gMjhdID0gXCJDYW5Ob3RTZW5kUmVxdWVzdFJlc3VsdFwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJDYW5Ob3RSZWNlaXZlUmVxdWVzdFJlc3VsdFwiXSA9IDI5XSA9IFwiQ2FuTm90UmVjZWl2ZVJlcXVlc3RSZXN1bHRcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiQ2FuTm90UGFyc2VSZXF1ZXN0UmVzdWx0XCJdID0gMzBdID0gXCJDYW5Ob3RQYXJzZVJlcXVlc3RSZXN1bHRcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiVW5leHBlY3RlZENhbGxiYWNrUmVzcG9uc2VcIl0gPSAzMV0gPSBcIlVuZXhwZWN0ZWRDYWxsYmFja1Jlc3BvbnNlXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkNhbk5vdFBhcnNlTnVtYmVyXCJdID0gMzJdID0gXCJDYW5Ob3RQYXJzZU51bWJlclwiO1xuICAgIENsaWVudEVycm9yQ29kZVtDbGllbnRFcnJvckNvZGVbXCJJbnRlcm5hbEVycm9yXCJdID0gMzNdID0gXCJJbnRlcm5hbEVycm9yXCI7XG4gICAgQ2xpZW50RXJyb3JDb2RlW0NsaWVudEVycm9yQ29kZVtcIkludmFsaWRIYW5kbGVcIl0gPSAzNF0gPSBcIkludmFsaWRIYW5kbGVcIjtcbiAgICBDbGllbnRFcnJvckNvZGVbQ2xpZW50RXJyb3JDb2RlW1wiTG9jYWxTdG9yYWdlRXJyb3JcIl0gPSAzNV0gPSBcIkxvY2FsU3RvcmFnZUVycm9yXCI7XG59KShDbGllbnRFcnJvckNvZGUgPSBleHBvcnRzLkNsaWVudEVycm9yQ29kZSB8fCAoZXhwb3J0cy5DbGllbnRFcnJvckNvZGUgPSB7fSkpO1xuLyoqXG4gKiBOZXR3b3JrIHByb3RvY29sIHVzZWQgdG8gcGVyZm9ybSBHcmFwaFFMIHF1ZXJpZXMuXG4gKi9cbnZhciBOZXR3b3JrUXVlcmllc1Byb3RvY29sO1xuKGZ1bmN0aW9uIChOZXR3b3JrUXVlcmllc1Byb3RvY29sKSB7XG4gICAgTmV0d29ya1F1ZXJpZXNQcm90b2NvbFtcIkhUVFBcIl0gPSBcIkhUVFBcIjtcbiAgICBOZXR3b3JrUXVlcmllc1Byb3RvY29sW1wiV1NcIl0gPSBcIldTXCI7XG59KShOZXR3b3JrUXVlcmllc1Byb3RvY29sID0gZXhwb3J0cy5OZXR3b3JrUXVlcmllc1Byb3RvY29sIHx8IChleHBvcnRzLk5ldHdvcmtRdWVyaWVzUHJvdG9jb2wgPSB7fSkpO1xuZnVuY3Rpb24gYXBwUmVxdWVzdFJlc3VsdEVycm9yKHRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRXJyb3InLFxuICAgICAgICB0ZXh0LFxuICAgIH07XG59XG5leHBvcnRzLmFwcFJlcXVlc3RSZXN1bHRFcnJvciA9IGFwcFJlcXVlc3RSZXN1bHRFcnJvcjtcbmZ1bmN0aW9uIGFwcFJlcXVlc3RSZXN1bHRPayhyZXN1bHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnT2snLFxuICAgICAgICByZXN1bHQsXG4gICAgfTtcbn1cbmV4cG9ydHMuYXBwUmVxdWVzdFJlc3VsdE9rID0gYXBwUmVxdWVzdFJlc3VsdE9rO1xuLyoqXG4gKiBQcm92aWRlcyBpbmZvcm1hdGlvbiBhYm91dCBsaWJyYXJ5LlxuICovXG5jbGFzcyBDbGllbnRNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBDb3JlIExpYnJhcnkgQVBJIHJlZmVyZW5jZVxuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mR2V0QXBpUmVmZXJlbmNlXG4gICAgICovXG4gICAgZ2V0X2FwaV9yZWZlcmVuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjbGllbnQuZ2V0X2FwaV9yZWZlcmVuY2UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBDb3JlIExpYnJhcnkgdmVyc2lvblxuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mVmVyc2lvblxuICAgICAqL1xuICAgIHZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjbGllbnQudmVyc2lvbicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIENvcmUgTGlicmFyeSBBUEkgcmVmZXJlbmNlXG4gICAgICogQHJldHVybnMgQ2xpZW50Q29uZmlnXG4gICAgICovXG4gICAgY29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY2xpZW50LmNvbmZpZycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgYnVpbGQuXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZCdWlsZEluZm9cbiAgICAgKi9cbiAgICBidWlsZF9pbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY2xpZW50LmJ1aWxkX2luZm8nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgYXBwbGljYXRpb24gcmVxdWVzdCBwcm9jZXNzaW5nIHJlc3VsdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlJlc29sdmVBcHBSZXF1ZXN0fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHJlc29sdmVfYXBwX3JlcXVlc3QocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjbGllbnQucmVzb2x2ZV9hcHBfcmVxdWVzdCcsIHBhcmFtcyk7XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnRNb2R1bGUgPSBDbGllbnRNb2R1bGU7XG4vLyBjcnlwdG8gbW9kdWxlXG52YXIgQ3J5cHRvRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChDcnlwdG9FcnJvckNvZGUpIHtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiSW52YWxpZFB1YmxpY0tleVwiXSA9IDEwMF0gPSBcIkludmFsaWRQdWJsaWNLZXlcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiSW52YWxpZFNlY3JldEtleVwiXSA9IDEwMV0gPSBcIkludmFsaWRTZWNyZXRLZXlcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiSW52YWxpZEtleVwiXSA9IDEwMl0gPSBcIkludmFsaWRLZXlcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiSW52YWxpZEZhY3Rvcml6ZUNoYWxsZW5nZVwiXSA9IDEwNl0gPSBcIkludmFsaWRGYWN0b3JpemVDaGFsbGVuZ2VcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiSW52YWxpZEJpZ0ludFwiXSA9IDEwN10gPSBcIkludmFsaWRCaWdJbnRcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiU2NyeXB0RmFpbGVkXCJdID0gMTA4XSA9IFwiU2NyeXB0RmFpbGVkXCI7XG4gICAgQ3J5cHRvRXJyb3JDb2RlW0NyeXB0b0Vycm9yQ29kZVtcIkludmFsaWRLZXlTaXplXCJdID0gMTA5XSA9IFwiSW52YWxpZEtleVNpemVcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiTmFjbFNlY3JldEJveEZhaWxlZFwiXSA9IDExMF0gPSBcIk5hY2xTZWNyZXRCb3hGYWlsZWRcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiTmFjbEJveEZhaWxlZFwiXSA9IDExMV0gPSBcIk5hY2xCb3hGYWlsZWRcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiTmFjbFNpZ25GYWlsZWRcIl0gPSAxMTJdID0gXCJOYWNsU2lnbkZhaWxlZFwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJCaXAzOUludmFsaWRFbnRyb3B5XCJdID0gMTEzXSA9IFwiQmlwMzlJbnZhbGlkRW50cm9weVwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJCaXAzOUludmFsaWRQaHJhc2VcIl0gPSAxMTRdID0gXCJCaXAzOUludmFsaWRQaHJhc2VcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiQmlwMzJJbnZhbGlkS2V5XCJdID0gMTE1XSA9IFwiQmlwMzJJbnZhbGlkS2V5XCI7XG4gICAgQ3J5cHRvRXJyb3JDb2RlW0NyeXB0b0Vycm9yQ29kZVtcIkJpcDMySW52YWxpZERlcml2ZVBhdGhcIl0gPSAxMTZdID0gXCJCaXAzMkludmFsaWREZXJpdmVQYXRoXCI7XG4gICAgQ3J5cHRvRXJyb3JDb2RlW0NyeXB0b0Vycm9yQ29kZVtcIkJpcDM5SW52YWxpZERpY3Rpb25hcnlcIl0gPSAxMTddID0gXCJCaXAzOUludmFsaWREaWN0aW9uYXJ5XCI7XG4gICAgQ3J5cHRvRXJyb3JDb2RlW0NyeXB0b0Vycm9yQ29kZVtcIkJpcDM5SW52YWxpZFdvcmRDb3VudFwiXSA9IDExOF0gPSBcIkJpcDM5SW52YWxpZFdvcmRDb3VudFwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJNbmVtb25pY0dlbmVyYXRpb25GYWlsZWRcIl0gPSAxMTldID0gXCJNbmVtb25pY0dlbmVyYXRpb25GYWlsZWRcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiTW5lbW9uaWNGcm9tRW50cm9weUZhaWxlZFwiXSA9IDEyMF0gPSBcIk1uZW1vbmljRnJvbUVudHJvcHlGYWlsZWRcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiU2lnbmluZ0JveE5vdFJlZ2lzdGVyZWRcIl0gPSAxMjFdID0gXCJTaWduaW5nQm94Tm90UmVnaXN0ZXJlZFwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJJbnZhbGlkU2lnbmF0dXJlXCJdID0gMTIyXSA9IFwiSW52YWxpZFNpZ25hdHVyZVwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJFbmNyeXB0aW9uQm94Tm90UmVnaXN0ZXJlZFwiXSA9IDEyM10gPSBcIkVuY3J5cHRpb25Cb3hOb3RSZWdpc3RlcmVkXCI7XG4gICAgQ3J5cHRvRXJyb3JDb2RlW0NyeXB0b0Vycm9yQ29kZVtcIkludmFsaWRJdlNpemVcIl0gPSAxMjRdID0gXCJJbnZhbGlkSXZTaXplXCI7XG4gICAgQ3J5cHRvRXJyb3JDb2RlW0NyeXB0b0Vycm9yQ29kZVtcIlVuc3VwcG9ydGVkQ2lwaGVyTW9kZVwiXSA9IDEyNV0gPSBcIlVuc3VwcG9ydGVkQ2lwaGVyTW9kZVwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJDYW5ub3RDcmVhdGVDaXBoZXJcIl0gPSAxMjZdID0gXCJDYW5ub3RDcmVhdGVDaXBoZXJcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiRW5jcnlwdERhdGFFcnJvclwiXSA9IDEyN10gPSBcIkVuY3J5cHREYXRhRXJyb3JcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiRGVjcnlwdERhdGFFcnJvclwiXSA9IDEyOF0gPSBcIkRlY3J5cHREYXRhRXJyb3JcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiSXZSZXF1aXJlZFwiXSA9IDEyOV0gPSBcIkl2UmVxdWlyZWRcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiQ3J5cHRvQm94Tm90UmVnaXN0ZXJlZFwiXSA9IDEzMF0gPSBcIkNyeXB0b0JveE5vdFJlZ2lzdGVyZWRcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiSW52YWxpZENyeXB0b0JveFR5cGVcIl0gPSAxMzFdID0gXCJJbnZhbGlkQ3J5cHRvQm94VHlwZVwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJDcnlwdG9Cb3hTZWNyZXRTZXJpYWxpemF0aW9uRXJyb3JcIl0gPSAxMzJdID0gXCJDcnlwdG9Cb3hTZWNyZXRTZXJpYWxpemF0aW9uRXJyb3JcIjtcbiAgICBDcnlwdG9FcnJvckNvZGVbQ3J5cHRvRXJyb3JDb2RlW1wiQ3J5cHRvQm94U2VjcmV0RGVzZXJpYWxpemF0aW9uRXJyb3JcIl0gPSAxMzNdID0gXCJDcnlwdG9Cb3hTZWNyZXREZXNlcmlhbGl6YXRpb25FcnJvclwiO1xuICAgIENyeXB0b0Vycm9yQ29kZVtDcnlwdG9FcnJvckNvZGVbXCJJbnZhbGlkTm9uY2VTaXplXCJdID0gMTM0XSA9IFwiSW52YWxpZE5vbmNlU2l6ZVwiO1xufSkoQ3J5cHRvRXJyb3JDb2RlID0gZXhwb3J0cy5DcnlwdG9FcnJvckNvZGUgfHwgKGV4cG9ydHMuQ3J5cHRvRXJyb3JDb2RlID0ge30pKTtcbmZ1bmN0aW9uIGVuY3J5cHRpb25BbGdvcml0aG1BRVModmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnQUVTJyxcbiAgICAgICAgdmFsdWUsXG4gICAgfTtcbn1cbmV4cG9ydHMuZW5jcnlwdGlvbkFsZ29yaXRobUFFUyA9IGVuY3J5cHRpb25BbGdvcml0aG1BRVM7XG5mdW5jdGlvbiBlbmNyeXB0aW9uQWxnb3JpdGhtQ2hhQ2hhMjAodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnQ2hhQ2hhMjAnLFxuICAgICAgICB2YWx1ZSxcbiAgICB9O1xufVxuZXhwb3J0cy5lbmNyeXB0aW9uQWxnb3JpdGhtQ2hhQ2hhMjAgPSBlbmNyeXB0aW9uQWxnb3JpdGhtQ2hhQ2hhMjA7XG5mdW5jdGlvbiBlbmNyeXB0aW9uQWxnb3JpdGhtTmFjbEJveCh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdOYWNsQm94JyxcbiAgICAgICAgdmFsdWUsXG4gICAgfTtcbn1cbmV4cG9ydHMuZW5jcnlwdGlvbkFsZ29yaXRobU5hY2xCb3ggPSBlbmNyeXB0aW9uQWxnb3JpdGhtTmFjbEJveDtcbmZ1bmN0aW9uIGVuY3J5cHRpb25BbGdvcml0aG1OYWNsU2VjcmV0Qm94KHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ05hY2xTZWNyZXRCb3gnLFxuICAgICAgICB2YWx1ZSxcbiAgICB9O1xufVxuZXhwb3J0cy5lbmNyeXB0aW9uQWxnb3JpdGhtTmFjbFNlY3JldEJveCA9IGVuY3J5cHRpb25BbGdvcml0aG1OYWNsU2VjcmV0Qm94O1xudmFyIENpcGhlck1vZGU7XG4oZnVuY3Rpb24gKENpcGhlck1vZGUpIHtcbiAgICBDaXBoZXJNb2RlW1wiQ0JDXCJdID0gXCJDQkNcIjtcbiAgICBDaXBoZXJNb2RlW1wiQ0ZCXCJdID0gXCJDRkJcIjtcbiAgICBDaXBoZXJNb2RlW1wiQ1RSXCJdID0gXCJDVFJcIjtcbiAgICBDaXBoZXJNb2RlW1wiRUNCXCJdID0gXCJFQ0JcIjtcbiAgICBDaXBoZXJNb2RlW1wiT0ZCXCJdID0gXCJPRkJcIjtcbn0pKENpcGhlck1vZGUgPSBleHBvcnRzLkNpcGhlck1vZGUgfHwgKGV4cG9ydHMuQ2lwaGVyTW9kZSA9IHt9KSk7XG5mdW5jdGlvbiBjcnlwdG9Cb3hTZWNyZXRSYW5kb21TZWVkUGhyYXNlKGRpY3Rpb25hcnksIHdvcmRjb3VudCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdSYW5kb21TZWVkUGhyYXNlJyxcbiAgICAgICAgZGljdGlvbmFyeSxcbiAgICAgICAgd29yZGNvdW50LFxuICAgIH07XG59XG5leHBvcnRzLmNyeXB0b0JveFNlY3JldFJhbmRvbVNlZWRQaHJhc2UgPSBjcnlwdG9Cb3hTZWNyZXRSYW5kb21TZWVkUGhyYXNlO1xuZnVuY3Rpb24gY3J5cHRvQm94U2VjcmV0UHJlZGVmaW5lZFNlZWRQaHJhc2UocGhyYXNlLCBkaWN0aW9uYXJ5LCB3b3JkY291bnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnUHJlZGVmaW5lZFNlZWRQaHJhc2UnLFxuICAgICAgICBwaHJhc2UsXG4gICAgICAgIGRpY3Rpb25hcnksXG4gICAgICAgIHdvcmRjb3VudCxcbiAgICB9O1xufVxuZXhwb3J0cy5jcnlwdG9Cb3hTZWNyZXRQcmVkZWZpbmVkU2VlZFBocmFzZSA9IGNyeXB0b0JveFNlY3JldFByZWRlZmluZWRTZWVkUGhyYXNlO1xuZnVuY3Rpb24gY3J5cHRvQm94U2VjcmV0RW5jcnlwdGVkU2VjcmV0KGVuY3J5cHRlZF9zZWNyZXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRW5jcnlwdGVkU2VjcmV0JyxcbiAgICAgICAgZW5jcnlwdGVkX3NlY3JldCxcbiAgICB9O1xufVxuZXhwb3J0cy5jcnlwdG9Cb3hTZWNyZXRFbmNyeXB0ZWRTZWNyZXQgPSBjcnlwdG9Cb3hTZWNyZXRFbmNyeXB0ZWRTZWNyZXQ7XG5mdW5jdGlvbiBib3hFbmNyeXB0aW9uQWxnb3JpdGhtQ2hhQ2hhMjAodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnQ2hhQ2hhMjAnLFxuICAgICAgICB2YWx1ZSxcbiAgICB9O1xufVxuZXhwb3J0cy5ib3hFbmNyeXB0aW9uQWxnb3JpdGhtQ2hhQ2hhMjAgPSBib3hFbmNyeXB0aW9uQWxnb3JpdGhtQ2hhQ2hhMjA7XG5mdW5jdGlvbiBib3hFbmNyeXB0aW9uQWxnb3JpdGhtTmFjbEJveCh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdOYWNsQm94JyxcbiAgICAgICAgdmFsdWUsXG4gICAgfTtcbn1cbmV4cG9ydHMuYm94RW5jcnlwdGlvbkFsZ29yaXRobU5hY2xCb3ggPSBib3hFbmNyeXB0aW9uQWxnb3JpdGhtTmFjbEJveDtcbmZ1bmN0aW9uIGJveEVuY3J5cHRpb25BbGdvcml0aG1OYWNsU2VjcmV0Qm94KHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ05hY2xTZWNyZXRCb3gnLFxuICAgICAgICB2YWx1ZSxcbiAgICB9O1xufVxuZXhwb3J0cy5ib3hFbmNyeXB0aW9uQWxnb3JpdGhtTmFjbFNlY3JldEJveCA9IGJveEVuY3J5cHRpb25BbGdvcml0aG1OYWNsU2VjcmV0Qm94O1xuZnVuY3Rpb24gcGFyYW1zT2ZBcHBQYXNzd29yZFByb3ZpZGVyR2V0UGFzc3dvcmQoZW5jcnlwdGlvbl9wdWJsaWNfa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0dldFBhc3N3b3JkJyxcbiAgICAgICAgZW5jcnlwdGlvbl9wdWJsaWNfa2V5LFxuICAgIH07XG59XG5leHBvcnRzLnBhcmFtc09mQXBwUGFzc3dvcmRQcm92aWRlckdldFBhc3N3b3JkID0gcGFyYW1zT2ZBcHBQYXNzd29yZFByb3ZpZGVyR2V0UGFzc3dvcmQ7XG5mdW5jdGlvbiByZXN1bHRPZkFwcFBhc3N3b3JkUHJvdmlkZXJHZXRQYXNzd29yZChlbmNyeXB0ZWRfcGFzc3dvcmQsIGFwcF9lbmNyeXB0aW9uX3B1YmtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdHZXRQYXNzd29yZCcsXG4gICAgICAgIGVuY3J5cHRlZF9wYXNzd29yZCxcbiAgICAgICAgYXBwX2VuY3J5cHRpb25fcHVia2V5LFxuICAgIH07XG59XG5leHBvcnRzLnJlc3VsdE9mQXBwUGFzc3dvcmRQcm92aWRlckdldFBhc3N3b3JkID0gcmVzdWx0T2ZBcHBQYXNzd29yZFByb3ZpZGVyR2V0UGFzc3dvcmQ7XG5mdW5jdGlvbiBwYXJhbXNPZkFwcFNpZ25pbmdCb3hHZXRQdWJsaWNLZXkoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0dldFB1YmxpY0tleScsXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyYW1zT2ZBcHBTaWduaW5nQm94R2V0UHVibGljS2V5ID0gcGFyYW1zT2ZBcHBTaWduaW5nQm94R2V0UHVibGljS2V5O1xuZnVuY3Rpb24gcGFyYW1zT2ZBcHBTaWduaW5nQm94U2lnbih1bnNpZ25lZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdTaWduJyxcbiAgICAgICAgdW5zaWduZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyYW1zT2ZBcHBTaWduaW5nQm94U2lnbiA9IHBhcmFtc09mQXBwU2lnbmluZ0JveFNpZ247XG5mdW5jdGlvbiByZXN1bHRPZkFwcFNpZ25pbmdCb3hHZXRQdWJsaWNLZXkocHVibGljX2tleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdHZXRQdWJsaWNLZXknLFxuICAgICAgICBwdWJsaWNfa2V5LFxuICAgIH07XG59XG5leHBvcnRzLnJlc3VsdE9mQXBwU2lnbmluZ0JveEdldFB1YmxpY0tleSA9IHJlc3VsdE9mQXBwU2lnbmluZ0JveEdldFB1YmxpY0tleTtcbmZ1bmN0aW9uIHJlc3VsdE9mQXBwU2lnbmluZ0JveFNpZ24oc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1NpZ24nLFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgfTtcbn1cbmV4cG9ydHMucmVzdWx0T2ZBcHBTaWduaW5nQm94U2lnbiA9IHJlc3VsdE9mQXBwU2lnbmluZ0JveFNpZ247XG5mdW5jdGlvbiBwYXJhbXNPZkFwcEVuY3J5cHRpb25Cb3hHZXRJbmZvKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdHZXRJbmZvJyxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJhbXNPZkFwcEVuY3J5cHRpb25Cb3hHZXRJbmZvID0gcGFyYW1zT2ZBcHBFbmNyeXB0aW9uQm94R2V0SW5mbztcbmZ1bmN0aW9uIHBhcmFtc09mQXBwRW5jcnlwdGlvbkJveEVuY3J5cHQoZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdFbmNyeXB0JyxcbiAgICAgICAgZGF0YSxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJhbXNPZkFwcEVuY3J5cHRpb25Cb3hFbmNyeXB0ID0gcGFyYW1zT2ZBcHBFbmNyeXB0aW9uQm94RW5jcnlwdDtcbmZ1bmN0aW9uIHBhcmFtc09mQXBwRW5jcnlwdGlvbkJveERlY3J5cHQoZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdEZWNyeXB0JyxcbiAgICAgICAgZGF0YSxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJhbXNPZkFwcEVuY3J5cHRpb25Cb3hEZWNyeXB0ID0gcGFyYW1zT2ZBcHBFbmNyeXB0aW9uQm94RGVjcnlwdDtcbmZ1bmN0aW9uIHJlc3VsdE9mQXBwRW5jcnlwdGlvbkJveEdldEluZm8oaW5mbykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdHZXRJbmZvJyxcbiAgICAgICAgaW5mbyxcbiAgICB9O1xufVxuZXhwb3J0cy5yZXN1bHRPZkFwcEVuY3J5cHRpb25Cb3hHZXRJbmZvID0gcmVzdWx0T2ZBcHBFbmNyeXB0aW9uQm94R2V0SW5mbztcbmZ1bmN0aW9uIHJlc3VsdE9mQXBwRW5jcnlwdGlvbkJveEVuY3J5cHQoZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdFbmNyeXB0JyxcbiAgICAgICAgZGF0YSxcbiAgICB9O1xufVxuZXhwb3J0cy5yZXN1bHRPZkFwcEVuY3J5cHRpb25Cb3hFbmNyeXB0ID0gcmVzdWx0T2ZBcHBFbmNyeXB0aW9uQm94RW5jcnlwdDtcbmZ1bmN0aW9uIHJlc3VsdE9mQXBwRW5jcnlwdGlvbkJveERlY3J5cHQoZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdEZWNyeXB0JyxcbiAgICAgICAgZGF0YSxcbiAgICB9O1xufVxuZXhwb3J0cy5yZXN1bHRPZkFwcEVuY3J5cHRpb25Cb3hEZWNyeXB0ID0gcmVzdWx0T2ZBcHBFbmNyeXB0aW9uQm94RGVjcnlwdDtcbmZ1bmN0aW9uIGRpc3BhdGNoQXBwUGFzc3dvcmRQcm92aWRlcihvYmosIHBhcmFtcywgYXBwX3JlcXVlc3RfaWQsIGNsaWVudCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcmFtcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnR2V0UGFzc3dvcmQnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCBvYmouZ2V0X3Bhc3N3b3JkKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xpZW50LnJlc29sdmVfYXBwX3JlcXVlc3QoYXBwX3JlcXVlc3RfaWQsIE9iamVjdC5hc3NpZ24oeyB0eXBlOiBwYXJhbXMudHlwZSB9LCByZXN1bHQpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNsaWVudC5yZWplY3RfYXBwX3JlcXVlc3QoYXBwX3JlcXVlc3RfaWQsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hBcHBTaWduaW5nQm94KG9iaiwgcGFyYW1zLCBhcHBfcmVxdWVzdF9pZCwgY2xpZW50KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIHN3aXRjaCAocGFyYW1zLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdHZXRQdWJsaWNLZXknOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCBvYmouZ2V0X3B1YmxpY19rZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnU2lnbic6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIG9iai5zaWduKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xpZW50LnJlc29sdmVfYXBwX3JlcXVlc3QoYXBwX3JlcXVlc3RfaWQsIE9iamVjdC5hc3NpZ24oeyB0eXBlOiBwYXJhbXMudHlwZSB9LCByZXN1bHQpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNsaWVudC5yZWplY3RfYXBwX3JlcXVlc3QoYXBwX3JlcXVlc3RfaWQsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hBcHBFbmNyeXB0aW9uQm94KG9iaiwgcGFyYW1zLCBhcHBfcmVxdWVzdF9pZCwgY2xpZW50KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIHN3aXRjaCAocGFyYW1zLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdHZXRJbmZvJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgb2JqLmdldF9pbmZvKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0VuY3J5cHQnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCBvYmouZW5jcnlwdChwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdEZWNyeXB0JzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgb2JqLmRlY3J5cHQocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGllbnQucmVzb2x2ZV9hcHBfcmVxdWVzdChhcHBfcmVxdWVzdF9pZCwgT2JqZWN0LmFzc2lnbih7IHR5cGU6IHBhcmFtcy50eXBlIH0sIHJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2xpZW50LnJlamVjdF9hcHBfcmVxdWVzdChhcHBfcmVxdWVzdF9pZCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIENyeXB0byBmdW5jdGlvbnMuXG4gKi9cbmNsYXNzIENyeXB0b01vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlZ2VyIGZhY3Rvcml6YXRpb25cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUGVyZm9ybXMgcHJpbWUgZmFjdG9yaXphdGlvbiDigJMgZGVjb21wb3NpdGlvbiBvZiBhIGNvbXBvc2l0ZSBudW1iZXJcbiAgICAgKiBpbnRvIGEgcHJvZHVjdCBvZiBzbWFsbGVyIHByaW1lIGludGVnZXJzIChmYWN0b3JzKS5cbiAgICAgKiBTZWUgW2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVnZXJfZmFjdG9yaXphdGlvbl1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZGYWN0b3JpemV9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mRmFjdG9yaXplXG4gICAgICovXG4gICAgZmFjdG9yaXplKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLmZhY3Rvcml6ZScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vZHVsYXIgZXhwb25lbnRpYXRpb25cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUGVyZm9ybXMgbW9kdWxhciBleHBvbmVudGlhdGlvbiBmb3IgYmlnIGludGVnZXJzIChgYmFzZWBeYGV4cG9uZW50YCBtb2QgYG1vZHVsdXNgKS5cbiAgICAgKiBTZWUgW2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vZHVsYXJfZXhwb25lbnRpYXRpb25dXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mTW9kdWxhclBvd2VyfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZk1vZHVsYXJQb3dlclxuICAgICAqL1xuICAgIG1vZHVsYXJfcG93ZXIocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8ubW9kdWxhcl9wb3dlcicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgQ1JDMTYgdXNpbmcgVE9OIGFsZ29yaXRobS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZUb25DcmMxNn0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZUb25DcmMxNlxuICAgICAqL1xuICAgIHRvbl9jcmMxNihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by50b25fY3JjMTYnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgcmFuZG9tIGJ5dGUgYXJyYXkgb2YgdGhlIHNwZWNpZmllZCBsZW5ndGggYW5kIHJldHVybnMgaXQgaW4gYGJhc2U2NGAgZm9ybWF0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mR2VuZXJhdGVSYW5kb21CeXRlc30gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZHZW5lcmF0ZVJhbmRvbUJ5dGVzXG4gICAgICovXG4gICAgZ2VuZXJhdGVfcmFuZG9tX2J5dGVzKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLmdlbmVyYXRlX3JhbmRvbV9ieXRlcycsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHB1YmxpYyBrZXkgdG8gdG9uIHNhZmVfZm9ybWF0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mQ29udmVydFB1YmxpY0tleVRvVG9uU2FmZUZvcm1hdH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZDb252ZXJ0UHVibGljS2V5VG9Ub25TYWZlRm9ybWF0XG4gICAgICovXG4gICAgY29udmVydF9wdWJsaWNfa2V5X3RvX3Rvbl9zYWZlX2Zvcm1hdChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5jb252ZXJ0X3B1YmxpY19rZXlfdG9fdG9uX3NhZmVfZm9ybWF0JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHJhbmRvbSBlZDI1NTE5IGtleSBwYWlyLlxuICAgICAqIEByZXR1cm5zIEtleVBhaXJcbiAgICAgKi9cbiAgICBnZW5lcmF0ZV9yYW5kb21fc2lnbl9rZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLmdlbmVyYXRlX3JhbmRvbV9zaWduX2tleXMnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgYSBkYXRhIHVzaW5nIHRoZSBwcm92aWRlZCBrZXlzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlNpZ259IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mU2lnblxuICAgICAqL1xuICAgIHNpZ24ocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8uc2lnbicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHNpZ25lZCBkYXRhIHVzaW5nIHRoZSBwcm92aWRlZCBwdWJsaWMga2V5LiBSYWlzZXMgZXJyb3IgaWYgdmVyaWZpY2F0aW9uIGlzIGZhaWxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZWZXJpZnlTaWduYXR1cmV9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mVmVyaWZ5U2lnbmF0dXJlXG4gICAgICovXG4gICAgdmVyaWZ5X3NpZ25hdHVyZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by52ZXJpZnlfc2lnbmF0dXJlJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBTSEEyNTYgaGFzaCBvZiB0aGUgc3BlY2lmaWVkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mSGFzaH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZIYXNoXG4gICAgICovXG4gICAgc2hhMjU2KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLnNoYTI1NicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgU0hBNTEyIGhhc2ggb2YgdGhlIHNwZWNpZmllZCBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkhhc2h9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mSGFzaFxuICAgICAqL1xuICAgIHNoYTUxMihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5zaGE1MTInLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGBzY3J5cHRgIGVuY3J5cHRpb25cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRGVyaXZlcyBrZXkgZnJvbSBgcGFzc3dvcmRgIGFuZCBga2V5YCB1c2luZyBgc2NyeXB0YCBhbGdvcml0aG0uXG4gICAgICogU2VlIFtodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TY3J5cHRdLlxuICAgICAqXG4gICAgICogIyBBcmd1bWVudHNcbiAgICAgKiAtIGBsb2dfbmAgLSBUaGUgbG9nMiBvZiB0aGUgU2NyeXB0IHBhcmFtZXRlciBgTmBcbiAgICAgKiAtIGByYCAtIFRoZSBTY3J5cHQgcGFyYW1ldGVyIGByYFxuICAgICAqIC0gYHBgIC0gVGhlIFNjcnlwdCBwYXJhbWV0ZXIgYHBgXG4gICAgICogIyBDb25kaXRpb25zXG4gICAgICogLSBgbG9nX25gIG11c3QgYmUgbGVzcyB0aGFuIGA2NGBcbiAgICAgKiAtIGByYCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgNDI5NDk2NzI5NWBcbiAgICAgKiAtIGBwYCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBgMGAgYW5kIGxlc3MgdGhhbiBgNDI5NDk2NzI5NWBcbiAgICAgKiAjIFJlY29tbWVuZGVkIHZhbHVlcyBzdWZmaWNpZW50IGZvciBtb3N0IHVzZS1jYXNlc1xuICAgICAqIC0gYGxvZ19uID0gMTVgIChgbiA9IDMyNzY4YClcbiAgICAgKiAtIGByID0gOGBcbiAgICAgKiAtIGBwID0gMWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZTY3J5cHR9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mU2NyeXB0XG4gICAgICovXG4gICAgc2NyeXB0KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLnNjcnlwdCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIGtleSBwYWlyIGZvciBzaWduaW5nIGZyb20gdGhlIHNlY3JldCBrZXlcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogKipOT1RFOioqIEluIHRoZSByZXN1bHQgdGhlIHNlY3JldCBrZXkgaXMgYWN0dWFsbHkgdGhlIGNvbmNhdGVuYXRpb25cbiAgICAgKiBvZiBzZWNyZXQgYW5kIHB1YmxpYyBrZXlzICgxMjggc3ltYm9scyBoZXggc3RyaW5nKSBieSBkZXNpZ24gb2YgW05hQ0xdKGh0dHA6Ly9uYWNsLmNyLnlwLnRvL3NpZ24uaHRtbCkuXG4gICAgICogU2VlIGFsc28gW3RoZSBzdGFja2V4Y2hhbmdlIHF1ZXN0aW9uXShodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNTQzNTMvKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZOYWNsU2lnbktleVBhaXJGcm9tU2VjcmV0fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBLZXlQYWlyXG4gICAgICovXG4gICAgbmFjbF9zaWduX2tleXBhaXJfZnJvbV9zZWNyZXRfa2V5KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLm5hY2xfc2lnbl9rZXlwYWlyX2Zyb21fc2VjcmV0X2tleScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIGRhdGEgdXNpbmcgdGhlIHNpZ25lcidzIHNlY3JldCBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mTmFjbFNpZ259IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mTmFjbFNpZ25cbiAgICAgKi9cbiAgICBuYWNsX3NpZ24ocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8ubmFjbF9zaWduJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhlIHNpZ25hdHVyZSBhbmQgcmV0dXJucyB0aGUgdW5zaWduZWQgbWVzc2FnZVxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBWZXJpZmllcyB0aGUgc2lnbmF0dXJlIGluIGBzaWduZWRgIHVzaW5nIHRoZSBzaWduZXIncyBwdWJsaWMga2V5IGBwdWJsaWNgXG4gICAgICogYW5kIHJldHVybnMgdGhlIG1lc3NhZ2UgYHVuc2lnbmVkYC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBzaWduYXR1cmUgZmFpbHMgdmVyaWZpY2F0aW9uLCBjcnlwdG9fc2lnbl9vcGVuIHJhaXNlcyBhbiBleGNlcHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mTmFjbFNpZ25PcGVufSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZk5hY2xTaWduT3BlblxuICAgICAqL1xuICAgIG5hY2xfc2lnbl9vcGVuKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLm5hY2xfc2lnbl9vcGVuJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgdGhlIG1lc3NhZ2UgdXNpbmcgdGhlIHNlY3JldCBrZXkgYW5kIHJldHVybnMgYSBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFNpZ25zIHRoZSBtZXNzYWdlIGB1bnNpZ25lZGAgdXNpbmcgdGhlIHNlY3JldCBrZXkgYHNlY3JldGBcbiAgICAgKiBhbmQgcmV0dXJucyBhIHNpZ25hdHVyZSBgc2lnbmF0dXJlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZOYWNsU2lnbn0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZOYWNsU2lnbkRldGFjaGVkXG4gICAgICovXG4gICAgbmFjbF9zaWduX2RldGFjaGVkKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLm5hY2xfc2lnbl9kZXRhY2hlZCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoZSBzaWduYXR1cmUgd2l0aCBwdWJsaWMga2V5IGFuZCBgdW5zaWduZWRgIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mTmFjbFNpZ25EZXRhY2hlZFZlcmlmeX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZOYWNsU2lnbkRldGFjaGVkVmVyaWZ5XG4gICAgICovXG4gICAgbmFjbF9zaWduX2RldGFjaGVkX3ZlcmlmeShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5uYWNsX3NpZ25fZGV0YWNoZWRfdmVyaWZ5JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgcmFuZG9tIE5hQ2wga2V5IHBhaXJcbiAgICAgKiBAcmV0dXJucyBLZXlQYWlyXG4gICAgICovXG4gICAgbmFjbF9ib3hfa2V5cGFpcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5uYWNsX2JveF9rZXlwYWlyJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBrZXkgcGFpciBmcm9tIGEgc2VjcmV0IGtleVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZk5hY2xCb3hLZXlQYWlyRnJvbVNlY3JldH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgS2V5UGFpclxuICAgICAqL1xuICAgIG5hY2xfYm94X2tleXBhaXJfZnJvbV9zZWNyZXRfa2V5KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLm5hY2xfYm94X2tleXBhaXJfZnJvbV9zZWNyZXRfa2V5JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIGtleSBhdXRoZW50aWNhdGVkIGVuY3J5cHRpb25cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRW5jcnlwdCBhbmQgYXV0aGVudGljYXRlIGEgbWVzc2FnZSB1c2luZyB0aGUgc2VuZGVycyBzZWNyZXQga2V5LCB0aGUgcmVjZWl2ZXJzIHB1YmxpY1xuICAgICAqIGtleSwgYW5kIGEgbm9uY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mTmFjbEJveH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZOYWNsQm94XG4gICAgICovXG4gICAgbmFjbF9ib3gocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8ubmFjbF9ib3gnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNyeXB0IGFuZCB2ZXJpZnkgdGhlIGNpcGhlciB0ZXh0IHVzaW5nIHRoZSByZWNlaXZlcnMgc2VjcmV0IGtleSwgdGhlIHNlbmRlcnMgcHVibGljIGtleSwgYW5kIHRoZSBub25jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZOYWNsQm94T3Blbn0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZOYWNsQm94T3BlblxuICAgICAqL1xuICAgIG5hY2xfYm94X29wZW4ocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8ubmFjbF9ib3hfb3BlbicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY3J5cHQgYW5kIGF1dGhlbnRpY2F0ZSBtZXNzYWdlIHVzaW5nIG5vbmNlIGFuZCBzZWNyZXQga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZk5hY2xTZWNyZXRCb3h9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mTmFjbEJveFxuICAgICAqL1xuICAgIG5hY2xfc2VjcmV0X2JveChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5uYWNsX3NlY3JldF9ib3gnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNyeXB0cyBhbmQgdmVyaWZpZXMgY2lwaGVyIHRleHQgdXNpbmcgYG5vbmNlYCBhbmQgc2VjcmV0IGBrZXlgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZk5hY2xTZWNyZXRCb3hPcGVufSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZk5hY2xCb3hPcGVuXG4gICAgICovXG4gICAgbmFjbF9zZWNyZXRfYm94X29wZW4ocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8ubmFjbF9zZWNyZXRfYm94X29wZW4nLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmludHMgdGhlIGxpc3Qgb2Ygd29yZHMgZnJvbSB0aGUgc3BlY2lmaWVkIGRpY3Rpb25hcnlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZNbmVtb25pY1dvcmRzfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZk1uZW1vbmljV29yZHNcbiAgICAgKi9cbiAgICBtbmVtb25pY193b3JkcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5tbmVtb25pY193b3JkcycsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHJhbmRvbSBtbmVtb25pY1xuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBHZW5lcmF0ZXMgYSByYW5kb20gbW5lbW9uaWMgZnJvbSB0aGUgc3BlY2lmaWVkIGRpY3Rpb25hcnkgYW5kIHdvcmQgY291bnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZNbmVtb25pY0Zyb21SYW5kb219IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mTW5lbW9uaWNGcm9tUmFuZG9tXG4gICAgICovXG4gICAgbW5lbW9uaWNfZnJvbV9yYW5kb20ocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8ubW5lbW9uaWNfZnJvbV9yYW5kb20nLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgbW5lbW9uaWMgZnJvbSBwcmUtZ2VuZXJhdGVkIGVudHJvcHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZNbmVtb25pY0Zyb21FbnRyb3B5fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZk1uZW1vbmljRnJvbUVudHJvcHlcbiAgICAgKi9cbiAgICBtbmVtb25pY19mcm9tX2VudHJvcHkocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8ubW5lbW9uaWNfZnJvbV9lbnRyb3B5JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIGEgbW5lbW9uaWMgcGhyYXNlXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBwaHJhc2Ugc3VwcGxpZWQgd2lsbCBiZSBjaGVja2VkIGZvciB3b3JkIGxlbmd0aCBhbmQgdmFsaWRhdGVkIGFjY29yZGluZyB0byB0aGUgY2hlY2tzdW1cbiAgICAgKiBzcGVjaWZpZWQgaW4gQklQMDAzOS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZNbmVtb25pY1ZlcmlmeX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZNbmVtb25pY1ZlcmlmeVxuICAgICAqL1xuICAgIG1uZW1vbmljX3ZlcmlmeShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5tbmVtb25pY192ZXJpZnknLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXJpdmVzIGEga2V5IHBhaXIgZm9yIHNpZ25pbmcgZnJvbSB0aGUgc2VlZCBwaHJhc2VcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVmFsaWRhdGVzIHRoZSBzZWVkIHBocmFzZSwgZ2VuZXJhdGVzIG1hc3RlciBrZXkgYW5kIHRoZW4gZGVyaXZlc1xuICAgICAqIHRoZSBrZXkgcGFpciBmcm9tIHRoZSBtYXN0ZXIga2V5IGFuZCB0aGUgc3BlY2lmaWVkIHBhdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZNbmVtb25pY0Rlcml2ZVNpZ25LZXlzfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBLZXlQYWlyXG4gICAgICovXG4gICAgbW5lbW9uaWNfZGVyaXZlX3NpZ25fa2V5cyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5tbmVtb25pY19kZXJpdmVfc2lnbl9rZXlzJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIGV4dGVuZGVkIG1hc3RlciBwcml2YXRlIGtleSB0aGF0IHdpbGwgYmUgdGhlIHJvb3QgZm9yIGFsbCB0aGUgZGVyaXZlZCBrZXlzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mSERLZXlYUHJ2RnJvbU1uZW1vbmljfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkhES2V5WFBydkZyb21NbmVtb25pY1xuICAgICAqL1xuICAgIGhka2V5X3hwcnZfZnJvbV9tbmVtb25pYyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5oZGtleV94cHJ2X2Zyb21fbW5lbW9uaWMnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGV4dGVuZGVkIHByaXZhdGUga2V5IGRlcml2ZWQgZnJvbSB0aGUgc3BlY2lmaWVkIGV4dGVuZGVkIHByaXZhdGUga2V5IGFuZCBjaGlsZCBpbmRleFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkhES2V5RGVyaXZlRnJvbVhQcnZ9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mSERLZXlEZXJpdmVGcm9tWFBydlxuICAgICAqL1xuICAgIGhka2V5X2Rlcml2ZV9mcm9tX3hwcnYocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8uaGRrZXlfZGVyaXZlX2Zyb21feHBydicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcml2ZXMgdGhlIGV4dGVuZGVkIHByaXZhdGUga2V5IGZyb20gdGhlIHNwZWNpZmllZCBrZXkgYW5kIHBhdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZIREtleURlcml2ZUZyb21YUHJ2UGF0aH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZIREtleURlcml2ZUZyb21YUHJ2UGF0aFxuICAgICAqL1xuICAgIGhka2V5X2Rlcml2ZV9mcm9tX3hwcnZfcGF0aChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5oZGtleV9kZXJpdmVfZnJvbV94cHJ2X3BhdGgnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgcHJpdmF0ZSBrZXkgZnJvbSB0aGUgc2VyaWFsaXplZCBleHRlbmRlZCBwcml2YXRlIGtleVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkhES2V5U2VjcmV0RnJvbVhQcnZ9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mSERLZXlTZWNyZXRGcm9tWFBydlxuICAgICAqL1xuICAgIGhka2V5X3NlY3JldF9mcm9tX3hwcnYocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8uaGRrZXlfc2VjcmV0X2Zyb21feHBydicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBwdWJsaWMga2V5IGZyb20gdGhlIHNlcmlhbGl6ZWQgZXh0ZW5kZWQgcHJpdmF0ZSBrZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZIREtleVB1YmxpY0Zyb21YUHJ2fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkhES2V5UHVibGljRnJvbVhQcnZcbiAgICAgKi9cbiAgICBoZGtleV9wdWJsaWNfZnJvbV94cHJ2KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLmhka2V5X3B1YmxpY19mcm9tX3hwcnYnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBzeW1tZXRyaWMgYGNoYWNoYTIwYCBlbmNyeXB0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkNoYUNoYTIwfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkNoYUNoYTIwXG4gICAgICovXG4gICAgY2hhY2hhMjAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8uY2hhY2hhMjAnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgQ3J5cHRvIEJveCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQ3J5cHRvIEJveCBpcyBhIHJvb3QgY3J5cHRvIG9iamVjdCwgdGhhdCBlbmNhcHN1bGF0ZXMgc29tZSBzZWNyZXQgKHNlZWQgcGhyYXNlIHVzdWFsbHkpXG4gICAgICogaW4gZW5jcnlwdGVkIGZvcm0gYW5kIGFjdHMgYXMgYSBmYWN0b3J5IGZvciBhbGwgY3J5cHRvIHByaW1pdGl2ZXMgdXNlZCBpbiBTREs6XG4gICAgICoga2V5cyBmb3Igc2lnbmluZyBhbmQgZW5jcnlwdGlvbiwgZGVyaXZlZCBmcm9tIHRoaXMgc2VjcmV0LlxuICAgICAqXG4gICAgICogQ3J5cHRvIEJveCBlbmNyeXB0cyBvcmlnaW5hbCBTZWVkIFBocmFzZSB3aXRoIHNhbHQgYW5kIHBhc3N3b3JkIHRoYXQgaXMgcmV0cmlldmVkXG4gICAgICogZnJvbSBgcGFzc3dvcmRfcHJvdmlkZXJgIGNhbGxiYWNrLCBpbXBsZW1lbnRlZCBvbiBBcHBsaWNhdGlvbiBzaWRlLlxuICAgICAqXG4gICAgICogV2hlbiB1c2VkLCBkZWNyeXB0ZWQgc2VjcmV0IHNob3dzIHVwIGluIGNvcmUgbGlicmFyeSdzIG1lbW9yeSBmb3IgYSB2ZXJ5IHNob3J0IHBlcmlvZFxuICAgICAqIG9mIHRpbWUgYW5kIHRoZW4gaXMgaW1tZWRpYXRlbHkgb3ZlcndyaXR0ZW4gd2l0aCB6ZXJvZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mQ3JlYXRlQ3J5cHRvQm94fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZWdpc3RlcmVkQ3J5cHRvQm94XG4gICAgICovXG4gICAgY3JlYXRlX2NyeXB0b19ib3gocGFyYW1zLCBvYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5jcmVhdGVfY3J5cHRvX2JveCcsIHBhcmFtcywgKHBhcmFtcywgcmVzcG9uc2VUeXBlKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hBcHBQYXNzd29yZFByb3ZpZGVyKG9iaiwgcGFyYW1zLnJlcXVlc3RfZGF0YSwgcGFyYW1zLmFwcF9yZXF1ZXN0X2lkLCB0aGlzLmNsaWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEFwcFBhc3N3b3JkUHJvdmlkZXIob2JqLCBwYXJhbXMsIG51bGwsIHRoaXMuY2xpZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgQ3J5cHRvIEJveC4gQ2xlYXJzIGFsbCBzZWNyZXQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVnaXN0ZXJlZENyeXB0b0JveH0gcGFyYW1zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICByZW1vdmVfY3J5cHRvX2JveChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5yZW1vdmVfY3J5cHRvX2JveCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBDcnlwdG8gQm94IEluZm8uIFVzZWQgdG8gZ2V0IGBlbmNyeXB0ZWRfc2VjcmV0YCB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciBhbGwgdGhlIGNyeXB0b2JveCBpbml0aWFsaXphdGlvbnMgZXhjZXB0IHRoZSBmaXJzdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlZ2lzdGVyZWRDcnlwdG9Cb3h9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mR2V0Q3J5cHRvQm94SW5mb1xuICAgICAqL1xuICAgIGdldF9jcnlwdG9fYm94X2luZm8ocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8uZ2V0X2NyeXB0b19ib3hfaW5mbycsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBDcnlwdG8gQm94IFNlZWQgUGhyYXNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBBdHRlbnRpb24hIFN0b3JlIHRoaXMgZGF0YSBpbiB5b3VyIGFwcGxpY2F0aW9uIGZvciBhIHZlcnkgc2hvcnQgcGVyaW9kIG9mIHRpbWUgYW5kIG92ZXJ3cml0ZSBpdCB3aXRoIHplcm9lcyBBU0FQLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWdpc3RlcmVkQ3J5cHRvQm94fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkdldENyeXB0b0JveFNlZWRQaHJhc2VcbiAgICAgKi9cbiAgICBnZXRfY3J5cHRvX2JveF9zZWVkX3BocmFzZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5nZXRfY3J5cHRvX2JveF9zZWVkX3BocmFzZScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBoYW5kbGUgb2YgU2lnbmluZyBCb3ggZGVyaXZlZCBmcm9tIENyeXB0byBCb3guXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mR2V0U2lnbmluZ0JveEZyb21DcnlwdG9Cb3h9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlZ2lzdGVyZWRTaWduaW5nQm94XG4gICAgICovXG4gICAgZ2V0X3NpZ25pbmdfYm94X2Zyb21fY3J5cHRvX2JveChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5nZXRfc2lnbmluZ19ib3hfZnJvbV9jcnlwdG9fYm94JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBFbmNyeXB0aW9uIEJveCBmcm9tIENyeXB0byBCb3guXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIERlcml2ZXMgZW5jcnlwdGlvbiBrZXlwYWlyIGZyb20gY3J5cHRvYm94IHNlY3JldCBhbmQgaGRwYXRoIGFuZFxuICAgICAqIHN0b3JlcyBpdCBpbiBjYWNoZSBmb3IgYHNlY3JldF9saWZldGltZWBcbiAgICAgKiBvciB1bnRpbCBleHBsaWNpdGx5IGNsZWFyZWQgYnkgYGNsZWFyX2NyeXB0b19ib3hfc2VjcmV0X2NhY2hlYCBtZXRob2QuXG4gICAgICogSWYgYHNlY3JldF9saWZldGltZWAgaXMgbm90IHNwZWNpZmllZCAtIG92ZXJ3cml0ZXMgZW5jcnlwdGlvbiBzZWNyZXQgd2l0aCB6ZXJvZXMgaW1tZWRpYXRlbHkgYWZ0ZXJcbiAgICAgKiBlbmNyeXB0aW9uIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZHZXRFbmNyeXB0aW9uQm94RnJvbUNyeXB0b0JveH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVnaXN0ZXJlZEVuY3J5cHRpb25Cb3hcbiAgICAgKi9cbiAgICBnZXRfZW5jcnlwdGlvbl9ib3hfZnJvbV9jcnlwdG9fYm94KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLmdldF9lbmNyeXB0aW9uX2JveF9mcm9tX2NyeXB0b19ib3gnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGNhY2hlZCBzZWNyZXRzIChvdmVyd3JpdGVzIHdpdGggemVyb2VzKSBmcm9tIGFsbCBzaWduaW5nIGFuZCBlbmNyeXB0aW9uIGJveGVzLCBkZXJpdmVkIGZyb20gY3J5cHRvIGJveC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVnaXN0ZXJlZENyeXB0b0JveH0gcGFyYW1zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBjbGVhcl9jcnlwdG9fYm94X3NlY3JldF9jYWNoZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5jbGVhcl9jcnlwdG9fYm94X3NlY3JldF9jYWNoZScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFuIGFwcGxpY2F0aW9uIGltcGxlbWVudGVkIHNpZ25pbmcgYm94LlxuICAgICAqIEByZXR1cm5zIFJlZ2lzdGVyZWRTaWduaW5nQm94XG4gICAgICovXG4gICAgcmVnaXN0ZXJfc2lnbmluZ19ib3gob2JqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8ucmVnaXN0ZXJfc2lnbmluZ19ib3gnLCB1bmRlZmluZWQsIChwYXJhbXMsIHJlc3BvbnNlVHlwZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoQXBwU2lnbmluZ0JveChvYmosIHBhcmFtcy5yZXF1ZXN0X2RhdGEsIHBhcmFtcy5hcHBfcmVxdWVzdF9pZCwgdGhpcy5jbGllbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hBcHBTaWduaW5nQm94KG9iaiwgcGFyYW1zLCBudWxsLCB0aGlzLmNsaWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVmYXVsdCBzaWduaW5nIGJveCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7S2V5UGFpcn0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVnaXN0ZXJlZFNpZ25pbmdCb3hcbiAgICAgKi9cbiAgICBnZXRfc2lnbmluZ19ib3gocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8uZ2V0X3NpZ25pbmdfYm94JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwdWJsaWMga2V5IG9mIHNpZ25pbmcga2V5IHBhaXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlZ2lzdGVyZWRTaWduaW5nQm94fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZlNpZ25pbmdCb3hHZXRQdWJsaWNLZXlcbiAgICAgKi9cbiAgICBzaWduaW5nX2JveF9nZXRfcHVibGljX2tleShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5zaWduaW5nX2JveF9nZXRfcHVibGljX2tleScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2lnbmVkIHVzZXIgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZTaWduaW5nQm94U2lnbn0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZTaWduaW5nQm94U2lnblxuICAgICAqL1xuICAgIHNpZ25pbmdfYm94X3NpZ24ocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8uc2lnbmluZ19ib3hfc2lnbicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgc2lnbmluZyBib3ggZnJvbSBTREsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlZ2lzdGVyZWRTaWduaW5nQm94fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHJlbW92ZV9zaWduaW5nX2JveChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5yZW1vdmVfc2lnbmluZ19ib3gnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhbiBhcHBsaWNhdGlvbiBpbXBsZW1lbnRlZCBlbmNyeXB0aW9uIGJveC5cbiAgICAgKiBAcmV0dXJucyBSZWdpc3RlcmVkRW5jcnlwdGlvbkJveFxuICAgICAqL1xuICAgIHJlZ2lzdGVyX2VuY3J5cHRpb25fYm94KG9iaikge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLnJlZ2lzdGVyX2VuY3J5cHRpb25fYm94JywgdW5kZWZpbmVkLCAocGFyYW1zLCByZXNwb25zZVR5cGUpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEFwcEVuY3J5cHRpb25Cb3gob2JqLCBwYXJhbXMucmVxdWVzdF9kYXRhLCBwYXJhbXMuYXBwX3JlcXVlc3RfaWQsIHRoaXMuY2xpZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlVHlwZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoQXBwRW5jcnlwdGlvbkJveChvYmosIHBhcmFtcywgbnVsbCwgdGhpcy5jbGllbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBlbmNyeXB0aW9uIGJveCBmcm9tIFNES1xuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWdpc3RlcmVkRW5jcnlwdGlvbkJveH0gcGFyYW1zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICByZW1vdmVfZW5jcnlwdGlvbl9ib3gocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdjcnlwdG8ucmVtb3ZlX2VuY3J5cHRpb25fYm94JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcmllcyBpbmZvIGZyb20gdGhlIGdpdmVuIGVuY3J5cHRpb24gYm94XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mRW5jcnlwdGlvbkJveEdldEluZm99IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mRW5jcnlwdGlvbkJveEdldEluZm9cbiAgICAgKi9cbiAgICBlbmNyeXB0aW9uX2JveF9nZXRfaW5mbyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5lbmNyeXB0aW9uX2JveF9nZXRfaW5mbycsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY3J5cHRzIGRhdGEgdXNpbmcgZ2l2ZW4gZW5jcnlwdGlvbiBib3ggTm90ZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQmxvY2sgY2lwaGVyIGFsZ29yaXRobXMgcGFkIGRhdGEgdG8gY2lwaGVyIGJsb2NrIHNpemUgc28gZW5jcnlwdGVkIGRhdGEgY2FuIGJlIGxvbmdlciB0aGVuIG9yaWdpbmFsIGRhdGEuIENsaWVudCBzaG91bGQgc3RvcmUgdGhlIG9yaWdpbmFsIGRhdGEgc2l6ZSBhZnRlciBlbmNyeXB0aW9uIGFuZCB1c2UgaXQgYWZ0ZXJcbiAgICAgKiBkZWNyeXB0aW9uIHRvIHJldHJpZXZlIHRoZSBvcmlnaW5hbCBkYXRhIGZyb20gZGVjcnlwdGVkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mRW5jcnlwdGlvbkJveEVuY3J5cHR9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mRW5jcnlwdGlvbkJveEVuY3J5cHRcbiAgICAgKi9cbiAgICBlbmNyeXB0aW9uX2JveF9lbmNyeXB0KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnY3J5cHRvLmVuY3J5cHRpb25fYm94X2VuY3J5cHQnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNyeXB0cyBkYXRhIHVzaW5nIGdpdmVuIGVuY3J5cHRpb24gYm94IE5vdGUuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEJsb2NrIGNpcGhlciBhbGdvcml0aG1zIHBhZCBkYXRhIHRvIGNpcGhlciBibG9jayBzaXplIHNvIGVuY3J5cHRlZCBkYXRhIGNhbiBiZSBsb25nZXIgdGhlbiBvcmlnaW5hbCBkYXRhLiBDbGllbnQgc2hvdWxkIHN0b3JlIHRoZSBvcmlnaW5hbCBkYXRhIHNpemUgYWZ0ZXIgZW5jcnlwdGlvbiBhbmQgdXNlIGl0IGFmdGVyXG4gICAgICogZGVjcnlwdGlvbiB0byByZXRyaWV2ZSB0aGUgb3JpZ2luYWwgZGF0YSBmcm9tIGRlY3J5cHRlZCBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkVuY3J5cHRpb25Cb3hEZWNyeXB0fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkVuY3J5cHRpb25Cb3hEZWNyeXB0XG4gICAgICovXG4gICAgZW5jcnlwdGlvbl9ib3hfZGVjcnlwdChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5lbmNyeXB0aW9uX2JveF9kZWNyeXB0JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBlbmNyeXB0aW9uIGJveCB3aXRoIHNwZWNpZmllZCBhbGdvcml0aG1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZDcmVhdGVFbmNyeXB0aW9uQm94fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZWdpc3RlcmVkRW5jcnlwdGlvbkJveFxuICAgICAqL1xuICAgIGNyZWF0ZV9lbmNyeXB0aW9uX2JveChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2NyeXB0by5jcmVhdGVfZW5jcnlwdGlvbl9ib3gnLCBwYXJhbXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ3J5cHRvTW9kdWxlID0gQ3J5cHRvTW9kdWxlO1xuLy8gYWJpIG1vZHVsZVxudmFyIEFiaUVycm9yQ29kZTtcbihmdW5jdGlvbiAoQWJpRXJyb3JDb2RlKSB7XG4gICAgQWJpRXJyb3JDb2RlW0FiaUVycm9yQ29kZVtcIlJlcXVpcmVkQWRkcmVzc01pc3NpbmdGb3JFbmNvZGVNZXNzYWdlXCJdID0gMzAxXSA9IFwiUmVxdWlyZWRBZGRyZXNzTWlzc2luZ0ZvckVuY29kZU1lc3NhZ2VcIjtcbiAgICBBYmlFcnJvckNvZGVbQWJpRXJyb3JDb2RlW1wiUmVxdWlyZWRDYWxsU2V0TWlzc2luZ0ZvckVuY29kZU1lc3NhZ2VcIl0gPSAzMDJdID0gXCJSZXF1aXJlZENhbGxTZXRNaXNzaW5nRm9yRW5jb2RlTWVzc2FnZVwiO1xuICAgIEFiaUVycm9yQ29kZVtBYmlFcnJvckNvZGVbXCJJbnZhbGlkSnNvblwiXSA9IDMwM10gPSBcIkludmFsaWRKc29uXCI7XG4gICAgQWJpRXJyb3JDb2RlW0FiaUVycm9yQ29kZVtcIkludmFsaWRNZXNzYWdlXCJdID0gMzA0XSA9IFwiSW52YWxpZE1lc3NhZ2VcIjtcbiAgICBBYmlFcnJvckNvZGVbQWJpRXJyb3JDb2RlW1wiRW5jb2RlRGVwbG95TWVzc2FnZUZhaWxlZFwiXSA9IDMwNV0gPSBcIkVuY29kZURlcGxveU1lc3NhZ2VGYWlsZWRcIjtcbiAgICBBYmlFcnJvckNvZGVbQWJpRXJyb3JDb2RlW1wiRW5jb2RlUnVuTWVzc2FnZUZhaWxlZFwiXSA9IDMwNl0gPSBcIkVuY29kZVJ1bk1lc3NhZ2VGYWlsZWRcIjtcbiAgICBBYmlFcnJvckNvZGVbQWJpRXJyb3JDb2RlW1wiQXR0YWNoU2lnbmF0dXJlRmFpbGVkXCJdID0gMzA3XSA9IFwiQXR0YWNoU2lnbmF0dXJlRmFpbGVkXCI7XG4gICAgQWJpRXJyb3JDb2RlW0FiaUVycm9yQ29kZVtcIkludmFsaWRUdmNJbWFnZVwiXSA9IDMwOF0gPSBcIkludmFsaWRUdmNJbWFnZVwiO1xuICAgIEFiaUVycm9yQ29kZVtBYmlFcnJvckNvZGVbXCJSZXF1aXJlZFB1YmxpY0tleU1pc3NpbmdGb3JGdW5jdGlvbkhlYWRlclwiXSA9IDMwOV0gPSBcIlJlcXVpcmVkUHVibGljS2V5TWlzc2luZ0ZvckZ1bmN0aW9uSGVhZGVyXCI7XG4gICAgQWJpRXJyb3JDb2RlW0FiaUVycm9yQ29kZVtcIkludmFsaWRTaWduZXJcIl0gPSAzMTBdID0gXCJJbnZhbGlkU2lnbmVyXCI7XG4gICAgQWJpRXJyb3JDb2RlW0FiaUVycm9yQ29kZVtcIkludmFsaWRBYmlcIl0gPSAzMTFdID0gXCJJbnZhbGlkQWJpXCI7XG4gICAgQWJpRXJyb3JDb2RlW0FiaUVycm9yQ29kZVtcIkludmFsaWRGdW5jdGlvbklkXCJdID0gMzEyXSA9IFwiSW52YWxpZEZ1bmN0aW9uSWRcIjtcbiAgICBBYmlFcnJvckNvZGVbQWJpRXJyb3JDb2RlW1wiSW52YWxpZERhdGFcIl0gPSAzMTNdID0gXCJJbnZhbGlkRGF0YVwiO1xuICAgIEFiaUVycm9yQ29kZVtBYmlFcnJvckNvZGVbXCJFbmNvZGVJbml0aWFsRGF0YUZhaWxlZFwiXSA9IDMxNF0gPSBcIkVuY29kZUluaXRpYWxEYXRhRmFpbGVkXCI7XG4gICAgQWJpRXJyb3JDb2RlW0FiaUVycm9yQ29kZVtcIkludmFsaWRGdW5jdGlvbk5hbWVcIl0gPSAzMTVdID0gXCJJbnZhbGlkRnVuY3Rpb25OYW1lXCI7XG59KShBYmlFcnJvckNvZGUgPSBleHBvcnRzLkFiaUVycm9yQ29kZSB8fCAoZXhwb3J0cy5BYmlFcnJvckNvZGUgPSB7fSkpO1xuZnVuY3Rpb24gYWJpQ29udHJhY3QodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnQ29udHJhY3QnLFxuICAgICAgICB2YWx1ZSxcbiAgICB9O1xufVxuZXhwb3J0cy5hYmlDb250cmFjdCA9IGFiaUNvbnRyYWN0O1xuZnVuY3Rpb24gYWJpSnNvbih2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdKc29uJyxcbiAgICAgICAgdmFsdWUsXG4gICAgfTtcbn1cbmV4cG9ydHMuYWJpSnNvbiA9IGFiaUpzb247XG5mdW5jdGlvbiBhYmlIYW5kbGUodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnSGFuZGxlJyxcbiAgICAgICAgdmFsdWUsXG4gICAgfTtcbn1cbmV4cG9ydHMuYWJpSGFuZGxlID0gYWJpSGFuZGxlO1xuZnVuY3Rpb24gYWJpU2VyaWFsaXplZCh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdTZXJpYWxpemVkJyxcbiAgICAgICAgdmFsdWUsXG4gICAgfTtcbn1cbmV4cG9ydHMuYWJpU2VyaWFsaXplZCA9IGFiaVNlcmlhbGl6ZWQ7XG5mdW5jdGlvbiBzaWduZXJOb25lKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdOb25lJyxcbiAgICB9O1xufVxuZXhwb3J0cy5zaWduZXJOb25lID0gc2lnbmVyTm9uZTtcbmZ1bmN0aW9uIHNpZ25lckV4dGVybmFsKHB1YmxpY19rZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRXh0ZXJuYWwnLFxuICAgICAgICBwdWJsaWNfa2V5LFxuICAgIH07XG59XG5leHBvcnRzLnNpZ25lckV4dGVybmFsID0gc2lnbmVyRXh0ZXJuYWw7XG5mdW5jdGlvbiBzaWduZXJLZXlzKGtleXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnS2V5cycsXG4gICAgICAgIGtleXMsXG4gICAgfTtcbn1cbmV4cG9ydHMuc2lnbmVyS2V5cyA9IHNpZ25lcktleXM7XG5mdW5jdGlvbiBzaWduZXJTaWduaW5nQm94KGhhbmRsZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdTaWduaW5nQm94JyxcbiAgICAgICAgaGFuZGxlLFxuICAgIH07XG59XG5leHBvcnRzLnNpZ25lclNpZ25pbmdCb3ggPSBzaWduZXJTaWduaW5nQm94O1xudmFyIE1lc3NhZ2VCb2R5VHlwZTtcbihmdW5jdGlvbiAoTWVzc2FnZUJvZHlUeXBlKSB7XG4gICAgTWVzc2FnZUJvZHlUeXBlW1wiSW5wdXRcIl0gPSBcIklucHV0XCI7XG4gICAgTWVzc2FnZUJvZHlUeXBlW1wiT3V0cHV0XCJdID0gXCJPdXRwdXRcIjtcbiAgICBNZXNzYWdlQm9keVR5cGVbXCJJbnRlcm5hbE91dHB1dFwiXSA9IFwiSW50ZXJuYWxPdXRwdXRcIjtcbiAgICBNZXNzYWdlQm9keVR5cGVbXCJFdmVudFwiXSA9IFwiRXZlbnRcIjtcbn0pKE1lc3NhZ2VCb2R5VHlwZSA9IGV4cG9ydHMuTWVzc2FnZUJvZHlUeXBlIHx8IChleHBvcnRzLk1lc3NhZ2VCb2R5VHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBzdGF0ZUluaXRTb3VyY2VNZXNzYWdlKHNvdXJjZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdNZXNzYWdlJyxcbiAgICAgICAgc291cmNlLFxuICAgIH07XG59XG5leHBvcnRzLnN0YXRlSW5pdFNvdXJjZU1lc3NhZ2UgPSBzdGF0ZUluaXRTb3VyY2VNZXNzYWdlO1xuZnVuY3Rpb24gc3RhdGVJbml0U291cmNlU3RhdGVJbml0KGNvZGUsIGRhdGEsIGxpYnJhcnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnU3RhdGVJbml0JyxcbiAgICAgICAgY29kZSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgbGlicmFyeSxcbiAgICB9O1xufVxuZXhwb3J0cy5zdGF0ZUluaXRTb3VyY2VTdGF0ZUluaXQgPSBzdGF0ZUluaXRTb3VyY2VTdGF0ZUluaXQ7XG5mdW5jdGlvbiBzdGF0ZUluaXRTb3VyY2VUdmModHZjLCBwdWJsaWNfa2V5LCBpbml0X3BhcmFtcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdUdmMnLFxuICAgICAgICB0dmMsXG4gICAgICAgIHB1YmxpY19rZXksXG4gICAgICAgIGluaXRfcGFyYW1zLFxuICAgIH07XG59XG5leHBvcnRzLnN0YXRlSW5pdFNvdXJjZVR2YyA9IHN0YXRlSW5pdFNvdXJjZVR2YztcbmZ1bmN0aW9uIG1lc3NhZ2VTb3VyY2VFbmNvZGVkKG1lc3NhZ2UsIGFiaSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdFbmNvZGVkJyxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgYWJpLFxuICAgIH07XG59XG5leHBvcnRzLm1lc3NhZ2VTb3VyY2VFbmNvZGVkID0gbWVzc2FnZVNvdXJjZUVuY29kZWQ7XG5mdW5jdGlvbiBtZXNzYWdlU291cmNlRW5jb2RpbmdQYXJhbXMocGFyYW1zKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnRW5jb2RpbmdQYXJhbXMnIH0sIHBhcmFtcyk7XG59XG5leHBvcnRzLm1lc3NhZ2VTb3VyY2VFbmNvZGluZ1BhcmFtcyA9IG1lc3NhZ2VTb3VyY2VFbmNvZGluZ1BhcmFtcztcbi8qKlxuICogUHJvdmlkZXMgbWVzc2FnZSBlbmNvZGluZyBhbmQgZGVjb2RpbmcgYWNjb3JkaW5nIHRvIHRoZSBBQkkgc3BlY2lmaWNhdGlvbi5cbiAqL1xuY2xhc3MgQWJpTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgbWVzc2FnZSBib2R5IGFjY29yZGluZyB0byBBQkkgZnVuY3Rpb24gY2FsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZFbmNvZGVNZXNzYWdlQm9keX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZFbmNvZGVNZXNzYWdlQm9keVxuICAgICAqL1xuICAgIGVuY29kZV9tZXNzYWdlX2JvZHkocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdhYmkuZW5jb2RlX21lc3NhZ2VfYm9keScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkF0dGFjaFNpZ25hdHVyZVRvTWVzc2FnZUJvZHl9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mQXR0YWNoU2lnbmF0dXJlVG9NZXNzYWdlQm9keVxuICAgICAqL1xuICAgIGF0dGFjaF9zaWduYXR1cmVfdG9fbWVzc2FnZV9ib2R5KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYWJpLmF0dGFjaF9zaWduYXR1cmVfdG9fbWVzc2FnZV9ib2R5JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBhbiBBQkktY29tcGF0aWJsZSBtZXNzYWdlXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEFsbG93cyB0byBlbmNvZGUgZGVwbG95IGFuZCBmdW5jdGlvbiBjYWxsIG1lc3NhZ2VzLFxuICAgICAqIGJvdGggc2lnbmVkIGFuZCB1bnNpZ25lZC5cbiAgICAgKlxuICAgICAqIFVzZSBjYXNlcyBpbmNsdWRlIG1lc3NhZ2VzIG9mIGFueSBwb3NzaWJsZSB0eXBlOlxuICAgICAqIC0gZGVwbG95IHdpdGggaW5pdGlhbCBmdW5jdGlvbiBjYWxsIChpLmUuIGBjb25zdHJ1Y3RvcmAgb3IgYW55IG90aGVyIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCBmb3Igc29tZSBraW5kXG4gICAgICogb2YgaW5pdGlhbGl6YXRpb24pO1xuICAgICAqIC0gZGVwbG95IHdpdGhvdXQgaW5pdGlhbCBmdW5jdGlvbiBjYWxsO1xuICAgICAqIC0gc2lnbmVkL3Vuc2lnbmVkICsgZGF0YSBmb3Igc2lnbmluZy5cbiAgICAgKlxuICAgICAqIGBTaWduZXJgIGRlZmluZXMgaG93IHRoZSBtZXNzYWdlIHNob3VsZCBvciBzaG91bGRuJ3QgYmUgc2lnbmVkOlxuICAgICAqXG4gICAgICogYFNpZ25lcjo6Tm9uZWAgY3JlYXRlcyBhbiB1bnNpZ25lZCBtZXNzYWdlLiBUaGlzIG1heSBiZSBuZWVkZWQgaW4gY2FzZSBvZiBzb21lIHB1YmxpYyBtZXRob2RzLFxuICAgICAqIHRoYXQgZG8gbm90IHJlcXVpcmUgYXV0aG9yaXphdGlvbiBieSBwdWJrZXkuXG4gICAgICpcbiAgICAgKiBgU2lnbmVyOjpFeHRlcm5hbGAgdGFrZXMgcHVibGljIGtleSBhbmQgcmV0dXJucyBgZGF0YV90b19zaWduYCBmb3IgbGF0ZXIgc2lnbmluZy5cbiAgICAgKiBVc2UgYGF0dGFjaF9zaWduYXR1cmVgIG1ldGhvZCB3aXRoIHRoZSByZXN1bHQgc2lnbmF0dXJlIHRvIGdldCB0aGUgc2lnbmVkIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBgU2lnbmVyOjpLZXlzYCBjcmVhdGVzIGEgc2lnbmVkIG1lc3NhZ2Ugd2l0aCBwcm92aWRlZCBrZXkgcGFpci5cbiAgICAgKlxuICAgICAqIFtTT09OXSBgU2lnbmVyOjpTaWduaW5nQm94YCBBbGxvd3MgdXNpbmcgYSBzcGVjaWFsIGludGVyZmFjZSB0byBpbXBsZW1lbnQgc2lnbmluZ1xuICAgICAqIHdpdGhvdXQgcHJpdmF0ZSBrZXkgZGlzY2xvc3VyZSB0byBTREsuIEZvciBpbnN0YW5jZSwgaW4gY2FzZSBvZiB1c2luZyBhIGNvbGQgd2FsbGV0IG9yIEhTTSxcbiAgICAgKiB3aGVuIGFwcGxpY2F0aW9uIGNhbGxzIHNvbWUgQVBJIHRvIHNpZ24gZGF0YS5cbiAgICAgKlxuICAgICAqIFRoZXJlIGlzIGFuIG9wdGlvbmFsIHB1YmxpYyBrZXkgY2FuIGJlIHByb3ZpZGVkIGluIGRlcGxveSBzZXQgaW4gb3JkZXIgdG8gc3Vic3RpdHV0ZSBvbmVcbiAgICAgKiBpbiBUVk0gZmlsZS5cbiAgICAgKlxuICAgICAqIFB1YmxpYyBrZXkgcmVzb2x2aW5nIHByaW9yaXR5OlxuICAgICAqIDEuIFB1YmxpYyBrZXkgZnJvbSBkZXBsb3kgc2V0LlxuICAgICAqIDIuIFB1YmxpYyBrZXksIHNwZWNpZmllZCBpbiBUVk0gZmlsZS5cbiAgICAgKiAzLiBQdWJsaWMga2V5LCBwcm92aWRlZCBieSBzaWduZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mRW5jb2RlTWVzc2FnZX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZFbmNvZGVNZXNzYWdlXG4gICAgICovXG4gICAgZW5jb2RlX21lc3NhZ2UocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdhYmkuZW5jb2RlX21lc3NhZ2UnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGFuIGludGVybmFsIEFCSS1jb21wYXRpYmxlIG1lc3NhZ2VcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQWxsb3dzIHRvIGVuY29kZSBkZXBsb3kgYW5kIGZ1bmN0aW9uIGNhbGwgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBVc2UgY2FzZXMgaW5jbHVkZSBtZXNzYWdlcyBvZiBhbnkgcG9zc2libGUgdHlwZTpcbiAgICAgKiAtIGRlcGxveSB3aXRoIGluaXRpYWwgZnVuY3Rpb24gY2FsbCAoaS5lLiBgY29uc3RydWN0b3JgIG9yIGFueSBvdGhlciBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgZm9yIHNvbWUga2luZFxuICAgICAqIG9mIGluaXRpYWxpemF0aW9uKTtcbiAgICAgKiAtIGRlcGxveSB3aXRob3V0IGluaXRpYWwgZnVuY3Rpb24gY2FsbDtcbiAgICAgKiAtIHNpbXBsZSBmdW5jdGlvbiBjYWxsXG4gICAgICpcbiAgICAgKiBUaGVyZSBpcyBhbiBvcHRpb25hbCBwdWJsaWMga2V5IGNhbiBiZSBwcm92aWRlZCBpbiBkZXBsb3kgc2V0IGluIG9yZGVyIHRvIHN1YnN0aXR1dGUgb25lXG4gICAgICogaW4gVFZNIGZpbGUuXG4gICAgICpcbiAgICAgKiBQdWJsaWMga2V5IHJlc29sdmluZyBwcmlvcml0eTpcbiAgICAgKiAxLiBQdWJsaWMga2V5IGZyb20gZGVwbG95IHNldC5cbiAgICAgKiAyLiBQdWJsaWMga2V5LCBzcGVjaWZpZWQgaW4gVFZNIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mRW5jb2RlSW50ZXJuYWxNZXNzYWdlfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkVuY29kZUludGVybmFsTWVzc2FnZVxuICAgICAqL1xuICAgIGVuY29kZV9pbnRlcm5hbF9tZXNzYWdlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYWJpLmVuY29kZV9pbnRlcm5hbF9tZXNzYWdlJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tYmluZXMgYGhleGAtZW5jb2RlZCBgc2lnbmF0dXJlYCB3aXRoIGBiYXNlNjRgLWVuY29kZWQgYHVuc2lnbmVkX21lc3NhZ2VgLiBSZXR1cm5zIHNpZ25lZCBtZXNzYWdlIGVuY29kZWQgaW4gYGJhc2U2NGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mQXR0YWNoU2lnbmF0dXJlfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkF0dGFjaFNpZ25hdHVyZVxuICAgICAqL1xuICAgIGF0dGFjaF9zaWduYXR1cmUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdhYmkuYXR0YWNoX3NpZ25hdHVyZScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXMgbWVzc2FnZSBib2R5IHVzaW5nIHByb3ZpZGVkIG1lc3NhZ2UgQk9DIGFuZCBBQkkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mRGVjb2RlTWVzc2FnZX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgRGVjb2RlZE1lc3NhZ2VCb2R5XG4gICAgICovXG4gICAgZGVjb2RlX21lc3NhZ2UocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdhYmkuZGVjb2RlX21lc3NhZ2UnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIG1lc3NhZ2UgYm9keSB1c2luZyBwcm92aWRlZCBib2R5IEJPQyBhbmQgQUJJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkRlY29kZU1lc3NhZ2VCb2R5fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBEZWNvZGVkTWVzc2FnZUJvZHlcbiAgICAgKi9cbiAgICBkZWNvZGVfbWVzc2FnZV9ib2R5KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYWJpLmRlY29kZV9tZXNzYWdlX2JvZHknLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFjY291bnQgc3RhdGUgQk9DXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIENyZWF0ZXMgYWNjb3VudCBzdGF0ZSBwcm92aWRlZCB3aXRoIG9uZSBvZiB0aGVzZSBzZXRzIG9mIGRhdGEgOlxuICAgICAqIDEuIEJPQyBvZiBjb2RlLCBCT0Mgb2YgZGF0YSwgQk9DIG9mIGxpYnJhcnlcbiAgICAgKiAyLiBUVkMgKHN0cmluZyBpbiBgYmFzZTY0YCksIGtleXMsIGluaXQgcGFyYW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mRW5jb2RlQWNjb3VudH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZFbmNvZGVBY2NvdW50XG4gICAgICovXG4gICAgZW5jb2RlX2FjY291bnQocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdhYmkuZW5jb2RlX2FjY291bnQnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGFjY291bnQgZGF0YSB1c2luZyBwcm92aWRlZCBkYXRhIEJPQyBhbmQgQUJJLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBOb3RlOiB0aGlzIGZlYXR1cmUgcmVxdWlyZXMgQUJJIDIuMSBvciBoaWdoZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mRGVjb2RlQWNjb3VudERhdGF9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mRGVjb2RlQWNjb3VudERhdGFcbiAgICAgKi9cbiAgICBkZWNvZGVfYWNjb3VudF9kYXRhKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYWJpLmRlY29kZV9hY2NvdW50X2RhdGEnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGluaXRpYWwgYWNjb3VudCBkYXRhIHdpdGggaW5pdGlhbCB2YWx1ZXMgZm9yIHRoZSBjb250cmFjdCdzIHN0YXRpYyB2YXJpYWJsZXMgYW5kIG93bmVyJ3MgcHVibGljIGtleS4gVGhpcyBvcGVyYXRpb24gaXMgYXBwbGljYWJsZSBvbmx5IGZvciBpbml0aWFsIGFjY291bnQgZGF0YSAoYmVmb3JlIGRlcGxveSkuIElmIHRoZSBjb250cmFjdCBpcyBhbHJlYWR5IGRlcGxveWVkLCBpdHMgZGF0YSBkb2Vzbid0IGNvbnRhaW4gdGhpcyBkYXRhIHNlY3Rpb24gYW55IG1vcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mVXBkYXRlSW5pdGlhbERhdGF9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mVXBkYXRlSW5pdGlhbERhdGFcbiAgICAgKi9cbiAgICB1cGRhdGVfaW5pdGlhbF9kYXRhKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYWJpLnVwZGF0ZV9pbml0aWFsX2RhdGEnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGluaXRpYWwgYWNjb3VudCBkYXRhIHdpdGggaW5pdGlhbCB2YWx1ZXMgZm9yIHRoZSBjb250cmFjdCdzIHN0YXRpYyB2YXJpYWJsZXMgYW5kIG93bmVyJ3MgcHVibGljIGtleSBpbnRvIGEgZGF0YSBCT0MgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGBlbmNvZGVfdHZjYCBmdW5jdGlvbiBhZnRlcndhcmRzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFuYWxvZ3VlIG9mIGB0dm0uYnVpbGREYXRhSW5pdGAgZnVuY3Rpb24gaW4gU29saWRpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mRW5jb2RlSW5pdGlhbERhdGF9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mRW5jb2RlSW5pdGlhbERhdGFcbiAgICAgKi9cbiAgICBlbmNvZGVfaW5pdGlhbF9kYXRhKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYWJpLmVuY29kZV9pbml0aWFsX2RhdGEnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGluaXRpYWwgdmFsdWVzIG9mIGEgY29udHJhY3QncyBzdGF0aWMgdmFyaWFibGVzIGFuZCBvd25lcidzIHB1YmxpYyBrZXkgZnJvbSBhY2NvdW50IGluaXRpYWwgZGF0YSBUaGlzIG9wZXJhdGlvbiBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIGluaXRpYWwgYWNjb3VudCBkYXRhIChiZWZvcmUgZGVwbG95KS4gSWYgdGhlIGNvbnRyYWN0IGlzIGFscmVhZHkgZGVwbG95ZWQsIGl0cyBkYXRhIGRvZXNuJ3QgY29udGFpbiB0aGlzIGRhdGEgc2VjdGlvbiBhbnkgbW9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZEZWNvZGVJbml0aWFsRGF0YX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZEZWNvZGVJbml0aWFsRGF0YVxuICAgICAqL1xuICAgIGRlY29kZV9pbml0aWFsX2RhdGEocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdhYmkuZGVjb2RlX2luaXRpYWxfZGF0YScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXMgQk9DIGludG8gSlNPTiBhcyBhIHNldCBvZiBwcm92aWRlZCBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBTb2xpZGl0eSBmdW5jdGlvbnMgdXNlIEFCSSB0eXBlcyBmb3IgW2J1aWxkZXIgZW5jb2RpbmddKGh0dHBzOi8vZ2l0aHViLmNvbS90b25sYWJzL1RPTi1Tb2xpZGl0eS1Db21waWxlci9ibG9iL21hc3Rlci9BUEkubWQjdHZtYnVpbGRlcnN0b3JlKS5cbiAgICAgKiBUaGUgc2ltcGxlc3Qgd2F5IHRvIGRlY29kZSBzdWNoIGEgQk9DIGlzIHRvIHVzZSBBQkkgZGVjb2RpbmcuXG4gICAgICogQUJJIGhhcyBpdCBvd24gcnVsZXMgZm9yIGZpZWxkcyBsYXlvdXQgaW4gY2VsbHMgc28gbWFudWFsbHkgZW5jb2RlZFxuICAgICAqIEJPQyBjYW4gbm90IGJlIGRlc2NyaWJlZCBpbiB0ZXJtcyBvZiBBQkkgcnVsZXMuXG4gICAgICpcbiAgICAgKiBUbyBzb2x2ZSB0aGlzIHByb2JsZW0gd2UgaW50cm9kdWNlIGEgbmV3IEFCSSB0eXBlIGBSZWYoPFBhcmFtVHlwZT4pYFxuICAgICAqIHdoaWNoIGFsbG93cyB0byBzdG9yZSBgUGFyYW1UeXBlYCBBQkkgcGFyYW1ldGVyIGluIGNlbGwgcmVmZXJlbmNlIGFuZCwgdGh1cyxcbiAgICAgKiBkZWNvZGUgbWFudWFsbHkgZW5jb2RlZCBCT0NzLiBUaGlzIHR5cGUgaXMgYXZhaWxhYmxlIG9ubHkgaW4gYGRlY29kZV9ib2NgIGZ1bmN0aW9uXG4gICAgICogYW5kIHdpbGwgbm90IGJlIGF2YWlsYWJsZSBpbiBBQkkgbWVzc2FnZXMgZW5jb2RpbmcgdW50aWwgaXQgaXMgaW5jbHVkZWQgaW50byBzb21lIEFCSSByZXZpc2lvbi5cbiAgICAgKlxuICAgICAqIFN1Y2ggQk9DIGRlc2NyaXB0aW9ucyBjb3ZlcnMgbW9zdCB1c2VycyBuZWVkcy4gSWYgc29tZW9uZSB3YW50cyB0byBkZWNvZGUgc29tZSBCT0Mgd2hpY2hcbiAgICAgKiBjYW4gbm90IGJlIGRlc2NyaWJlZCBieSB0aGVzZSBydWxlcyAoaS5lLiBCT0Mgd2l0aCBUTEIgY29udGFpbmluZyBjb25zdHJ1Y3RvcnMgb2YgZmxhZ3NcbiAgICAgKiBkZWZpbmluZyBzb21lIHBhcnNpbmcgY29uZGl0aW9ucykgdGhlbiB0aGV5IGNhbiBkZWNvZGUgdGhlIGZpZWxkcyB1cCB0byBmb3JrIGNvbmRpdGlvbixcbiAgICAgKiBjaGVjayB0aGUgcGFyc2VkIGRhdGEgbWFudWFsbHksIGV4cGFuZCB0aGUgcGFyc2luZyBzY2hlbWEgYW5kIHRoZW4gZGVjb2RlIHRoZSB3aG9sZSBCT0NcbiAgICAgKiB3aXRoIHRoZSBmdWxsIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZEZWNvZGVCb2N9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mRGVjb2RlQm9jXG4gICAgICovXG4gICAgZGVjb2RlX2JvYyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2FiaS5kZWNvZGVfYm9jJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBnaXZlbiBwYXJhbWV0ZXJzIGluIEpTT04gaW50byBhIEJPQyB1c2luZyBwYXJhbSB0eXBlcyBmcm9tIEFCSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZBYmlFbmNvZGVCb2N9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mQWJpRW5jb2RlQm9jXG4gICAgICovXG4gICAgZW5jb2RlX2JvYyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2FiaS5lbmNvZGVfYm9jJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBjb250cmFjdCBmdW5jdGlvbiBJRCBieSBjb250cmFjdCBBQklcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZDYWxjRnVuY3Rpb25JZH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZDYWxjRnVuY3Rpb25JZFxuICAgICAqL1xuICAgIGNhbGNfZnVuY3Rpb25faWQocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdhYmkuY2FsY19mdW5jdGlvbl9pZCcsIHBhcmFtcyk7XG4gICAgfVxufVxuZXhwb3J0cy5BYmlNb2R1bGUgPSBBYmlNb2R1bGU7XG5mdW5jdGlvbiBib2NDYWNoZVR5cGVQaW5uZWQocGluKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1Bpbm5lZCcsXG4gICAgICAgIHBpbixcbiAgICB9O1xufVxuZXhwb3J0cy5ib2NDYWNoZVR5cGVQaW5uZWQgPSBib2NDYWNoZVR5cGVQaW5uZWQ7XG5mdW5jdGlvbiBib2NDYWNoZVR5cGVVbnBpbm5lZCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnVW5waW5uZWQnLFxuICAgIH07XG59XG5leHBvcnRzLmJvY0NhY2hlVHlwZVVucGlubmVkID0gYm9jQ2FjaGVUeXBlVW5waW5uZWQ7XG52YXIgQm9jRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChCb2NFcnJvckNvZGUpIHtcbiAgICBCb2NFcnJvckNvZGVbQm9jRXJyb3JDb2RlW1wiSW52YWxpZEJvY1wiXSA9IDIwMV0gPSBcIkludmFsaWRCb2NcIjtcbiAgICBCb2NFcnJvckNvZGVbQm9jRXJyb3JDb2RlW1wiU2VyaWFsaXphdGlvbkVycm9yXCJdID0gMjAyXSA9IFwiU2VyaWFsaXphdGlvbkVycm9yXCI7XG4gICAgQm9jRXJyb3JDb2RlW0JvY0Vycm9yQ29kZVtcIkluYXBwcm9wcmlhdGVCbG9ja1wiXSA9IDIwM10gPSBcIkluYXBwcm9wcmlhdGVCbG9ja1wiO1xuICAgIEJvY0Vycm9yQ29kZVtCb2NFcnJvckNvZGVbXCJNaXNzaW5nU291cmNlQm9jXCJdID0gMjA0XSA9IFwiTWlzc2luZ1NvdXJjZUJvY1wiO1xuICAgIEJvY0Vycm9yQ29kZVtCb2NFcnJvckNvZGVbXCJJbnN1ZmZpY2llbnRDYWNoZVNpemVcIl0gPSAyMDVdID0gXCJJbnN1ZmZpY2llbnRDYWNoZVNpemVcIjtcbiAgICBCb2NFcnJvckNvZGVbQm9jRXJyb3JDb2RlW1wiQm9jUmVmTm90Rm91bmRcIl0gPSAyMDZdID0gXCJCb2NSZWZOb3RGb3VuZFwiO1xuICAgIEJvY0Vycm9yQ29kZVtCb2NFcnJvckNvZGVbXCJJbnZhbGlkQm9jUmVmXCJdID0gMjA3XSA9IFwiSW52YWxpZEJvY1JlZlwiO1xufSkoQm9jRXJyb3JDb2RlID0gZXhwb3J0cy5Cb2NFcnJvckNvZGUgfHwgKGV4cG9ydHMuQm9jRXJyb3JDb2RlID0ge30pKTtcbmZ1bmN0aW9uIGJ1aWxkZXJPcEludGVnZXIoc2l6ZSwgdmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnSW50ZWdlcicsXG4gICAgICAgIHNpemUsXG4gICAgICAgIHZhbHVlLFxuICAgIH07XG59XG5leHBvcnRzLmJ1aWxkZXJPcEludGVnZXIgPSBidWlsZGVyT3BJbnRlZ2VyO1xuZnVuY3Rpb24gYnVpbGRlck9wQml0U3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0JpdFN0cmluZycsXG4gICAgICAgIHZhbHVlLFxuICAgIH07XG59XG5leHBvcnRzLmJ1aWxkZXJPcEJpdFN0cmluZyA9IGJ1aWxkZXJPcEJpdFN0cmluZztcbmZ1bmN0aW9uIGJ1aWxkZXJPcENlbGwoYnVpbGRlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdDZWxsJyxcbiAgICAgICAgYnVpbGRlcixcbiAgICB9O1xufVxuZXhwb3J0cy5idWlsZGVyT3BDZWxsID0gYnVpbGRlck9wQ2VsbDtcbmZ1bmN0aW9uIGJ1aWxkZXJPcENlbGxCb2MoYm9jKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0NlbGxCb2MnLFxuICAgICAgICBib2MsXG4gICAgfTtcbn1cbmV4cG9ydHMuYnVpbGRlck9wQ2VsbEJvYyA9IGJ1aWxkZXJPcENlbGxCb2M7XG5mdW5jdGlvbiBidWlsZGVyT3BBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnQWRkcmVzcycsXG4gICAgICAgIGFkZHJlc3MsXG4gICAgfTtcbn1cbmV4cG9ydHMuYnVpbGRlck9wQWRkcmVzcyA9IGJ1aWxkZXJPcEFkZHJlc3M7XG4vKipcbiAqIEJPQyBtYW5pcHVsYXRpb24gbW9kdWxlLlxuICovXG5jbGFzcyBCb2NNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIG1lc3NhZ2UgYm9jIGludG8gYSBKU09OXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEpTT04gc3RydWN0dXJlIGlzIGNvbXBhdGlibGUgd2l0aCBHcmFwaFFMIEFQSSBtZXNzYWdlIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlBhcnNlfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZlBhcnNlXG4gICAgICovXG4gICAgcGFyc2VfbWVzc2FnZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2JvYy5wYXJzZV9tZXNzYWdlJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRyYW5zYWN0aW9uIGJvYyBpbnRvIGEgSlNPTlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBKU09OIHN0cnVjdHVyZSBpcyBjb21wYXRpYmxlIHdpdGggR3JhcGhRTCBBUEkgdHJhbnNhY3Rpb24gb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mUGFyc2V9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mUGFyc2VcbiAgICAgKi9cbiAgICBwYXJzZV90cmFuc2FjdGlvbihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2JvYy5wYXJzZV90cmFuc2FjdGlvbicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhY2NvdW50IGJvYyBpbnRvIGEgSlNPTlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBKU09OIHN0cnVjdHVyZSBpcyBjb21wYXRpYmxlIHdpdGggR3JhcGhRTCBBUEkgYWNjb3VudCBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZQYXJzZX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZQYXJzZVxuICAgICAqL1xuICAgIHBhcnNlX2FjY291bnQocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdib2MucGFyc2VfYWNjb3VudCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBibG9jayBib2MgaW50byBhIEpTT05cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSlNPTiBzdHJ1Y3R1cmUgaXMgY29tcGF0aWJsZSB3aXRoIEdyYXBoUUwgQVBJIGJsb2NrIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlBhcnNlfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZlBhcnNlXG4gICAgICovXG4gICAgcGFyc2VfYmxvY2socGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdib2MucGFyc2VfYmxvY2snLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgc2hhcmRzdGF0ZSBib2MgaW50byBhIEpTT05cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSlNPTiBzdHJ1Y3R1cmUgaXMgY29tcGF0aWJsZSB3aXRoIEdyYXBoUUwgQVBJIHNoYXJkc3RhdGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mUGFyc2VTaGFyZHN0YXRlfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZlBhcnNlXG4gICAgICovXG4gICAgcGFyc2Vfc2hhcmRzdGF0ZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2JvYy5wYXJzZV9zaGFyZHN0YXRlJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBibG9ja2NoYWluIGNvbmZpZ3VyYXRpb24gZnJvbSBrZXkgYmxvY2sgYW5kIGFsc28gZnJvbSB6ZXJvc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mR2V0QmxvY2tjaGFpbkNvbmZpZ30gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZHZXRCbG9ja2NoYWluQ29uZmlnXG4gICAgICovXG4gICAgZ2V0X2Jsb2NrY2hhaW5fY29uZmlnKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYm9jLmdldF9ibG9ja2NoYWluX2NvbmZpZycsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgQk9DIHJvb3QgaGFzaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkdldEJvY0hhc2h9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mR2V0Qm9jSGFzaFxuICAgICAqL1xuICAgIGdldF9ib2NfaGFzaChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2JvYy5nZXRfYm9jX2hhc2gnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIEJPQyBkZXB0aFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkdldEJvY0RlcHRofSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkdldEJvY0RlcHRoXG4gICAgICovXG4gICAgZ2V0X2JvY19kZXB0aChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2JvYy5nZXRfYm9jX2RlcHRoJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgY29kZSBmcm9tIFRWQyBjb250cmFjdCBpbWFnZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkdldENvZGVGcm9tVHZjfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkdldENvZGVGcm9tVHZjXG4gICAgICovXG4gICAgZ2V0X2NvZGVfZnJvbV90dmMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdib2MuZ2V0X2NvZGVfZnJvbV90dmMnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgQk9DIGZyb20gY2FjaGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZCb2NDYWNoZUdldH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZCb2NDYWNoZUdldFxuICAgICAqL1xuICAgIGNhY2hlX2dldChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2JvYy5jYWNoZV9nZXQnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTYXZlIEJPQyBpbnRvIGNhY2hlIG9yIGluY3JlYXNlIHBpbiBjb3VudGVyIGZvciBleGlzdGluZyBwaW5uZWQgQk9DXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mQm9jQ2FjaGVTZXR9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mQm9jQ2FjaGVTZXRcbiAgICAgKi9cbiAgICBjYWNoZV9zZXQocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdib2MuY2FjaGVfc2V0JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5waW4gQk9DcyB3aXRoIHNwZWNpZmllZCBwaW4gZGVmaW5lZCBpbiB0aGUgYGNhY2hlX3NldGAuIERlY3JlYXNlIHBpbiByZWZlcmVuY2UgY291bnRlciBmb3IgQk9DcyB3aXRoIHNwZWNpZmllZCBwaW4gZGVmaW5lZCBpbiB0aGUgYGNhY2hlX3NldGAuIEJPQ3Mgd2hpY2ggaGF2ZSBvbmx5IDEgcGluIGFuZCBpdHMgcmVmZXJlbmNlIGNvdW50ZXIgYmVjb21lIDAgd2lsbCBiZSByZW1vdmVkIGZyb20gY2FjaGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZCb2NDYWNoZVVucGlufSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGNhY2hlX3VucGluKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYm9jLmNhY2hlX3VucGluJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBiYWcgb2YgY2VsbHMgKEJPQykgd2l0aCBidWlsZGVyIG9wZXJhdGlvbnMuIFRoaXMgbWV0aG9kIHByb3ZpZGVzIHRoZSBzYW1lIGZ1bmN0aW9uYWxpdHkgYXMgU29saWRpdHkgVHZtQnVpbGRlci4gUmVzdWx0aW5nIEJPQyBvZiB0aGlzIG1ldGhvZCBjYW4gYmUgcGFzc2VkIGludG8gU29saWRpdHkgYW5kIEMrKyBjb250cmFjdHMgYXMgVHZtQ2VsbCB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkVuY29kZUJvY30gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZFbmNvZGVCb2NcbiAgICAgKi9cbiAgICBlbmNvZGVfYm9jKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYm9jLmVuY29kZV9ib2MnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250cmFjdCBjb2RlJ3Mgc2FsdCBpZiBpdCBpcyBwcmVzZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkdldENvZGVTYWx0fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkdldENvZGVTYWx0XG4gICAgICovXG4gICAgZ2V0X2NvZGVfc2FsdChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2JvYy5nZXRfY29kZV9zYWx0JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBuZXcgc2FsdCB0byBjb250cmFjdCBjb2RlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXcgY29udHJhY3QgY29kZSB3aXRoIHNhbHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mU2V0Q29kZVNhbHR9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mU2V0Q29kZVNhbHRcbiAgICAgKi9cbiAgICBzZXRfY29kZV9zYWx0KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYm9jLnNldF9jb2RlX3NhbHQnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIHR2YyBpbnRvIGNvZGUsIGRhdGEsIGxpYnJhcmllcyBhbmQgc3BlY2lhbCBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkRlY29kZVR2Y30gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZEZWNvZGVUdmNcbiAgICAgKi9cbiAgICBkZWNvZGVfdHZjKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYm9jLmRlY29kZV90dmMnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHR2YyBmcm9tIGNvZGUsIGRhdGEsIGxpYnJhcmllcyBhbnMgc3BlY2lhbCBvcHRpb25zIChzZWUgaW5wdXQgcGFyYW1zKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkVuY29kZVR2Y30gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZFbmNvZGVUdmNcbiAgICAgKi9cbiAgICBlbmNvZGVfdHZjKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnYm9jLmVuY29kZV90dmMnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGEgbWVzc2FnZVxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBBbGxvd3MgdG8gZW5jb2RlIGFueSBleHRlcm5hbCBpbmJvdW5kIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mRW5jb2RlRXh0ZXJuYWxJbk1lc3NhZ2V9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mRW5jb2RlRXh0ZXJuYWxJbk1lc3NhZ2VcbiAgICAgKi9cbiAgICBlbmNvZGVfZXh0ZXJuYWxfaW5fbWVzc2FnZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2JvYy5lbmNvZGVfZXh0ZXJuYWxfaW5fbWVzc2FnZScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbXBpbGVyIHZlcnNpb24gdXNlZCB0byBjb21waWxlIHRoZSBjb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkdldENvbXBpbGVyVmVyc2lvbn0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZHZXRDb21waWxlclZlcnNpb25cbiAgICAgKi9cbiAgICBnZXRfY29tcGlsZXJfdmVyc2lvbihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2JvYy5nZXRfY29tcGlsZXJfdmVyc2lvbicsIHBhcmFtcyk7XG4gICAgfVxufVxuZXhwb3J0cy5Cb2NNb2R1bGUgPSBCb2NNb2R1bGU7XG4vLyBwcm9jZXNzaW5nIG1vZHVsZVxudmFyIFByb2Nlc3NpbmdFcnJvckNvZGU7XG4oZnVuY3Rpb24gKFByb2Nlc3NpbmdFcnJvckNvZGUpIHtcbiAgICBQcm9jZXNzaW5nRXJyb3JDb2RlW1Byb2Nlc3NpbmdFcnJvckNvZGVbXCJNZXNzYWdlQWxyZWFkeUV4cGlyZWRcIl0gPSA1MDFdID0gXCJNZXNzYWdlQWxyZWFkeUV4cGlyZWRcIjtcbiAgICBQcm9jZXNzaW5nRXJyb3JDb2RlW1Byb2Nlc3NpbmdFcnJvckNvZGVbXCJNZXNzYWdlSGFzTm90RGVzdGluYXRpb25BZGRyZXNzXCJdID0gNTAyXSA9IFwiTWVzc2FnZUhhc05vdERlc3RpbmF0aW9uQWRkcmVzc1wiO1xuICAgIFByb2Nlc3NpbmdFcnJvckNvZGVbUHJvY2Vzc2luZ0Vycm9yQ29kZVtcIkNhbk5vdEJ1aWxkTWVzc2FnZUNlbGxcIl0gPSA1MDNdID0gXCJDYW5Ob3RCdWlsZE1lc3NhZ2VDZWxsXCI7XG4gICAgUHJvY2Vzc2luZ0Vycm9yQ29kZVtQcm9jZXNzaW5nRXJyb3JDb2RlW1wiRmV0Y2hCbG9ja0ZhaWxlZFwiXSA9IDUwNF0gPSBcIkZldGNoQmxvY2tGYWlsZWRcIjtcbiAgICBQcm9jZXNzaW5nRXJyb3JDb2RlW1Byb2Nlc3NpbmdFcnJvckNvZGVbXCJTZW5kTWVzc2FnZUZhaWxlZFwiXSA9IDUwNV0gPSBcIlNlbmRNZXNzYWdlRmFpbGVkXCI7XG4gICAgUHJvY2Vzc2luZ0Vycm9yQ29kZVtQcm9jZXNzaW5nRXJyb3JDb2RlW1wiSW52YWxpZE1lc3NhZ2VCb2NcIl0gPSA1MDZdID0gXCJJbnZhbGlkTWVzc2FnZUJvY1wiO1xuICAgIFByb2Nlc3NpbmdFcnJvckNvZGVbUHJvY2Vzc2luZ0Vycm9yQ29kZVtcIk1lc3NhZ2VFeHBpcmVkXCJdID0gNTA3XSA9IFwiTWVzc2FnZUV4cGlyZWRcIjtcbiAgICBQcm9jZXNzaW5nRXJyb3JDb2RlW1Byb2Nlc3NpbmdFcnJvckNvZGVbXCJUcmFuc2FjdGlvbldhaXRUaW1lb3V0XCJdID0gNTA4XSA9IFwiVHJhbnNhY3Rpb25XYWl0VGltZW91dFwiO1xuICAgIFByb2Nlc3NpbmdFcnJvckNvZGVbUHJvY2Vzc2luZ0Vycm9yQ29kZVtcIkludmFsaWRCbG9ja1JlY2VpdmVkXCJdID0gNTA5XSA9IFwiSW52YWxpZEJsb2NrUmVjZWl2ZWRcIjtcbiAgICBQcm9jZXNzaW5nRXJyb3JDb2RlW1Byb2Nlc3NpbmdFcnJvckNvZGVbXCJDYW5Ob3RDaGVja0Jsb2NrU2hhcmRcIl0gPSA1MTBdID0gXCJDYW5Ob3RDaGVja0Jsb2NrU2hhcmRcIjtcbiAgICBQcm9jZXNzaW5nRXJyb3JDb2RlW1Byb2Nlc3NpbmdFcnJvckNvZGVbXCJCbG9ja05vdEZvdW5kXCJdID0gNTExXSA9IFwiQmxvY2tOb3RGb3VuZFwiO1xuICAgIFByb2Nlc3NpbmdFcnJvckNvZGVbUHJvY2Vzc2luZ0Vycm9yQ29kZVtcIkludmFsaWREYXRhXCJdID0gNTEyXSA9IFwiSW52YWxpZERhdGFcIjtcbiAgICBQcm9jZXNzaW5nRXJyb3JDb2RlW1Byb2Nlc3NpbmdFcnJvckNvZGVbXCJFeHRlcm5hbFNpZ25lck11c3ROb3RCZVVzZWRcIl0gPSA1MTNdID0gXCJFeHRlcm5hbFNpZ25lck11c3ROb3RCZVVzZWRcIjtcbiAgICBQcm9jZXNzaW5nRXJyb3JDb2RlW1Byb2Nlc3NpbmdFcnJvckNvZGVbXCJNZXNzYWdlUmVqZWN0ZWRcIl0gPSA1MTRdID0gXCJNZXNzYWdlUmVqZWN0ZWRcIjtcbiAgICBQcm9jZXNzaW5nRXJyb3JDb2RlW1Byb2Nlc3NpbmdFcnJvckNvZGVbXCJJbnZhbGlkUmVtcFN0YXR1c1wiXSA9IDUxNV0gPSBcIkludmFsaWRSZW1wU3RhdHVzXCI7XG4gICAgUHJvY2Vzc2luZ0Vycm9yQ29kZVtQcm9jZXNzaW5nRXJyb3JDb2RlW1wiTmV4dFJlbXBTdGF0dXNUaW1lb3V0XCJdID0gNTE2XSA9IFwiTmV4dFJlbXBTdGF0dXNUaW1lb3V0XCI7XG59KShQcm9jZXNzaW5nRXJyb3JDb2RlID0gZXhwb3J0cy5Qcm9jZXNzaW5nRXJyb3JDb2RlIHx8IChleHBvcnRzLlByb2Nlc3NpbmdFcnJvckNvZGUgPSB7fSkpO1xuZnVuY3Rpb24gcHJvY2Vzc2luZ0V2ZW50V2lsbEZldGNoRmlyc3RCbG9jaygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnV2lsbEZldGNoRmlyc3RCbG9jaycsXG4gICAgfTtcbn1cbmV4cG9ydHMucHJvY2Vzc2luZ0V2ZW50V2lsbEZldGNoRmlyc3RCbG9jayA9IHByb2Nlc3NpbmdFdmVudFdpbGxGZXRjaEZpcnN0QmxvY2s7XG5mdW5jdGlvbiBwcm9jZXNzaW5nRXZlbnRGZXRjaEZpcnN0QmxvY2tGYWlsZWQoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRmV0Y2hGaXJzdEJsb2NrRmFpbGVkJyxcbiAgICAgICAgZXJyb3IsXG4gICAgfTtcbn1cbmV4cG9ydHMucHJvY2Vzc2luZ0V2ZW50RmV0Y2hGaXJzdEJsb2NrRmFpbGVkID0gcHJvY2Vzc2luZ0V2ZW50RmV0Y2hGaXJzdEJsb2NrRmFpbGVkO1xuZnVuY3Rpb24gcHJvY2Vzc2luZ0V2ZW50V2lsbFNlbmQoc2hhcmRfYmxvY2tfaWQsIG1lc3NhZ2VfaWQsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnV2lsbFNlbmQnLFxuICAgICAgICBzaGFyZF9ibG9ja19pZCxcbiAgICAgICAgbWVzc2FnZV9pZCxcbiAgICAgICAgbWVzc2FnZSxcbiAgICB9O1xufVxuZXhwb3J0cy5wcm9jZXNzaW5nRXZlbnRXaWxsU2VuZCA9IHByb2Nlc3NpbmdFdmVudFdpbGxTZW5kO1xuZnVuY3Rpb24gcHJvY2Vzc2luZ0V2ZW50RGlkU2VuZChzaGFyZF9ibG9ja19pZCwgbWVzc2FnZV9pZCwgbWVzc2FnZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdEaWRTZW5kJyxcbiAgICAgICAgc2hhcmRfYmxvY2tfaWQsXG4gICAgICAgIG1lc3NhZ2VfaWQsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgfTtcbn1cbmV4cG9ydHMucHJvY2Vzc2luZ0V2ZW50RGlkU2VuZCA9IHByb2Nlc3NpbmdFdmVudERpZFNlbmQ7XG5mdW5jdGlvbiBwcm9jZXNzaW5nRXZlbnRTZW5kRmFpbGVkKHNoYXJkX2Jsb2NrX2lkLCBtZXNzYWdlX2lkLCBtZXNzYWdlLCBlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdTZW5kRmFpbGVkJyxcbiAgICAgICAgc2hhcmRfYmxvY2tfaWQsXG4gICAgICAgIG1lc3NhZ2VfaWQsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIGVycm9yLFxuICAgIH07XG59XG5leHBvcnRzLnByb2Nlc3NpbmdFdmVudFNlbmRGYWlsZWQgPSBwcm9jZXNzaW5nRXZlbnRTZW5kRmFpbGVkO1xuZnVuY3Rpb24gcHJvY2Vzc2luZ0V2ZW50V2lsbEZldGNoTmV4dEJsb2NrKHNoYXJkX2Jsb2NrX2lkLCBtZXNzYWdlX2lkLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1dpbGxGZXRjaE5leHRCbG9jaycsXG4gICAgICAgIHNoYXJkX2Jsb2NrX2lkLFxuICAgICAgICBtZXNzYWdlX2lkLFxuICAgICAgICBtZXNzYWdlLFxuICAgIH07XG59XG5leHBvcnRzLnByb2Nlc3NpbmdFdmVudFdpbGxGZXRjaE5leHRCbG9jayA9IHByb2Nlc3NpbmdFdmVudFdpbGxGZXRjaE5leHRCbG9jaztcbmZ1bmN0aW9uIHByb2Nlc3NpbmdFdmVudEZldGNoTmV4dEJsb2NrRmFpbGVkKHNoYXJkX2Jsb2NrX2lkLCBtZXNzYWdlX2lkLCBtZXNzYWdlLCBlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZXRjaE5leHRCbG9ja0ZhaWxlZCcsXG4gICAgICAgIHNoYXJkX2Jsb2NrX2lkLFxuICAgICAgICBtZXNzYWdlX2lkLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBlcnJvcixcbiAgICB9O1xufVxuZXhwb3J0cy5wcm9jZXNzaW5nRXZlbnRGZXRjaE5leHRCbG9ja0ZhaWxlZCA9IHByb2Nlc3NpbmdFdmVudEZldGNoTmV4dEJsb2NrRmFpbGVkO1xuZnVuY3Rpb24gcHJvY2Vzc2luZ0V2ZW50TWVzc2FnZUV4cGlyZWQobWVzc2FnZV9pZCwgbWVzc2FnZSwgZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnTWVzc2FnZUV4cGlyZWQnLFxuICAgICAgICBtZXNzYWdlX2lkLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBlcnJvcixcbiAgICB9O1xufVxuZXhwb3J0cy5wcm9jZXNzaW5nRXZlbnRNZXNzYWdlRXhwaXJlZCA9IHByb2Nlc3NpbmdFdmVudE1lc3NhZ2VFeHBpcmVkO1xuZnVuY3Rpb24gcHJvY2Vzc2luZ0V2ZW50UmVtcFNlbnRUb1ZhbGlkYXRvcnMobWVzc2FnZV9pZCwgdGltZXN0YW1wLCBqc29uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1JlbXBTZW50VG9WYWxpZGF0b3JzJyxcbiAgICAgICAgbWVzc2FnZV9pZCxcbiAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICBqc29uLFxuICAgIH07XG59XG5leHBvcnRzLnByb2Nlc3NpbmdFdmVudFJlbXBTZW50VG9WYWxpZGF0b3JzID0gcHJvY2Vzc2luZ0V2ZW50UmVtcFNlbnRUb1ZhbGlkYXRvcnM7XG5mdW5jdGlvbiBwcm9jZXNzaW5nRXZlbnRSZW1wSW5jbHVkZWRJbnRvQmxvY2sobWVzc2FnZV9pZCwgdGltZXN0YW1wLCBqc29uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1JlbXBJbmNsdWRlZEludG9CbG9jaycsXG4gICAgICAgIG1lc3NhZ2VfaWQsXG4gICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAganNvbixcbiAgICB9O1xufVxuZXhwb3J0cy5wcm9jZXNzaW5nRXZlbnRSZW1wSW5jbHVkZWRJbnRvQmxvY2sgPSBwcm9jZXNzaW5nRXZlbnRSZW1wSW5jbHVkZWRJbnRvQmxvY2s7XG5mdW5jdGlvbiBwcm9jZXNzaW5nRXZlbnRSZW1wSW5jbHVkZWRJbnRvQWNjZXB0ZWRCbG9jayhtZXNzYWdlX2lkLCB0aW1lc3RhbXAsIGpzb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnUmVtcEluY2x1ZGVkSW50b0FjY2VwdGVkQmxvY2snLFxuICAgICAgICBtZXNzYWdlX2lkLFxuICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgIGpzb24sXG4gICAgfTtcbn1cbmV4cG9ydHMucHJvY2Vzc2luZ0V2ZW50UmVtcEluY2x1ZGVkSW50b0FjY2VwdGVkQmxvY2sgPSBwcm9jZXNzaW5nRXZlbnRSZW1wSW5jbHVkZWRJbnRvQWNjZXB0ZWRCbG9jaztcbmZ1bmN0aW9uIHByb2Nlc3NpbmdFdmVudFJlbXBPdGhlcihtZXNzYWdlX2lkLCB0aW1lc3RhbXAsIGpzb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnUmVtcE90aGVyJyxcbiAgICAgICAgbWVzc2FnZV9pZCxcbiAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICBqc29uLFxuICAgIH07XG59XG5leHBvcnRzLnByb2Nlc3NpbmdFdmVudFJlbXBPdGhlciA9IHByb2Nlc3NpbmdFdmVudFJlbXBPdGhlcjtcbmZ1bmN0aW9uIHByb2Nlc3NpbmdFdmVudFJlbXBFcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdSZW1wRXJyb3InLFxuICAgICAgICBlcnJvcixcbiAgICB9O1xufVxuZXhwb3J0cy5wcm9jZXNzaW5nRXZlbnRSZW1wRXJyb3IgPSBwcm9jZXNzaW5nRXZlbnRSZW1wRXJyb3I7XG4vKipcbiAqIE1lc3NhZ2UgcHJvY2Vzc2luZyBtb2R1bGUuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgbW9kdWxlIGluY29ycG9yYXRlcyBmdW5jdGlvbnMgcmVsYXRlZCB0byBjb21wbGV4IG1lc3NhZ2VcbiAqIHByb2Nlc3Npbmcgc2NlbmFyaW9zLlxuICovXG5jbGFzcyBQcm9jZXNzaW5nTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIG1lc3NhZ2UgdG8gdGhlIG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogU2VuZHMgbWVzc2FnZSB0byB0aGUgbmV0d29yayBhbmQgcmV0dXJucyB0aGUgbGFzdCBnZW5lcmF0ZWQgc2hhcmQgYmxvY2sgb2YgdGhlIGRlc3RpbmF0aW9uIGFjY291bnRcbiAgICAgKiBiZWZvcmUgdGhlIG1lc3NhZ2Ugd2FzIHNlbnQuIEl0IHdpbGwgYmUgcmVxdWlyZWQgbGF0ZXIgZm9yIG1lc3NhZ2UgcHJvY2Vzc2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZTZW5kTWVzc2FnZX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZTZW5kTWVzc2FnZVxuICAgICAqL1xuICAgIHNlbmRfbWVzc2FnZShwYXJhbXMsIHJlc3BvbnNlSGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgncHJvY2Vzc2luZy5zZW5kX21lc3NhZ2UnLCBwYXJhbXMsIHJlc3BvbnNlSGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIG1vbml0b3Jpbmcgb2YgdGhlIG5ldHdvcmsgZm9yIHRoZSByZXN1bHQgdHJhbnNhY3Rpb24gb2YgdGhlIGV4dGVybmFsIGluYm91bmQgbWVzc2FnZSBwcm9jZXNzaW5nLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBgc2VuZF9ldmVudHNgIGVuYWJsZXMgaW50ZXJtZWRpYXRlIGV2ZW50cywgc3VjaCBhcyBgV2lsbEZldGNoTmV4dEJsb2NrYCxcbiAgICAgKiBgRmV0Y2hOZXh0QmxvY2tGYWlsZWRgIHRoYXQgbWF5IGJlIHVzZWZ1bCBmb3IgbG9nZ2luZyBvZiBuZXcgc2hhcmQgYmxvY2tzIGNyZWF0aW9uXG4gICAgICogZHVyaW5nIG1lc3NhZ2UgcHJvY2Vzc2luZy5cbiAgICAgKlxuICAgICAqIE5vdGUsIHRoYXQgcHJlc2VuY2Ugb2YgdGhlIGBhYmlgIHBhcmFtZXRlciBpcyBjcml0aWNhbCBmb3IgQUJJXG4gICAgICogY29tcGxpYW50IGNvbnRyYWN0cy4gTWVzc2FnZSBwcm9jZXNzaW5nIHVzZXMgZHJhc3RpY2FsbHlcbiAgICAgKiBkaWZmZXJlbnQgc3RyYXRlZ3kgZm9yIHByb2Nlc3NpbmcgbWVzc2FnZSBmb3IgY29udHJhY3RzIHdoaWNoXG4gICAgICogQUJJIGluY2x1ZGVzIFwiZXhwaXJlXCIgaGVhZGVyLlxuICAgICAqXG4gICAgICogV2hlbiB0aGUgQUJJIGhlYWRlciBgZXhwaXJlYCBpcyBwcmVzZW50LCB0aGUgcHJvY2Vzc2luZyB1c2VzXG4gICAgICogYG1lc3NhZ2UgZXhwaXJhdGlvbmAgc3RyYXRlZ3k6XG4gICAgICogLSBUaGUgbWF4aW11bSBibG9jayBnZW4gdGltZSBpcyBzZXQgdG9cbiAgICAgKiAgIGBtZXNzYWdlX2V4cGlyYXRpb25fdGltZW91dCArIHRyYW5zYWN0aW9uX3dhaXRfdGltZW91dGAuXG4gICAgICogLSBXaGVuIG1heGltdW0gYmxvY2sgZ2VuIHRpbWUgaXMgcmVhY2hlZCwgdGhlIHByb2Nlc3Npbmcgd2lsbFxuICAgICAqICAgYmUgZmluaXNoZWQgd2l0aCBgTWVzc2FnZUV4cGlyZWRgIGVycm9yLlxuICAgICAqXG4gICAgICogV2hlbiB0aGUgQUJJIGhlYWRlciBgZXhwaXJlYCBpc24ndCBwcmVzZW50IG9yIGBhYmlgIHBhcmFtZXRlclxuICAgICAqIGlzbid0IHNwZWNpZmllZCwgdGhlIHByb2Nlc3NpbmcgdXNlcyBgdHJhbnNhY3Rpb24gd2FpdGluZ2BcbiAgICAgKiBzdHJhdGVneTpcbiAgICAgKiAtIFRoZSBtYXhpbXVtIGJsb2NrIGdlbiB0aW1lIGlzIHNldCB0b1xuICAgICAqICAgYG5vdygpICsgdHJhbnNhY3Rpb25fd2FpdF90aW1lb3V0YC5cbiAgICAgKlxuICAgICAqIC0gSWYgbWF4aW11bSBibG9jayBnZW4gdGltZSBpcyByZWFjaGVkIGFuZCBubyByZXN1bHQgdHJhbnNhY3Rpb24gaXMgZm91bmQsXG4gICAgICogdGhlIHByb2Nlc3Npbmcgd2lsbCBleGl0IHdpdGggYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mV2FpdEZvclRyYW5zYWN0aW9ufSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZlByb2Nlc3NNZXNzYWdlXG4gICAgICovXG4gICAgd2FpdF9mb3JfdHJhbnNhY3Rpb24ocGFyYW1zLCByZXNwb25zZUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ3Byb2Nlc3Npbmcud2FpdF9mb3JfdHJhbnNhY3Rpb24nLCBwYXJhbXMsIHJlc3BvbnNlSGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbWVzc2FnZSwgc2VuZHMgaXQgdG8gdGhlIG5ldHdvcmsgYW5kIG1vbml0b3JzIGl0cyBwcm9jZXNzaW5nLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBDcmVhdGVzIEFCSS1jb21wYXRpYmxlIG1lc3NhZ2UsXG4gICAgICogc2VuZHMgaXQgdG8gdGhlIG5ldHdvcmsgYW5kIG1vbml0b3JzIGZvciB0aGUgcmVzdWx0IHRyYW5zYWN0aW9uLlxuICAgICAqIERlY29kZXMgdGhlIG91dHB1dCBtZXNzYWdlcycgYm9kaWVzLlxuICAgICAqXG4gICAgICogSWYgY29udHJhY3QncyBBQkkgaW5jbHVkZXMgXCJleHBpcmVcIiBoZWFkZXIsIHRoZW5cbiAgICAgKiBTREsgaW1wbGVtZW50cyByZXRyaWVzIGluIGNhc2Ugb2YgdW5zdWNjZXNzZnVsIG1lc3NhZ2UgZGVsaXZlcnkgd2l0aGluIHRoZSBleHBpcmF0aW9uXG4gICAgICogdGltZW91dDogU0RLIHJlY3JlYXRlcyB0aGUgbWVzc2FnZSwgc2VuZHMgaXQgYW5kIHByb2Nlc3NlcyBpdCBhZ2Fpbi5cbiAgICAgKlxuICAgICAqIFRoZSBpbnRlcm1lZGlhdGUgZXZlbnRzLCBzdWNoIGFzIGBXaWxsRmV0Y2hGaXJzdEJsb2NrYCwgYFdpbGxTZW5kYCwgYERpZFNlbmRgLFxuICAgICAqIGBXaWxsRmV0Y2hOZXh0QmxvY2tgLCBldGMgLSBhcmUgc3dpdGNoZWQgb24vb2ZmIGJ5IGBzZW5kX2V2ZW50c2AgZmxhZ1xuICAgICAqIGFuZCBsb2dnZWQgaW50byB0aGUgc3VwcGxpZWQgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGUgcmV0cnkgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIGFyZSBkZWZpbmVkIGluIHRoZSBjbGllbnQncyBgTmV0d29ya0NvbmZpZ2AgYW5kIGBBYmlDb25maWdgLlxuICAgICAqXG4gICAgICogSWYgY29udHJhY3QncyBBQkkgZG9lcyBub3QgaW5jbHVkZSBcImV4cGlyZVwiIGhlYWRlclxuICAgICAqIHRoZW4sIGlmIG5vIHRyYW5zYWN0aW9uIGlzIGZvdW5kIHdpdGhpbiB0aGUgbmV0d29yayB0aW1lb3V0IChzZWUgY29uZmlnIHBhcmFtZXRlciApLCBleGl0cyB3aXRoIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlByb2Nlc3NNZXNzYWdlfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZlByb2Nlc3NNZXNzYWdlXG4gICAgICovXG4gICAgcHJvY2Vzc19tZXNzYWdlKHBhcmFtcywgcmVzcG9uc2VIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdwcm9jZXNzaW5nLnByb2Nlc3NfbWVzc2FnZScsIHBhcmFtcywgcmVzcG9uc2VIYW5kbGVyKTtcbiAgICB9XG59XG5leHBvcnRzLlByb2Nlc3NpbmdNb2R1bGUgPSBQcm9jZXNzaW5nTW9kdWxlO1xuZnVuY3Rpb24gYWRkcmVzc1N0cmluZ0Zvcm1hdEFjY291bnRJZCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnQWNjb3VudElkJyxcbiAgICB9O1xufVxuZXhwb3J0cy5hZGRyZXNzU3RyaW5nRm9ybWF0QWNjb3VudElkID0gYWRkcmVzc1N0cmluZ0Zvcm1hdEFjY291bnRJZDtcbmZ1bmN0aW9uIGFkZHJlc3NTdHJpbmdGb3JtYXRIZXgoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0hleCcsXG4gICAgfTtcbn1cbmV4cG9ydHMuYWRkcmVzc1N0cmluZ0Zvcm1hdEhleCA9IGFkZHJlc3NTdHJpbmdGb3JtYXRIZXg7XG5mdW5jdGlvbiBhZGRyZXNzU3RyaW5nRm9ybWF0QmFzZTY0KHVybCwgdGVzdCwgYm91bmNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0Jhc2U2NCcsXG4gICAgICAgIHVybCxcbiAgICAgICAgdGVzdCxcbiAgICAgICAgYm91bmNlLFxuICAgIH07XG59XG5leHBvcnRzLmFkZHJlc3NTdHJpbmdGb3JtYXRCYXNlNjQgPSBhZGRyZXNzU3RyaW5nRm9ybWF0QmFzZTY0O1xudmFyIEFjY291bnRBZGRyZXNzVHlwZTtcbihmdW5jdGlvbiAoQWNjb3VudEFkZHJlc3NUeXBlKSB7XG4gICAgQWNjb3VudEFkZHJlc3NUeXBlW1wiQWNjb3VudElkXCJdID0gXCJBY2NvdW50SWRcIjtcbiAgICBBY2NvdW50QWRkcmVzc1R5cGVbXCJIZXhcIl0gPSBcIkhleFwiO1xuICAgIEFjY291bnRBZGRyZXNzVHlwZVtcIkJhc2U2NFwiXSA9IFwiQmFzZTY0XCI7XG59KShBY2NvdW50QWRkcmVzc1R5cGUgPSBleHBvcnRzLkFjY291bnRBZGRyZXNzVHlwZSB8fCAoZXhwb3J0cy5BY2NvdW50QWRkcmVzc1R5cGUgPSB7fSkpO1xuLyoqXG4gKiBNaXNjIHV0aWxpdHkgRnVuY3Rpb25zLlxuICovXG5jbGFzcyBVdGlsc01vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhZGRyZXNzIGZyb20gYW55IFRPTiBmb3JtYXQgdG8gYW55IFRPTiBmb3JtYXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZDb252ZXJ0QWRkcmVzc30gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZDb252ZXJ0QWRkcmVzc1xuICAgICAqL1xuICAgIGNvbnZlcnRfYWRkcmVzcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ3V0aWxzLmNvbnZlcnRfYWRkcmVzcycsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBhbmQgcmV0dXJucyB0aGUgdHlwZSBvZiBhbnkgVE9OIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEFkZHJlc3MgdHlwZXMgYXJlIHRoZSBmb2xsb3dpbmdcbiAgICAgKlxuICAgICAqIGAwOjkxOWRiOGU3NDBkNTBiZjM0OWRmMmVlYTAzZmEzMGMzODVkODQ2Yjk5MWZmNTU0MmU2NzA5OGVlODMzZmM3ZjdgIC0gc3RhbmRhcmQgVE9OIGFkZHJlc3MgbW9zdFxuICAgICAqIGNvbW1vbmx5IHVzZWQgaW4gYWxsIGNhc2VzLiBBbHNvIGNhbGxlZCBhcyBoZXggYWRkcmVzc1xuICAgICAqIGA5MTlkYjhlNzQwZDUwYmYzNDlkZjJlZWEwM2ZhMzBjMzg1ZDg0NmI5OTFmZjU1NDJlNjcwOThlZTgzM2ZjN2Y3YCAtIGFjY291bnQgSUQuIEEgcGFydCBvZiBmdWxsXG4gICAgICogYWRkcmVzcy4gSWRlbnRpZmllcyBhY2NvdW50IGluc2lkZSBwYXJ0aWN1bGFyIHdvcmtjaGFpblxuICAgICAqIGBFUUNSbmJqblFOVUw4MG5mTHVvRCtqRERoZGhHdVpIL1ZVTG1jSmp1Z3ovSDl3YW1gIC0gYmFzZTY0IGFkZHJlc3MuIEFsc28gY2FsbGVkIFwidXNlci1mcmllbmRseVwiLlxuICAgICAqIFdhcyB1c2VkIGF0IHRoZSBiZWdpbm5pbmcgb2YgVE9OLiBOb3cgaXQgaXMgc3VwcG9ydGVkIGZvciBjb21wYXRpYmlsaXR5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mR2V0QWRkcmVzc1R5cGV9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mR2V0QWRkcmVzc1R5cGVcbiAgICAgKi9cbiAgICBnZXRfYWRkcmVzc190eXBlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgndXRpbHMuZ2V0X2FkZHJlc3NfdHlwZScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgc3RvcmFnZSBmZWUgZm9yIGFuIGFjY291bnQgb3ZlciBhIHNwZWNpZmllZCB0aW1lIHBlcmlvZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkNhbGNTdG9yYWdlRmVlfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkNhbGNTdG9yYWdlRmVlXG4gICAgICovXG4gICAgY2FsY19zdG9yYWdlX2ZlZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ3V0aWxzLmNhbGNfc3RvcmFnZV9mZWUnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wcmVzc2VzIGRhdGEgdXNpbmcgWnN0YW5kYXJkIGFsZ29yaXRobVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkNvbXByZXNzWnN0ZH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZDb21wcmVzc1pzdGRcbiAgICAgKi9cbiAgICBjb21wcmVzc196c3RkKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgndXRpbHMuY29tcHJlc3NfenN0ZCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29tcHJlc3NlcyBkYXRhIHVzaW5nIFpzdGFuZGFyZCBhbGdvcml0aG1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZEZWNvbXByZXNzWnN0ZH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZEZWNvbXByZXNzWnN0ZFxuICAgICAqL1xuICAgIGRlY29tcHJlc3NfenN0ZChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ3V0aWxzLmRlY29tcHJlc3NfenN0ZCcsIHBhcmFtcyk7XG4gICAgfVxufVxuZXhwb3J0cy5VdGlsc01vZHVsZSA9IFV0aWxzTW9kdWxlO1xuLy8gdHZtIG1vZHVsZVxudmFyIFR2bUVycm9yQ29kZTtcbihmdW5jdGlvbiAoVHZtRXJyb3JDb2RlKSB7XG4gICAgVHZtRXJyb3JDb2RlW1R2bUVycm9yQ29kZVtcIkNhbk5vdFJlYWRUcmFuc2FjdGlvblwiXSA9IDQwMV0gPSBcIkNhbk5vdFJlYWRUcmFuc2FjdGlvblwiO1xuICAgIFR2bUVycm9yQ29kZVtUdm1FcnJvckNvZGVbXCJDYW5Ob3RSZWFkQmxvY2tjaGFpbkNvbmZpZ1wiXSA9IDQwMl0gPSBcIkNhbk5vdFJlYWRCbG9ja2NoYWluQ29uZmlnXCI7XG4gICAgVHZtRXJyb3JDb2RlW1R2bUVycm9yQ29kZVtcIlRyYW5zYWN0aW9uQWJvcnRlZFwiXSA9IDQwM10gPSBcIlRyYW5zYWN0aW9uQWJvcnRlZFwiO1xuICAgIFR2bUVycm9yQ29kZVtUdm1FcnJvckNvZGVbXCJJbnRlcm5hbEVycm9yXCJdID0gNDA0XSA9IFwiSW50ZXJuYWxFcnJvclwiO1xuICAgIFR2bUVycm9yQ29kZVtUdm1FcnJvckNvZGVbXCJBY3Rpb25QaGFzZUZhaWxlZFwiXSA9IDQwNV0gPSBcIkFjdGlvblBoYXNlRmFpbGVkXCI7XG4gICAgVHZtRXJyb3JDb2RlW1R2bUVycm9yQ29kZVtcIkFjY291bnRDb2RlTWlzc2luZ1wiXSA9IDQwNl0gPSBcIkFjY291bnRDb2RlTWlzc2luZ1wiO1xuICAgIFR2bUVycm9yQ29kZVtUdm1FcnJvckNvZGVbXCJMb3dCYWxhbmNlXCJdID0gNDA3XSA9IFwiTG93QmFsYW5jZVwiO1xuICAgIFR2bUVycm9yQ29kZVtUdm1FcnJvckNvZGVbXCJBY2NvdW50RnJvemVuT3JEZWxldGVkXCJdID0gNDA4XSA9IFwiQWNjb3VudEZyb3plbk9yRGVsZXRlZFwiO1xuICAgIFR2bUVycm9yQ29kZVtUdm1FcnJvckNvZGVbXCJBY2NvdW50TWlzc2luZ1wiXSA9IDQwOV0gPSBcIkFjY291bnRNaXNzaW5nXCI7XG4gICAgVHZtRXJyb3JDb2RlW1R2bUVycm9yQ29kZVtcIlVua25vd25FeGVjdXRpb25FcnJvclwiXSA9IDQxMF0gPSBcIlVua25vd25FeGVjdXRpb25FcnJvclwiO1xuICAgIFR2bUVycm9yQ29kZVtUdm1FcnJvckNvZGVbXCJJbnZhbGlkSW5wdXRTdGFja1wiXSA9IDQxMV0gPSBcIkludmFsaWRJbnB1dFN0YWNrXCI7XG4gICAgVHZtRXJyb3JDb2RlW1R2bUVycm9yQ29kZVtcIkludmFsaWRBY2NvdW50Qm9jXCJdID0gNDEyXSA9IFwiSW52YWxpZEFjY291bnRCb2NcIjtcbiAgICBUdm1FcnJvckNvZGVbVHZtRXJyb3JDb2RlW1wiSW52YWxpZE1lc3NhZ2VUeXBlXCJdID0gNDEzXSA9IFwiSW52YWxpZE1lc3NhZ2VUeXBlXCI7XG4gICAgVHZtRXJyb3JDb2RlW1R2bUVycm9yQ29kZVtcIkNvbnRyYWN0RXhlY3V0aW9uRXJyb3JcIl0gPSA0MTRdID0gXCJDb250cmFjdEV4ZWN1dGlvbkVycm9yXCI7XG59KShUdm1FcnJvckNvZGUgPSBleHBvcnRzLlR2bUVycm9yQ29kZSB8fCAoZXhwb3J0cy5Udm1FcnJvckNvZGUgPSB7fSkpO1xuZnVuY3Rpb24gYWNjb3VudEZvckV4ZWN1dG9yTm9uZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnTm9uZScsXG4gICAgfTtcbn1cbmV4cG9ydHMuYWNjb3VudEZvckV4ZWN1dG9yTm9uZSA9IGFjY291bnRGb3JFeGVjdXRvck5vbmU7XG5mdW5jdGlvbiBhY2NvdW50Rm9yRXhlY3V0b3JVbmluaXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1VuaW5pdCcsXG4gICAgfTtcbn1cbmV4cG9ydHMuYWNjb3VudEZvckV4ZWN1dG9yVW5pbml0ID0gYWNjb3VudEZvckV4ZWN1dG9yVW5pbml0O1xuZnVuY3Rpb24gYWNjb3VudEZvckV4ZWN1dG9yQWNjb3VudChib2MsIHVubGltaXRlZF9iYWxhbmNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0FjY291bnQnLFxuICAgICAgICBib2MsXG4gICAgICAgIHVubGltaXRlZF9iYWxhbmNlLFxuICAgIH07XG59XG5leHBvcnRzLmFjY291bnRGb3JFeGVjdXRvckFjY291bnQgPSBhY2NvdW50Rm9yRXhlY3V0b3JBY2NvdW50O1xuY2xhc3MgVHZtTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtdWxhdGVzIGFsbCB0aGUgcGhhc2VzIG9mIGNvbnRyYWN0IGV4ZWN1dGlvbiBsb2NhbGx5XG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFBlcmZvcm1zIGFsbCB0aGUgcGhhc2VzIG9mIGNvbnRyYWN0IGV4ZWN1dGlvbiBvbiBUcmFuc2FjdGlvbiBFeGVjdXRvciAtXG4gICAgICogdGhlIHNhbWUgY29tcG9uZW50IHRoYXQgaXMgdXNlZCBvbiBWYWxpZGF0b3IgTm9kZXMuXG4gICAgICpcbiAgICAgKiBDYW4gYmUgdXNlZCBmb3IgY29udHJhY3QgZGVidWdnaW5nLCB0byBmaW5kIG91dCB0aGUgcmVhc29uIHdoeSBhIG1lc3NhZ2Ugd2FzIG5vdCBkZWxpdmVyZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAqIFZhbGlkYXRvcnMgdGhyb3cgYXdheSB0aGUgZmFpbGVkIGV4dGVybmFsIGluYm91bmQgbWVzc2FnZXMgKGlmIHRoZXkgZmFpbGVkIGJlZG9yZSBgQUNDRVBUYCkgaW4gdGhlIHJlYWwgbmV0d29yay5cbiAgICAgKiBUaGlzIGlzIHdoeSB0aGVzZSBtZXNzYWdlcyBhcmUgaW1wb3NzaWJsZSB0byBkZWJ1ZyBpbiB0aGUgcmVhbCBuZXR3b3JrLlxuICAgICAqIFdpdGggdGhlIGhlbHAgb2YgcnVuX2V4ZWN1dG9yIHlvdSBjYW4gZG8gdGhhdC4gSW4gZmFjdCwgYHByb2Nlc3NfbWVzc2FnZWAgZnVuY3Rpb25cbiAgICAgKiBwZXJmb3JtcyBsb2NhbCBjaGVjayB3aXRoIGBydW5fZXhlY3V0b3JgIGlmIHRoZXJlIHdhcyBubyB0cmFuc2FjdGlvbiBhcyBhIHJlc3VsdCBvZiBwcm9jZXNzaW5nXG4gICAgICogYW5kIHJldHVybnMgdGhlIGVycm9yLCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgICpcbiAgICAgKiBBbm90aGVyIHVzZSBjYXNlIHRvIHVzZSBgcnVuX2V4ZWN1dG9yYCBpcyB0byBlc3RpbWF0ZSBmZWVzIGZvciBtZXNzYWdlIGV4ZWN1dGlvbi5cbiAgICAgKiBTZXQgIGBBY2NvdW50Rm9yRXhlY3V0b3I6OkFjY291bnQudW5saW1pdGVkX2JhbGFuY2VgXG4gICAgICogdG8gYHRydWVgIHNvIHRoYXQgZW11bGF0aW9uIHdpbGwgbm90IGRlcGVuZCBvbiB0aGUgYWN0dWFsIGJhbGFuY2UuXG4gICAgICogVGhpcyBtYXkgYmUgbmVlZGVkIHRvIGNhbGN1bGF0ZSBkZXBsb3kgZmVlcyBmb3IgYW4gYWNjb3VudCB0aGF0IGRvZXMgbm90IGV4aXN0IHlldC5cbiAgICAgKiBKU09OIHdpdGggZmVlcyBpcyBpbiBgZmVlc2AgZmllbGQgb2YgdGhlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIE9uZSBtb3JlIHVzZSBjYXNlIC0geW91IGNhbiBwcm9kdWNlIHRoZSBzZXF1ZW5jZSBvZiBvcGVyYXRpb25zLFxuICAgICAqIHRodXMgZW11bGF0aW5nIHRoZSBzZXF1ZW50aWFsIGNvbnRyYWN0IGNhbGxzIGxvY2FsbHkuXG4gICAgICogQW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogVHJhbnNhY3Rpb24gZXhlY3V0b3IgcmVxdWlyZXMgYWNjb3VudCBCT0MgKGJhZyBvZiBjZWxscykgYXMgYSBwYXJhbWV0ZXIuXG4gICAgICogVG8gZ2V0IHRoZSBhY2NvdW50IEJPQyAtIHVzZSBgbmV0LnF1ZXJ5YCBtZXRob2QgdG8gZG93bmxvYWQgaXQgZnJvbSBHcmFwaFFMIEFQSVxuICAgICAqIChmaWVsZCBgYm9jYCBvZiBgYWNjb3VudGApIG9yIGdlbmVyYXRlIGl0IHdpdGggYGFiaS5lbmNvZGVfYWNjb3VudGAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQWxzbyBpdCByZXF1aXJlcyBtZXNzYWdlIEJPQy4gVG8gZ2V0IHRoZSBtZXNzYWdlIEJPQyAtIHVzZSBgYWJpLmVuY29kZV9tZXNzYWdlYCBvciBgYWJpLmVuY29kZV9pbnRlcm5hbF9tZXNzYWdlYC5cbiAgICAgKlxuICAgICAqIElmIHlvdSBuZWVkIHRoaXMgZW11bGF0aW9uIHRvIGJlIGFzIHByZWNpc2UgYXMgcG9zc2libGUgKGZvciBpbnN0YW5jZSAtIGVtdWxhdGUgdHJhbnNhY3Rpb25cbiAgICAgKiB3aXRoIHBhcnRpY3VsYXIgbHQgaW4gcGFydGljdWxhciBibG9jayBvciB1c2UgcGFydGljdWxhciBibG9ja2NoYWluIGNvbmZpZyxcbiAgICAgKiBkb3dubG9hZGVkIGZyb20gYSBwYXJ0aWN1bGFyIGtleSBibG9jayAtIHRoZW4gc3BlY2lmeSBgZXhlY3V0aW9uX29wdGlvbnNgIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIElmIHlvdSBuZWVkIHRvIHNlZSB0aGUgYWJvcnRlZCB0cmFuc2FjdGlvbiBhcyBhIHJlc3VsdCwgbm90IGFzIGFuIGVycm9yLCBzZXQgYHNraXBfdHJhbnNhY3Rpb25fY2hlY2tgIHRvIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZSdW5FeGVjdXRvcn0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZSdW5FeGVjdXRvclxuICAgICAqL1xuICAgIHJ1bl9leGVjdXRvcihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ3R2bS5ydW5fZXhlY3V0b3InLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBnZXQtbWV0aG9kcyBvZiBBQkktY29tcGF0aWJsZSBjb250cmFjdHNcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUGVyZm9ybXMgb25seSBhIHBhcnQgb2YgY29tcHV0ZSBwaGFzZSBvZiB0cmFuc2FjdGlvbiBleGVjdXRpb25cbiAgICAgKiB0aGF0IGlzIHVzZWQgdG8gcnVuIGdldC1tZXRob2RzIG9mIEFCSS1jb21wYXRpYmxlIGNvbnRyYWN0cy5cbiAgICAgKlxuICAgICAqIElmIHlvdSB0cnkgdG8gcnVuIGdldC1tZXRob2RzIHdpdGggYHJ1bl9leGVjdXRvcmAgeW91IHdpbGwgZ2V0IGFuIGVycm9yLCBiZWNhdXNlIGl0IGNoZWNrcyBBQ0NFUFQgYW5kIGV4aXRzXG4gICAgICogaWYgdGhlcmUgaXMgbm9uZSwgd2hpY2ggaXMgYWN0dWFsbHkgdHJ1ZSBmb3IgZ2V0LW1ldGhvZHMuXG4gICAgICpcbiAgICAgKiAgVG8gZ2V0IHRoZSBhY2NvdW50IEJPQyAoYmFnIG9mIGNlbGxzKSAtIHVzZSBgbmV0LnF1ZXJ5YCBtZXRob2QgdG8gZG93bmxvYWQgaXQgZnJvbSBHcmFwaFFMIEFQSVxuICAgICAqIChmaWVsZCBgYm9jYCBvZiBgYWNjb3VudGApIG9yIGdlbmVyYXRlIGl0IHdpdGggYGFiaS5lbmNvZGVfYWNjb3VudCBtZXRob2RgLlxuICAgICAqIFRvIGdldCB0aGUgbWVzc2FnZSBCT0MgLSB1c2UgYGFiaS5lbmNvZGVfbWVzc2FnZWAgb3IgcHJlcGFyZSBpdCBhbnkgb3RoZXIgd2F5LCBmb3IgaW5zdGFuY2UsIHdpdGggRklGVCBzY3JpcHQuXG4gICAgICpcbiAgICAgKiBBdHRlbnRpb24hIFVwZGF0ZWQgYWNjb3VudCBzdGF0ZSBpcyBwcm9kdWNlcyBhcyB3ZWxsLCBidXQgb25seVxuICAgICAqIGBhY2NvdW50X3N0YXRlLnN0b3JhZ2Uuc3RhdGUuZGF0YWAgIHBhcnQgb2YgdGhlIEJPQyBpcyB1cGRhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlJ1blR2bX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZSdW5Udm1cbiAgICAgKi9cbiAgICBydW5fdHZtKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgndHZtLnJ1bl90dm0nLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBhIGdldC1tZXRob2Qgb2YgRklGVCBjb250cmFjdFxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBFeGVjdXRlcyBhIGdldC1tZXRob2Qgb2YgRklGVCBjb250cmFjdCB0aGF0IGZ1bGZpbGxzIHRoZSBzbWMtZ3VpZGVsaW5lcyBodHRwczovL3Rlc3QudG9uLm9yZy9zbWMtZ3VpZGVsaW5lcy50eHRcbiAgICAgKiBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGRhdGEgZnJvbSBUVk0ncyBzdGFja1xuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlJ1bkdldH0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZSdW5HZXRcbiAgICAgKi9cbiAgICBydW5fZ2V0KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgndHZtLnJ1bl9nZXQnLCBwYXJhbXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHZtTW9kdWxlID0gVHZtTW9kdWxlO1xuLy8gbmV0IG1vZHVsZVxudmFyIE5ldEVycm9yQ29kZTtcbihmdW5jdGlvbiAoTmV0RXJyb3JDb2RlKSB7XG4gICAgTmV0RXJyb3JDb2RlW05ldEVycm9yQ29kZVtcIlF1ZXJ5RmFpbGVkXCJdID0gNjAxXSA9IFwiUXVlcnlGYWlsZWRcIjtcbiAgICBOZXRFcnJvckNvZGVbTmV0RXJyb3JDb2RlW1wiU3Vic2NyaWJlRmFpbGVkXCJdID0gNjAyXSA9IFwiU3Vic2NyaWJlRmFpbGVkXCI7XG4gICAgTmV0RXJyb3JDb2RlW05ldEVycm9yQ29kZVtcIldhaXRGb3JGYWlsZWRcIl0gPSA2MDNdID0gXCJXYWl0Rm9yRmFpbGVkXCI7XG4gICAgTmV0RXJyb3JDb2RlW05ldEVycm9yQ29kZVtcIkdldFN1YnNjcmlwdGlvblJlc3VsdEZhaWxlZFwiXSA9IDYwNF0gPSBcIkdldFN1YnNjcmlwdGlvblJlc3VsdEZhaWxlZFwiO1xuICAgIE5ldEVycm9yQ29kZVtOZXRFcnJvckNvZGVbXCJJbnZhbGlkU2VydmVyUmVzcG9uc2VcIl0gPSA2MDVdID0gXCJJbnZhbGlkU2VydmVyUmVzcG9uc2VcIjtcbiAgICBOZXRFcnJvckNvZGVbTmV0RXJyb3JDb2RlW1wiQ2xvY2tPdXRPZlN5bmNcIl0gPSA2MDZdID0gXCJDbG9ja091dE9mU3luY1wiO1xuICAgIE5ldEVycm9yQ29kZVtOZXRFcnJvckNvZGVbXCJXYWl0Rm9yVGltZW91dFwiXSA9IDYwN10gPSBcIldhaXRGb3JUaW1lb3V0XCI7XG4gICAgTmV0RXJyb3JDb2RlW05ldEVycm9yQ29kZVtcIkdyYXBocWxFcnJvclwiXSA9IDYwOF0gPSBcIkdyYXBocWxFcnJvclwiO1xuICAgIE5ldEVycm9yQ29kZVtOZXRFcnJvckNvZGVbXCJOZXR3b3JrTW9kdWxlU3VzcGVuZGVkXCJdID0gNjA5XSA9IFwiTmV0d29ya01vZHVsZVN1c3BlbmRlZFwiO1xuICAgIE5ldEVycm9yQ29kZVtOZXRFcnJvckNvZGVbXCJXZWJzb2NrZXREaXNjb25uZWN0ZWRcIl0gPSA2MTBdID0gXCJXZWJzb2NrZXREaXNjb25uZWN0ZWRcIjtcbiAgICBOZXRFcnJvckNvZGVbTmV0RXJyb3JDb2RlW1wiTm90U3VwcG9ydGVkXCJdID0gNjExXSA9IFwiTm90U3VwcG9ydGVkXCI7XG4gICAgTmV0RXJyb3JDb2RlW05ldEVycm9yQ29kZVtcIk5vRW5kcG9pbnRzUHJvdmlkZWRcIl0gPSA2MTJdID0gXCJOb0VuZHBvaW50c1Byb3ZpZGVkXCI7XG4gICAgTmV0RXJyb3JDb2RlW05ldEVycm9yQ29kZVtcIkdyYXBocWxXZWJzb2NrZXRJbml0RXJyb3JcIl0gPSA2MTNdID0gXCJHcmFwaHFsV2Vic29ja2V0SW5pdEVycm9yXCI7XG4gICAgTmV0RXJyb3JDb2RlW05ldEVycm9yQ29kZVtcIk5ldHdvcmtNb2R1bGVSZXN1bWVkXCJdID0gNjE0XSA9IFwiTmV0d29ya01vZHVsZVJlc3VtZWRcIjtcbiAgICBOZXRFcnJvckNvZGVbTmV0RXJyb3JDb2RlW1wiVW5hdXRob3JpemVkXCJdID0gNjE1XSA9IFwiVW5hdXRob3JpemVkXCI7XG59KShOZXRFcnJvckNvZGUgPSBleHBvcnRzLk5ldEVycm9yQ29kZSB8fCAoZXhwb3J0cy5OZXRFcnJvckNvZGUgPSB7fSkpO1xudmFyIFNvcnREaXJlY3Rpb247XG4oZnVuY3Rpb24gKFNvcnREaXJlY3Rpb24pIHtcbiAgICBTb3J0RGlyZWN0aW9uW1wiQVNDXCJdID0gXCJBU0NcIjtcbiAgICBTb3J0RGlyZWN0aW9uW1wiREVTQ1wiXSA9IFwiREVTQ1wiO1xufSkoU29ydERpcmVjdGlvbiA9IGV4cG9ydHMuU29ydERpcmVjdGlvbiB8fCAoZXhwb3J0cy5Tb3J0RGlyZWN0aW9uID0ge30pKTtcbmZ1bmN0aW9uIHBhcmFtc09mUXVlcnlPcGVyYXRpb25RdWVyeUNvbGxlY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnUXVlcnlDb2xsZWN0aW9uJyB9LCBwYXJhbXMpO1xufVxuZXhwb3J0cy5wYXJhbXNPZlF1ZXJ5T3BlcmF0aW9uUXVlcnlDb2xsZWN0aW9uID0gcGFyYW1zT2ZRdWVyeU9wZXJhdGlvblF1ZXJ5Q29sbGVjdGlvbjtcbmZ1bmN0aW9uIHBhcmFtc09mUXVlcnlPcGVyYXRpb25XYWl0Rm9yQ29sbGVjdGlvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdXYWl0Rm9yQ29sbGVjdGlvbicgfSwgcGFyYW1zKTtcbn1cbmV4cG9ydHMucGFyYW1zT2ZRdWVyeU9wZXJhdGlvbldhaXRGb3JDb2xsZWN0aW9uID0gcGFyYW1zT2ZRdWVyeU9wZXJhdGlvbldhaXRGb3JDb2xsZWN0aW9uO1xuZnVuY3Rpb24gcGFyYW1zT2ZRdWVyeU9wZXJhdGlvbkFnZ3JlZ2F0ZUNvbGxlY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnQWdncmVnYXRlQ29sbGVjdGlvbicgfSwgcGFyYW1zKTtcbn1cbmV4cG9ydHMucGFyYW1zT2ZRdWVyeU9wZXJhdGlvbkFnZ3JlZ2F0ZUNvbGxlY3Rpb24gPSBwYXJhbXNPZlF1ZXJ5T3BlcmF0aW9uQWdncmVnYXRlQ29sbGVjdGlvbjtcbmZ1bmN0aW9uIHBhcmFtc09mUXVlcnlPcGVyYXRpb25RdWVyeUNvdW50ZXJwYXJ0aWVzKHBhcmFtcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgdHlwZTogJ1F1ZXJ5Q291bnRlcnBhcnRpZXMnIH0sIHBhcmFtcyk7XG59XG5leHBvcnRzLnBhcmFtc09mUXVlcnlPcGVyYXRpb25RdWVyeUNvdW50ZXJwYXJ0aWVzID0gcGFyYW1zT2ZRdWVyeU9wZXJhdGlvblF1ZXJ5Q291bnRlcnBhcnRpZXM7XG52YXIgQWdncmVnYXRpb25GbjtcbihmdW5jdGlvbiAoQWdncmVnYXRpb25Gbikge1xuICAgIEFnZ3JlZ2F0aW9uRm5bXCJDT1VOVFwiXSA9IFwiQ09VTlRcIjtcbiAgICBBZ2dyZWdhdGlvbkZuW1wiTUlOXCJdID0gXCJNSU5cIjtcbiAgICBBZ2dyZWdhdGlvbkZuW1wiTUFYXCJdID0gXCJNQVhcIjtcbiAgICBBZ2dyZWdhdGlvbkZuW1wiU1VNXCJdID0gXCJTVU1cIjtcbiAgICBBZ2dyZWdhdGlvbkZuW1wiQVZFUkFHRVwiXSA9IFwiQVZFUkFHRVwiO1xufSkoQWdncmVnYXRpb25GbiA9IGV4cG9ydHMuQWdncmVnYXRpb25GbiB8fCAoZXhwb3J0cy5BZ2dyZWdhdGlvbkZuID0ge30pKTtcbi8qKlxuICogTmV0d29yayBhY2Nlc3MuXG4gKi9cbmNsYXNzIE5ldE1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBEQXBwU2VydmVyIEdyYXBoUUwgcXVlcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mUXVlcnl9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mUXVlcnlcbiAgICAgKi9cbiAgICBxdWVyeShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC5xdWVyeScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIG11bHRpcGxlIHF1ZXJpZXMgcGVyIHNpbmdsZSBmZXRjaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZCYXRjaFF1ZXJ5fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkJhdGNoUXVlcnlcbiAgICAgKi9cbiAgICBiYXRjaF9xdWVyeShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC5iYXRjaF9xdWVyeScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJpZXMgY29sbGVjdGlvbiBkYXRhXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFF1ZXJpZXMgZGF0YSB0aGF0IHNhdGlzZmllcyB0aGUgYGZpbHRlcmAgY29uZGl0aW9ucyxcbiAgICAgKiBsaW1pdHMgdGhlIG51bWJlciBvZiByZXR1cm5lZCByZWNvcmRzIGFuZCBvcmRlcnMgdGhlbS5cbiAgICAgKiBUaGUgcHJvamVjdGlvbiBmaWVsZHMgYXJlIGxpbWl0ZWQgdG8gYHJlc3VsdGAgZmllbGRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mUXVlcnlDb2xsZWN0aW9ufSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZlF1ZXJ5Q29sbGVjdGlvblxuICAgICAqL1xuICAgIHF1ZXJ5X2NvbGxlY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCduZXQucXVlcnlfY29sbGVjdGlvbicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFnZ3JlZ2F0ZXMgY29sbGVjdGlvbiBkYXRhLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBBZ2dyZWdhdGVzIHZhbHVlcyBmcm9tIHRoZSBzcGVjaWZpZWQgYGZpZWxkc2AgZm9yIHJlY29yZHNcbiAgICAgKiB0aGF0IHNhdGlzZmllcyB0aGUgYGZpbHRlcmAgY29uZGl0aW9ucyxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZBZ2dyZWdhdGVDb2xsZWN0aW9ufSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkFnZ3JlZ2F0ZUNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICBhZ2dyZWdhdGVfY29sbGVjdGlvbihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC5hZ2dyZWdhdGVfY29sbGVjdGlvbicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgZnVsZmlsbHMgdGhlIGNvbmRpdGlvbnMgb3Igd2FpdHMgZm9yIGl0cyBhcHBlYXJhbmNlXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRyaWdnZXJzIG9ubHkgb25jZS5cbiAgICAgKiBJZiBvYmplY3QgdGhhdCBzYXRpc2ZpZXMgdGhlIGBmaWx0ZXJgIGNvbmRpdGlvbnNcbiAgICAgKiBhbHJlYWR5IGV4aXN0cyAtIHJldHVybnMgaXQgaW1tZWRpYXRlbHkuXG4gICAgICogSWYgbm90IC0gd2FpdHMgZm9yIGluc2VydC91cGRhdGUgb2YgZGF0YSB3aXRoaW4gdGhlIHNwZWNpZmllZCBgdGltZW91dGAsXG4gICAgICogYW5kIHJldHVybnMgaXQuXG4gICAgICogVGhlIHByb2plY3Rpb24gZmllbGRzIGFyZSBsaW1pdGVkIHRvIGByZXN1bHRgIGZpZWxkc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZldhaXRGb3JDb2xsZWN0aW9ufSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZldhaXRGb3JDb2xsZWN0aW9uXG4gICAgICovXG4gICAgd2FpdF9mb3JfY29sbGVjdGlvbihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC53YWl0X2Zvcl9jb2xsZWN0aW9uJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhIHN1YnNjcmlwdGlvblxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBDYW5jZWxzIGEgc3Vic2NyaXB0aW9uIHNwZWNpZmllZCBieSBpdHMgaGFuZGxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZXN1bHRPZlN1YnNjcmliZUNvbGxlY3Rpb259IHBhcmFtc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCduZXQudW5zdWJzY3JpYmUnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29sbGVjdGlvbiBzdWJzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVHJpZ2dlcnMgZm9yIGVhY2ggaW5zZXJ0L3VwZGF0ZSBvZiBkYXRhIHRoYXQgc2F0aXNmaWVzXG4gICAgICogdGhlIGBmaWx0ZXJgIGNvbmRpdGlvbnMuXG4gICAgICogVGhlIHByb2plY3Rpb24gZmllbGRzIGFyZSBsaW1pdGVkIHRvIGByZXN1bHRgIGZpZWxkcy5cbiAgICAgKlxuICAgICAqIFRoZSBzdWJzY3JpcHRpb24gaXMgYSBwZXJzaXN0ZW50IGNvbW11bmljYXRpb24gY2hhbm5lbCBiZXR3ZWVuXG4gICAgICogY2xpZW50IGFuZCBGcmVlIFRPTiBOZXR3b3JrLlxuICAgICAqIEFsbCBjaGFuZ2VzIGluIHRoZSBibG9ja2NoYWluIHdpbGwgYmUgcmVmbGVjdGVkIGluIHJlYWx0aW1lLlxuICAgICAqIENoYW5nZXMgbWVhbnMgaW5zZXJ0cyBhbmQgdXBkYXRlcyBvZiB0aGUgYmxvY2tjaGFpbiBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqICMjIyBJbXBvcnRhbnQgTm90ZXMgb24gU3Vic2NyaXB0aW9uc1xuICAgICAqXG4gICAgICogVW5mb3J0dW5hdGVseSBzb21ldGltZXMgdGhlIGNvbm5lY3Rpb24gd2l0aCB0aGUgbmV0d29yayBicmFrZXMgZG93bi5cbiAgICAgKiBJbiB0aGlzIHNpdHVhdGlvbiB0aGUgbGlicmFyeSBhdHRlbXB0cyB0byByZWNvbm5lY3QgdG8gdGhlIG5ldHdvcmsuXG4gICAgICogVGhpcyByZWNvbm5lY3Rpb24gc2VxdWVuY2UgY2FuIHRha2Ugc2lnbmlmaWNhbnQgdGltZS5cbiAgICAgKiBBbGwgb2YgdGhpcyB0aW1lIHRoZSBjbGllbnQgaXMgZGlzY29ubmVjdGVkIGZyb20gdGhlIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBCYWQgbmV3cyBpcyB0aGF0IGFsbCBibG9ja2NoYWluIGNoYW5nZXMgdGhhdCBoYXBwZW5lZCB3aGlsZVxuICAgICAqIHRoZSBjbGllbnQgd2FzIGRpc2Nvbm5lY3RlZCBhcmUgbG9zdC5cbiAgICAgKlxuICAgICAqIEdvb2QgbmV3cyBpcyB0aGF0IHRoZSBjbGllbnQgcmVwb3J0IGVycm9ycyB0byB0aGUgY2FsbGJhY2sgd2hlblxuICAgICAqIGl0IGxvc2VzIGFuZCByZXN1bWVzIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBTbywgaWYgdGhlIGxvc3QgY2hhbmdlcyBhcmUgaW1wb3J0YW50IHRvIHRoZSBhcHBsaWNhdGlvbiB0aGVuXG4gICAgICogdGhlIGFwcGxpY2F0aW9uIG11c3QgaGFuZGxlIHRoZXNlIGVycm9yIHJlcG9ydHMuXG4gICAgICpcbiAgICAgKiBMaWJyYXJ5IHJlcG9ydHMgZXJyb3JzIHdpdGggYHJlc3BvbnNlVHlwZWAgPT0gMTAxXG4gICAgICogYW5kIHRoZSBlcnJvciBvYmplY3QgcGFzc2VkIHZpYSBgcGFyYW1zYC5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIGxpYnJhcnkgaGFzIHN1Y2Nlc3NmdWxseSByZWNvbm5lY3RlZFxuICAgICAqIHRoZSBhcHBsaWNhdGlvbiByZWNlaXZlcyBjYWxsYmFjayB3aXRoXG4gICAgICogYHJlc3BvbnNlVHlwZWAgPT0gMTAxIGFuZCBgcGFyYW1zLmNvZGVgID09IDYxNCAoTmV0d29ya01vZHVsZVJlc3VtZWQpLlxuICAgICAqXG4gICAgICogQXBwbGljYXRpb24gY2FuIHVzZSBzZXZlcmFsIHdheXMgdG8gaGFuZGxlIHRoaXMgc2l0dWF0aW9uOlxuICAgICAqIC0gSWYgYXBwbGljYXRpb24gbW9uaXRvcnMgY2hhbmdlcyBmb3IgdGhlIHNpbmdsZSBibG9ja2NoYWluXG4gICAgICogb2JqZWN0IChmb3IgZXhhbXBsZSBzcGVjaWZpYyBhY2NvdW50KTogIGFwcGxpY2F0aW9uXG4gICAgICogY2FuIHBlcmZvcm0gYSBxdWVyeSBmb3IgdGhpcyBvYmplY3QgYW5kIGhhbmRsZSBhY3R1YWwgZGF0YSBhcyBhXG4gICAgICogcmVndWxhciBkYXRhIGZyb20gdGhlIHN1YnNjcmlwdGlvbi5cbiAgICAgKiAtIElmIGFwcGxpY2F0aW9uIG1vbml0b3JzIHNlcXVlbmNlIG9mIHNvbWUgYmxvY2tjaGFpbiBvYmplY3RzXG4gICAgICogKGZvciBleGFtcGxlIHRyYW5zYWN0aW9ucyBvZiB0aGUgc3BlY2lmaWMgYWNjb3VudCk6IGFwcGxpY2F0aW9uIG11c3RcbiAgICAgKiByZWZyZXNoIGFsbCBjYWNoZWQgKG9yIHZpc2libGUgdG8gdXNlcikgbGlzdHMgd2hlcmUgdGhpcyBzZXF1ZW5jZXMgcHJlc2VudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mU3Vic2NyaWJlQ29sbGVjdGlvbn0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZTdWJzY3JpYmVDb2xsZWN0aW9uXG4gICAgICovXG4gICAgc3Vic2NyaWJlX2NvbGxlY3Rpb24ocGFyYW1zLCByZXNwb25zZUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC5zdWJzY3JpYmVfY29sbGVjdGlvbicsIHBhcmFtcywgcmVzcG9uc2VIYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN1YnNjcmlwdGlvblxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgc3Vic2NyaXB0aW9uIGlzIGEgcGVyc2lzdGVudCBjb21tdW5pY2F0aW9uIGNoYW5uZWwgYmV0d2VlblxuICAgICAqIGNsaWVudCBhbmQgRXZlcnNjYWxlIE5ldHdvcmsuXG4gICAgICpcbiAgICAgKiAjIyMgSW1wb3J0YW50IE5vdGVzIG9uIFN1YnNjcmlwdGlvbnNcbiAgICAgKlxuICAgICAqIFVuZm9ydHVuYXRlbHkgc29tZXRpbWVzIHRoZSBjb25uZWN0aW9uIHdpdGggdGhlIG5ldHdvcmsgYnJlYWtlcyBkb3duLlxuICAgICAqIEluIHRoaXMgc2l0dWF0aW9uIHRoZSBsaWJyYXJ5IGF0dGVtcHRzIHRvIHJlY29ubmVjdCB0byB0aGUgbmV0d29yay5cbiAgICAgKiBUaGlzIHJlY29ubmVjdGlvbiBzZXF1ZW5jZSBjYW4gdGFrZSBzaWduaWZpY2FudCB0aW1lLlxuICAgICAqIEFsbCBvZiB0aGlzIHRpbWUgdGhlIGNsaWVudCBpcyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEJhZCBuZXdzIGlzIHRoYXQgYWxsIGNoYW5nZXMgdGhhdCBoYXBwZW5lZCB3aGlsZVxuICAgICAqIHRoZSBjbGllbnQgd2FzIGRpc2Nvbm5lY3RlZCBhcmUgbG9zdC5cbiAgICAgKlxuICAgICAqIEdvb2QgbmV3cyBpcyB0aGF0IHRoZSBjbGllbnQgcmVwb3J0IGVycm9ycyB0byB0aGUgY2FsbGJhY2sgd2hlblxuICAgICAqIGl0IGxvc2VzIGFuZCByZXN1bWVzIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBTbywgaWYgdGhlIGxvc3QgY2hhbmdlcyBhcmUgaW1wb3J0YW50IHRvIHRoZSBhcHBsaWNhdGlvbiB0aGVuXG4gICAgICogdGhlIGFwcGxpY2F0aW9uIG11c3QgaGFuZGxlIHRoZXNlIGVycm9yIHJlcG9ydHMuXG4gICAgICpcbiAgICAgKiBMaWJyYXJ5IHJlcG9ydHMgZXJyb3JzIHdpdGggYHJlc3BvbnNlVHlwZWAgPT0gMTAxXG4gICAgICogYW5kIHRoZSBlcnJvciBvYmplY3QgcGFzc2VkIHZpYSBgcGFyYW1zYC5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIGxpYnJhcnkgaGFzIHN1Y2Nlc3NmdWxseSByZWNvbm5lY3RlZFxuICAgICAqIHRoZSBhcHBsaWNhdGlvbiByZWNlaXZlcyBjYWxsYmFjayB3aXRoXG4gICAgICogYHJlc3BvbnNlVHlwZWAgPT0gMTAxIGFuZCBgcGFyYW1zLmNvZGVgID09IDYxNCAoTmV0d29ya01vZHVsZVJlc3VtZWQpLlxuICAgICAqXG4gICAgICogQXBwbGljYXRpb24gY2FuIHVzZSBzZXZlcmFsIHdheXMgdG8gaGFuZGxlIHRoaXMgc2l0dWF0aW9uOlxuICAgICAqIC0gSWYgYXBwbGljYXRpb24gbW9uaXRvcnMgY2hhbmdlcyBmb3IgdGhlIHNpbmdsZVxuICAgICAqIG9iamVjdCAoZm9yIGV4YW1wbGUgc3BlY2lmaWMgYWNjb3VudCk6ICBhcHBsaWNhdGlvblxuICAgICAqIGNhbiBwZXJmb3JtIGEgcXVlcnkgZm9yIHRoaXMgb2JqZWN0IGFuZCBoYW5kbGUgYWN0dWFsIGRhdGEgYXMgYVxuICAgICAqIHJlZ3VsYXIgZGF0YSBmcm9tIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICogLSBJZiBhcHBsaWNhdGlvbiBtb25pdG9ycyBzZXF1ZW5jZSBvZiBzb21lIG9iamVjdHNcbiAgICAgKiAoZm9yIGV4YW1wbGUgdHJhbnNhY3Rpb25zIG9mIHRoZSBzcGVjaWZpYyBhY2NvdW50KTogYXBwbGljYXRpb24gbXVzdFxuICAgICAqIHJlZnJlc2ggYWxsIGNhY2hlZCAob3IgdmlzaWJsZSB0byB1c2VyKSBsaXN0cyB3aGVyZSB0aGlzIHNlcXVlbmNlcyBwcmVzZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZTdWJzY3JpYmV9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mU3Vic2NyaWJlQ29sbGVjdGlvblxuICAgICAqL1xuICAgIHN1YnNjcmliZShwYXJhbXMsIHJlc3BvbnNlSGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnbmV0LnN1YnNjcmliZScsIHBhcmFtcywgcmVzcG9uc2VIYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VzcGVuZHMgbmV0d29yayBtb2R1bGUgdG8gc3RvcCBhbnkgbmV0d29yayBhY3Rpdml0eVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc3VzcGVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC5zdXNwZW5kJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgbmV0d29yayBtb2R1bGUgdG8gZW5hYmxlIG5ldHdvcmsgYWN0aXZpdHlcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC5yZXN1bWUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBJRCBvZiB0aGUgbGFzdCBibG9jayBpbiBhIHNwZWNpZmllZCBhY2NvdW50IHNoYXJkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mRmluZExhc3RTaGFyZEJsb2NrfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkZpbmRMYXN0U2hhcmRCbG9ja1xuICAgICAqL1xuICAgIGZpbmRfbGFzdF9zaGFyZF9ibG9jayhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC5maW5kX2xhc3Rfc2hhcmRfYmxvY2snLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyB0aGUgbGlzdCBvZiBhbHRlcm5hdGl2ZSBlbmRwb2ludHMgZnJvbSBzZXJ2ZXJcbiAgICAgKiBAcmV0dXJucyBFbmRwb2ludHNTZXRcbiAgICAgKi9cbiAgICBmZXRjaF9lbmRwb2ludHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCduZXQuZmV0Y2hfZW5kcG9pbnRzJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxpc3Qgb2YgZW5kcG9pbnRzIHRvIHVzZSBvbiByZWluaXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RW5kcG9pbnRzU2V0fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHNldF9lbmRwb2ludHMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCduZXQuc2V0X2VuZHBvaW50cycsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIHRoZSBsaXN0IG9mIGFsdGVybmF0aXZlIGVuZHBvaW50cyBmcm9tIHNlcnZlclxuICAgICAqIEByZXR1cm5zIFJlc3VsdE9mR2V0RW5kcG9pbnRzXG4gICAgICovXG4gICAgZ2V0X2VuZHBvaW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC5nZXRfZW5kcG9pbnRzJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0byBxdWVyeSBhbmQgcGFnaW5hdGUgdGhyb3VnaCB0aGUgbGlzdCBvZiBhY2NvdW50cyB0aGF0IHRoZSBzcGVjaWZpZWQgYWNjb3VudCBoYXMgaW50ZXJhY3RlZCB3aXRoLCBzb3J0ZWQgYnkgdGhlIHRpbWUgb2YgdGhlIGxhc3QgaW50ZXJuYWwgbWVzc2FnZSBiZXR3ZWVuIGFjY291bnRzXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqICpBdHRlbnRpb24qIHRoaXMgcXVlcnkgcmV0cmlldmVzIGRhdGEgZnJvbSAnQ291bnRlcnBhcnRpZXMnIHNlcnZpY2Ugd2hpY2ggaXMgbm90IHN1cHBvcnRlZCBpblxuICAgICAqIHRoZSBvcGVuc291cmNlIHZlcnNpb24gb2YgREFwcCBTZXJ2ZXIgKGFuZCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQpIGFzIHdlbGwgYXMgaW4gRXZlcm5vZGUgU0UgKHdpbGwgYmUgc3VwcG9ydGVkIGluIFNFIGluIGZ1dHVyZSksXG4gICAgICogYnV0IGlzIGFsd2F5cyBhY2Nlc3NpYmxlIHZpYSBbRVZFUiBPUyBDbG91ZHNdKC4uL3Rvbi1vcy1hcGkvbmV0d29ya3MubWQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mUXVlcnlDb3VudGVycGFydGllc30gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZRdWVyeUNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICBxdWVyeV9jb3VudGVycGFydGllcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC5xdWVyeV9jb3VudGVycGFydGllcycsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0cmVlIG9mIHRyYW5zYWN0aW9ucyB0cmlnZ2VyZWQgYnkgYSBzcGVjaWZpYyBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBQZXJmb3JtcyByZWN1cnNpdmUgcmV0cmlldmFsIG9mIGEgdHJhbnNhY3Rpb25zIHRyZWUgcHJvZHVjZWQgYnkgYSBzcGVjaWZpYyBtZXNzYWdlOlxuICAgICAqIGluX21zZyAtPiBkc3RfdHJhbnNhY3Rpb24gLT4gb3V0X21lc3NhZ2VzIC0+IGRzdF90cmFuc2FjdGlvbiAtPiAuLi5cbiAgICAgKiBJZiB0aGUgY2hhaW4gb2YgdHJhbnNhY3Rpb25zIGV4ZWN1dGlvbiBpcyBpbiBwcm9ncmVzcyB3aGlsZSB0aGUgZnVuY3Rpb24gaXMgcnVubmluZyxcbiAgICAgKiBpdCB3aWxsIHdhaXQgZm9yIHRoZSBuZXh0IHRyYW5zYWN0aW9ucyB0byBhcHBlYXIgdW50aWwgdGhlIGZ1bGwgdHJlZSBvciBtb3JlIHRoYW4gNTAgdHJhbnNhY3Rpb25zXG4gICAgICogYXJlIHJlY2VpdmVkLlxuICAgICAqXG4gICAgICogQWxsIHRoZSByZXRyaWV2ZWQgbWVzc2FnZXMgYW5kIHRyYW5zYWN0aW9ucyBhcmUgaW5jbHVkZWRcbiAgICAgKiBpbnRvIGByZXN1bHQubWVzc2FnZXNgIGFuZCBgcmVzdWx0LnRyYW5zYWN0aW9uc2AgcmVzcGVjdGl2ZWx5LlxuICAgICAqXG4gICAgICogRnVuY3Rpb24gcmVhZHMgdHJhbnNhY3Rpb25zIGxheWVyIGJ5IGxheWVyLCBieSBwYWdlcyBvZiAyMCB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiBUaGUgcmV0cmlldmFsIHByb3Nlc3MgZ29lcyBsaWtlIHRoaXM6XG4gICAgICogTGV0J3MgYXNzdW1lIHdlIGhhdmUgYW4gaW5maW5pdGUgY2hhaW4gb2YgdHJhbnNhY3Rpb25zIGFuZCBlYWNoIHRyYW5zYWN0aW9uIGdlbmVyYXRlcyA1IG1lc3NhZ2VzLlxuICAgICAqIDEuIFJldHJpZXZlIDFzdCBtZXNzYWdlIChpbnB1dCBwYXJhbWV0ZXIpIGFuZCBjb3JyZXNwb25kaW5nIHRyYW5zYWN0aW9uIC0gcHV0IGl0IGludG8gcmVzdWx0LlxuICAgICAqIEl0IGlzIHRoZSBmaXJzdCBsZXZlbCBvZiB0aGUgdHJlZSBvZiB0cmFuc2FjdGlvbnMgLSBpdHMgcm9vdC5cbiAgICAgKiBSZXRyaWV2ZSA1IG91dCBtZXNzYWdlIGlkcyBmcm9tIHRoZSB0cmFuc2FjdGlvbiBmb3IgbmV4dCBzdGVwcy5cbiAgICAgKiAyLiBSZXRyaWV2ZSA1IG1lc3NhZ2VzIGFuZCBjb3JyZXNwb25kaW5nIHRyYW5zYWN0aW9ucyBvbiB0aGUgMm5kIGxheWVyLiBQdXQgdGhlbSBpbnRvIHJlc3VsdC5cbiAgICAgKiBSZXRyaWV2ZSA1KjUgb3V0IG1lc3NhZ2UgaWRzIGZyb20gdGhlc2UgdHJhbnNhY3Rpb25zIGZvciBuZXh0IHN0ZXBzXG4gICAgICogMy4gUmV0cmlldmUgMjAgKHNpemUgb2YgdGhlIHBhZ2UpIG1lc3NhZ2VzIGFuZCB0cmFuc2FjdGlvbnMgKDNyZCBsYXllcikgYW5kIDIwKjU9MTAwIG1lc3NhZ2UgaWRzICg0dGggbGF5ZXIpLlxuICAgICAqIDQuIFJldHJpZXZlIHRoZSBsYXN0IDUgbWVzc2FnZXMgYW5kIDUgdHJhbnNhY3Rpb25zIG9uIHRoZSAzcmQgbGF5ZXIgKyAxNSBtZXNzYWdlcyBhbmQgdHJhbnNhY3Rpb25zIChvZiAxMDApIGZyb20gdGhlIDR0aCBsYXllclxuICAgICAqICsgMjUgbWVzc2FnZSBpZHMgb2YgdGhlIDR0aCBsYXllciArIDc1IG1lc3NhZ2UgaWRzIG9mIHRoZSA1dGggbGF5ZXIuXG4gICAgICogNS4gUmV0cmlldmUgMjAgbW9yZSBtZXNzYWdlcyBhbmQgMjAgbW9yZSB0cmFuc2FjdGlvbnMgb2YgdGhlIDR0aCBsYXllciArIDEwMCBtb3JlIG1lc3NhZ2UgaWRzIG9mIHRoZSA1dGggbGF5ZXIuXG4gICAgICogNi4gTm93IHdlIGhhdmUgMSs1KzIwKzIwKzIwID0gNjYgdHJhbnNhY3Rpb25zLCB3aGljaCBpcyBtb3JlIHRoYW4gNTAuIEZ1bmN0aW9uIGV4aXRzIHdpdGggdGhlIHRyZWUgb2ZcbiAgICAgKiAxbS0+MXQtPjVtLT41dC0+MjVtLT4yNXQtPjM1bS0+MzV0LiBJZiB3ZSBzZWUgYW55IG1lc3NhZ2UgaWRzIGluIHRoZSBsYXN0IHRyYW5zYWN0aW9ucyBvdXRfbXNncywgd2hpY2ggZG9uJ3QgaGF2ZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgbWVzc2FnZXMgaW4gdGhlIGZ1bmN0aW9uIHJlc3VsdCwgaXQgbWVhbnMgdGhhdCB0aGUgZnVsbCB0cmVlIHdhcyBub3QgcmVjZWl2ZWQgYW5kIHdlIG5lZWQgdG8gY29udGludWUgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogVG8gc3VtbWFyaXplLCBpdCBpcyBndWFyYW50ZWVkIHRoYXQgZWFjaCBtZXNzYWdlIGluIGByZXN1bHQubWVzc2FnZXNgIGhhcyB0aGUgY29ycmVzcG9uZGluZyB0cmFuc2FjdGlvblxuICAgICAqIGluIHRoZSBgcmVzdWx0LnRyYW5zYWN0aW9uc2AuXG4gICAgICogQnV0IHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGFsbCBtZXNzYWdlcyBmcm9tIHRyYW5zYWN0aW9ucyBgb3V0X21zZ3NgIGFyZVxuICAgICAqIHByZXNlbnRlZCBpbiBgcmVzdWx0Lm1lc3NhZ2VzYC5cbiAgICAgKiBTbyB0aGUgYXBwbGljYXRpb24gaGFzIHRvIGNvbnRpbnVlIHJldHJpZXZhbCBmb3IgbWlzc2luZyBtZXNzYWdlcyBpZiBpdCByZXF1aXJlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZRdWVyeVRyYW5zYWN0aW9uVHJlZX0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVzdWx0T2ZRdWVyeVRyYW5zYWN0aW9uVHJlZVxuICAgICAqL1xuICAgIHF1ZXJ5X3RyYW5zYWN0aW9uX3RyZWUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCduZXQucXVlcnlfdHJhbnNhY3Rpb25fdHJlZScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYmxvY2sgaXRlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEJsb2NrIGl0ZXJhdG9yIHVzZXMgcm9idXN0IGl0ZXJhdGlvbiBtZXRob2RzIHRoYXQgZ3VhcmFudGllcyB0aGF0IGV2ZXJ5XG4gICAgICogYmxvY2sgaW4gdGhlIHNwZWNpZmllZCByYW5nZSBpc24ndCBtaXNzZWQgb3IgaXRlcmF0ZWQgdHdpY2UuXG4gICAgICpcbiAgICAgKiBJdGVyYXRlZCByYW5nZSBjYW4gYmUgcmVkdWNlZCB3aXRoIHNvbWUgZmlsdGVyczpcbiAgICAgKiAtIGBzdGFydF90aW1lYCDigJMgdGhlIGJvdHRvbSB0aW1lIHJhbmdlLiBPbmx5IGJsb2NrcyB3aXRoIGBnZW5fdXRpbWVgXG4gICAgICogbW9yZSBvciBlcXVhbCB0byB0aGlzIHZhbHVlIGlzIGl0ZXJhdGVkLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBvbWl0dGVkIHRoZW4gdGhlcmUgaXNcbiAgICAgKiBubyBib3R0b20gdGltZSBlZGdlLCBzbyBhbGwgYmxvY2tzIHNpbmNlIHplcm8gc3RhdGUgaXMgaXRlcmF0ZWQuXG4gICAgICogLSBgZW5kX3RpbWVgIOKAkyB0aGUgdXBwZXIgdGltZSByYW5nZS4gT25seSBibG9ja3Mgd2l0aCBgZ2VuX3V0aW1lYFxuICAgICAqIGxlc3MgdGhlbiB0aGlzIHZhbHVlIGlzIGl0ZXJhdGVkLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBvbWl0dGVkIHRoZW4gdGhlcmUgaXNcbiAgICAgKiBubyB1cHBlciB0aW1lIGVkZ2UsIHNvIGl0ZXJhdG9yIG5ldmVyIGZpbmlzaGVzLlxuICAgICAqIC0gYHNoYXJkX2ZpbHRlcmAg4oCTIHdvcmtjaGFpbnMgYW5kIHNoYXJkIHByZWZpeGVzIHRoYXQgcmVkdWNlIHRoZSBzZXQgb2YgaW50ZXJlc3RpbmdcbiAgICAgKiBibG9ja3MuIEJsb2NrIGNvbmZvcm1zIHRvIHRoZSBzaGFyZCBmaWx0ZXIgaWYgaXQgYmVsb25ncyB0byB0aGUgZmlsdGVyIHdvcmtjaGFpblxuICAgICAqIGFuZCB0aGUgZmlyc3QgYml0cyBvZiBibG9jaydzIGBzaGFyZGAgZmllbGRzIG1hdGNoZXMgdG8gdGhlIHNoYXJkIHByZWZpeC5cbiAgICAgKiBPbmx5IGJsb2NrcyB3aXRoIHN1aXRhYmxlIHNoYXJkIGFyZSBpdGVyYXRlZC5cbiAgICAgKlxuICAgICAqIEl0ZW1zIGl0ZXJhdGVkIGlzIGEgSlNPTiBvYmplY3RzIHdpdGggYmxvY2sgZGF0YS4gVGhlIG1pbmltYWwgc2V0IG9mIHJldHVybmVkXG4gICAgICogZmllbGRzIGlzOlxuICAgICAqIGBgYHRleHRcbiAgICAgKiBpZFxuICAgICAqIGdlbl91dGltZVxuICAgICAqIHdvcmtjaGFpbl9pZFxuICAgICAqIHNoYXJkXG4gICAgICogYWZ0ZXJfc3BsaXRcbiAgICAgKiBhZnRlcl9tZXJnZVxuICAgICAqIHByZXZfcmVmIHtcbiAgICAgKiAgICAgcm9vdF9oYXNoXG4gICAgICogfVxuICAgICAqIHByZXZfYWx0X3JlZiB7XG4gICAgICogICAgIHJvb3RfaGFzaFxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBBcHBsaWNhdGlvbiBjYW4gcmVxdWVzdCBhZGRpdGlvbmFsIGZpZWxkcyBpbiB0aGUgYHJlc3VsdGAgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQXBwbGljYXRpb24gc2hvdWxkIGNhbGwgdGhlIGByZW1vdmVfaXRlcmF0b3JgIHdoZW4gaXRlcmF0b3IgaXMgbm8gbG9uZ2VyIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkNyZWF0ZUJsb2NrSXRlcmF0b3J9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlZ2lzdGVyZWRJdGVyYXRvclxuICAgICAqL1xuICAgIGNyZWF0ZV9ibG9ja19pdGVyYXRvcihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC5jcmVhdGVfYmxvY2tfaXRlcmF0b3InLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIGJsb2NrIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgaXRlcmF0b3Igc3RheXMgZXhhY3RseSBhdCB0aGUgc2FtZSBwb3NpdGlvbiB3aGVyZSB0aGUgYHJlc3VtZV9zdGF0ZWAgd2FzIGNhdGNoZWQuXG4gICAgICpcbiAgICAgKiBBcHBsaWNhdGlvbiBzaG91bGQgY2FsbCB0aGUgYHJlbW92ZV9pdGVyYXRvcmAgd2hlbiBpdGVyYXRvciBpcyBubyBsb25nZXIgcmVxdWlyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mUmVzdW1lQmxvY2tJdGVyYXRvcn0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVnaXN0ZXJlZEl0ZXJhdG9yXG4gICAgICovXG4gICAgcmVzdW1lX2Jsb2NrX2l0ZXJhdG9yKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnbmV0LnJlc3VtZV9ibG9ja19pdGVyYXRvcicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdHJhbnNhY3Rpb24gaXRlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRyYW5zYWN0aW9uIGl0ZXJhdG9yIHVzZXMgcm9idXN0IGl0ZXJhdGlvbiBtZXRob2RzIHRoYXQgZ3VhcmFudHkgdGhhdCBldmVyeVxuICAgICAqIHRyYW5zYWN0aW9uIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UgaXNuJ3QgbWlzc2VkIG9yIGl0ZXJhdGVkIHR3aWNlLlxuICAgICAqXG4gICAgICogSXRlcmF0ZWQgcmFuZ2UgY2FuIGJlIHJlZHVjZWQgd2l0aCBzb21lIGZpbHRlcnM6XG4gICAgICogLSBgc3RhcnRfdGltZWAg4oCTIHRoZSBib3R0b20gdGltZSByYW5nZS4gT25seSB0cmFuc2FjdGlvbnMgd2l0aCBgbm93YFxuICAgICAqIG1vcmUgb3IgZXF1YWwgdG8gdGhpcyB2YWx1ZSBhcmUgaXRlcmF0ZWQuIElmIHRoaXMgcGFyYW1ldGVyIGlzIG9taXR0ZWQgdGhlbiB0aGVyZSBpc1xuICAgICAqIG5vIGJvdHRvbSB0aW1lIGVkZ2UsIHNvIGFsbCB0aGUgdHJhbnNhY3Rpb25zIHNpbmNlIHplcm8gc3RhdGUgYXJlIGl0ZXJhdGVkLlxuICAgICAqIC0gYGVuZF90aW1lYCDigJMgdGhlIHVwcGVyIHRpbWUgcmFuZ2UuIE9ubHkgdHJhbnNhY3Rpb25zIHdpdGggYG5vd2BcbiAgICAgKiBsZXNzIHRoZW4gdGhpcyB2YWx1ZSBhcmUgaXRlcmF0ZWQuIElmIHRoaXMgcGFyYW1ldGVyIGlzIG9taXR0ZWQgdGhlbiB0aGVyZSBpc1xuICAgICAqIG5vIHVwcGVyIHRpbWUgZWRnZSwgc28gaXRlcmF0b3IgbmV2ZXIgZmluaXNoZXMuXG4gICAgICogLSBgc2hhcmRfZmlsdGVyYCDigJMgd29ya2NoYWlucyBhbmQgc2hhcmQgcHJlZml4ZXMgdGhhdCByZWR1Y2UgdGhlIHNldCBvZiBpbnRlcmVzdGluZ1xuICAgICAqIGFjY291bnRzLiBBY2NvdW50IGFkZHJlc3MgY29uZm9ybXMgdG8gdGhlIHNoYXJkIGZpbHRlciBpZlxuICAgICAqIGl0IGJlbG9uZ3MgdG8gdGhlIGZpbHRlciB3b3JrY2hhaW4gYW5kIHRoZSBmaXJzdCBiaXRzIG9mIGFkZHJlc3MgbWF0Y2ggdG9cbiAgICAgKiB0aGUgc2hhcmQgcHJlZml4LiBPbmx5IHRyYW5zYWN0aW9ucyB3aXRoIHN1aXRhYmxlIGFjY291bnQgYWRkcmVzc2VzIGFyZSBpdGVyYXRlZC5cbiAgICAgKiAtIGBhY2NvdW50c19maWx0ZXJgIOKAkyBzZXQgb2YgYWNjb3VudCBhZGRyZXNzZXMgd2hvc2UgdHJhbnNhY3Rpb25zIG11c3QgYmUgaXRlcmF0ZWQuXG4gICAgICogTm90ZSB0aGF0IGFjY291bnRzIGZpbHRlciBjYW4gY29uZmxpY3Qgd2l0aCBzaGFyZCBmaWx0ZXIgc28gYXBwbGljYXRpb24gbXVzdCBjb21iaW5lXG4gICAgICogdGhlc2UgZmlsdGVycyBjYXJlZnVsbHkuXG4gICAgICpcbiAgICAgKiBJdGVyYXRlZCBpdGVtIGlzIGEgSlNPTiBvYmplY3RzIHdpdGggdHJhbnNhY3Rpb24gZGF0YS4gVGhlIG1pbmltYWwgc2V0IG9mIHJldHVybmVkXG4gICAgICogZmllbGRzIGlzOlxuICAgICAqIGBgYHRleHRcbiAgICAgKiBpZFxuICAgICAqIGFjY291bnRfYWRkclxuICAgICAqIG5vd1xuICAgICAqIGJhbGFuY2VfZGVsdGEoZm9ybWF0OkRFQylcbiAgICAgKiBib3VuY2UgeyBib3VuY2VfdHlwZSB9XG4gICAgICogaW5fbWVzc2FnZSB7XG4gICAgICogICAgIGlkXG4gICAgICogICAgIHZhbHVlKGZvcm1hdDpERUMpXG4gICAgICogICAgIG1zZ190eXBlXG4gICAgICogICAgIHNyY1xuICAgICAqIH1cbiAgICAgKiBvdXRfbWVzc2FnZXMge1xuICAgICAqICAgICBpZFxuICAgICAqICAgICB2YWx1ZShmb3JtYXQ6REVDKVxuICAgICAqICAgICBtc2dfdHlwZVxuICAgICAqICAgICBkc3RcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQXBwbGljYXRpb24gY2FuIHJlcXVlc3QgYW4gYWRkaXRpb25hbCBmaWVsZHMgaW4gdGhlIGByZXN1bHRgIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEFub3RoZXIgcGFyYW1ldGVyIHRoYXQgYWZmZWN0cyBvbiB0aGUgcmV0dXJuZWQgZmllbGRzIGlzIHRoZSBgaW5jbHVkZV90cmFuc2ZlcnNgLlxuICAgICAqIFdoZW4gdGhpcyBwYXJhbWV0ZXIgaXMgYHRydWVgIHRoZSBpdGVyYXRvciBjb21wdXRlcyBhbmQgYWRkcyBgdHJhbnNmZXJgIGZpZWxkIGNvbnRhaW5pbmdcbiAgICAgKiBsaXN0IG9mIHRoZSB1c2VmdWwgYFRyYW5zYWN0aW9uVHJhbnNmZXJgIG9iamVjdHMuXG4gICAgICogRWFjaCB0cmFuc2ZlciBpcyBjYWxjdWxhdGVkIGZyb20gdGhlIHBhcnRpY3VsYXIgbWVzc2FnZSByZWxhdGVkIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIGFuZCBoYXMgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4gICAgICogLSBtZXNzYWdlIOKAkyBzb3VyY2UgbWVzc2FnZSBpZGVudGlmaWVyLlxuICAgICAqIC0gaXNCb3VuY2VkIOKAkyBpbmRpY2F0ZXMgdGhhdCB0aGUgdHJhbnNhY3Rpb24gaXMgYm91bmNlZCwgd2hpY2ggbWVhbnMgdGhlIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgYmFjayB0byB0aGUgc2VuZGVyLlxuICAgICAqIC0gaXNEZXBvc2l0IOKAkyBpbmRpY2F0ZXMgdGhhdCB0aGlzIHRyYW5zZmVyIGlzIHRoZSBkZXBvc2l0ICh0cnVlKSBvciB3aXRoZHJhdyAoZmFsc2UpLlxuICAgICAqIC0gY291bnRlcnBhcnR5IOKAkyBhY2NvdW50IGFkZHJlc3Mgb2YgdGhlIHRyYW5zZmVyIHNvdXJjZSBvciBkZXN0aW5hdGlvbiBkZXBlbmRpbmcgb24gYGlzRGVwb3NpdGAuXG4gICAgICogLSB2YWx1ZSDigJMgYW1vdW50IG9mIG5hbm8gdG9rZW5zIHRyYW5zZmVycmVkLiBUaGUgdmFsdWUgaXMgcmVwcmVzZW50ZWQgYXMgYSBkZWNpbWFsIHN0cmluZ1xuICAgICAqIGJlY2F1c2UgdGhlIGFjdHVhbCB2YWx1ZSBjYW4gYmUgbW9yZSBwcmVjaXNlIHRoYW4gdGhlIEpTT04gbnVtYmVyIGNhbiByZXByZXNlbnQuIEFwcGxpY2F0aW9uXG4gICAgICogbXVzdCB1c2UgdGhpcyBzdHJpbmcgY2FyZWZ1bGx5IOKAkyBjb252ZXJzaW9uIHRvIG51bWJlciBjYW4gZm9sbG93IHRvIGxvb3NlIG9mIHByZWNpc2lvbi5cbiAgICAgKlxuICAgICAqIEFwcGxpY2F0aW9uIHNob3VsZCBjYWxsIHRoZSBgcmVtb3ZlX2l0ZXJhdG9yYCB3aGVuIGl0ZXJhdG9yIGlzIG5vIGxvbmdlciByZXF1aXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZDcmVhdGVUcmFuc2FjdGlvbkl0ZXJhdG9yfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZWdpc3RlcmVkSXRlcmF0b3JcbiAgICAgKi9cbiAgICBjcmVhdGVfdHJhbnNhY3Rpb25faXRlcmF0b3IocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCduZXQuY3JlYXRlX3RyYW5zYWN0aW9uX2l0ZXJhdG9yJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdW1lcyB0cmFuc2FjdGlvbiBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGl0ZXJhdG9yIHN0YXlzIGV4YWN0bHkgYXQgdGhlIHNhbWUgcG9zaXRpb24gd2hlcmUgdGhlIGByZXN1bWVfc3RhdGVgIHdhcyBjYXVnaHQuXG4gICAgICogTm90ZSB0aGF0IGByZXN1bWVfc3RhdGVgIGRvZXNuJ3Qgc3RvcmUgdGhlIGFjY291bnQgZmlsdGVyLiBJZiB0aGUgYXBwbGljYXRpb24gcmVxdWlyZXNcbiAgICAgKiB0byB1c2UgdGhlIHNhbWUgYWNjb3VudCBmaWx0ZXIgYXMgaXQgd2FzIHdoZW4gdGhlIGl0ZXJhdG9yIHdhcyBjcmVhdGVkIHRoZW4gdGhlIGFwcGxpY2F0aW9uXG4gICAgICogbXVzdCBwYXNzIHRoZSBhY2NvdW50IGZpbHRlciBhZ2FpbiBpbiBgYWNjb3VudHNfZmlsdGVyYCBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBBcHBsaWNhdGlvbiBzaG91bGQgY2FsbCB0aGUgYHJlbW92ZV9pdGVyYXRvcmAgd2hlbiBpdGVyYXRvciBpcyBubyBsb25nZXIgcmVxdWlyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mUmVzdW1lVHJhbnNhY3Rpb25JdGVyYXRvcn0gcGFyYW1zXG4gICAgICogQHJldHVybnMgUmVnaXN0ZXJlZEl0ZXJhdG9yXG4gICAgICovXG4gICAgcmVzdW1lX3RyYW5zYWN0aW9uX2l0ZXJhdG9yKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnbmV0LnJlc3VtZV90cmFuc2FjdGlvbl9pdGVyYXRvcicsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmV4dCBhdmFpbGFibGUgaXRlbXMuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEluIGFkZGl0aW9uIHRvIGF2YWlsYWJsZSBpdGVtcyB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGBoYXNfbW9yZWAgZmxhZ1xuICAgICAqIGluZGljYXRpbmcgdGhhdCB0aGUgaXRlcmF0b3IgaXNuJ3QgcmVhY2ggdGhlIGVuZCBvZiB0aGUgaXRlcmF0ZWQgcmFuZ2UgeWV0LlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gcmV0dXJuIHRoZSBlbXB0eSBsaXN0IG9mIGF2YWlsYWJsZSBpdGVtcyBidXRcbiAgICAgKiBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBhcmUgbW9yZSBpdGVtcyBpcyBhdmFpbGFibGUuXG4gICAgICogVGhpcyBzaXR1YXRpb24gYXBwZWFycyB3aGVuIHRoZSBpdGVyYXRvciBkb2Vzbid0IHJlYWNoIGl0ZXJhdGVkIHJhbmdlXG4gICAgICogYnV0IGRhdGFiYXNlIGRvZXNuJ3QgY29udGFpbnMgYXZhaWxhYmxlIGl0ZW1zIHlldC5cbiAgICAgKlxuICAgICAqIElmIGFwcGxpY2F0aW9uIHJlcXVlc3RzIHJlc3VtZSBzdGF0ZSBpbiBgcmV0dXJuX3Jlc3VtZV9zdGF0ZWAgcGFyYW1ldGVyXG4gICAgICogdGhlbiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHJlc3VtZV9zdGF0ZWAgdGhhdCBjYW4gYmUgdXNlZCBsYXRlciB0b1xuICAgICAqIHJlc3VtZSB0aGUgaXRlcmF0aW9uIGZyb20gdGhlIHBvc2l0aW9uIGFmdGVyIHJldHVybmVkIGl0ZW1zLlxuICAgICAqXG4gICAgICogVGhlIHN0cnVjdHVyZSBvZiB0aGUgaXRlbXMgcmV0dXJuZWQgZGVwZW5kcyBvbiB0aGUgaXRlcmF0b3IgdXNlZC5cbiAgICAgKiBTZWUgdGhlIGRlc2NyaXB0aW9uIHRvIHRoZSBhcHByb3ByaWF0ZWQgaXRlcmF0b3IgY3JlYXRpb24gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mSXRlcmF0b3JOZXh0fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkl0ZXJhdG9yTmV4dFxuICAgICAqL1xuICAgIGl0ZXJhdG9yX25leHQocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCduZXQuaXRlcmF0b3JfbmV4dCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gaXRlcmF0b3JcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRnJlZXMgYWxsIHJlc291cmNlcyBhbGxvY2F0ZWQgaW4gbGlicmFyeSB0byBzZXJ2ZSBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEFwcGxpY2F0aW9uIGFsd2F5cyBzaG91bGQgY2FsbCB0aGUgYHJlbW92ZV9pdGVyYXRvcmAgd2hlbiBpdGVyYXRvclxuICAgICAqIGlzIG5vIGxvbmdlciByZXF1aXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVnaXN0ZXJlZEl0ZXJhdG9yfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHJlbW92ZV9pdGVyYXRvcihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ25ldC5yZW1vdmVfaXRlcmF0b3InLCBwYXJhbXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTmV0TW9kdWxlID0gTmV0TW9kdWxlO1xuLy8gZGVib3QgbW9kdWxlXG52YXIgRGVib3RFcnJvckNvZGU7XG4oZnVuY3Rpb24gKERlYm90RXJyb3JDb2RlKSB7XG4gICAgRGVib3RFcnJvckNvZGVbRGVib3RFcnJvckNvZGVbXCJEZWJvdFN0YXJ0RmFpbGVkXCJdID0gODAxXSA9IFwiRGVib3RTdGFydEZhaWxlZFwiO1xuICAgIERlYm90RXJyb3JDb2RlW0RlYm90RXJyb3JDb2RlW1wiRGVib3RGZXRjaEZhaWxlZFwiXSA9IDgwMl0gPSBcIkRlYm90RmV0Y2hGYWlsZWRcIjtcbiAgICBEZWJvdEVycm9yQ29kZVtEZWJvdEVycm9yQ29kZVtcIkRlYm90RXhlY3V0aW9uRmFpbGVkXCJdID0gODAzXSA9IFwiRGVib3RFeGVjdXRpb25GYWlsZWRcIjtcbiAgICBEZWJvdEVycm9yQ29kZVtEZWJvdEVycm9yQ29kZVtcIkRlYm90SW52YWxpZEhhbmRsZVwiXSA9IDgwNF0gPSBcIkRlYm90SW52YWxpZEhhbmRsZVwiO1xuICAgIERlYm90RXJyb3JDb2RlW0RlYm90RXJyb3JDb2RlW1wiRGVib3RJbnZhbGlkSnNvblBhcmFtc1wiXSA9IDgwNV0gPSBcIkRlYm90SW52YWxpZEpzb25QYXJhbXNcIjtcbiAgICBEZWJvdEVycm9yQ29kZVtEZWJvdEVycm9yQ29kZVtcIkRlYm90SW52YWxpZEZ1bmN0aW9uSWRcIl0gPSA4MDZdID0gXCJEZWJvdEludmFsaWRGdW5jdGlvbklkXCI7XG4gICAgRGVib3RFcnJvckNvZGVbRGVib3RFcnJvckNvZGVbXCJEZWJvdEludmFsaWRBYmlcIl0gPSA4MDddID0gXCJEZWJvdEludmFsaWRBYmlcIjtcbiAgICBEZWJvdEVycm9yQ29kZVtEZWJvdEVycm9yQ29kZVtcIkRlYm90R2V0TWV0aG9kRmFpbGVkXCJdID0gODA4XSA9IFwiRGVib3RHZXRNZXRob2RGYWlsZWRcIjtcbiAgICBEZWJvdEVycm9yQ29kZVtEZWJvdEVycm9yQ29kZVtcIkRlYm90SW52YWxpZE1zZ1wiXSA9IDgwOV0gPSBcIkRlYm90SW52YWxpZE1zZ1wiO1xuICAgIERlYm90RXJyb3JDb2RlW0RlYm90RXJyb3JDb2RlW1wiRGVib3RFeHRlcm5hbENhbGxGYWlsZWRcIl0gPSA4MTBdID0gXCJEZWJvdEV4dGVybmFsQ2FsbEZhaWxlZFwiO1xuICAgIERlYm90RXJyb3JDb2RlW0RlYm90RXJyb3JDb2RlW1wiRGVib3RCcm93c2VyQ2FsbGJhY2tGYWlsZWRcIl0gPSA4MTFdID0gXCJEZWJvdEJyb3dzZXJDYWxsYmFja0ZhaWxlZFwiO1xuICAgIERlYm90RXJyb3JDb2RlW0RlYm90RXJyb3JDb2RlW1wiRGVib3RPcGVyYXRpb25SZWplY3RlZFwiXSA9IDgxMl0gPSBcIkRlYm90T3BlcmF0aW9uUmVqZWN0ZWRcIjtcbiAgICBEZWJvdEVycm9yQ29kZVtEZWJvdEVycm9yQ29kZVtcIkRlYm90Tm9Db2RlXCJdID0gODEzXSA9IFwiRGVib3ROb0NvZGVcIjtcbn0pKERlYm90RXJyb3JDb2RlID0gZXhwb3J0cy5EZWJvdEVycm9yQ29kZSB8fCAoZXhwb3J0cy5EZWJvdEVycm9yQ29kZSA9IHt9KSk7XG5mdW5jdGlvbiBkZWJvdEFjdGl2aXR5VHJhbnNhY3Rpb24obXNnLCBkc3QsIG91dCwgZmVlLCBzZXRjb2RlLCBzaWdua2V5LCBzaWduaW5nX2JveF9oYW5kbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnVHJhbnNhY3Rpb24nLFxuICAgICAgICBtc2csXG4gICAgICAgIGRzdCxcbiAgICAgICAgb3V0LFxuICAgICAgICBmZWUsXG4gICAgICAgIHNldGNvZGUsXG4gICAgICAgIHNpZ25rZXksXG4gICAgICAgIHNpZ25pbmdfYm94X2hhbmRsZSxcbiAgICB9O1xufVxuZXhwb3J0cy5kZWJvdEFjdGl2aXR5VHJhbnNhY3Rpb24gPSBkZWJvdEFjdGl2aXR5VHJhbnNhY3Rpb247XG5mdW5jdGlvbiBwYXJhbXNPZkFwcERlYm90QnJvd3NlckxvZyhtc2cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnTG9nJyxcbiAgICAgICAgbXNnLFxuICAgIH07XG59XG5leHBvcnRzLnBhcmFtc09mQXBwRGVib3RCcm93c2VyTG9nID0gcGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJMb2c7XG5mdW5jdGlvbiBwYXJhbXNPZkFwcERlYm90QnJvd3NlclN3aXRjaChjb250ZXh0X2lkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1N3aXRjaCcsXG4gICAgICAgIGNvbnRleHRfaWQsXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJTd2l0Y2ggPSBwYXJhbXNPZkFwcERlYm90QnJvd3NlclN3aXRjaDtcbmZ1bmN0aW9uIHBhcmFtc09mQXBwRGVib3RCcm93c2VyU3dpdGNoQ29tcGxldGVkKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdTd2l0Y2hDb21wbGV0ZWQnLFxuICAgIH07XG59XG5leHBvcnRzLnBhcmFtc09mQXBwRGVib3RCcm93c2VyU3dpdGNoQ29tcGxldGVkID0gcGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJTd2l0Y2hDb21wbGV0ZWQ7XG5mdW5jdGlvbiBwYXJhbXNPZkFwcERlYm90QnJvd3NlclNob3dBY3Rpb24oYWN0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1Nob3dBY3Rpb24nLFxuICAgICAgICBhY3Rpb24sXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJTaG93QWN0aW9uID0gcGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJTaG93QWN0aW9uO1xuZnVuY3Rpb24gcGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJJbnB1dChwcm9tcHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnSW5wdXQnLFxuICAgICAgICBwcm9tcHQsXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJJbnB1dCA9IHBhcmFtc09mQXBwRGVib3RCcm93c2VySW5wdXQ7XG5mdW5jdGlvbiBwYXJhbXNPZkFwcERlYm90QnJvd3NlckdldFNpZ25pbmdCb3goKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0dldFNpZ25pbmdCb3gnLFxuICAgIH07XG59XG5leHBvcnRzLnBhcmFtc09mQXBwRGVib3RCcm93c2VyR2V0U2lnbmluZ0JveCA9IHBhcmFtc09mQXBwRGVib3RCcm93c2VyR2V0U2lnbmluZ0JveDtcbmZ1bmN0aW9uIHBhcmFtc09mQXBwRGVib3RCcm93c2VySW52b2tlRGVib3QoZGVib3RfYWRkciwgYWN0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0ludm9rZURlYm90JyxcbiAgICAgICAgZGVib3RfYWRkcixcbiAgICAgICAgYWN0aW9uLFxuICAgIH07XG59XG5leHBvcnRzLnBhcmFtc09mQXBwRGVib3RCcm93c2VySW52b2tlRGVib3QgPSBwYXJhbXNPZkFwcERlYm90QnJvd3Nlckludm9rZURlYm90O1xuZnVuY3Rpb24gcGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJTZW5kKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnU2VuZCcsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJTZW5kID0gcGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJTZW5kO1xuZnVuY3Rpb24gcGFyYW1zT2ZBcHBEZWJvdEJyb3dzZXJBcHByb3ZlKGFjdGl2aXR5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0FwcHJvdmUnLFxuICAgICAgICBhY3Rpdml0eSxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJhbXNPZkFwcERlYm90QnJvd3NlckFwcHJvdmUgPSBwYXJhbXNPZkFwcERlYm90QnJvd3NlckFwcHJvdmU7XG5mdW5jdGlvbiByZXN1bHRPZkFwcERlYm90QnJvd3NlcklucHV0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0lucHV0JyxcbiAgICAgICAgdmFsdWUsXG4gICAgfTtcbn1cbmV4cG9ydHMucmVzdWx0T2ZBcHBEZWJvdEJyb3dzZXJJbnB1dCA9IHJlc3VsdE9mQXBwRGVib3RCcm93c2VySW5wdXQ7XG5mdW5jdGlvbiByZXN1bHRPZkFwcERlYm90QnJvd3NlckdldFNpZ25pbmdCb3goc2lnbmluZ19ib3gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnR2V0U2lnbmluZ0JveCcsXG4gICAgICAgIHNpZ25pbmdfYm94LFxuICAgIH07XG59XG5leHBvcnRzLnJlc3VsdE9mQXBwRGVib3RCcm93c2VyR2V0U2lnbmluZ0JveCA9IHJlc3VsdE9mQXBwRGVib3RCcm93c2VyR2V0U2lnbmluZ0JveDtcbmZ1bmN0aW9uIHJlc3VsdE9mQXBwRGVib3RCcm93c2VySW52b2tlRGVib3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0ludm9rZURlYm90JyxcbiAgICB9O1xufVxuZXhwb3J0cy5yZXN1bHRPZkFwcERlYm90QnJvd3Nlckludm9rZURlYm90ID0gcmVzdWx0T2ZBcHBEZWJvdEJyb3dzZXJJbnZva2VEZWJvdDtcbmZ1bmN0aW9uIHJlc3VsdE9mQXBwRGVib3RCcm93c2VyQXBwcm92ZShhcHByb3ZlZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdBcHByb3ZlJyxcbiAgICAgICAgYXBwcm92ZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMucmVzdWx0T2ZBcHBEZWJvdEJyb3dzZXJBcHByb3ZlID0gcmVzdWx0T2ZBcHBEZWJvdEJyb3dzZXJBcHByb3ZlO1xuZnVuY3Rpb24gZGlzcGF0Y2hBcHBEZWJvdEJyb3dzZXIob2JqLCBwYXJhbXMsIGFwcF9yZXF1ZXN0X2lkLCBjbGllbnQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgc3dpdGNoIChwYXJhbXMudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0xvZyc6XG4gICAgICAgICAgICAgICAgICAgIG9iai5sb2cocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnU3dpdGNoJzpcbiAgICAgICAgICAgICAgICAgICAgb2JqLnN3aXRjaChwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdTd2l0Y2hDb21wbGV0ZWQnOlxuICAgICAgICAgICAgICAgICAgICBvYmouc3dpdGNoX2NvbXBsZXRlZCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdTaG93QWN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgb2JqLnNob3dfYWN0aW9uKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0lucHV0JzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgb2JqLmlucHV0KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0dldFNpZ25pbmdCb3gnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCBvYmouZ2V0X3NpZ25pbmdfYm94KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0ludm9rZURlYm90JzpcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgb2JqLmludm9rZV9kZWJvdChwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdTZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgb2JqLnNlbmQocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQXBwcm92ZSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIG9iai5hcHByb3ZlKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xpZW50LnJlc29sdmVfYXBwX3JlcXVlc3QoYXBwX3JlcXVlc3RfaWQsIE9iamVjdC5hc3NpZ24oeyB0eXBlOiBwYXJhbXMudHlwZSB9LCByZXN1bHQpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNsaWVudC5yZWplY3RfYXBwX3JlcXVlc3QoYXBwX3JlcXVlc3RfaWQsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBbVU5TVEFCTEVdKFVOU1RBQkxFLm1kKSBNb2R1bGUgZm9yIHdvcmtpbmcgd2l0aCBkZWJvdC5cbiAqL1xuY2xhc3MgRGVib3RNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogW1VOU1RBQkxFXShVTlNUQUJMRS5tZCkgQ3JlYXRlcyBhbmQgaW5zdGFuY2Ugb2YgRGVCb3QuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIERvd25sb2FkcyBkZWJvdCBzbWFydCBjb250cmFjdCAoY29kZSBhbmQgZGF0YSkgZnJvbSBibG9ja2NoYWluIGFuZCBjcmVhdGVzXG4gICAgICogYW4gaW5zdGFuY2Ugb2YgRGVib3QgRW5naW5lIGZvciBpdC5cbiAgICAgKlxuICAgICAqICMgUmVtYXJrc1xuICAgICAqIEl0IGRvZXMgbm90IHN3aXRjaCBkZWJvdCB0byBjb250ZXh0IDAuIEJyb3dzZXIgQ2FsbGJhY2tzIGFyZSBub3QgY2FsbGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkluaXR9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIFJlZ2lzdGVyZWREZWJvdFxuICAgICAqL1xuICAgIGluaXQocGFyYW1zLCBvYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2RlYm90LmluaXQnLCBwYXJhbXMsIChwYXJhbXMsIHJlc3BvbnNlVHlwZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoQXBwRGVib3RCcm93c2VyKG9iaiwgcGFyYW1zLnJlcXVlc3RfZGF0YSwgcGFyYW1zLmFwcF9yZXF1ZXN0X2lkLCB0aGlzLmNsaWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEFwcERlYm90QnJvd3NlcihvYmosIHBhcmFtcywgbnVsbCwgdGhpcy5jbGllbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogW1VOU1RBQkxFXShVTlNUQUJMRS5tZCkgU3RhcnRzIHRoZSBEZUJvdC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRG93bmxvYWRzIGRlYm90IHNtYXJ0IGNvbnRyYWN0IGZyb20gYmxvY2tjaGFpbiBhbmQgc3dpdGNoZXMgaXQgdG9cbiAgICAgKiBjb250ZXh0IHplcm8uXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgdXNlZCBieSBEZWJvdCBCcm93c2VyIHRvIHN0YXJ0IGEgZGlhbG9nIHdpdGggZGVib3QuXG4gICAgICogV2hpbGUgdGhlIGZ1bmN0aW9uIGlzIGV4ZWN1dGluZywgc2V2ZXJhbCBCcm93c2VyIENhbGxiYWNrcyBjYW4gYmUgY2FsbGVkLFxuICAgICAqIHNpbmNlIHRoZSBkZWJvdCB0cmllcyB0byBkaXNwbGF5IGFsbCBhY3Rpb25zIGZyb20gdGhlIGNvbnRleHQgMCB0byB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIGRlYm90IHN0YXJ0cyBTREsgcmVnaXN0ZXJzIGBCcm93c2VyQ2FsbGJhY2tzYCBBcHBPYmplY3QuXG4gICAgICogVGhlcmVmb3JlIHdoZW4gYGRlYm90ZS5yZW1vdmVgIGlzIGNhbGxlZCB0aGUgZGVib3QgaXMgYmVpbmcgZGVsZXRlZCBhbmQgdGhlIGNhbGxiYWNrIGlzIGNhbGxlZFxuICAgICAqIHdpdGggYGZpbmlzaGA9YHRydWVgIHdoaWNoIGluZGljYXRlcyB0aGF0IGl0IHdpbGwgbmV2ZXIgYmUgdXNlZCBhZ2Fpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZTdGFydH0gcGFyYW1zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdGFydChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QoJ2RlYm90LnN0YXJ0JywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogW1VOU1RBQkxFXShVTlNUQUJMRS5tZCkgRmV0Y2hlcyBEZUJvdCBtZXRhZGF0YSBmcm9tIGJsb2NrY2hhaW4uXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIERvd25sb2FkcyBEZUJvdCBmcm9tIGJsb2NrY2hhaW4gYW5kIGNyZWF0ZXMgYW5kIGZldGNoZXMgaXRzIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZkZldGNofSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRPZkZldGNoXG4gICAgICovXG4gICAgZmV0Y2gocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdkZWJvdC5mZXRjaCcsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFtVTlNUQUJMRV0oVU5TVEFCTEUubWQpIEV4ZWN1dGVzIGRlYm90IGFjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQ2FsbHMgZGVib3QgZW5naW5lIHJlZmVyZW5jZWQgYnkgZGVib3QgaGFuZGxlIHRvIGV4ZWN1dGUgaW5wdXQgYWN0aW9uLlxuICAgICAqIENhbGxzIERlYm90IEJyb3dzZXIgQ2FsbGJhY2tzIGlmIG5lZWRlZC5cbiAgICAgKlxuICAgICAqICMgUmVtYXJrc1xuICAgICAqIENoYWluIG9mIGFjdGlvbnMgY2FuIGJlIGV4ZWN1dGVkIGlmIGlucHV0IGFjdGlvbiBnZW5lcmF0ZXMgYSBsaXN0IG9mIHN1YmFjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmFtc09mRXhlY3V0ZX0gcGFyYW1zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBleGVjdXRlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnZGVib3QuZXhlY3V0ZScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFtVTlNUQUJMRV0oVU5TVEFCTEUubWQpIFNlbmRzIG1lc3NhZ2UgdG8gRGVib3QuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFVzZWQgYnkgRGVib3QgQnJvd3NlciB0byBzZW5kIHJlc3BvbnNlIG9uIERpbnRlcmZhY2UgY2FsbCBvciBmcm9tIG90aGVyIERlYm90cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZTZW5kfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHNlbmQocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdkZWJvdC5zZW5kJywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogW1VOU1RBQkxFXShVTlNUQUJMRS5tZCkgRGVzdHJveXMgZGVib3QgaGFuZGxlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBSZW1vdmVzIGhhbmRsZSBmcm9tIENsaWVudCBDb250ZXh0IGFuZCBkcm9wcyBkZWJvdCBlbmdpbmUgcmVmZXJlbmNlZCBieSB0aGF0IGhhbmRsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZSZW1vdmV9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcmVtb3ZlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgnZGVib3QucmVtb3ZlJywgcGFyYW1zKTtcbiAgICB9XG59XG5leHBvcnRzLkRlYm90TW9kdWxlID0gRGVib3RNb2R1bGU7XG4vLyBwcm9vZnMgbW9kdWxlXG52YXIgUHJvb2ZzRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChQcm9vZnNFcnJvckNvZGUpIHtcbiAgICBQcm9vZnNFcnJvckNvZGVbUHJvb2ZzRXJyb3JDb2RlW1wiSW52YWxpZERhdGFcIl0gPSA5MDFdID0gXCJJbnZhbGlkRGF0YVwiO1xuICAgIFByb29mc0Vycm9yQ29kZVtQcm9vZnNFcnJvckNvZGVbXCJQcm9vZkNoZWNrRmFpbGVkXCJdID0gOTAyXSA9IFwiUHJvb2ZDaGVja0ZhaWxlZFwiO1xuICAgIFByb29mc0Vycm9yQ29kZVtQcm9vZnNFcnJvckNvZGVbXCJJbnRlcm5hbEVycm9yXCJdID0gOTAzXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xuICAgIFByb29mc0Vycm9yQ29kZVtQcm9vZnNFcnJvckNvZGVbXCJEYXRhRGlmZmVyc0Zyb21Qcm92ZW5cIl0gPSA5MDRdID0gXCJEYXRhRGlmZmVyc0Zyb21Qcm92ZW5cIjtcbn0pKFByb29mc0Vycm9yQ29kZSA9IGV4cG9ydHMuUHJvb2ZzRXJyb3JDb2RlIHx8IChleHBvcnRzLlByb29mc0Vycm9yQ29kZSA9IHt9KSk7XG4vKipcbiAqIFtVTlNUQUJMRV0oVU5TVEFCTEUubWQpIE1vZHVsZSBmb3IgcHJvdmluZyBkYXRhLCByZXRyaWV2ZWQgZnJvbSBUT05PUyBBUEkuXG4gKi9cbmNsYXNzIFByb29mc01vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92ZXMgdGhhdCBhIGdpdmVuIGJsb2NrJ3MgZGF0YSwgd2hpY2ggaXMgcXVlcmllZCBmcm9tIFRPTk9TIEFQSSwgY2FuIGJlIHRydXN0ZWQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoaXMgZnVuY3Rpb24gY2hlY2tzIGJsb2NrIHByb29mcyBhbmQgY29tcGFyZXMgZ2l2ZW4gZGF0YSB3aXRoIHRoZSBwcm92ZW4uXG4gICAgICogSWYgdGhlIGdpdmVuIGRhdGEgZGlmZmVycyBmcm9tIHRoZSBwcm92ZW4sIHRoZSBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gICAgICogVGhlIGlucHV0IHBhcmFtIGlzIGEgc2luZ2xlIGJsb2NrJ3MgSlNPTiBvYmplY3QsIHdoaWNoIHdhcyBxdWVyaWVkIGZyb20gREFwcCBzZXJ2ZXIgdXNpbmdcbiAgICAgKiBmdW5jdGlvbnMgc3VjaCBhcyBgbmV0LnF1ZXJ5YCwgYG5ldC5xdWVyeV9jb2xsZWN0aW9uYCBvciBgbmV0LndhaXRfZm9yX2NvbGxlY3Rpb25gLlxuICAgICAqIElmIGJsb2NrJ3MgQk9DIGlzIG5vdCBwcm92aWRlZCBpbiB0aGUgSlNPTiwgaXQgd2lsbCBiZSBxdWVyaWVkIGZyb20gREFwcCBzZXJ2ZXJcbiAgICAgKiAoaW4gdGhpcyBjYXNlIGl0IGlzIHJlcXVpcmVkIHRvIHByb3ZpZGUgYXQgbGVhc3QgYGlkYCBvZiBibG9jaykuXG4gICAgICpcbiAgICAgKiBQbGVhc2Ugbm90ZSwgdGhhdCBqb2lucyAobGlrZSBgc2lnbmF0dXJlc2AgaW4gYEJsb2NrYCkgYXJlIHNlcGFyYXRlZCBlbnRpdGllcyBhbmQgbm90IHN1cHBvcnRlZCxcbiAgICAgKiBzbyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpbiBhIGNhc2UgaWYgSlNPTiBiZWluZyBjaGVja2VkIGhhcyBzdWNoIGVudGl0aWVzIGluIGl0LlxuICAgICAqXG4gICAgICogSWYgYGNhY2hlX2luX2xvY2FsX3N0b3JhZ2VgIGluIGNvbmZpZyBpcyBzZXQgdG8gYHRydWVgIChkZWZhdWx0KSwgZG93bmxvYWRlZCBwcm9vZnMgYW5kXG4gICAgICogbWFzdGVyLWNoYWluIEJPQ3MgYXJlIHNhdmVkIGludG8gdGhlIHBlcnNpc3RlbnQgbG9jYWwgc3RvcmFnZSAoZS5nLiBmaWxlIHN5c3RlbSBmb3IgbmF0aXZlXG4gICAgICogZW52aXJvbm1lbnRzIG9yIGJyb3dzZXIncyBJbmRleGVkREIgZm9yIHRoZSB3ZWIpOyBvdGhlcndpc2UgYWxsIHRoZSBkYXRhIGlzIGNhY2hlZCBvbmx5IGluXG4gICAgICogbWVtb3J5IGluIGN1cnJlbnQgY2xpZW50J3MgY29udGV4dCBhbmQgd2lsbCBiZSBsb3N0IGFmdGVyIGRlc3RydWN0aW9uIG9mIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiAqKldoeSBQcm9vZnMgYXJlIG5lZWRlZCoqXG4gICAgICpcbiAgICAgKiBQcm9vZnMgYXJlIG5lZWRlZCB0byBlbnN1cmUgdGhhdCB0aGUgZGF0YSBkb3dubG9hZGVkIGZyb20gYSBEQXBwIHNlcnZlciBpcyByZWFsIGJsb2NrY2hhaW5cbiAgICAgKiBkYXRhLiBDaGVja2luZyBwcm9vZnMgY2FuIHByb3RlY3QgZnJvbSB0aGUgbWFsaWNpb3VzIERBcHAgc2VydmVyIHdoaWNoIGNhbiBwb3RlbnRpYWxseSBwcm92aWRlXG4gICAgICogZmFrZSBkYXRhLCBvciBhbHNvIGZyb20gXCJNYW4gaW4gdGhlIE1pZGRsZVwiIGF0dGFja3MgY2xhc3MuXG4gICAgICpcbiAgICAgKiAqKldoYXQgUHJvb2ZzIGFyZSoqXG4gICAgICpcbiAgICAgKiBTaW1wbHksIHByb29mIGlzIGEgbGlzdCBvZiBzaWduYXR1cmVzIG9mIHZhbGlkYXRvcnMnLCB3aGljaCBoYXZlIHNpZ25lZCB0aGlzIHBhcnRpY3VsYXIgbWFzdGVyLVxuICAgICAqIGJsb2NrLlxuICAgICAqXG4gICAgICogVGhlIHZlcnkgZmlyc3QgdmFsaWRhdG9yIHNldCdzIHB1YmxpYyBrZXlzIGFyZSBpbmNsdWRlZCBpbiB0aGUgemVyby1zdGF0ZS4gV2hlIGtub3cgYSByb290IGhhc2hcbiAgICAgKiBvZiB0aGUgemVyby1zdGF0ZSwgYmVjYXVzZSBpdCBpcyBzdG9yZWQgaW4gdGhlIG5ldHdvcmsgY29uZmlndXJhdGlvbiBmaWxlLCBpdCBpcyBvdXIgYXV0aG9yaXR5XG4gICAgICogcm9vdC4gRm9yIHByb3ZpbmcgemVyby1zdGF0ZSBpdCBpcyBlbm91Z2ggdG8gY2FsY3VsYXRlIGFuZCBjb21wYXJlIGl0cyByb290IGhhc2guXG4gICAgICpcbiAgICAgKiBJbiBlYWNoIG5ldyB2YWxpZGF0b3IgY3ljbGUgdGhlIHZhbGlkYXRvciBzZXQgaXMgY2hhbmdlZC4gVGhlIG5ldyBvbmUgaXMgc3RvcmVkIGluIGEga2V5LWJsb2NrLFxuICAgICAqIHdoaWNoIGlzIHNpZ25lZCBieSB0aGUgdmFsaWRhdG9yIHNldCwgd2hpY2ggd2UgYWxyZWFkeSB0cnVzdCwgdGhlIG5leHQgdmFsaWRhdG9yIHNldCB3aWxsIGJlXG4gICAgICogc3RvcmVkIHRvIHRoZSBuZXcga2V5LWJsb2NrIGFuZCBzaWduZWQgYnkgdGhlIGN1cnJlbnQgdmFsaWRhdG9yIHNldCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogSW4gb3JkZXIgdG8gcHJvdmUgYW55IGJsb2NrIGluIHRoZSBtYXN0ZXItY2hhaW4gd2UgbmVlZCB0byBjaGVjaywgdGhhdCBpdCBoYXMgYmVlbiBzaWduZWQgYnlcbiAgICAgKiBhIHRydXN0ZWQgdmFsaWRhdG9yIHNldC4gU28gd2UgbmVlZCB0byBjaGVjayBhbGwga2V5LWJsb2NrcycgcHJvb2ZzLCBzdGFydGVkIGZyb20gdGhlIHplcm8tc3RhdGVcbiAgICAgKiBhbmQgdW50aWwgdGhlIGJsb2NrLCB3aGljaCB3ZSB3YW50IHRvIHByb3ZlLiBCdXQgaXQgY2FuIHRha2UgYSBsb3Qgb2YgdGltZSBhbmQgdHJhZmZpYyB0b1xuICAgICAqIGRvd25sb2FkIGFuZCBwcm92ZSBhbGwga2V5LWJsb2NrcyBvbiBhIGNsaWVudC4gRm9yIHNvbHZpbmcgdGhpcywgc3BlY2lhbCB0cnVzdGVkIGJsb2NrcyBhcmUgdXNlZFxuICAgICAqIGluIEV2ZXItU0RLLlxuICAgICAqXG4gICAgICogVGhlIHRydXN0ZWQgYmxvY2sgaXMgdGhlIGF1dGhvcml0eSByb290LCBhcyB3ZWxsLCBhcyB0aGUgemVyby1zdGF0ZS4gRWFjaCB0cnVzdGVkIGJsb2NrIGlzIHRoZVxuICAgICAqIGBpZGAgKGUuZy4gYHJvb3RfaGFzaGApIG9mIHRoZSBhbHJlYWR5IHByb3ZlbiBrZXktYmxvY2suIFRoZXJlIGNhbiBiZSBwbGVudHkgb2YgdHJ1c3RlZFxuICAgICAqIGJsb2Nrcywgc28gdGhlcmUgY2FuIGJlIGEgbG90IG9mIGF1dGhvcml0eSByb290cy4gVGhlIGhhc2hlcyBvZiB0cnVzdGVkIGJsb2NrcyBmb3IgTWFpbk5ldFxuICAgICAqIGFuZCBEZXZOZXQgYXJlIGhhcmRjb2RlZCBpbiBTREsgaW4gYSBzZXBhcmF0ZWQgYmluYXJ5IGZpbGUgKHRydXN0ZWRfa2V5X2Jsb2Nrcy5iaW4pIGFuZCBpc1xuICAgICAqIGJlaW5nIHVwZGF0ZWQgZm9yIGVhY2ggcmVsZWFzZSBieSB1c2luZyBgdXBkYXRlX3RydXN0ZWRfYmxvY2tzYCB1dGlsaXR5LlxuICAgICAqXG4gICAgICogU2VlIFt1cGRhdGVfdHJ1c3RlZF9ibG9ja3NdKC4uLy4uLy4uL3Rvb2xzL3VwZGF0ZV90cnVzdGVkX2Jsb2NrcykgZGlyZWN0b3J5IGZvciBtb3JlIGluZm8uXG4gICAgICpcbiAgICAgKiBJbiBmdXR1cmUgU0RLIHJlbGVhc2VzLCBvbmUgd2lsbCBhbHNvIGJlIGFibGUgdG8gcHJvdmlkZSB0aGVpciBoYXNoZXMgb2YgdHJ1c3RlZCBibG9ja3MgZm9yXG4gICAgICogb3RoZXIgbmV0d29ya3MsIGJlc2lkZXMgZm9yIE1haW5OZXQgYW5kIERldk5ldC5cbiAgICAgKiBCeSB1c2luZyB0cnVzdGVkIGtleS1ibG9ja3MsIGluIG9yZGVyIHRvIHByb3ZlIGFueSBibG9jaywgd2UgY2FuIHByb3ZlIGNoYWluIG9mIGtleS1ibG9ja3MgdG9cbiAgICAgKiB0aGUgY2xvc2VzdCBwcmV2aW91cyB0cnVzdGVkIGtleS1ibG9jaywgbm90IG9ubHkgdG8gdGhlIHplcm8tc3RhdGUuXG4gICAgICpcbiAgICAgKiBCdXQgc2hhcmQtYmxvY2tzIGRvbid0IGhhdmUgcHJvb2ZzIG9uIERBcHAgc2VydmVyLiBJbiB0aGlzIGNhc2UsIGluIG9yZGVyIHRvIHByb3ZlIGFueSBzaGFyZC1cbiAgICAgKiBibG9jayBkYXRhLCB3ZSBzZWFyY2ggZm9yIGEgY29ycmVzcG9uZGluZyBtYXN0ZXItYmxvY2ssIHdoaWNoIGNvbnRhaW5zIHRoZSByb290IGhhc2ggb2YgdGhpc1xuICAgICAqIHNoYXJkLWJsb2NrLCBvciBzb21lIHNoYXJkIGJsb2NrIHdoaWNoIGlzIGxpbmtlZCB0byB0aGF0IGJsb2NrIGluIHNoYXJkLWNoYWluLiBBZnRlciBwcm92aW5nXG4gICAgICogdGhpcyBtYXN0ZXItYmxvY2ssIHdlIHRyYXZlcnNlIHRocm91Z2ggZWFjaCBsaW5rIGFuZCBjYWxjdWxhdGUgYW5kIGNvbXBhcmUgaGFzaGVzIHdpdGggbGlua3MsXG4gICAgICogb25lLWJ5LW9uZS4gQWZ0ZXIgdGhhdCB3ZSBjYW4gZW5zdXJlIHRoYXQgdGhpcyBzaGFyZC1ibG9jayBoYXMgYWxzbyBiZWVuIHByb3Zlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyYW1zT2ZQcm9vZkJsb2NrRGF0YX0gcGFyYW1zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBwcm9vZl9ibG9ja19kYXRhKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgncHJvb2ZzLnByb29mX2Jsb2NrX2RhdGEnLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92ZXMgdGhhdCBhIGdpdmVuIHRyYW5zYWN0aW9uJ3MgZGF0YSwgd2hpY2ggaXMgcXVlcmllZCBmcm9tIFRPTk9TIEFQSSwgY2FuIGJlIHRydXN0ZWQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoaXMgZnVuY3Rpb24gcmVxdWVzdHMgdGhlIGNvcnJlc3BvbmRpbmcgYmxvY2ssIGNoZWNrcyBibG9jayBwcm9vZnMsIGVuc3VyZXMgdGhhdCBnaXZlblxuICAgICAqIHRyYW5zYWN0aW9uIGV4aXN0cyBpbiB0aGUgcHJvdmVuIGJsb2NrIGFuZCBjb21wYXJlcyBnaXZlbiBkYXRhIHdpdGggdGhlIHByb3Zlbi5cbiAgICAgKiBJZiB0aGUgZ2l2ZW4gZGF0YSBkaWZmZXJzIGZyb20gdGhlIHByb3ZlbiwgdGhlIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAgICAgKiBUaGUgaW5wdXQgcGFyYW1ldGVyIGlzIGEgc2luZ2xlIHRyYW5zYWN0aW9uJ3MgSlNPTiBvYmplY3QgKHNlZSBwYXJhbXMgZGVzY3JpcHRpb24pLFxuICAgICAqIHdoaWNoIHdhcyBxdWVyaWVkIGZyb20gVE9OT1MgQVBJIHVzaW5nIGZ1bmN0aW9ucyBzdWNoIGFzIGBuZXQucXVlcnlgLCBgbmV0LnF1ZXJ5X2NvbGxlY3Rpb25gXG4gICAgICogb3IgYG5ldC53YWl0X2Zvcl9jb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIElmIHRyYW5zYWN0aW9uJ3MgQk9DIGFuZC9vciBgYmxvY2tfaWRgIGFyZSBub3QgcHJvdmlkZWQgaW4gdGhlIEpTT04sIHRoZXkgd2lsbCBiZSBxdWVyaWVkIGZyb21cbiAgICAgKiBUT05PUyBBUEkuXG4gICAgICpcbiAgICAgKiBQbGVhc2Ugbm90ZSwgdGhhdCBqb2lucyAobGlrZSBgYWNjb3VudGAsIGBpbl9tZXNzYWdlYCwgYG91dF9tZXNzYWdlc2AsIGV0Yy4gaW4gYFRyYW5zYWN0aW9uYFxuICAgICAqIGVudGl0eSkgYXJlIHNlcGFyYXRlZCBlbnRpdGllcyBhbmQgbm90IHN1cHBvcnRlZCwgc28gZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaW4gYSBjYXNlXG4gICAgICogaWYgSlNPTiBiZWluZyBjaGVja2VkIGhhcyBzdWNoIGVudGl0aWVzIGluIGl0LlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgcHJvb2ZzIGNoZWNraW5nLCBzZWUgZGVzY3JpcHRpb24gb2YgYHByb29mX2Jsb2NrX2RhdGFgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlByb29mVHJhbnNhY3Rpb25EYXRhfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHByb29mX3RyYW5zYWN0aW9uX2RhdGEocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KCdwcm9vZnMucHJvb2ZfdHJhbnNhY3Rpb25fZGF0YScsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZlcyB0aGF0IGEgZ2l2ZW4gbWVzc2FnZSdzIGRhdGEsIHdoaWNoIGlzIHF1ZXJpZWQgZnJvbSBUT05PUyBBUEksIGNhbiBiZSB0cnVzdGVkLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGZpcnN0IHByb3ZlcyB0aGUgY29ycmVzcG9uZGluZyB0cmFuc2FjdGlvbiwgZW5zdXJlcyB0aGF0IHRoZSBwcm92ZW4gdHJhbnNhY3Rpb25cbiAgICAgKiByZWZlcnMgdG8gdGhlIGdpdmVuIG1lc3NhZ2UgYW5kIGNvbXBhcmVzIGdpdmVuIGRhdGEgd2l0aCB0aGUgcHJvdmVuLlxuICAgICAqIElmIHRoZSBnaXZlbiBkYXRhIGRpZmZlcnMgZnJvbSB0aGUgcHJvdmVuLCB0aGUgZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICAgICAqIFRoZSBpbnB1dCBwYXJhbWV0ZXIgaXMgYSBzaW5nbGUgbWVzc2FnZSdzIEpTT04gb2JqZWN0IChzZWUgcGFyYW1zIGRlc2NyaXB0aW9uKSxcbiAgICAgKiB3aGljaCB3YXMgcXVlcmllZCBmcm9tIFRPTk9TIEFQSSB1c2luZyBmdW5jdGlvbnMgc3VjaCBhcyBgbmV0LnF1ZXJ5YCwgYG5ldC5xdWVyeV9jb2xsZWN0aW9uYFxuICAgICAqIG9yIGBuZXQud2FpdF9mb3JfY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBJZiBtZXNzYWdlJ3MgQk9DIGFuZC9vciBub24tbnVsbCBgc3JjX3RyYW5zYWN0aW9uLmlkYCBvciBgZHN0X3RyYW5zYWN0aW9uLmlkYCBhcmUgbm90IHByb3ZpZGVkXG4gICAgICogaW4gdGhlIEpTT04sIHRoZXkgd2lsbCBiZSBxdWVyaWVkIGZyb20gVE9OT1MgQVBJLlxuICAgICAqXG4gICAgICogUGxlYXNlIG5vdGUsIHRoYXQgam9pbnMgKGxpa2UgYGJsb2NrYCwgYGRzdF9hY2NvdW50YCwgYGRzdF90cmFuc2FjdGlvbmAsIGBzcmNfYWNjb3VudGAsXG4gICAgICogYHNyY190cmFuc2FjdGlvbmAsIGV0Yy4gaW4gYE1lc3NhZ2VgIGVudGl0eSkgYXJlIHNlcGFyYXRlZCBlbnRpdGllcyBhbmQgbm90IHN1cHBvcnRlZCxcbiAgICAgKiBzbyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpbiBhIGNhc2UgaWYgSlNPTiBiZWluZyBjaGVja2VkIGhhcyBzdWNoIGVudGl0aWVzIGluIGl0LlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgcHJvb2ZzIGNoZWNraW5nLCBzZWUgZGVzY3JpcHRpb24gb2YgYHByb29mX2Jsb2NrX2RhdGFgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbXNPZlByb29mTWVzc2FnZURhdGF9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcHJvb2ZfbWVzc2FnZV9kYXRhKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCgncHJvb2ZzLnByb29mX21lc3NhZ2VfZGF0YScsIHBhcmFtcyk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm9vZnNNb2R1bGUgPSBQcm9vZnNNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGVzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///691\n')},113:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"libWebSetup\": () => (/* binding */ libWebSetup),\n/* harmony export */   \"libWeb\": () => (/* binding */ libWeb)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n/*\n * Copyright 2018-2020 TON Labs LTD.\n *\n * Licensed under the SOFTWARE EVALUATION License (the \"License\"); you may not use\n * this file except in compliance with the License.\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific TON DEV software governing permissions and\n * limitations under the License.\n *\n */\n\n// This file is just a template that used to generate index.js at npm installation stage\n\nconst workerScript = `//****************************************************************** WRAPPER BEGIN\n\nlet wasm;\n\nconst cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = new Uint8Array();\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = new TextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedInt32Memory0 = new Int32Array();\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nlet cachedFloat64Memory0 = new Float64Array();\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nlet cachedBigInt64Memory0 = new BigInt64Array();\n\nfunction getBigInt64Memory0() {\n    if (cachedBigInt64Memory0.byteLength === 0) {\n        cachedBigInt64Memory0 = new BigInt64Array(wasm.memory.buffer);\n    }\n    return cachedBigInt64Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  \\`\\${val}\\`;\n    }\n    if (type == 'string') {\n        return \\`\"\\${val}\"\\`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return \\`Symbol(\\${description})\\`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return \\`Function(\\${name})\\`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\\\[object ([^\\\\]]+)\\\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of \\`val\\`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return \\`\\${val.name}: \\${val.message}\\\\n\\${val.stack}\\`;\n    }\n    // TODO we could test for more things here, like \\`Set\\`s and \\`Map\\`s.\n    return className;\n}\n\nfunction makeClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        try {\n            return f(state.a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(state.a, state.b);\n                state.a = 0;\n\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_50(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__Fn__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__he8db5fa167706a09(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wbg_adapter_53(arg0, arg1) {\n    wasm._dyn_core__ops__function__Fn_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hed540c88454df031(arg0, arg1);\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);\n\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_56(arg0, arg1) {\n    wasm._dyn_core__ops__function__FnMut_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hc182e4d50354196b(arg0, arg1);\n}\n\nfunction __wbg_adapter_59(arg0, arg1, arg2) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h7cbc3c322963706f(retptr, arg0, arg1, addHeapObject(arg2));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        if (r1) {\n            throw takeObject(r0);\n        }\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction __wbg_adapter_62(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h3709808ff1741914(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wbg_adapter_65(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h6c6161aacd664479(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wbg_adapter_68(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h68aa97d113ee360c(arg0, arg1, addHeapObject(arg2));\n}\n\n/**\n* @param {string} config_json\n* @returns {string}\n*/\nfunction core_create_context(config_json) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(config_json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.core_create_context(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\n/**\n* @param {number} context\n*/\nfunction core_destroy_context(context) {\n    wasm.core_destroy_context(context);\n}\n\n/**\n* @param {number} context\n* @param {string} function_name\n* @param {any} params\n* @param {number} request_id\n*/\nfunction core_request(context, function_name, params, request_id) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(function_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.core_request(retptr, context, ptr0, len0, addHeapObject(params), request_id);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        if (r1) {\n            throw takeObject(r0);\n        }\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nasync function load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"\\`WebAssembly.instantiateStreaming\\` failed because your server does not serve wasm with \\`application/wasm\\` MIME type. Falling back to \\`WebAssembly.instantiate\\` which is slower. Original error:\\\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction getImports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_new_8d2af00bc1e329ee = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_buffer_3f3d764d4747d564 = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_d9aa266703cb98be = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbg_newwithlength_7c42f7e738a9d5d3 = function(arg0) {\n        const ret = new Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_a68214f35c417fa9 = function(arg0, arg1, arg2) {\n        getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_newwithu8arraysequence_f863246af83e1785 = function() { return handleError(function (arg0) {\n        const ret = new Blob(getObject(arg0));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_get_765201544a2b6869 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_ArrayBuffer_e5e48f4762c5610b = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof ArrayBuffer;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbg_new_8c3f0052272a457a = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_keys_0702294afaeb6044 = function(arg0) {\n        const ret = Object.keys(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_length_6e3bbe7c8bd4dbd8 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_get_57245cc7d7c7619d = function(arg0, arg1) {\n        const ret = getObject(arg0)[arg1 >>> 0];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_new0_a57059d72c5b7aee = function() {\n        const ret = new Date();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getTime_cb82adb2556ed13e = function(arg0) {\n        const ret = getObject(arg0).getTime();\n        return ret;\n    };\n    imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {\n        const ret = getObject(arg0) == getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = getObject(arg0);\n        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_bigint = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'bigint';\n        return ret;\n    };\n    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'number' ? obj : undefined;\n        getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n    };\n    imports.wbg.__wbg_isSafeInteger_dfa0593e8d7ac35a = function(arg0) {\n        const ret = Number.isSafeInteger(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbindgen_bigint_get_as_i64 = function(arg0, arg1) {\n        const v = getObject(arg1);\n        const ret = typeof(v) === 'bigint' ? v : undefined;\n        getBigInt64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0n : ret;\n        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n    };\n    imports.wbg.__wbindgen_bigint_from_i64 = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_jsval_eq = function(arg0, arg1) {\n        const ret = getObject(arg0) === getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {\n        const ret = BigInt.asUintN(64, arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_isArray_27c46c67f498e15d = function(arg0) {\n        const ret = Array.isArray(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_iterator_6f9d4f28845f426c = function() {\n        const ret = Symbol.iterator;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_in = function(arg0, arg1) {\n        const ret = getObject(arg0) in getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg_entries_65a76a413fc91037 = function(arg0) {\n        const ret = Object.entries(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_null = function(arg0) {\n        const ret = getObject(arg0) === null;\n        return ret;\n    };\n    imports.wbg.__wbg_String_91fba7ded13ba54c = function(arg0, arg1) {\n        const ret = String(getObject(arg1));\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_0b9bfdd97583284e = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_String_33099856e8a8246a = function(arg0, arg1) {\n        const ret = String(getObject(arg1));\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_coreresponsehandler_a52879454c60c764 = function(arg0, arg1, arg2, arg3) {\n        core_response_handler(arg0 >>> 0, takeObject(arg1), arg2 >>> 0, arg3 !== 0);\n    };\n    imports.wbg.__wbg_message_fe2af63ccc8985bc = function(arg0) {\n        const ret = getObject(arg0).message;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_1d9a920c6bfc44a8 = function() {\n        const ret = new Array();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_268f7b7dd3430798 = function() {\n        const ret = new Map();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_933729cf5b66ac11 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbg_set_fbc33d020f507b72 = function(arg0, arg1, arg2) {\n        getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_process_0cc2ada8524d6f83 = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_versions_c11acceab27a6c87 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_node_7ff1ce49caf23815 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_NODE_MODULE_cf6401cc1091279e = function() {\n        const ret = module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_a746e79b322b9336 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_crypto_2036bed7c44c25e7 = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_msCrypto_a21fc88caf1ecdc8 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_f5933855e4f48a19 = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transaction_cce96cbebd81fe1c = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        const ret = getObject(arg0).transaction(getStringFromWasm0(arg1, arg2), takeObject(arg3));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_setoncomplete_3e57a8cec8327f66 = function(arg0, arg1) {\n        getObject(arg0).oncomplete = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonerror_00051c0213f27b2c = function(arg0, arg1) {\n        getObject(arg0).onerror = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonabort_404bee3b9940d03d = function(arg0, arg1) {\n        getObject(arg0).onabort = getObject(arg1);\n    };\n    imports.wbg.__wbg_item_52a6bec36314687b = function(arg0, arg1, arg2) {\n        const ret = getObject(arg1).item(arg2 >>> 0);\n        var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_objectStore_f17976b0e6377830 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).objectStore(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_target_bf704b7db7ad1387 = function(arg0) {\n        const ret = getObject(arg0).target;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_readyState_fb287f170113917c = function(arg0) {\n        const ret = getObject(arg0).readyState;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_setonsuccess_5f71593bc51653a3 = function(arg0, arg1) {\n        getObject(arg0).onsuccess = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonerror_d5771cc5bf9ea74c = function(arg0, arg1) {\n        getObject(arg0).onerror = getObject(arg1);\n    };\n    imports.wbg.__wbindgen_cb_drop = function(arg0) {\n        const obj = takeObject(arg0).original;\n        if (obj.cnt-- == 1) {\n            obj.a = 0;\n            return true;\n        }\n        const ret = false;\n        return ret;\n    };\n    imports.wbg.__wbg_next_aaef7c8aa5e212ac = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).next();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_done_1b73b0672e15f234 = function(arg0) {\n        const ret = getObject(arg0).done;\n        return ret;\n    };\n    imports.wbg.__wbg_value_1ccc36bc03462d71 = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbg_call_97ae9d8645dc388b = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_next_579e583d33566a86 = function(arg0) {\n        const ret = getObject(arg0).next;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_self_6d479506f72c6a71 = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_window_f2557cc78490aceb = function() { return handleError(function () {\n        const ret = window.window;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_7f206bda628d5286 = function() { return handleError(function () {\n        const ret = globalThis.globalThis;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_global_ba75c50d1cf384f4 = function() { return handleError(function () {\n        const ret = global.global;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_newnoargs_b5b063fc6c2f0376 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_83db9690f9353e79 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_length_9e1ae1900cb0fbd5 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_set_bf3f89b92d5a34bf = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_self_7eede1f4488bf346 = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_crypto_c909fb428dcbddb6 = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_msCrypto_511eefefbfc70ae4 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_MODULE_ef3aa2eb251158a5 = function() {\n        const ret = module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_900d5c3984fe7703 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getRandomValues_307049345d0bd88c = function(arg0) {\n        const ret = getObject(arg0).getRandomValues;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_randomFillSync_85b3f4c52c56c313 = function(arg0, arg1, arg2) {\n        getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n    };\n    imports.wbg.__wbg_subarray_58ad4efbb5bcb886 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getRandomValues_cd175915511f705e = function(arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    };\n    imports.wbg.__wbg_randomFillSync_065afffde01daa66 = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_getRandomValues_b99eec4244a475bb = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_Uint8Array_971eeda69eb75003 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Uint8Array;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_put_84e7fc93eee27b28 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).put(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_delete_8abedd1043b4105d = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).delete(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_setTimeout_d6fcf0d9067b8e64 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).setTimeout(getObject(arg1), arg2);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_clearTimeout_7d6f7bfeed34b348 = function(arg0, arg1) {\n        getObject(arg0).clearTimeout(arg1);\n    };\n    imports.wbg.__wbg_newwithstrandinit_05d7180788420c40 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_headers_85824e993aa739bf = function(arg0) {\n        const ret = getObject(arg0).headers;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_992c1d31586b2957 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).set(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n    }, arguments) };\n    imports.wbg.__wbg_fetch_0fe04905cccfc2aa = function(arg0, arg1) {\n        const ret = getObject(arg0).fetch(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_instanceof_Response_eaa426220848a39e = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Response;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_status_c4ef3dd591e63435 = function(arg0) {\n        const ret = getObject(arg0).status;\n        return ret;\n    };\n    imports.wbg.__wbg_url_74285ddf2747cb3d = function(arg0, arg1) {\n        const ret = getObject(arg1).url;\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_setonversionchange_840d65cd0888dfb0 = function(arg0, arg1) {\n        getObject(arg0).onversionchange = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonupgradeneeded_17d0b9530f1e0cac = function(arg0, arg1) {\n        getObject(arg0).onupgradeneeded = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonblocked_e66d6be5c879980d = function(arg0, arg1) {\n        getObject(arg0).onblocked = getObject(arg1);\n    };\n    imports.wbg.__wbg_message_a7af3ee0cc0fe28d = function(arg0, arg1) {\n        const ret = getObject(arg1).message;\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_Window_5684341ff6dfe3ad = function(arg0) {\n        const ret = getObject(arg0).Window;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_WorkerGlobalScope_e0447ffcae8bb272 = function(arg0) {\n        const ret = getObject(arg0).WorkerGlobalScope;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_indexedDB_050f0962ab607ac5 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).indexedDB;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_indexedDB_8d9e9ab4616df7f0 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).indexedDB;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_open_a31c3fe1fdc244eb = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).open(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_newwithstr_d5b5f9b985ee84fb = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        const ret = new WebSocket(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_d29e507f6606de91 = function() { return handleError(function (arg0, arg1) {\n        const ret = new WebSocket(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_setonmessage_c5a806b62a0c5607 = function(arg0, arg1) {\n        getObject(arg0).onmessage = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonopen_9ce48dce57e549b5 = function(arg0, arg1) {\n        getObject(arg0).onopen = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonerror_02393260b3e29972 = function(arg0, arg1) {\n        getObject(arg0).onerror = getObject(arg1);\n    };\n    imports.wbg.__wbg_send_80b256d87a6779e5 = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).send(getStringFromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_data_7b1f01f4e6a64fbe = function(arg0) {\n        const ret = getObject(arg0).data;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stringify_d6471d300ded9b68 = function() { return handleError(function (arg0) {\n        const ret = JSON.stringify(getObject(arg0));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_objectStoreNames_8c06c40d2b05141c = function(arg0) {\n        const ret = getObject(arg0).objectStoreNames;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_createObjectStore_d3e2789c13dde1fc = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).createObjectStore(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_Error_56b496a10a56de66 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Error;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_getTimezoneOffset_89bd4275e1ca8341 = function(arg0) {\n        const ret = getObject(arg0).getTimezoneOffset();\n        return ret;\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(getObject(arg1));\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbg_then_cedad20fbbd9418a = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_resolve_99fe17964f31ffc0 = function(arg0) {\n        const ret = Promise.resolve(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_11f7a54d67b4bfad = function(arg0, arg1) {\n        const ret = getObject(arg0).then(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_result_9e399c14676970d9 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).result;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_error_aacf5ac191e54ed0 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).error;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_get_6285bf458a1ee758 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).get(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_Window_acc97ff9f5d2c7b4 = function(arg0) {\n        let result;\n        try {\n            result = true;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_close_45d053bea59e7746 = function() { return handleError(function (arg0) {\n        getObject(arg0).close();\n    }, arguments) };\n    imports.wbg.__wbg_text_1169d752cc697903 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).text();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_closure_wrapper947 = function(arg0, arg1, arg2) {\n        const ret = makeClosure(arg0, arg1, 44, __wbg_adapter_50);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper958 = function(arg0, arg1, arg2) {\n        const ret = makeClosure(arg0, arg1, 47, __wbg_adapter_53);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6159 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 238, __wbg_adapter_56);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6824 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 247, __wbg_adapter_59);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6874 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 244, __wbg_adapter_62);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6875 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 1206, __wbg_adapter_65);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6876 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 241, __wbg_adapter_68);\n        return addHeapObject(ret);\n    };\n\n    return imports;\n}\n\nfunction initMemory(imports, maybe_memory) {\n\n}\n\nfunction finalizeInit(instance, module) {\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n    cachedBigInt64Memory0 = new BigInt64Array();\n    cachedFloat64Memory0 = new Float64Array();\n    cachedInt32Memory0 = new Int32Array();\n    cachedUint8Memory0 = new Uint8Array();\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    const imports = getImports();\n\n    initMemory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return finalizeInit(instance, module);\n}\n\nasync function init(input) {\n    if (typeof input === 'undefined') {    }\n    const imports = getImports();\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    initMemory(imports);\n\n    const { instance, module } = await load(await input, imports);\n\n    return finalizeInit(instance, module);\n}\n\n\n//****************************************************************** WRAPPER END\n\nfunction replaceUndefinedWithNulls(value) {\n    if (value === undefined) {\n        return null;\n    }\n    if (value instanceof Blob) {\n        return value;\n    }\n    if (typeof value === \"object\" && value !== null) {\n        const result = Array.isArray(value) ? [] : {};\n        for (const key in value) {\n            result[key] = replaceUndefinedWithNulls(value[key]);\n        }\n        return result;\n    }\n    return value;\n};\n\nfunction core_response_handler(request_id, params, response_type, finished) {\n    postMessage({\n        type: 'response',\n        requestId: request_id,\n        params: replaceUndefinedWithNulls(params),\n        responseType: response_type,\n        finished,\n    });\n}\n\nasync function replaceBlobsWithArrayBuffers(value) {\n    if (value instanceof Blob) {\n        return await value.arrayBuffer();\n    }\n    if (typeof value === \"bigint\") {\n        if (value < Number.MAX_SAFE_INTEGER && value > Number.MIN_SAFE_INTEGER) {\n            return Number(value);\n        } else {\n            return value.toString();\n        }\n    }\n    if (typeof value === \"object\" && value !== null) {\n        const result = Array.isArray(value) ? [] : {};\n        for (const key in value) {\n            result[key] = await replaceBlobsWithArrayBuffers(value[key]);\n        }\n        return result;\n    }\n    return value;\n}\n\nself.onmessage = (e) => {\n    const message = e.data;\n    switch (message.type) {\n    case 'init':\n        (async () => {\n            await init(message.wasmModule);\n            postMessage({ type: 'init' });\n        })();\n        break;\n\n    case 'createContext':\n        postMessage({\n            type: 'createContext',\n            result: core_create_context(message.configJson),\n            requestId: message.requestId,\n        });\n        break;\n\n    case 'destroyContext':\n        core_destroy_context(message.context);\n        postMessage({\n            type: 'destroyContext'\n        });\n        break;\n\n    case 'request':\n        (async () => {\n            core_request(\n                message.context,\n                message.functionName,\n                await replaceBlobsWithArrayBuffers(message.functionParams),\n                message.requestId,\n            );\n        })();\n        break;\n    }\n};\n`;\n\nlet options = null;\n\nfunction libWebSetup(libOptions) {\n    options = libOptions;\n}\n\nfunction debugLog(message) {\n    if (options && options.debugLog) {\n        options.debugLog(message);\n    }\n}\n\n\nasync function loadModule() {\n    const startLoadTime = Date.now();\n    let wasmModule;\n    if (options && options.loadModule) {\n        wasmModule = await options.loadModule;\n    } else {\n        const fetched = fetch((options && options.binaryURL) || \"/eversdk.wasm\");\n        if (WebAssembly.compileStreaming) {\n            debugLog(\"compileStreaming binary\");\n            return await WebAssembly.compileStreaming(fetched);\n        }\n        debugLog(\"compile binary\");\n        wasmModule = await WebAssembly.compile(await (await fetched).arrayBuffer());\n    }\n    await init(wasmModule);\n    debugLog(`compile time ${Date.now() - startLoadTime}`);\n}\n\nfunction withSeparateWorker() {\n    function debugLog(message) {\n        if (options && options.debugLog) {\n            options.debugLog(message);\n        }\n    }\n\n    const workerBlob = new Blob(\n        [workerScript],\n        { type: \"application/javascript\" },\n    );\n    const workerUrl = URL.createObjectURL(workerBlob);\n    const worker = new Worker(workerUrl);\n\n\n    let nextCreateContextRequestId = 1;\n    const createContextRequests = new Map();\n    let initComplete = false;\n\n    let responseHandler = null;\n\n    worker.onmessage = (evt) => {\n        const message = evt.data;\n        switch (message.type) {\n        case \"init\":\n            initComplete = true;\n            for (const [requestId, request] of createContextRequests.entries()) {\n                worker.postMessage({\n                    type: \"createContext\",\n                    requestId,\n                    configJson: request.configJson,\n                });\n            }\n            break;\n        case \"createContext\":\n            const request = createContextRequests.get(message.requestId);\n            if (request) {\n                createContextRequests.delete(message.requestId);\n                request.resolve(message.result);\n            }\n            break;\n        case \"destroyContext\":\n            break;\n        case \"response\":\n            if (responseHandler) {\n                responseHandler(\n                    message.requestId,\n                    message.params,\n                    message.responseType,\n                    message.finished,\n                );\n            }\n            break;\n        }\n    };\n\n    worker.onerror = (evt) => {\n        console.log(`Error from Web Worker: ${evt.message}`);\n    };\n\n    (async () => {\n        worker.postMessage({\n            type: \"init\",\n            wasmModule: await loadModule(),\n        });\n    })();\n\n    return Promise.resolve({\n        setResponseParamsHandler: (handler) => {\n            responseHandler = handler;\n        },\n        createContext: (configJson) => {\n            return new Promise((resolve) => {\n                const requestId = nextCreateContextRequestId;\n                nextCreateContextRequestId += 1;\n                createContextRequests.set(requestId, {\n                    configJson,\n                    resolve,\n                });\n                if (initComplete) {\n                    worker.postMessage({\n                        type: \"createContext\",\n                        requestId,\n                        configJson,\n                    });\n                }\n            });\n        },\n        destroyContext: (context) => {\n            worker.postMessage({\n                type: \"destroyContext\",\n                context,\n            });\n        },\n        sendRequestParams: (context, requestId, functionName, functionParams) => {\n            worker.postMessage({\n                type: \"request\",\n                context,\n                requestId,\n                functionName,\n                functionParams,\n            });\n        },\n    });\n}\n\nfunction withoutSeparateWorker() {\n//****************************************************************** WRAPPER BEGIN\n\nlet wasm;\n\nconst cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = new Uint8Array();\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = new TextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedInt32Memory0 = new Int32Array();\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nlet cachedFloat64Memory0 = new Float64Array();\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nlet cachedBigInt64Memory0 = new BigInt64Array();\n\nfunction getBigInt64Memory0() {\n    if (cachedBigInt64Memory0.byteLength === 0) {\n        cachedBigInt64Memory0 = new BigInt64Array(wasm.memory.buffer);\n    }\n    return cachedBigInt64Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction makeClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        try {\n            return f(state.a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(state.a, state.b);\n                state.a = 0;\n\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_50(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__Fn__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__he8db5fa167706a09(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wbg_adapter_53(arg0, arg1) {\n    wasm._dyn_core__ops__function__Fn_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hed540c88454df031(arg0, arg1);\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);\n\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_56(arg0, arg1) {\n    wasm._dyn_core__ops__function__FnMut_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hc182e4d50354196b(arg0, arg1);\n}\n\nfunction __wbg_adapter_59(arg0, arg1, arg2) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h7cbc3c322963706f(retptr, arg0, arg1, addHeapObject(arg2));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        if (r1) {\n            throw takeObject(r0);\n        }\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction __wbg_adapter_62(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h3709808ff1741914(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wbg_adapter_65(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h6c6161aacd664479(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wbg_adapter_68(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h68aa97d113ee360c(arg0, arg1, addHeapObject(arg2));\n}\n\n/**\n* @param {string} config_json\n* @returns {string}\n*/\nfunction core_create_context(config_json) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(config_json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.core_create_context(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\n/**\n* @param {number} context\n*/\nfunction core_destroy_context(context) {\n    wasm.core_destroy_context(context);\n}\n\n/**\n* @param {number} context\n* @param {string} function_name\n* @param {any} params\n* @param {number} request_id\n*/\nfunction core_request(context, function_name, params, request_id) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(function_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.core_request(retptr, context, ptr0, len0, addHeapObject(params), request_id);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        if (r1) {\n            throw takeObject(r0);\n        }\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nasync function load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction getImports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_new_8d2af00bc1e329ee = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_buffer_3f3d764d4747d564 = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_d9aa266703cb98be = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbg_newwithlength_7c42f7e738a9d5d3 = function(arg0) {\n        const ret = new Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_a68214f35c417fa9 = function(arg0, arg1, arg2) {\n        getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_newwithu8arraysequence_f863246af83e1785 = function() { return handleError(function (arg0) {\n        const ret = new Blob(getObject(arg0));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_get_765201544a2b6869 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_ArrayBuffer_e5e48f4762c5610b = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof ArrayBuffer;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbg_new_8c3f0052272a457a = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_keys_0702294afaeb6044 = function(arg0) {\n        const ret = Object.keys(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_length_6e3bbe7c8bd4dbd8 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_get_57245cc7d7c7619d = function(arg0, arg1) {\n        const ret = getObject(arg0)[arg1 >>> 0];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_new0_a57059d72c5b7aee = function() {\n        const ret = new Date();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getTime_cb82adb2556ed13e = function(arg0) {\n        const ret = getObject(arg0).getTime();\n        return ret;\n    };\n    imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {\n        const ret = getObject(arg0) == getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = getObject(arg0);\n        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_bigint = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'bigint';\n        return ret;\n    };\n    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'number' ? obj : undefined;\n        getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n    };\n    imports.wbg.__wbg_isSafeInteger_dfa0593e8d7ac35a = function(arg0) {\n        const ret = Number.isSafeInteger(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbindgen_bigint_get_as_i64 = function(arg0, arg1) {\n        const v = getObject(arg1);\n        const ret = typeof(v) === 'bigint' ? v : undefined;\n        getBigInt64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0n : ret;\n        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n    };\n    imports.wbg.__wbindgen_bigint_from_i64 = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_jsval_eq = function(arg0, arg1) {\n        const ret = getObject(arg0) === getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {\n        const ret = BigInt.asUintN(64, arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_isArray_27c46c67f498e15d = function(arg0) {\n        const ret = Array.isArray(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_iterator_6f9d4f28845f426c = function() {\n        const ret = Symbol.iterator;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_in = function(arg0, arg1) {\n        const ret = getObject(arg0) in getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg_entries_65a76a413fc91037 = function(arg0) {\n        const ret = Object.entries(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_null = function(arg0) {\n        const ret = getObject(arg0) === null;\n        return ret;\n    };\n    imports.wbg.__wbg_String_91fba7ded13ba54c = function(arg0, arg1) {\n        const ret = String(getObject(arg1));\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_0b9bfdd97583284e = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_String_33099856e8a8246a = function(arg0, arg1) {\n        const ret = String(getObject(arg1));\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_coreresponsehandler_a52879454c60c764 = function(arg0, arg1, arg2, arg3) {\n        core_response_handler(arg0 >>> 0, takeObject(arg1), arg2 >>> 0, arg3 !== 0);\n    };\n    imports.wbg.__wbg_message_fe2af63ccc8985bc = function(arg0) {\n        const ret = getObject(arg0).message;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_1d9a920c6bfc44a8 = function() {\n        const ret = new Array();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_268f7b7dd3430798 = function() {\n        const ret = new Map();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_933729cf5b66ac11 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbg_set_fbc33d020f507b72 = function(arg0, arg1, arg2) {\n        getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_process_0cc2ada8524d6f83 = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_versions_c11acceab27a6c87 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_node_7ff1ce49caf23815 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_NODE_MODULE_cf6401cc1091279e = function() {\n        const ret = module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_a746e79b322b9336 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_crypto_2036bed7c44c25e7 = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_msCrypto_a21fc88caf1ecdc8 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_f5933855e4f48a19 = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transaction_cce96cbebd81fe1c = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        const ret = getObject(arg0).transaction(getStringFromWasm0(arg1, arg2), takeObject(arg3));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_setoncomplete_3e57a8cec8327f66 = function(arg0, arg1) {\n        getObject(arg0).oncomplete = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonerror_00051c0213f27b2c = function(arg0, arg1) {\n        getObject(arg0).onerror = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonabort_404bee3b9940d03d = function(arg0, arg1) {\n        getObject(arg0).onabort = getObject(arg1);\n    };\n    imports.wbg.__wbg_item_52a6bec36314687b = function(arg0, arg1, arg2) {\n        const ret = getObject(arg1).item(arg2 >>> 0);\n        var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_objectStore_f17976b0e6377830 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).objectStore(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_target_bf704b7db7ad1387 = function(arg0) {\n        const ret = getObject(arg0).target;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_readyState_fb287f170113917c = function(arg0) {\n        const ret = getObject(arg0).readyState;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_setonsuccess_5f71593bc51653a3 = function(arg0, arg1) {\n        getObject(arg0).onsuccess = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonerror_d5771cc5bf9ea74c = function(arg0, arg1) {\n        getObject(arg0).onerror = getObject(arg1);\n    };\n    imports.wbg.__wbindgen_cb_drop = function(arg0) {\n        const obj = takeObject(arg0).original;\n        if (obj.cnt-- == 1) {\n            obj.a = 0;\n            return true;\n        }\n        const ret = false;\n        return ret;\n    };\n    imports.wbg.__wbg_next_aaef7c8aa5e212ac = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).next();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_done_1b73b0672e15f234 = function(arg0) {\n        const ret = getObject(arg0).done;\n        return ret;\n    };\n    imports.wbg.__wbg_value_1ccc36bc03462d71 = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbg_call_97ae9d8645dc388b = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_next_579e583d33566a86 = function(arg0) {\n        const ret = getObject(arg0).next;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_self_6d479506f72c6a71 = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_window_f2557cc78490aceb = function() { return handleError(function () {\n        const ret = window.window;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_7f206bda628d5286 = function() { return handleError(function () {\n        const ret = globalThis.globalThis;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_global_ba75c50d1cf384f4 = function() { return handleError(function () {\n        const ret = __webpack_require__.g.global;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_newnoargs_b5b063fc6c2f0376 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_83db9690f9353e79 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_length_9e1ae1900cb0fbd5 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_set_bf3f89b92d5a34bf = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_self_7eede1f4488bf346 = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_crypto_c909fb428dcbddb6 = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_msCrypto_511eefefbfc70ae4 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_MODULE_ef3aa2eb251158a5 = function() {\n        const ret = module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_900d5c3984fe7703 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getRandomValues_307049345d0bd88c = function(arg0) {\n        const ret = getObject(arg0).getRandomValues;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_randomFillSync_85b3f4c52c56c313 = function(arg0, arg1, arg2) {\n        getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n    };\n    imports.wbg.__wbg_subarray_58ad4efbb5bcb886 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getRandomValues_cd175915511f705e = function(arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    };\n    imports.wbg.__wbg_randomFillSync_065afffde01daa66 = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_getRandomValues_b99eec4244a475bb = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_Uint8Array_971eeda69eb75003 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Uint8Array;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_put_84e7fc93eee27b28 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).put(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_delete_8abedd1043b4105d = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).delete(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_setTimeout_d6fcf0d9067b8e64 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).setTimeout(getObject(arg1), arg2);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_clearTimeout_7d6f7bfeed34b348 = function(arg0, arg1) {\n        getObject(arg0).clearTimeout(arg1);\n    };\n    imports.wbg.__wbg_newwithstrandinit_05d7180788420c40 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_headers_85824e993aa739bf = function(arg0) {\n        const ret = getObject(arg0).headers;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_992c1d31586b2957 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).set(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n    }, arguments) };\n    imports.wbg.__wbg_fetch_0fe04905cccfc2aa = function(arg0, arg1) {\n        const ret = getObject(arg0).fetch(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_instanceof_Response_eaa426220848a39e = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Response;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_status_c4ef3dd591e63435 = function(arg0) {\n        const ret = getObject(arg0).status;\n        return ret;\n    };\n    imports.wbg.__wbg_url_74285ddf2747cb3d = function(arg0, arg1) {\n        const ret = getObject(arg1).url;\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_setonversionchange_840d65cd0888dfb0 = function(arg0, arg1) {\n        getObject(arg0).onversionchange = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonupgradeneeded_17d0b9530f1e0cac = function(arg0, arg1) {\n        getObject(arg0).onupgradeneeded = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonblocked_e66d6be5c879980d = function(arg0, arg1) {\n        getObject(arg0).onblocked = getObject(arg1);\n    };\n    imports.wbg.__wbg_message_a7af3ee0cc0fe28d = function(arg0, arg1) {\n        const ret = getObject(arg1).message;\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_Window_5684341ff6dfe3ad = function(arg0) {\n        const ret = getObject(arg0).Window;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_WorkerGlobalScope_e0447ffcae8bb272 = function(arg0) {\n        const ret = getObject(arg0).WorkerGlobalScope;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_indexedDB_050f0962ab607ac5 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).indexedDB;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_indexedDB_8d9e9ab4616df7f0 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).indexedDB;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_open_a31c3fe1fdc244eb = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).open(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_newwithstr_d5b5f9b985ee84fb = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        const ret = new WebSocket(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_d29e507f6606de91 = function() { return handleError(function (arg0, arg1) {\n        const ret = new WebSocket(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_setonmessage_c5a806b62a0c5607 = function(arg0, arg1) {\n        getObject(arg0).onmessage = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonopen_9ce48dce57e549b5 = function(arg0, arg1) {\n        getObject(arg0).onopen = getObject(arg1);\n    };\n    imports.wbg.__wbg_setonerror_02393260b3e29972 = function(arg0, arg1) {\n        getObject(arg0).onerror = getObject(arg1);\n    };\n    imports.wbg.__wbg_send_80b256d87a6779e5 = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).send(getStringFromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_data_7b1f01f4e6a64fbe = function(arg0) {\n        const ret = getObject(arg0).data;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stringify_d6471d300ded9b68 = function() { return handleError(function (arg0) {\n        const ret = JSON.stringify(getObject(arg0));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_objectStoreNames_8c06c40d2b05141c = function(arg0) {\n        const ret = getObject(arg0).objectStoreNames;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_createObjectStore_d3e2789c13dde1fc = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).createObjectStore(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_Error_56b496a10a56de66 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Error;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_getTimezoneOffset_89bd4275e1ca8341 = function(arg0) {\n        const ret = getObject(arg0).getTimezoneOffset();\n        return ret;\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(getObject(arg1));\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbg_then_cedad20fbbd9418a = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_resolve_99fe17964f31ffc0 = function(arg0) {\n        const ret = Promise.resolve(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_11f7a54d67b4bfad = function(arg0, arg1) {\n        const ret = getObject(arg0).then(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_result_9e399c14676970d9 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).result;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_error_aacf5ac191e54ed0 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).error;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_get_6285bf458a1ee758 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).get(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_Window_acc97ff9f5d2c7b4 = function(arg0) {\n        let result;\n        try {\n            result = true;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_close_45d053bea59e7746 = function() { return handleError(function (arg0) {\n        getObject(arg0).close();\n    }, arguments) };\n    imports.wbg.__wbg_text_1169d752cc697903 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).text();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_closure_wrapper947 = function(arg0, arg1, arg2) {\n        const ret = makeClosure(arg0, arg1, 44, __wbg_adapter_50);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper958 = function(arg0, arg1, arg2) {\n        const ret = makeClosure(arg0, arg1, 47, __wbg_adapter_53);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6159 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 238, __wbg_adapter_56);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6824 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 247, __wbg_adapter_59);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6874 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 244, __wbg_adapter_62);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6875 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 1206, __wbg_adapter_65);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6876 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 241, __wbg_adapter_68);\n        return addHeapObject(ret);\n    };\n\n    return imports;\n}\n\nfunction initMemory(imports, maybe_memory) {\n\n}\n\nfunction finalizeInit(instance, module) {\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n    cachedBigInt64Memory0 = new BigInt64Array();\n    cachedFloat64Memory0 = new Float64Array();\n    cachedInt32Memory0 = new Int32Array();\n    cachedUint8Memory0 = new Uint8Array();\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    const imports = getImports();\n\n    initMemory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return finalizeInit(instance, module);\n}\n\nasync function init(input) {\n    if (typeof input === 'undefined') {    }\n    const imports = getImports();\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    initMemory(imports);\n\n    const { instance, module } = await load(await input, imports);\n\n    return finalizeInit(instance, module);\n}\n\n\n//****************************************************************** WRAPPER END\n    function replaceUndefinedWithNulls(value) {\n        if (value === undefined) {\n            return null;\n        }\n        if (value instanceof Blob) {\n            return value;\n        }\n        if (typeof value === \"object\" && value !== null) {\n            const result = Array.isArray(value) ? [] : {};\n            for (const key in value) {\n                result[key] = replaceUndefinedWithNulls(value[key]);\n            }\n            return result;\n        }\n        return value;\n    }\n\n    async function replaceBlobsWithArrayBuffers(value) {\n        if (value instanceof Blob) {\n            return await value.arrayBuffer();\n        }\n        if (typeof value === \"bigint\") {\n            if (value < Number.MAX_SAFE_INTEGER && value > Number.MIN_SAFE_INTEGER) {\n                return Number(value);\n            } else {\n                return value.toString();\n            }\n        }\n        if (typeof value === \"object\" && value !== null) {\n            const result = Array.isArray(value) ? [] : {};\n            for (const key in value) {\n                result[key] = await replaceBlobsWithArrayBuffers(value[key]);\n            }\n            return result;\n        }\n        return value;\n    }\n\n\n    let deferredCreateContext = [];\n    let responseHandler = null;\n\n    function core_response_handler(request_id, params, response_type, finished) {\n        if (responseHandler) {\n            responseHandler(\n                request_id,\n                params,\n                response_type,\n                finished,\n            );\n        }\n    }\n\n    (async () => {\n        await init(await loadModule());\n        for (const createContext of deferredCreateContext) {\n            createContext.resolve(core_create_context(createContext.configJson));\n        }\n        deferredCreateContext = null;\n    })();\n\n    return Promise.resolve({\n        setResponseParamsHandler: (handler) => {\n            responseHandler = handler;\n        },\n        createContext: (configJson) => {\n            return deferredCreateContext === null\n                ? Promise.resolve(core_create_context(configJson))\n                : new Promise((resolve) => {\n                    deferredCreateContext.push({\n                        configJson,\n                        resolve,\n                    });\n                });\n        },\n        destroyContext: (context) => {\n            core_destroy_context(context);\n        },\n        sendRequestParams: (context, requestId, functionName, functionParams) => {\n            (async () => {\n                core_request(\n                    context,\n                    functionName,\n                    await replaceBlobsWithArrayBuffers(functionParams),\n                    requestId,\n                );\n            })();\n        },\n    });\n\n}\n\nfunction libWeb() {\n    return options && options.disableSeparateWorker ? withoutSeparateWorker() : withSeparateWorker();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL0BldmVyc2RrL2xpYi13ZWIvaW5kZXguanM/NzgzMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMTgtMjAyMCBUT04gTGFicyBMVEQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIFNPRlRXQVJFIEVWQUxVQVRJT04gTGljZW5zZSAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXG4gKiB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIFRPTiBERVYgc29mdHdhcmUgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbi8vIFRoaXMgZmlsZSBpcyBqdXN0IGEgdGVtcGxhdGUgdGhhdCB1c2VkIHRvIGdlbmVyYXRlIGluZGV4LmpzIGF0IG5wbSBpbnN0YWxsYXRpb24gc3RhZ2VcblxuY29uc3Qgd29ya2VyU2NyaXB0ID0gYC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFdSQVBQRVIgQkVHSU5cblxubGV0IHdhc207XG5cbmNvbnN0IGNhY2hlZFRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgaWdub3JlQk9NOiB0cnVlLCBmYXRhbDogdHJ1ZSB9KTtcblxuY2FjaGVkVGV4dERlY29kZXIuZGVjb2RlKCk7XG5cbmxldCBjYWNoZWRVaW50OE1lbW9yeTAgPSBuZXcgVWludDhBcnJheSgpO1xuXG5mdW5jdGlvbiBnZXRVaW50OE1lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZFVpbnQ4TWVtb3J5MC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhY2hlZFVpbnQ4TWVtb3J5MCA9IG5ldyBVaW50OEFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRVaW50OE1lbW9yeTA7XG59XG5cbmZ1bmN0aW9uIGdldFN0cmluZ0Zyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHJldHVybiBjYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoZ2V0VWludDhNZW1vcnkwKCkuc3ViYXJyYXkocHRyLCBwdHIgKyBsZW4pKTtcbn1cblxuY29uc3QgaGVhcCA9IG5ldyBBcnJheSgzMikuZmlsbCh1bmRlZmluZWQpO1xuXG5oZWFwLnB1c2godW5kZWZpbmVkLCBudWxsLCB0cnVlLCBmYWxzZSk7XG5cbmxldCBoZWFwX25leHQgPSBoZWFwLmxlbmd0aDtcblxuZnVuY3Rpb24gYWRkSGVhcE9iamVjdChvYmopIHtcbiAgICBpZiAoaGVhcF9uZXh0ID09PSBoZWFwLmxlbmd0aCkgaGVhcC5wdXNoKGhlYXAubGVuZ3RoICsgMSk7XG4gICAgY29uc3QgaWR4ID0gaGVhcF9uZXh0O1xuICAgIGhlYXBfbmV4dCA9IGhlYXBbaWR4XTtcblxuICAgIGhlYXBbaWR4XSA9IG9iajtcbiAgICByZXR1cm4gaWR4O1xufVxuXG5mdW5jdGlvbiBnZXRPYmplY3QoaWR4KSB7IHJldHVybiBoZWFwW2lkeF07IH1cblxuZnVuY3Rpb24gZHJvcE9iamVjdChpZHgpIHtcbiAgICBpZiAoaWR4IDwgMzYpIHJldHVybjtcbiAgICBoZWFwW2lkeF0gPSBoZWFwX25leHQ7XG4gICAgaGVhcF9uZXh0ID0gaWR4O1xufVxuXG5mdW5jdGlvbiB0YWtlT2JqZWN0KGlkeCkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChpZHgpO1xuICAgIGRyb3BPYmplY3QoaWR4KTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5sZXQgV0FTTV9WRUNUT1JfTEVOID0gMDtcblxuY29uc3QgY2FjaGVkVGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoJ3V0Zi04Jyk7XG5cbmNvbnN0IGVuY29kZVN0cmluZyA9ICh0eXBlb2YgY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlSW50byA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZnVuY3Rpb24gKGFyZywgdmlldykge1xuICAgIHJldHVybiBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGVJbnRvKGFyZywgdmlldyk7XG59XG4gICAgOiBmdW5jdGlvbiAoYXJnLCB2aWV3KSB7XG4gICAgY29uc3QgYnVmID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlKGFyZyk7XG4gICAgdmlldy5zZXQoYnVmKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWFkOiBhcmcubGVuZ3RoLFxuICAgICAgICB3cml0dGVuOiBidWYubGVuZ3RoXG4gICAgfTtcbn0pO1xuXG5mdW5jdGlvbiBwYXNzU3RyaW5nVG9XYXNtMChhcmcsIG1hbGxvYywgcmVhbGxvYykge1xuXG4gICAgaWYgKHJlYWxsb2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBidWYgPSBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGUoYXJnKTtcbiAgICAgICAgY29uc3QgcHRyID0gbWFsbG9jKGJ1Zi5sZW5ndGgpO1xuICAgICAgICBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIsIHB0ciArIGJ1Zi5sZW5ndGgpLnNldChidWYpO1xuICAgICAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBidWYubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGxldCBsZW4gPSBhcmcubGVuZ3RoO1xuICAgIGxldCBwdHIgPSBtYWxsb2MobGVuKTtcblxuICAgIGNvbnN0IG1lbSA9IGdldFVpbnQ4TWVtb3J5MCgpO1xuXG4gICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICBmb3IgKDsgb2Zmc2V0IDwgbGVuOyBvZmZzZXQrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gYXJnLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgaWYgKGNvZGUgPiAweDdGKSBicmVhaztcbiAgICAgICAgbWVtW3B0ciArIG9mZnNldF0gPSBjb2RlO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXQgIT09IGxlbikge1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBwdHIgPSByZWFsbG9jKHB0ciwgbGVuLCBsZW4gPSBvZmZzZXQgKyBhcmcubGVuZ3RoICogMyk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIgKyBvZmZzZXQsIHB0ciArIGxlbik7XG4gICAgICAgIGNvbnN0IHJldCA9IGVuY29kZVN0cmluZyhhcmcsIHZpZXcpO1xuXG4gICAgICAgIG9mZnNldCArPSByZXQud3JpdHRlbjtcbiAgICB9XG5cbiAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHB0cjtcbn1cblxuZnVuY3Rpb24gaXNMaWtlTm9uZSh4KSB7XG4gICAgcmV0dXJuIHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsO1xufVxuXG5sZXQgY2FjaGVkSW50MzJNZW1vcnkwID0gbmV3IEludDMyQXJyYXkoKTtcblxuZnVuY3Rpb24gZ2V0SW50MzJNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWRJbnQzMk1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRJbnQzMk1lbW9yeTAgPSBuZXcgSW50MzJBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkSW50MzJNZW1vcnkwO1xufVxuXG5sZXQgY2FjaGVkRmxvYXQ2NE1lbW9yeTAgPSBuZXcgRmxvYXQ2NEFycmF5KCk7XG5cbmZ1bmN0aW9uIGdldEZsb2F0NjRNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWRGbG9hdDY0TWVtb3J5MC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhY2hlZEZsb2F0NjRNZW1vcnkwID0gbmV3IEZsb2F0NjRBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkRmxvYXQ2NE1lbW9yeTA7XG59XG5cbmxldCBjYWNoZWRCaWdJbnQ2NE1lbW9yeTAgPSBuZXcgQmlnSW50NjRBcnJheSgpO1xuXG5mdW5jdGlvbiBnZXRCaWdJbnQ2NE1lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZEJpZ0ludDY0TWVtb3J5MC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhY2hlZEJpZ0ludDY0TWVtb3J5MCA9IG5ldyBCaWdJbnQ2NEFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRCaWdJbnQ2NE1lbW9yeTA7XG59XG5cbmZ1bmN0aW9uIGRlYnVnU3RyaW5nKHZhbCkge1xuICAgIC8vIHByaW1pdGl2ZSB0eXBlc1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsO1xuICAgIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAgXFxgXFwke3ZhbH1cXGA7XG4gICAgfVxuICAgIGlmICh0eXBlID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBcXGBcIlxcJHt2YWx9XCJcXGA7XG4gICAgfVxuICAgIGlmICh0eXBlID09ICdzeW1ib2wnKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdmFsLmRlc2NyaXB0aW9uO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdTeW1ib2wnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFxcYFN5bWJvbChcXCR7ZGVzY3JpcHRpb259KVxcYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB2YWwubmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnICYmIG5hbWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFxcYEZ1bmN0aW9uKFxcJHtuYW1lfSlcXGA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Z1bmN0aW9uJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBvYmplY3RzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSB2YWwubGVuZ3RoO1xuICAgICAgICBsZXQgZGVidWcgPSAnWyc7XG4gICAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkZWJ1ZyArPSBkZWJ1Z1N0cmluZyh2YWxbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVidWcgKz0gJywgJyArIGRlYnVnU3RyaW5nKHZhbFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcgKz0gJ10nO1xuICAgICAgICByZXR1cm4gZGVidWc7XG4gICAgfVxuICAgIC8vIFRlc3QgZm9yIGJ1aWx0LWluXG4gICAgY29uc3QgYnVpbHRJbk1hdGNoZXMgPSAvXFxcXFtvYmplY3QgKFteXFxcXF1dKylcXFxcXS8uZXhlYyh0b1N0cmluZy5jYWxsKHZhbCkpO1xuICAgIGxldCBjbGFzc05hbWU7XG4gICAgaWYgKGJ1aWx0SW5NYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gYnVpbHRJbk1hdGNoZXNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmFpbGVkIHRvIG1hdGNoIHRoZSBzdGFuZGFyZCAnW29iamVjdCBDbGFzc05hbWVdJ1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpO1xuICAgIH1cbiAgICBpZiAoY2xhc3NOYW1lID09ICdPYmplY3QnKSB7XG4gICAgICAgIC8vIHdlJ3JlIGEgdXNlciBkZWZpbmVkIGNsYXNzIG9yIE9iamVjdFxuICAgICAgICAvLyBKU09OLnN0cmluZ2lmeSBhdm9pZHMgcHJvYmxlbXMgd2l0aCBjeWNsZXMsIGFuZCBpcyBnZW5lcmFsbHkgbXVjaFxuICAgICAgICAvLyBlYXNpZXIgdGhhbiBsb29waW5nIHRocm91Z2ggb3duUHJvcGVydGllcyBvZiBcXGB2YWxcXGAuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gJ09iamVjdCgnICsgSlNPTi5zdHJpbmdpZnkodmFsKSArICcpJztcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuICdPYmplY3QnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVycm9yc1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gXFxgXFwke3ZhbC5uYW1lfTogXFwke3ZhbC5tZXNzYWdlfVxcXFxuXFwke3ZhbC5zdGFja31cXGA7XG4gICAgfVxuICAgIC8vIFRPRE8gd2UgY291bGQgdGVzdCBmb3IgbW9yZSB0aGluZ3MgaGVyZSwgbGlrZSBcXGBTZXRcXGBzIGFuZCBcXGBNYXBcXGBzLlxuICAgIHJldHVybiBjbGFzc05hbWU7XG59XG5cbmZ1bmN0aW9uIG1ha2VDbG9zdXJlKGFyZzAsIGFyZzEsIGR0b3IsIGYpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHsgYTogYXJnMCwgYjogYXJnMSwgY250OiAxLCBkdG9yIH07XG4gICAgY29uc3QgcmVhbCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIC8vIEZpcnN0IHVwIHdpdGggYSBjbG9zdXJlIHdlIGluY3JlbWVudCB0aGUgaW50ZXJuYWwgcmVmZXJlbmNlXG4gICAgICAgIC8vIGNvdW50LiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgUnVzdCBjbG9zdXJlIGVudmlyb25tZW50IHdvbid0XG4gICAgICAgIC8vIGJlIGRlYWxsb2NhdGVkIHdoaWxlIHdlJ3JlIGludm9raW5nIGl0LlxuICAgICAgICBzdGF0ZS5jbnQrKztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmKHN0YXRlLmEsIHN0YXRlLmIsIC4uLmFyZ3MpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKC0tc3RhdGUuY250ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yLmdldChzdGF0ZS5kdG9yKShzdGF0ZS5hLCBzdGF0ZS5iKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hID0gMDtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZWFsLm9yaWdpbmFsID0gc3RhdGU7XG5cbiAgICByZXR1cm4gcmVhbDtcbn1cbmZ1bmN0aW9uIF9fd2JnX2FkYXB0ZXJfNTAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIHdhc20uX2R5bl9jb3JlX19vcHNfX2Z1bmN0aW9uX19Gbl9fQV9fX19PdXRwdXRfX19SX2FzX3dhc21fYmluZGdlbl9fY2xvc3VyZV9fV2FzbUNsb3N1cmVfX19kZXNjcmliZV9faW52b2tlX19oZThkYjVmYTE2NzcwNmEwOShhcmcwLCBhcmcxLCBhZGRIZWFwT2JqZWN0KGFyZzIpKTtcbn1cblxuZnVuY3Rpb24gX193YmdfYWRhcHRlcl81MyhhcmcwLCBhcmcxKSB7XG4gICAgd2FzbS5fZHluX2NvcmVfX29wc19fZnVuY3Rpb25fX0ZuX19fX19PdXRwdXRfX19SX2FzX3dhc21fYmluZGdlbl9fY2xvc3VyZV9fV2FzbUNsb3N1cmVfX19kZXNjcmliZV9faW52b2tlX19oZWQ1NDBjODg0NTRkZjAzMShhcmcwLCBhcmcxKTtcbn1cblxuZnVuY3Rpb24gbWFrZU11dENsb3N1cmUoYXJnMCwgYXJnMSwgZHRvciwgZikge1xuICAgIGNvbnN0IHN0YXRlID0geyBhOiBhcmcwLCBiOiBhcmcxLCBjbnQ6IDEsIGR0b3IgfTtcbiAgICBjb25zdCByZWFsID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgLy8gRmlyc3QgdXAgd2l0aCBhIGNsb3N1cmUgd2UgaW5jcmVtZW50IHRoZSBpbnRlcm5hbCByZWZlcmVuY2VcbiAgICAgICAgLy8gY291bnQuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBSdXN0IGNsb3N1cmUgZW52aXJvbm1lbnQgd29uJ3RcbiAgICAgICAgLy8gYmUgZGVhbGxvY2F0ZWQgd2hpbGUgd2UncmUgaW52b2tpbmcgaXQuXG4gICAgICAgIHN0YXRlLmNudCsrO1xuICAgICAgICBjb25zdCBhID0gc3RhdGUuYTtcbiAgICAgICAgc3RhdGUuYSA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZihhLCBzdGF0ZS5iLCAuLi5hcmdzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICgtLXN0YXRlLmNudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfMi5nZXQoc3RhdGUuZHRvcikoYSwgc3RhdGUuYik7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYSA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJlYWwub3JpZ2luYWwgPSBzdGF0ZTtcblxuICAgIHJldHVybiByZWFsO1xufVxuZnVuY3Rpb24gX193YmdfYWRhcHRlcl81NihhcmcwLCBhcmcxKSB7XG4gICAgd2FzbS5fZHluX2NvcmVfX29wc19fZnVuY3Rpb25fX0ZuTXV0X19fX19PdXRwdXRfX19SX2FzX3dhc21fYmluZGdlbl9fY2xvc3VyZV9fV2FzbUNsb3N1cmVfX19kZXNjcmliZV9faW52b2tlX19oYzE4MmU0ZDUwMzU0MTk2YihhcmcwLCBhcmcxKTtcbn1cblxuZnVuY3Rpb24gX193YmdfYWRhcHRlcl81OShhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIHdhc20uX2R5bl9jb3JlX19vcHNfX2Z1bmN0aW9uX19Gbk11dF9fQV9fX19PdXRwdXRfX19SX2FzX3dhc21fYmluZGdlbl9fY2xvc3VyZV9fV2FzbUNsb3N1cmVfX19kZXNjcmliZV9faW52b2tlX19oN2NiYzNjMzIyOTYzNzA2ZihyZXRwdHIsIGFyZzAsIGFyZzEsIGFkZEhlYXBPYmplY3QoYXJnMikpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfX3diZ19hZGFwdGVyXzYyKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICB3YXNtLl9keW5fY29yZV9fb3BzX19mdW5jdGlvbl9fRm5NdXRfX0FfX19fT3V0cHV0X19fUl9hc193YXNtX2JpbmRnZW5fX2Nsb3N1cmVfX1dhc21DbG9zdXJlX19fZGVzY3JpYmVfX2ludm9rZV9faDM3MDk4MDhmZjE3NDE5MTQoYXJnMCwgYXJnMSwgYWRkSGVhcE9iamVjdChhcmcyKSk7XG59XG5cbmZ1bmN0aW9uIF9fd2JnX2FkYXB0ZXJfNjUoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIHdhc20uX2R5bl9jb3JlX19vcHNfX2Z1bmN0aW9uX19Gbk11dF9fQV9fX19PdXRwdXRfX19SX2FzX3dhc21fYmluZGdlbl9fY2xvc3VyZV9fV2FzbUNsb3N1cmVfX19kZXNjcmliZV9faW52b2tlX19oNmM2MTYxYWFjZDY2NDQ3OShhcmcwLCBhcmcxLCBhZGRIZWFwT2JqZWN0KGFyZzIpKTtcbn1cblxuZnVuY3Rpb24gX193YmdfYWRhcHRlcl82OChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgd2FzbS5fZHluX2NvcmVfX29wc19fZnVuY3Rpb25fX0ZuTXV0X19BX19fX091dHB1dF9fX1JfYXNfd2FzbV9iaW5kZ2VuX19jbG9zdXJlX19XYXNtQ2xvc3VyZV9fX2Rlc2NyaWJlX19pbnZva2VfX2g2OGFhOTdkMTEzZWUzNjBjKGFyZzAsIGFyZzEsIGFkZEhlYXBPYmplY3QoYXJnMikpO1xufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZ19qc29uXG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZnVuY3Rpb24gY29yZV9jcmVhdGVfY29udGV4dChjb25maWdfanNvbikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY29uZmlnX2pzb24sIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5jb3JlX2NyZWF0ZV9jb250ZXh0KHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocjAsIHIxKTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge251bWJlcn0gY29udGV4dFxuKi9cbmZ1bmN0aW9uIGNvcmVfZGVzdHJveV9jb250ZXh0KGNvbnRleHQpIHtcbiAgICB3YXNtLmNvcmVfZGVzdHJveV9jb250ZXh0KGNvbnRleHQpO1xufVxuXG4vKipcbiogQHBhcmFtIHtudW1iZXJ9IGNvbnRleHRcbiogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uX25hbWVcbiogQHBhcmFtIHthbnl9IHBhcmFtc1xuKiBAcGFyYW0ge251bWJlcn0gcmVxdWVzdF9pZFxuKi9cbmZ1bmN0aW9uIGNvcmVfcmVxdWVzdChjb250ZXh0LCBmdW5jdGlvbl9uYW1lLCBwYXJhbXMsIHJlcXVlc3RfaWQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGZ1bmN0aW9uX25hbWUsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5jb3JlX3JlcXVlc3QocmV0cHRyLCBjb250ZXh0LCBwdHIwLCBsZW4wLCBhZGRIZWFwT2JqZWN0KHBhcmFtcyksIHJlcXVlc3RfaWQpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihmLCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhuX3N0b3JlKGFkZEhlYXBPYmplY3QoZSkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXlVOEZyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHJldHVybiBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIgLyAxLCBwdHIgLyAxICsgbGVuKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZChtb2R1bGUsIGltcG9ydHMpIHtcbiAgICBpZiAodHlwZW9mIFJlc3BvbnNlID09PSAnZnVuY3Rpb24nICYmIG1vZHVsZSBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKG1vZHVsZSwgaW1wb3J0cyk7XG5cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kdWxlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSAhPSAnYXBwbGljYXRpb24vd2FzbScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiXFxgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmdcXGAgZmFpbGVkIGJlY2F1c2UgeW91ciBzZXJ2ZXIgZG9lcyBub3Qgc2VydmUgd2FzbSB3aXRoIFxcYGFwcGxpY2F0aW9uL3dhc21cXGAgTUlNRSB0eXBlLiBGYWxsaW5nIGJhY2sgdG8gXFxgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVcXGAgd2hpY2ggaXMgc2xvd2VyLiBPcmlnaW5hbCBlcnJvcjpcXFxcblwiLCBlKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCBtb2R1bGUuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJ5dGVzLCBpbXBvcnRzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUobW9kdWxlLCBpbXBvcnRzKTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5JbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5zdGFuY2UsIG1vZHVsZSB9O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEltcG9ydHMoKSB7XG4gICAgY29uc3QgaW1wb3J0cyA9IHt9O1xuICAgIGltcG9ydHMud2JnID0ge307XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzhkMmFmMDBiYzFlMzI5ZWUgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBFcnJvcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9zdHJpbmdfbmV3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX21lbW9yeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm1lbW9yeTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2J1ZmZlcl8zZjNkNzY0ZDQ3NDdkNTY0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuYnVmZmVyO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZDlhYTI2NjcwM2NiOThiZSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoZ2V0T2JqZWN0KGFyZzApLCBhcmcxID4+PiAwLCBhcmcyID4+PiAwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fb2JqZWN0X2Ryb3BfcmVmID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICB0YWtlT2JqZWN0KGFyZzApO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3d2l0aGxlbmd0aF83YzQyZjdlNzM4YTlkNWQzID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgQXJyYXkoYXJnMCA+Pj4gMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfYTY4MjE0ZjM1YzQxN2ZhOSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApW2FyZzEgPj4+IDBdID0gdGFrZU9iamVjdChhcmcyKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld3dpdGh1OGFycmF5c2VxdWVuY2VfZjg2MzI0NmFmODNlMTc4NSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEJsb2IoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0Xzc2NTIwMTU0NGEyYjY4NjkgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFJlZmxlY3QuZ2V0KGdldE9iamVjdChhcmcwKSwgZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zdGFuY2VvZl9BcnJheUJ1ZmZlcl9lNWU0OGY0NzYyYzU2MTBiID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZ2V0T2JqZWN0KGFyZzApIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc19vYmplY3QgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGdldE9iamVjdChhcmcwKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKHZhbCkgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld184YzNmMDA1MjI3MmE0NTdhID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9vYmplY3RfY2xvbmVfcmVmID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19rZXlzXzA3MDIyOTRhZmFlYjYwNDQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE9iamVjdC5rZXlzKGdldE9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19sZW5ndGhfNmUzYmJlN2M4YmQ0ZGJkOCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldF81NzI0NWNjN2Q3Yzc2MTlkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMClbYXJnMSA+Pj4gMF07XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX3N0cmluZ19nZXQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKG9iaikgPT09ICdzdHJpbmcnID8gb2JqIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUocmV0KSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChyZXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gcHRyMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ldzBfYTU3MDU5ZDcyYzViN2FlZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0VGltZV9jYjgyYWRiMjU1NmVkMTNlID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZ2V0VGltZSgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9qc3ZhbF9sb29zZV9lcSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApID09IGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fYm9vbGVhbl9nZXQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHYgPSBnZXRPYmplY3QoYXJnMCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZih2KSA9PT0gJ2Jvb2xlYW4nID8gKHYgPyAxIDogMCkgOiAyO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc19iaWdpbnQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZihnZXRPYmplY3QoYXJnMCkpID09PSAnYmlnaW50JztcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fbnVtYmVyX2dldCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2Yob2JqKSA9PT0gJ251bWJlcicgPyBvYmogOiB1bmRlZmluZWQ7XG4gICAgICAgIGdldEZsb2F0NjRNZW1vcnkwKClbYXJnMCAvIDggKyAxXSA9IGlzTGlrZU5vbmUocmV0KSA/IDAgOiByZXQ7XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMF0gPSAhaXNMaWtlTm9uZShyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaXNTYWZlSW50ZWdlcl9kZmEwNTkzZThkN2FjMzVhID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBOdW1iZXIuaXNTYWZlSW50ZWdlcihnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9iaWdpbnRfZ2V0X2FzX2k2NCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgdiA9IGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKHYpID09PSAnYmlnaW50JyA/IHYgOiB1bmRlZmluZWQ7XG4gICAgICAgIGdldEJpZ0ludDY0TWVtb3J5MCgpW2FyZzAgLyA4ICsgMV0gPSBpc0xpa2VOb25lKHJldCkgPyAwbiA6IHJldDtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAwXSA9ICFpc0xpa2VOb25lKHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2JpZ2ludF9mcm9tX2k2NCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gYXJnMDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fanN2YWxfZXEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKSA9PT0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9iaWdpbnRfZnJvbV91NjQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEJpZ0ludC5hc1VpbnROKDY0LCBhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fZXJyb3JfbmV3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgRXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2lzQXJyYXlfMjdjNDZjNjdmNDk4ZTE1ZCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gQXJyYXkuaXNBcnJheShnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaXRlcmF0b3JfNmY5ZDRmMjg4NDVmNDI2YyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBTeW1ib2wuaXRlcmF0b3I7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2luID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkgaW4gZ2V0T2JqZWN0KGFyZzEpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZW50cmllc182NWE3NmE0MTNmYzkxMDM3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBPYmplY3QuZW50cmllcyhnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc191bmRlZmluZWQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc19udWxsID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkgPT09IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19TdHJpbmdfOTFmYmE3ZGVkMTNiYTU0YyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gU3RyaW5nKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChyZXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAxXSA9IGxlbjA7XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMF0gPSBwdHIwO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9udW1iZXJfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBhcmcwO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzBiOWJmZGQ5NzU4MzI4NGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IE9iamVjdCgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfU3RyaW5nXzMzMDk5ODU2ZThhODI0NmEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFN0cmluZyhnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gcHRyMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NvcmVyZXNwb25zZWhhbmRsZXJfYTUyODc5NDU0YzYwYzc2NCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgY29yZV9yZXNwb25zZV9oYW5kbGVyKGFyZzAgPj4+IDAsIHRha2VPYmplY3QoYXJnMSksIGFyZzIgPj4+IDAsIGFyZzMgIT09IDApO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbWVzc2FnZV9mZTJhZjYzY2NjODk4NWJjID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkubWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld18xZDlhOTIwYzZiZmM0NGE4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBBcnJheSgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzI2OGY3YjdkZDM0MzA3OTggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0XzkzMzcyOWNmNWI2NmFjMTEgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5zZXQoZ2V0T2JqZWN0KGFyZzEpLCBnZXRPYmplY3QoYXJnMikpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc19zdHJpbmcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZihnZXRPYmplY3QoYXJnMCkpID09PSAnc3RyaW5nJztcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF9mYmMzM2QwMjBmNTA3YjcyID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBnZXRPYmplY3QoYXJnMClbdGFrZU9iamVjdChhcmcxKV0gPSB0YWtlT2JqZWN0KGFyZzIpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcHJvY2Vzc18wY2MyYWRhODUyNGQ2ZjgzID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkucHJvY2VzcztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3ZlcnNpb25zX2MxMWFjY2VhYjI3YTZjODcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS52ZXJzaW9ucztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vZGVfN2ZmMWNlNDljYWYyMzgxNSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm5vZGU7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdGF0aWNfYWNjZXNzb3JfTk9ERV9NT0RVTEVfY2Y2NDAxY2MxMDkxMjc5ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBtb2R1bGU7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZXF1aXJlX2E3NDZlNzliMzIyYjkzMzYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5yZXF1aXJlKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NyeXB0b18yMDM2YmVkN2M0NGMyNWU3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuY3J5cHRvO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbXNDcnlwdG9fYTIxZmM4OGNhZjFlY2RjOCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm1zQ3J5cHRvO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3d2l0aGxlbmd0aF9mNTkzMzg1NWU0ZjQ4YTE5ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShhcmcwID4+PiAwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3RyYW5zYWN0aW9uX2NjZTk2Y2JlYmQ4MWZlMWMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS50cmFuc2FjdGlvbihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMiksIHRha2VPYmplY3QoYXJnMykpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRvbmNvbXBsZXRlXzNlNTdhOGNlYzgzMjdmNjYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbmNvbXBsZXRlID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0b25lcnJvcl8wMDA1MWMwMjEzZjI3YjJjID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub25lcnJvciA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldG9uYWJvcnRfNDA0YmVlM2I5OTQwZDAzZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9uYWJvcnQgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pdGVtXzUyYTZiZWMzNjMxNDY4N2IgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcxKS5pdGVtKGFyZzIgPj4+IDApO1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUocmV0KSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChyZXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gcHRyMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX29iamVjdFN0b3JlX2YxNzk3NmIwZTYzNzc4MzAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5vYmplY3RTdG9yZShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190YXJnZXRfYmY3MDRiN2RiN2FkMTM4NyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnRhcmdldDtcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZWFkeVN0YXRlX2ZiMjg3ZjE3MDExMzkxN2MgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5yZWFkeVN0YXRlO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0b25zdWNjZXNzXzVmNzE1OTNiYzUxNjUzYTMgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbnN1Y2Nlc3MgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRvbmVycm9yX2Q1NzcxY2M1YmY5ZWE3NGMgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbmVycm9yID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jYl9kcm9wID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCBvYmogPSB0YWtlT2JqZWN0KGFyZzApLm9yaWdpbmFsO1xuICAgICAgICBpZiAob2JqLmNudC0tID09IDEpIHtcbiAgICAgICAgICAgIG9iai5hID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV4dF9hYWVmN2M4YWE1ZTIxMmFjID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkubmV4dCgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19kb25lXzFiNzNiMDY3MmUxNWYyMzQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5kb25lO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdmFsdWVfMWNjYzM2YmMwMzQ2MmQ3MSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnZhbHVlO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc19mdW5jdGlvbiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKGdldE9iamVjdChhcmcwKSkgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jYWxsXzk3YWU5ZDg2NDVkYzM4OGIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5jYWxsKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25leHRfNTc5ZTU4M2QzMzU2NmE4NiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm5leHQ7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZWxmXzZkNDc5NTA2ZjcyYzZhNzEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gc2VsZi5zZWxmO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ193aW5kb3dfZjI1NTdjYzc4NDkwYWNlYiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3aW5kb3cud2luZG93O1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nbG9iYWxUaGlzXzdmMjA2YmRhNjI4ZDUyODYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2xvYmFsVGhpcy5nbG9iYWxUaGlzO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nbG9iYWxfYmE3NWM1MGQxY2YzODRmNCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXQgPSBnbG9iYWwuZ2xvYmFsO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdub2FyZ3NfYjViMDYzZmM2YzJmMDM3NiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEZ1bmN0aW9uKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfODNkYjk2OTBmOTM1M2U3OSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnNldChnZXRPYmplY3QoYXJnMSksIGFyZzIgPj4+IDApO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbGVuZ3RoXzllMWFlMTkwMGNiMGZiZDUgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5sZW5ndGg7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfYmYzZjg5YjkyZDVhMzRiZiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gUmVmbGVjdC5zZXQoZ2V0T2JqZWN0KGFyZzApLCBnZXRPYmplY3QoYXJnMSksIGdldE9iamVjdChhcmcyKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NlbGZfN2VlZGUxZjQ0ODhiZjM0NiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXQgPSBzZWxmLnNlbGY7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NyeXB0b19jOTA5ZmI0MjhkY2JkZGI2ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuY3J5cHRvO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbXNDcnlwdG9fNTExZWVmZWZiZmM3MGFlNCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm1zQ3J5cHRvO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3RhdGljX2FjY2Vzc29yX01PRFVMRV9lZjNhYTJlYjI1MTE1OGE1ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG1vZHVsZTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3JlcXVpcmVfOTAwZDVjMzk4NGZlNzcwMyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnJlcXVpcmUoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFJhbmRvbVZhbHVlc18zMDcwNDkzNDVkMGJkODhjID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZ2V0UmFuZG9tVmFsdWVzO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmFuZG9tRmlsbFN5bmNfODViM2Y0YzUyYzU2YzMxMyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnJhbmRvbUZpbGxTeW5jKGdldEFycmF5VThGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3ViYXJyYXlfNThhZDRlZmJiNWJjYjg4NiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnN1YmFycmF5KGFyZzEgPj4+IDAsIGFyZzIgPj4+IDApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0UmFuZG9tVmFsdWVzX2NkMTc1OTE1NTExZjcwNWUgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5nZXRSYW5kb21WYWx1ZXMoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3JhbmRvbUZpbGxTeW5jXzA2NWFmZmZkZTAxZGFhNjYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5yYW5kb21GaWxsU3luYyhnZXRBcnJheVU4RnJvbVdhc20wKGFyZzEsIGFyZzIpKTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0UmFuZG9tVmFsdWVzX2I5OWVlYzQyNDRhNDc1YmIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5nZXRSYW5kb21WYWx1ZXMoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zdGFuY2VvZl9VaW50OEFycmF5Xzk3MWVlZGE2OWViNzUwMDMgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBnZXRPYmplY3QoYXJnMCkgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3B1dF84NGU3ZmM5M2VlZTI3YjI4ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkucHV0KGdldE9iamVjdChhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZGVsZXRlXzhhYmVkZDEwNDNiNDEwNWQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5kZWxldGUoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0VGltZW91dF9kNmZjZjBkOTA2N2I4ZTY0ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuc2V0VGltZW91dChnZXRPYmplY3QoYXJnMSksIGFyZzIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jbGVhclRpbWVvdXRfN2Q2ZjdiZmVlZDM0YjM0OCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmNsZWFyVGltZW91dChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld3dpdGhzdHJhbmRpbml0XzA1ZDcxODA3ODg0MjBjNDAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBSZXF1ZXN0KGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaGVhZGVyc184NTgyNGU5OTNhYTczOWJmID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuaGVhZGVycztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF85OTJjMWQzMTU4NmIyOTU3ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuc2V0KGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzMsIGFyZzQpKTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZmV0Y2hfMGZlMDQ5MDVjY2NmYzJhYSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmZldGNoKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbnN0YW5jZW9mX1Jlc3BvbnNlX2VhYTQyNjIyMDg0OGEzOWUgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBnZXRPYmplY3QoYXJnMCkgaW5zdGFuY2VvZiBSZXNwb25zZTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdGF0dXNfYzRlZjNkZDU5MWU2MzQzNSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnN0YXR1cztcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3VybF83NDI4NWRkZjI3NDdjYjNkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMSkudXJsO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gcHRyMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldG9udmVyc2lvbmNoYW5nZV84NDBkNjVjZDA4ODhkZmIwID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub252ZXJzaW9uY2hhbmdlID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0b251cGdyYWRlbmVlZGVkXzE3ZDBiOTUzMGYxZTBjYWMgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbnVwZ3JhZGVuZWVkZWQgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRvbmJsb2NrZWRfZTY2ZDZiZTVjODc5OTgwZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9uYmxvY2tlZCA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX21lc3NhZ2VfYTdhZjNlZTBjYzBmZTI4ZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzEpLm1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChyZXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAxXSA9IGxlbjA7XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMF0gPSBwdHIwO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfV2luZG93XzU2ODQzNDFmZjZkZmUzYWQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5XaW5kb3c7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19Xb3JrZXJHbG9iYWxTY29wZV9lMDQ0N2ZmY2FlOGJiMjcyID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuV29ya2VyR2xvYmFsU2NvcGU7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbmRleGVkREJfMDUwZjA5NjJhYjYwN2FjNSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmluZGV4ZWREQjtcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luZGV4ZWREQl84ZDllOWFiNDYxNmRmN2YwID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuaW5kZXhlZERCO1xuICAgICAgICByZXR1cm4gaXNMaWtlTm9uZShyZXQpID8gMCA6IGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfb3Blbl9hMzFjM2ZlMWZkYzI0NGViID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkub3BlbihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXd3aXRoc3RyX2Q1YjVmOWI5ODVlZTg0ZmIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBXZWJTb2NrZXQoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpLCBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMiwgYXJnMykpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfZDI5ZTUwN2Y2NjA2ZGU5MSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFdlYlNvY2tldChnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRvbm1lc3NhZ2VfYzVhODA2YjYyYTBjNTYwNyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9ubWVzc2FnZSA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldG9ub3Blbl85Y2U0OGRjZTU3ZTU0OWI1ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub25vcGVuID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0b25lcnJvcl8wMjM5MzI2MGIzZTI5OTcyID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub25lcnJvciA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NlbmRfODBiMjU2ZDg3YTY3NzllNSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnNlbmQoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpKTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZGF0YV83YjFmMDFmNGU2YTY0ZmJlID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZGF0YTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N0cmluZ2lmeV9kNjQ3MWQzMDBkZWQ5YjY4ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBKU09OLnN0cmluZ2lmeShnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19vYmplY3RTdG9yZU5hbWVzXzhjMDZjNDBkMmIwNTE0MWMgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5vYmplY3RTdG9yZU5hbWVzO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY3JlYXRlT2JqZWN0U3RvcmVfZDNlMjc4OWMxM2RkZTFmYyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNyZWF0ZU9iamVjdFN0b3JlKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luc3RhbmNlb2ZfRXJyb3JfNTZiNDk2YTEwYTU2ZGU2NiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGdldE9iamVjdChhcmcwKSBpbnN0YW5jZW9mIEVycm9yO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFRpbWV6b25lT2Zmc2V0Xzg5YmQ0Mjc1ZTFjYTgzNDEgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9kZWJ1Z19zdHJpbmcgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGRlYnVnU3RyaW5nKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChyZXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAxXSA9IGxlbjA7XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMF0gPSBwdHIwO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl90aHJvdyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190aGVuX2NlZGFkMjBmYmJkOTQxOGEgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS50aGVuKGdldE9iamVjdChhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Jlc29sdmVfOTlmZTE3OTY0ZjMxZmZjMCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gUHJvbWlzZS5yZXNvbHZlKGdldE9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190aGVuXzExZjdhNTRkNjdiNGJmYWQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS50aGVuKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZXN1bHRfOWUzOTljMTQ2NzY5NzBkOSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnJlc3VsdDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZXJyb3JfYWFjZjVhYzE5MWU1NGVkMCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmVycm9yO1xuICAgICAgICByZXR1cm4gaXNMaWtlTm9uZShyZXQpID8gMCA6IGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0XzYyODViZjQ1OGExZWU3NTggPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5nZXQoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zdGFuY2VvZl9XaW5kb3dfYWNjOTdmZjlmNWQyYzdiNCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY2xvc2VfNDVkMDUzYmVhNTllNzc0NiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmNsb3NlKCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3RleHRfMTE2OWQ3NTJjYzY5NzkwMyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnRleHQoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jbG9zdXJlX3dyYXBwZXI5NDcgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG1ha2VDbG9zdXJlKGFyZzAsIGFyZzEsIDQ0LCBfX3diZ19hZGFwdGVyXzUwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2xvc3VyZV93cmFwcGVyOTU4ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBtYWtlQ2xvc3VyZShhcmcwLCBhcmcxLCA0NywgX193YmdfYWRhcHRlcl81Myk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nsb3N1cmVfd3JhcHBlcjYxNTkgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG1ha2VNdXRDbG9zdXJlKGFyZzAsIGFyZzEsIDIzOCwgX193YmdfYWRhcHRlcl81Nik7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nsb3N1cmVfd3JhcHBlcjY4MjQgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG1ha2VNdXRDbG9zdXJlKGFyZzAsIGFyZzEsIDI0NywgX193YmdfYWRhcHRlcl81OSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nsb3N1cmVfd3JhcHBlcjY4NzQgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG1ha2VNdXRDbG9zdXJlKGFyZzAsIGFyZzEsIDI0NCwgX193YmdfYWRhcHRlcl82Mik7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nsb3N1cmVfd3JhcHBlcjY4NzUgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG1ha2VNdXRDbG9zdXJlKGFyZzAsIGFyZzEsIDEyMDYsIF9fd2JnX2FkYXB0ZXJfNjUpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jbG9zdXJlX3dyYXBwZXI2ODc2ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCAyNDEsIF9fd2JnX2FkYXB0ZXJfNjgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW1wb3J0cztcbn1cblxuZnVuY3Rpb24gaW5pdE1lbW9yeShpbXBvcnRzLCBtYXliZV9tZW1vcnkpIHtcblxufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZUluaXQoaW5zdGFuY2UsIG1vZHVsZSkge1xuICAgIHdhc20gPSBpbnN0YW5jZS5leHBvcnRzO1xuICAgIGluaXQuX193YmluZGdlbl93YXNtX21vZHVsZSA9IG1vZHVsZTtcbiAgICBjYWNoZWRCaWdJbnQ2NE1lbW9yeTAgPSBuZXcgQmlnSW50NjRBcnJheSgpO1xuICAgIGNhY2hlZEZsb2F0NjRNZW1vcnkwID0gbmV3IEZsb2F0NjRBcnJheSgpO1xuICAgIGNhY2hlZEludDMyTWVtb3J5MCA9IG5ldyBJbnQzMkFycmF5KCk7XG4gICAgY2FjaGVkVWludDhNZW1vcnkwID0gbmV3IFVpbnQ4QXJyYXkoKTtcblxuXG4gICAgcmV0dXJuIHdhc207XG59XG5cbmZ1bmN0aW9uIGluaXRTeW5jKG1vZHVsZSkge1xuICAgIGNvbnN0IGltcG9ydHMgPSBnZXRJbXBvcnRzKCk7XG5cbiAgICBpbml0TWVtb3J5KGltcG9ydHMpO1xuXG4gICAgaWYgKCEobW9kdWxlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTW9kdWxlKSkge1xuICAgICAgICBtb2R1bGUgPSBuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG1vZHVsZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobW9kdWxlLCBpbXBvcnRzKTtcblxuICAgIHJldHVybiBmaW5hbGl6ZUluaXQoaW5zdGFuY2UsIG1vZHVsZSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGluaXQoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJykgeyAgICB9XG4gICAgY29uc3QgaW1wb3J0cyA9IGdldEltcG9ydHMoKTtcblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8ICh0eXBlb2YgUmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHx8ICh0eXBlb2YgVVJMID09PSAnZnVuY3Rpb24nICYmIGlucHV0IGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICBpbnB1dCA9IGZldGNoKGlucHV0KTtcbiAgICB9XG5cbiAgICBpbml0TWVtb3J5KGltcG9ydHMpO1xuXG4gICAgY29uc3QgeyBpbnN0YW5jZSwgbW9kdWxlIH0gPSBhd2FpdCBsb2FkKGF3YWl0IGlucHV0LCBpbXBvcnRzKTtcblxuICAgIHJldHVybiBmaW5hbGl6ZUluaXQoaW5zdGFuY2UsIG1vZHVsZSk7XG59XG5cblxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogV1JBUFBFUiBFTkRcblxuZnVuY3Rpb24gcmVwbGFjZVVuZGVmaW5lZFdpdGhOdWxscyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IFtdIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHJlcGxhY2VVbmRlZmluZWRXaXRoTnVsbHModmFsdWVba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuZnVuY3Rpb24gY29yZV9yZXNwb25zZV9oYW5kbGVyKHJlcXVlc3RfaWQsIHBhcmFtcywgcmVzcG9uc2VfdHlwZSwgZmluaXNoZWQpIHtcbiAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdyZXNwb25zZScsXG4gICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdF9pZCxcbiAgICAgICAgcGFyYW1zOiByZXBsYWNlVW5kZWZpbmVkV2l0aE51bGxzKHBhcmFtcyksXG4gICAgICAgIHJlc3BvbnNlVHlwZTogcmVzcG9uc2VfdHlwZSxcbiAgICAgICAgZmluaXNoZWQsXG4gICAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlcGxhY2VCbG9ic1dpdGhBcnJheUJ1ZmZlcnModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB2YWx1ZS5hcnJheUJ1ZmZlcigpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICYmIHZhbHVlID4gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IFtdIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGF3YWl0IHJlcGxhY2VCbG9ic1dpdGhBcnJheUJ1ZmZlcnModmFsdWVba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5zZWxmLm9ubWVzc2FnZSA9IChlKSA9PiB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGUuZGF0YTtcbiAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgaW5pdChtZXNzYWdlLndhc21Nb2R1bGUpO1xuICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlOiAnaW5pdCcgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnY3JlYXRlQ29udGV4dCc6XG4gICAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdjcmVhdGVDb250ZXh0JyxcbiAgICAgICAgICAgIHJlc3VsdDogY29yZV9jcmVhdGVfY29udGV4dChtZXNzYWdlLmNvbmZpZ0pzb24pLFxuICAgICAgICAgICAgcmVxdWVzdElkOiBtZXNzYWdlLnJlcXVlc3RJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZGVzdHJveUNvbnRleHQnOlxuICAgICAgICBjb3JlX2Rlc3Ryb3lfY29udGV4dChtZXNzYWdlLmNvbnRleHQpO1xuICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnZGVzdHJveUNvbnRleHQnXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JlcXVlc3QnOlxuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29yZV9yZXF1ZXN0KFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udGV4dCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICBhd2FpdCByZXBsYWNlQmxvYnNXaXRoQXJyYXlCdWZmZXJzKG1lc3NhZ2UuZnVuY3Rpb25QYXJhbXMpLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVxdWVzdElkLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcbmA7XG5cbmxldCBvcHRpb25zID0gbnVsbDtcblxuZXhwb3J0IGZ1bmN0aW9uIGxpYldlYlNldHVwKGxpYk9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gbGliT3B0aW9ucztcbn1cblxuZnVuY3Rpb24gZGVidWdMb2cobWVzc2FnZSkge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGVidWdMb2cpIHtcbiAgICAgICAgb3B0aW9ucy5kZWJ1Z0xvZyhtZXNzYWdlKTtcbiAgICB9XG59XG5cblxuYXN5bmMgZnVuY3Rpb24gbG9hZE1vZHVsZSgpIHtcbiAgICBjb25zdCBzdGFydExvYWRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgd2FzbU1vZHVsZTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxvYWRNb2R1bGUpIHtcbiAgICAgICAgd2FzbU1vZHVsZSA9IGF3YWl0IG9wdGlvbnMubG9hZE1vZHVsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmZXRjaGVkID0gZmV0Y2goKG9wdGlvbnMgJiYgb3B0aW9ucy5iaW5hcnlVUkwpIHx8IFwiL2V2ZXJzZGsud2FzbVwiKTtcbiAgICAgICAgaWYgKFdlYkFzc2VtYmx5LmNvbXBpbGVTdHJlYW1pbmcpIHtcbiAgICAgICAgICAgIGRlYnVnTG9nKFwiY29tcGlsZVN0cmVhbWluZyBiaW5hcnlcIik7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZVN0cmVhbWluZyhmZXRjaGVkKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Z0xvZyhcImNvbXBpbGUgYmluYXJ5XCIpO1xuICAgICAgICB3YXNtTW9kdWxlID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShhd2FpdCAoYXdhaXQgZmV0Y2hlZCkuYXJyYXlCdWZmZXIoKSk7XG4gICAgfVxuICAgIGF3YWl0IGluaXQod2FzbU1vZHVsZSk7XG4gICAgZGVidWdMb2coYGNvbXBpbGUgdGltZSAke0RhdGUubm93KCkgLSBzdGFydExvYWRUaW1lfWApO1xufVxuXG5mdW5jdGlvbiB3aXRoU2VwYXJhdGVXb3JrZXIoKSB7XG4gICAgZnVuY3Rpb24gZGVidWdMb2cobWVzc2FnZSkge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnTG9nKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRlYnVnTG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgd29ya2VyQmxvYiA9IG5ldyBCbG9iKFxuICAgICAgICBbd29ya2VyU2NyaXB0XSxcbiAgICAgICAgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIiB9LFxuICAgICk7XG4gICAgY29uc3Qgd29ya2VyVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh3b3JrZXJCbG9iKTtcbiAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclVybCk7XG5cblxuICAgIGxldCBuZXh0Q3JlYXRlQ29udGV4dFJlcXVlc3RJZCA9IDE7XG4gICAgY29uc3QgY3JlYXRlQ29udGV4dFJlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgIGxldCBpbml0Q29tcGxldGUgPSBmYWxzZTtcblxuICAgIGxldCByZXNwb25zZUhhbmRsZXIgPSBudWxsO1xuXG4gICAgd29ya2VyLm9ubWVzc2FnZSA9IChldnQpID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV2dC5kYXRhO1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICBjYXNlIFwiaW5pdFwiOlxuICAgICAgICAgICAgaW5pdENvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3JlcXVlc3RJZCwgcmVxdWVzdF0gb2YgY3JlYXRlQ29udGV4dFJlcXVlc3RzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY3JlYXRlQ29udGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ0pzb246IHJlcXVlc3QuY29uZmlnSnNvbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY3JlYXRlQ29udGV4dFwiOlxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGNyZWF0ZUNvbnRleHRSZXF1ZXN0cy5nZXQobWVzc2FnZS5yZXF1ZXN0SWQpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVDb250ZXh0UmVxdWVzdHMuZGVsZXRlKG1lc3NhZ2UucmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc29sdmUobWVzc2FnZS5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZXN0cm95Q29udGV4dFwiOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZXNwb25zZVwiOlxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlc3BvbnNlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5maW5pc2hlZCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgd29ya2VyLm9uZXJyb3IgPSAoZXZ0KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBFcnJvciBmcm9tIFdlYiBXb3JrZXI6ICR7ZXZ0Lm1lc3NhZ2V9YCk7XG4gICAgfTtcblxuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBcImluaXRcIixcbiAgICAgICAgICAgIHdhc21Nb2R1bGU6IGF3YWl0IGxvYWRNb2R1bGUoKSxcbiAgICAgICAgfSk7XG4gICAgfSkoKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBzZXRSZXNwb25zZVBhcmFtc0hhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICByZXNwb25zZUhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVDb250ZXh0OiAoY29uZmlnSnNvbikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdElkID0gbmV4dENyZWF0ZUNvbnRleHRSZXF1ZXN0SWQ7XG4gICAgICAgICAgICAgICAgbmV4dENyZWF0ZUNvbnRleHRSZXF1ZXN0SWQgKz0gMTtcbiAgICAgICAgICAgICAgICBjcmVhdGVDb250ZXh0UmVxdWVzdHMuc2V0KHJlcXVlc3RJZCwge1xuICAgICAgICAgICAgICAgICAgICBjb25maWdKc29uLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpbml0Q29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY3JlYXRlQ29udGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnSnNvbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3lDb250ZXh0OiAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImRlc3Ryb3lDb250ZXh0XCIsXG4gICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZW5kUmVxdWVzdFBhcmFtczogKGNvbnRleHQsIHJlcXVlc3RJZCwgZnVuY3Rpb25OYW1lLCBmdW5jdGlvblBhcmFtcykgPT4ge1xuICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25QYXJhbXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gd2l0aG91dFNlcGFyYXRlV29ya2VyKCkge1xuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogV1JBUFBFUiBCRUdJTlxuXG5sZXQgd2FzbTtcblxuY29uc3QgY2FjaGVkVGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBpZ25vcmVCT006IHRydWUsIGZhdGFsOiB0cnVlIH0pO1xuXG5jYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoKTtcblxubGV0IGNhY2hlZFVpbnQ4TWVtb3J5MCA9IG5ldyBVaW50OEFycmF5KCk7XG5cbmZ1bmN0aW9uIGdldFVpbnQ4TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkVWludDhNZW1vcnkwLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FjaGVkVWludDhNZW1vcnkwID0gbmV3IFVpbnQ4QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFVpbnQ4TWVtb3J5MDtcbn1cblxuZnVuY3Rpb24gZ2V0U3RyaW5nRnJvbVdhc20wKHB0ciwgbGVuKSB7XG4gICAgcmV0dXJuIGNhY2hlZFRleHREZWNvZGVyLmRlY29kZShnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIsIHB0ciArIGxlbikpO1xufVxuXG5jb25zdCBoZWFwID0gbmV3IEFycmF5KDMyKS5maWxsKHVuZGVmaW5lZCk7XG5cbmhlYXAucHVzaCh1bmRlZmluZWQsIG51bGwsIHRydWUsIGZhbHNlKTtcblxubGV0IGhlYXBfbmV4dCA9IGhlYXAubGVuZ3RoO1xuXG5mdW5jdGlvbiBhZGRIZWFwT2JqZWN0KG9iaikge1xuICAgIGlmIChoZWFwX25leHQgPT09IGhlYXAubGVuZ3RoKSBoZWFwLnB1c2goaGVhcC5sZW5ndGggKyAxKTtcbiAgICBjb25zdCBpZHggPSBoZWFwX25leHQ7XG4gICAgaGVhcF9uZXh0ID0gaGVhcFtpZHhdO1xuXG4gICAgaGVhcFtpZHhdID0gb2JqO1xuICAgIHJldHVybiBpZHg7XG59XG5cbmZ1bmN0aW9uIGdldE9iamVjdChpZHgpIHsgcmV0dXJuIGhlYXBbaWR4XTsgfVxuXG5mdW5jdGlvbiBkcm9wT2JqZWN0KGlkeCkge1xuICAgIGlmIChpZHggPCAzNikgcmV0dXJuO1xuICAgIGhlYXBbaWR4XSA9IGhlYXBfbmV4dDtcbiAgICBoZWFwX25leHQgPSBpZHg7XG59XG5cbmZ1bmN0aW9uIHRha2VPYmplY3QoaWR4KSB7XG4gICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGlkeCk7XG4gICAgZHJvcE9iamVjdChpZHgpO1xuICAgIHJldHVybiByZXQ7XG59XG5cbmxldCBXQVNNX1ZFQ1RPUl9MRU4gPSAwO1xuXG5jb25zdCBjYWNoZWRUZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigndXRmLTgnKTtcblxuY29uc3QgZW5jb2RlU3RyaW5nID0gKHR5cGVvZiBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGVJbnRvID09PSAnZnVuY3Rpb24nXG4gICAgPyBmdW5jdGlvbiAoYXJnLCB2aWV3KSB7XG4gICAgcmV0dXJuIGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZUludG8oYXJnLCB2aWV3KTtcbn1cbiAgICA6IGZ1bmN0aW9uIChhcmcsIHZpZXcpIHtcbiAgICBjb25zdCBidWYgPSBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGUoYXJnKTtcbiAgICB2aWV3LnNldChidWYpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlYWQ6IGFyZy5sZW5ndGgsXG4gICAgICAgIHdyaXR0ZW46IGJ1Zi5sZW5ndGhcbiAgICB9O1xufSk7XG5cbmZ1bmN0aW9uIHBhc3NTdHJpbmdUb1dhc20wKGFyZywgbWFsbG9jLCByZWFsbG9jKSB7XG5cbiAgICBpZiAocmVhbGxvYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZShhcmcpO1xuICAgICAgICBjb25zdCBwdHIgPSBtYWxsb2MoYnVmLmxlbmd0aCk7XG4gICAgICAgIGdldFVpbnQ4TWVtb3J5MCgpLnN1YmFycmF5KHB0ciwgcHRyICsgYnVmLmxlbmd0aCkuc2V0KGJ1Zik7XG4gICAgICAgIFdBU01fVkVDVE9SX0xFTiA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgbGV0IGxlbiA9IGFyZy5sZW5ndGg7XG4gICAgbGV0IHB0ciA9IG1hbGxvYyhsZW4pO1xuXG4gICAgY29uc3QgbWVtID0gZ2V0VWludDhNZW1vcnkwKCk7XG5cbiAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgIGZvciAoOyBvZmZzZXQgPCBsZW47IG9mZnNldCsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhcmcuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICBpZiAoY29kZSA+IDB4N0YpIGJyZWFrO1xuICAgICAgICBtZW1bcHRyICsgb2Zmc2V0XSA9IGNvZGU7XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCAhPT0gbGVuKSB7XG4gICAgICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZShvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHB0ciA9IHJlYWxsb2MocHRyLCBsZW4sIGxlbiA9IG9mZnNldCArIGFyZy5sZW5ndGggKiAzKTtcbiAgICAgICAgY29uc3QgdmlldyA9IGdldFVpbnQ4TWVtb3J5MCgpLnN1YmFycmF5KHB0ciArIG9mZnNldCwgcHRyICsgbGVuKTtcbiAgICAgICAgY29uc3QgcmV0ID0gZW5jb2RlU3RyaW5nKGFyZywgdmlldyk7XG5cbiAgICAgICAgb2Zmc2V0ICs9IHJldC53cml0dGVuO1xuICAgIH1cblxuICAgIFdBU01fVkVDVE9SX0xFTiA9IG9mZnNldDtcbiAgICByZXR1cm4gcHRyO1xufVxuXG5mdW5jdGlvbiBpc0xpa2VOb25lKHgpIHtcbiAgICByZXR1cm4geCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGw7XG59XG5cbmxldCBjYWNoZWRJbnQzMk1lbW9yeTAgPSBuZXcgSW50MzJBcnJheSgpO1xuXG5mdW5jdGlvbiBnZXRJbnQzMk1lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZEludDMyTWVtb3J5MC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhY2hlZEludDMyTWVtb3J5MCA9IG5ldyBJbnQzMkFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRJbnQzMk1lbW9yeTA7XG59XG5cbmxldCBjYWNoZWRGbG9hdDY0TWVtb3J5MCA9IG5ldyBGbG9hdDY0QXJyYXkoKTtcblxuZnVuY3Rpb24gZ2V0RmxvYXQ2NE1lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZEZsb2F0NjRNZW1vcnkwLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FjaGVkRmxvYXQ2NE1lbW9yeTAgPSBuZXcgRmxvYXQ2NEFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRGbG9hdDY0TWVtb3J5MDtcbn1cblxubGV0IGNhY2hlZEJpZ0ludDY0TWVtb3J5MCA9IG5ldyBCaWdJbnQ2NEFycmF5KCk7XG5cbmZ1bmN0aW9uIGdldEJpZ0ludDY0TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkQmlnSW50NjRNZW1vcnkwLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FjaGVkQmlnSW50NjRNZW1vcnkwID0gbmV3IEJpZ0ludDY0QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZEJpZ0ludDY0TWVtb3J5MDtcbn1cblxuZnVuY3Rpb24gZGVidWdTdHJpbmcodmFsKSB7XG4gICAgLy8gcHJpbWl0aXZlIHR5cGVzXG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gICAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICBgJHt2YWx9YDtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGBcIiR7dmFsfVwiYDtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB2YWwuZGVzY3JpcHRpb247XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1N5bWJvbCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYFN5bWJvbCgke2Rlc2NyaXB0aW9ufSlgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHZhbC5uYW1lO1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgJiYgbmFtZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYEZ1bmN0aW9uKCR7bmFtZX0pYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnRnVuY3Rpb24nO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9iamVjdHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHZhbC5sZW5ndGg7XG4gICAgICAgIGxldCBkZWJ1ZyA9ICdbJztcbiAgICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRlYnVnICs9IGRlYnVnU3RyaW5nKHZhbFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkZWJ1ZyArPSAnLCAnICsgZGVidWdTdHJpbmcodmFsW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyArPSAnXSc7XG4gICAgICAgIHJldHVybiBkZWJ1ZztcbiAgICB9XG4gICAgLy8gVGVzdCBmb3IgYnVpbHQtaW5cbiAgICBjb25zdCBidWlsdEluTWF0Y2hlcyA9IC9cXFtvYmplY3QgKFteXFxdXSspXFxdLy5leGVjKHRvU3RyaW5nLmNhbGwodmFsKSk7XG4gICAgbGV0IGNsYXNzTmFtZTtcbiAgICBpZiAoYnVpbHRJbk1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjbGFzc05hbWUgPSBidWlsdEluTWF0Y2hlc1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWlsZWQgdG8gbWF0Y2ggdGhlIHN0YW5kYXJkICdbb2JqZWN0IENsYXNzTmFtZV0nXG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCk7XG4gICAgfVxuICAgIGlmIChjbGFzc05hbWUgPT0gJ09iamVjdCcpIHtcbiAgICAgICAgLy8gd2UncmUgYSB1c2VyIGRlZmluZWQgY2xhc3Mgb3IgT2JqZWN0XG4gICAgICAgIC8vIEpTT04uc3RyaW5naWZ5IGF2b2lkcyBwcm9ibGVtcyB3aXRoIGN5Y2xlcywgYW5kIGlzIGdlbmVyYWxseSBtdWNoXG4gICAgICAgIC8vIGVhc2llciB0aGFuIGxvb3BpbmcgdGhyb3VnaCBvd25Qcm9wZXJ0aWVzIG9mIGB2YWxgLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICdPYmplY3QoJyArIEpTT04uc3RyaW5naWZ5KHZhbCkgKyAnKSc7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiAnT2JqZWN0JztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlcnJvcnNcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGAke3ZhbC5uYW1lfTogJHt2YWwubWVzc2FnZX1cXG4ke3ZhbC5zdGFja31gO1xuICAgIH1cbiAgICAvLyBUT0RPIHdlIGNvdWxkIHRlc3QgZm9yIG1vcmUgdGhpbmdzIGhlcmUsIGxpa2UgYFNldGBzIGFuZCBgTWFwYHMuXG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxuZnVuY3Rpb24gbWFrZUNsb3N1cmUoYXJnMCwgYXJnMSwgZHRvciwgZikge1xuICAgIGNvbnN0IHN0YXRlID0geyBhOiBhcmcwLCBiOiBhcmcxLCBjbnQ6IDEsIGR0b3IgfTtcbiAgICBjb25zdCByZWFsID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgLy8gRmlyc3QgdXAgd2l0aCBhIGNsb3N1cmUgd2UgaW5jcmVtZW50IHRoZSBpbnRlcm5hbCByZWZlcmVuY2VcbiAgICAgICAgLy8gY291bnQuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBSdXN0IGNsb3N1cmUgZW52aXJvbm1lbnQgd29uJ3RcbiAgICAgICAgLy8gYmUgZGVhbGxvY2F0ZWQgd2hpbGUgd2UncmUgaW52b2tpbmcgaXQuXG4gICAgICAgIHN0YXRlLmNudCsrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGYoc3RhdGUuYSwgc3RhdGUuYiwgLi4uYXJncyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoLS1zdGF0ZS5jbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIuZ2V0KHN0YXRlLmR0b3IpKHN0YXRlLmEsIHN0YXRlLmIpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmEgPSAwO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJlYWwub3JpZ2luYWwgPSBzdGF0ZTtcblxuICAgIHJldHVybiByZWFsO1xufVxuZnVuY3Rpb24gX193YmdfYWRhcHRlcl81MChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgd2FzbS5fZHluX2NvcmVfX29wc19fZnVuY3Rpb25fX0ZuX19BX19fX091dHB1dF9fX1JfYXNfd2FzbV9iaW5kZ2VuX19jbG9zdXJlX19XYXNtQ2xvc3VyZV9fX2Rlc2NyaWJlX19pbnZva2VfX2hlOGRiNWZhMTY3NzA2YTA5KGFyZzAsIGFyZzEsIGFkZEhlYXBPYmplY3QoYXJnMikpO1xufVxuXG5mdW5jdGlvbiBfX3diZ19hZGFwdGVyXzUzKGFyZzAsIGFyZzEpIHtcbiAgICB3YXNtLl9keW5fY29yZV9fb3BzX19mdW5jdGlvbl9fRm5fX19fX091dHB1dF9fX1JfYXNfd2FzbV9iaW5kZ2VuX19jbG9zdXJlX19XYXNtQ2xvc3VyZV9fX2Rlc2NyaWJlX19pbnZva2VfX2hlZDU0MGM4ODQ1NGRmMDMxKGFyZzAsIGFyZzEpO1xufVxuXG5mdW5jdGlvbiBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCBkdG9yLCBmKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB7IGE6IGFyZzAsIGI6IGFyZzEsIGNudDogMSwgZHRvciB9O1xuICAgIGNvbnN0IHJlYWwgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAvLyBGaXJzdCB1cCB3aXRoIGEgY2xvc3VyZSB3ZSBpbmNyZW1lbnQgdGhlIGludGVybmFsIHJlZmVyZW5jZVxuICAgICAgICAvLyBjb3VudC4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIFJ1c3QgY2xvc3VyZSBlbnZpcm9ubWVudCB3b24ndFxuICAgICAgICAvLyBiZSBkZWFsbG9jYXRlZCB3aGlsZSB3ZSdyZSBpbnZva2luZyBpdC5cbiAgICAgICAgc3RhdGUuY250Kys7XG4gICAgICAgIGNvbnN0IGEgPSBzdGF0ZS5hO1xuICAgICAgICBzdGF0ZS5hID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmKGEsIHN0YXRlLmIsIC4uLmFyZ3MpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKC0tc3RhdGUuY250ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yLmdldChzdGF0ZS5kdG9yKShhLCBzdGF0ZS5iKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmVhbC5vcmlnaW5hbCA9IHN0YXRlO1xuXG4gICAgcmV0dXJuIHJlYWw7XG59XG5mdW5jdGlvbiBfX3diZ19hZGFwdGVyXzU2KGFyZzAsIGFyZzEpIHtcbiAgICB3YXNtLl9keW5fY29yZV9fb3BzX19mdW5jdGlvbl9fRm5NdXRfX19fX091dHB1dF9fX1JfYXNfd2FzbV9iaW5kZ2VuX19jbG9zdXJlX19XYXNtQ2xvc3VyZV9fX2Rlc2NyaWJlX19pbnZva2VfX2hjMTgyZTRkNTAzNTQxOTZiKGFyZzAsIGFyZzEpO1xufVxuXG5mdW5jdGlvbiBfX3diZ19hZGFwdGVyXzU5KGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgd2FzbS5fZHluX2NvcmVfX29wc19fZnVuY3Rpb25fX0ZuTXV0X19BX19fX091dHB1dF9fX1JfYXNfd2FzbV9iaW5kZ2VuX19jbG9zdXJlX19XYXNtQ2xvc3VyZV9fX2Rlc2NyaWJlX19pbnZva2VfX2g3Y2JjM2MzMjI5NjM3MDZmKHJldHB0ciwgYXJnMCwgYXJnMSwgYWRkSGVhcE9iamVjdChhcmcyKSk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9fd2JnX2FkYXB0ZXJfNjIoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIHdhc20uX2R5bl9jb3JlX19vcHNfX2Z1bmN0aW9uX19Gbk11dF9fQV9fX19PdXRwdXRfX19SX2FzX3dhc21fYmluZGdlbl9fY2xvc3VyZV9fV2FzbUNsb3N1cmVfX19kZXNjcmliZV9faW52b2tlX19oMzcwOTgwOGZmMTc0MTkxNChhcmcwLCBhcmcxLCBhZGRIZWFwT2JqZWN0KGFyZzIpKTtcbn1cblxuZnVuY3Rpb24gX193YmdfYWRhcHRlcl82NShhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgd2FzbS5fZHluX2NvcmVfX29wc19fZnVuY3Rpb25fX0ZuTXV0X19BX19fX091dHB1dF9fX1JfYXNfd2FzbV9iaW5kZ2VuX19jbG9zdXJlX19XYXNtQ2xvc3VyZV9fX2Rlc2NyaWJlX19pbnZva2VfX2g2YzYxNjFhYWNkNjY0NDc5KGFyZzAsIGFyZzEsIGFkZEhlYXBPYmplY3QoYXJnMikpO1xufVxuXG5mdW5jdGlvbiBfX3diZ19hZGFwdGVyXzY4KGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICB3YXNtLl9keW5fY29yZV9fb3BzX19mdW5jdGlvbl9fRm5NdXRfX0FfX19fT3V0cHV0X19fUl9hc193YXNtX2JpbmRnZW5fX2Nsb3N1cmVfX1dhc21DbG9zdXJlX19fZGVzY3JpYmVfX2ludm9rZV9faDY4YWE5N2QxMTNlZTM2MGMoYXJnMCwgYXJnMSwgYWRkSGVhcE9iamVjdChhcmcyKSk7XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnX2pzb25cbiogQHJldHVybnMge3N0cmluZ31cbiovXG5mdW5jdGlvbiBjb3JlX2NyZWF0ZV9jb250ZXh0KGNvbmZpZ19qc29uKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChjb25maWdfanNvbiwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmNvcmVfY3JlYXRlX2NvbnRleHQocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyMCwgcjEpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7bnVtYmVyfSBjb250ZXh0XG4qL1xuZnVuY3Rpb24gY29yZV9kZXN0cm95X2NvbnRleHQoY29udGV4dCkge1xuICAgIHdhc20uY29yZV9kZXN0cm95X2NvbnRleHQoY29udGV4dCk7XG59XG5cbi8qKlxuKiBAcGFyYW0ge251bWJlcn0gY29udGV4dFxuKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25fbmFtZVxuKiBAcGFyYW0ge2FueX0gcGFyYW1zXG4qIEBwYXJhbSB7bnVtYmVyfSByZXF1ZXN0X2lkXG4qL1xuZnVuY3Rpb24gY29yZV9yZXF1ZXN0KGNvbnRleHQsIGZ1bmN0aW9uX25hbWUsIHBhcmFtcywgcmVxdWVzdF9pZCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoZnVuY3Rpb25fbmFtZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmNvcmVfcmVxdWVzdChyZXRwdHIsIGNvbnRleHQsIHB0cjAsIGxlbjAsIGFkZEhlYXBPYmplY3QocGFyYW1zKSwgcmVxdWVzdF9pZCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGYsIGFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leG5fc3RvcmUoYWRkSGVhcE9iamVjdChlKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRBcnJheVU4RnJvbVdhc20wKHB0ciwgbGVuKSB7XG4gICAgcmV0dXJuIGdldFVpbnQ4TWVtb3J5MCgpLnN1YmFycmF5KHB0ciAvIDEsIHB0ciAvIDEgKyBsZW4pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBsb2FkKG1vZHVsZSwgaW1wb3J0cykge1xuICAgIGlmICh0eXBlb2YgUmVzcG9uc2UgPT09ICdmdW5jdGlvbicgJiYgbW9kdWxlIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcobW9kdWxlLCBpbXBvcnRzKTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChtb2R1bGUuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpICE9ICdhcHBsaWNhdGlvbi93YXNtJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmdgIGZhaWxlZCBiZWNhdXNlIHlvdXIgc2VydmVyIGRvZXMgbm90IHNlcnZlIHdhc20gd2l0aCBgYXBwbGljYXRpb24vd2FzbWAgTUlNRSB0eXBlLiBGYWxsaW5nIGJhY2sgdG8gYFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlYCB3aGljaCBpcyBzbG93ZXIuIE9yaWdpbmFsIGVycm9yOlxcblwiLCBlKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCBtb2R1bGUuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJ5dGVzLCBpbXBvcnRzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUobW9kdWxlLCBpbXBvcnRzKTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5JbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5zdGFuY2UsIG1vZHVsZSB9O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEltcG9ydHMoKSB7XG4gICAgY29uc3QgaW1wb3J0cyA9IHt9O1xuICAgIGltcG9ydHMud2JnID0ge307XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzhkMmFmMDBiYzFlMzI5ZWUgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBFcnJvcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9zdHJpbmdfbmV3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX21lbW9yeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm1lbW9yeTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2J1ZmZlcl8zZjNkNzY0ZDQ3NDdkNTY0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuYnVmZmVyO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZDlhYTI2NjcwM2NiOThiZSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoZ2V0T2JqZWN0KGFyZzApLCBhcmcxID4+PiAwLCBhcmcyID4+PiAwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fb2JqZWN0X2Ryb3BfcmVmID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICB0YWtlT2JqZWN0KGFyZzApO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3d2l0aGxlbmd0aF83YzQyZjdlNzM4YTlkNWQzID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgQXJyYXkoYXJnMCA+Pj4gMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfYTY4MjE0ZjM1YzQxN2ZhOSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApW2FyZzEgPj4+IDBdID0gdGFrZU9iamVjdChhcmcyKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld3dpdGh1OGFycmF5c2VxdWVuY2VfZjg2MzI0NmFmODNlMTc4NSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEJsb2IoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0Xzc2NTIwMTU0NGEyYjY4NjkgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFJlZmxlY3QuZ2V0KGdldE9iamVjdChhcmcwKSwgZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zdGFuY2VvZl9BcnJheUJ1ZmZlcl9lNWU0OGY0NzYyYzU2MTBiID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZ2V0T2JqZWN0KGFyZzApIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc19vYmplY3QgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGdldE9iamVjdChhcmcwKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKHZhbCkgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld184YzNmMDA1MjI3MmE0NTdhID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9vYmplY3RfY2xvbmVfcmVmID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19rZXlzXzA3MDIyOTRhZmFlYjYwNDQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE9iamVjdC5rZXlzKGdldE9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19sZW5ndGhfNmUzYmJlN2M4YmQ0ZGJkOCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldF81NzI0NWNjN2Q3Yzc2MTlkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMClbYXJnMSA+Pj4gMF07XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX3N0cmluZ19nZXQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKG9iaikgPT09ICdzdHJpbmcnID8gb2JqIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUocmV0KSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChyZXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gcHRyMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ldzBfYTU3MDU5ZDcyYzViN2FlZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0VGltZV9jYjgyYWRiMjU1NmVkMTNlID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZ2V0VGltZSgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9qc3ZhbF9sb29zZV9lcSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApID09IGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fYm9vbGVhbl9nZXQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHYgPSBnZXRPYmplY3QoYXJnMCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZih2KSA9PT0gJ2Jvb2xlYW4nID8gKHYgPyAxIDogMCkgOiAyO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc19iaWdpbnQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZihnZXRPYmplY3QoYXJnMCkpID09PSAnYmlnaW50JztcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fbnVtYmVyX2dldCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2Yob2JqKSA9PT0gJ251bWJlcicgPyBvYmogOiB1bmRlZmluZWQ7XG4gICAgICAgIGdldEZsb2F0NjRNZW1vcnkwKClbYXJnMCAvIDggKyAxXSA9IGlzTGlrZU5vbmUocmV0KSA/IDAgOiByZXQ7XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMF0gPSAhaXNMaWtlTm9uZShyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaXNTYWZlSW50ZWdlcl9kZmEwNTkzZThkN2FjMzVhID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBOdW1iZXIuaXNTYWZlSW50ZWdlcihnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9iaWdpbnRfZ2V0X2FzX2k2NCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgdiA9IGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKHYpID09PSAnYmlnaW50JyA/IHYgOiB1bmRlZmluZWQ7XG4gICAgICAgIGdldEJpZ0ludDY0TWVtb3J5MCgpW2FyZzAgLyA4ICsgMV0gPSBpc0xpa2VOb25lKHJldCkgPyAwbiA6IHJldDtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAwXSA9ICFpc0xpa2VOb25lKHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2JpZ2ludF9mcm9tX2k2NCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gYXJnMDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fanN2YWxfZXEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKSA9PT0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9iaWdpbnRfZnJvbV91NjQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEJpZ0ludC5hc1VpbnROKDY0LCBhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fZXJyb3JfbmV3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgRXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2lzQXJyYXlfMjdjNDZjNjdmNDk4ZTE1ZCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gQXJyYXkuaXNBcnJheShnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaXRlcmF0b3JfNmY5ZDRmMjg4NDVmNDI2YyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBTeW1ib2wuaXRlcmF0b3I7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2luID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkgaW4gZ2V0T2JqZWN0KGFyZzEpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZW50cmllc182NWE3NmE0MTNmYzkxMDM3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBPYmplY3QuZW50cmllcyhnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc191bmRlZmluZWQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc19udWxsID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkgPT09IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19TdHJpbmdfOTFmYmE3ZGVkMTNiYTU0YyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gU3RyaW5nKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChyZXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAxXSA9IGxlbjA7XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMF0gPSBwdHIwO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9udW1iZXJfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBhcmcwO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzBiOWJmZGQ5NzU4MzI4NGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IE9iamVjdCgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfU3RyaW5nXzMzMDk5ODU2ZThhODI0NmEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFN0cmluZyhnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gcHRyMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NvcmVyZXNwb25zZWhhbmRsZXJfYTUyODc5NDU0YzYwYzc2NCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgY29yZV9yZXNwb25zZV9oYW5kbGVyKGFyZzAgPj4+IDAsIHRha2VPYmplY3QoYXJnMSksIGFyZzIgPj4+IDAsIGFyZzMgIT09IDApO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbWVzc2FnZV9mZTJhZjYzY2NjODk4NWJjID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkubWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld18xZDlhOTIwYzZiZmM0NGE4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBBcnJheSgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzI2OGY3YjdkZDM0MzA3OTggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0XzkzMzcyOWNmNWI2NmFjMTEgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5zZXQoZ2V0T2JqZWN0KGFyZzEpLCBnZXRPYmplY3QoYXJnMikpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc19zdHJpbmcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZihnZXRPYmplY3QoYXJnMCkpID09PSAnc3RyaW5nJztcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF9mYmMzM2QwMjBmNTA3YjcyID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBnZXRPYmplY3QoYXJnMClbdGFrZU9iamVjdChhcmcxKV0gPSB0YWtlT2JqZWN0KGFyZzIpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcHJvY2Vzc18wY2MyYWRhODUyNGQ2ZjgzID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkucHJvY2VzcztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3ZlcnNpb25zX2MxMWFjY2VhYjI3YTZjODcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS52ZXJzaW9ucztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vZGVfN2ZmMWNlNDljYWYyMzgxNSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm5vZGU7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdGF0aWNfYWNjZXNzb3JfTk9ERV9NT0RVTEVfY2Y2NDAxY2MxMDkxMjc5ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBtb2R1bGU7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZXF1aXJlX2E3NDZlNzliMzIyYjkzMzYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5yZXF1aXJlKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NyeXB0b18yMDM2YmVkN2M0NGMyNWU3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuY3J5cHRvO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbXNDcnlwdG9fYTIxZmM4OGNhZjFlY2RjOCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm1zQ3J5cHRvO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3d2l0aGxlbmd0aF9mNTkzMzg1NWU0ZjQ4YTE5ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShhcmcwID4+PiAwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3RyYW5zYWN0aW9uX2NjZTk2Y2JlYmQ4MWZlMWMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS50cmFuc2FjdGlvbihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMiksIHRha2VPYmplY3QoYXJnMykpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRvbmNvbXBsZXRlXzNlNTdhOGNlYzgzMjdmNjYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbmNvbXBsZXRlID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0b25lcnJvcl8wMDA1MWMwMjEzZjI3YjJjID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub25lcnJvciA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldG9uYWJvcnRfNDA0YmVlM2I5OTQwZDAzZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9uYWJvcnQgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pdGVtXzUyYTZiZWMzNjMxNDY4N2IgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcxKS5pdGVtKGFyZzIgPj4+IDApO1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUocmV0KSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChyZXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gcHRyMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX29iamVjdFN0b3JlX2YxNzk3NmIwZTYzNzc4MzAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5vYmplY3RTdG9yZShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190YXJnZXRfYmY3MDRiN2RiN2FkMTM4NyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnRhcmdldDtcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZWFkeVN0YXRlX2ZiMjg3ZjE3MDExMzkxN2MgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5yZWFkeVN0YXRlO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0b25zdWNjZXNzXzVmNzE1OTNiYzUxNjUzYTMgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbnN1Y2Nlc3MgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRvbmVycm9yX2Q1NzcxY2M1YmY5ZWE3NGMgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbmVycm9yID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jYl9kcm9wID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCBvYmogPSB0YWtlT2JqZWN0KGFyZzApLm9yaWdpbmFsO1xuICAgICAgICBpZiAob2JqLmNudC0tID09IDEpIHtcbiAgICAgICAgICAgIG9iai5hID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV4dF9hYWVmN2M4YWE1ZTIxMmFjID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkubmV4dCgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19kb25lXzFiNzNiMDY3MmUxNWYyMzQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5kb25lO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdmFsdWVfMWNjYzM2YmMwMzQ2MmQ3MSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnZhbHVlO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc19mdW5jdGlvbiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKGdldE9iamVjdChhcmcwKSkgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jYWxsXzk3YWU5ZDg2NDVkYzM4OGIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5jYWxsKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25leHRfNTc5ZTU4M2QzMzU2NmE4NiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm5leHQ7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZWxmXzZkNDc5NTA2ZjcyYzZhNzEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gc2VsZi5zZWxmO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ193aW5kb3dfZjI1NTdjYzc4NDkwYWNlYiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3aW5kb3cud2luZG93O1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nbG9iYWxUaGlzXzdmMjA2YmRhNjI4ZDUyODYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2xvYmFsVGhpcy5nbG9iYWxUaGlzO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nbG9iYWxfYmE3NWM1MGQxY2YzODRmNCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXQgPSBnbG9iYWwuZ2xvYmFsO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdub2FyZ3NfYjViMDYzZmM2YzJmMDM3NiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEZ1bmN0aW9uKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfODNkYjk2OTBmOTM1M2U3OSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnNldChnZXRPYmplY3QoYXJnMSksIGFyZzIgPj4+IDApO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbGVuZ3RoXzllMWFlMTkwMGNiMGZiZDUgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5sZW5ndGg7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfYmYzZjg5YjkyZDVhMzRiZiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gUmVmbGVjdC5zZXQoZ2V0T2JqZWN0KGFyZzApLCBnZXRPYmplY3QoYXJnMSksIGdldE9iamVjdChhcmcyKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NlbGZfN2VlZGUxZjQ0ODhiZjM0NiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXQgPSBzZWxmLnNlbGY7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NyeXB0b19jOTA5ZmI0MjhkY2JkZGI2ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuY3J5cHRvO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbXNDcnlwdG9fNTExZWVmZWZiZmM3MGFlNCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm1zQ3J5cHRvO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3RhdGljX2FjY2Vzc29yX01PRFVMRV9lZjNhYTJlYjI1MTE1OGE1ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG1vZHVsZTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3JlcXVpcmVfOTAwZDVjMzk4NGZlNzcwMyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnJlcXVpcmUoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFJhbmRvbVZhbHVlc18zMDcwNDkzNDVkMGJkODhjID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZ2V0UmFuZG9tVmFsdWVzO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmFuZG9tRmlsbFN5bmNfODViM2Y0YzUyYzU2YzMxMyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnJhbmRvbUZpbGxTeW5jKGdldEFycmF5VThGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3ViYXJyYXlfNThhZDRlZmJiNWJjYjg4NiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnN1YmFycmF5KGFyZzEgPj4+IDAsIGFyZzIgPj4+IDApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0UmFuZG9tVmFsdWVzX2NkMTc1OTE1NTExZjcwNWUgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5nZXRSYW5kb21WYWx1ZXMoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3JhbmRvbUZpbGxTeW5jXzA2NWFmZmZkZTAxZGFhNjYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5yYW5kb21GaWxsU3luYyhnZXRBcnJheVU4RnJvbVdhc20wKGFyZzEsIGFyZzIpKTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0UmFuZG9tVmFsdWVzX2I5OWVlYzQyNDRhNDc1YmIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5nZXRSYW5kb21WYWx1ZXMoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zdGFuY2VvZl9VaW50OEFycmF5Xzk3MWVlZGE2OWViNzUwMDMgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBnZXRPYmplY3QoYXJnMCkgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3B1dF84NGU3ZmM5M2VlZTI3YjI4ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkucHV0KGdldE9iamVjdChhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZGVsZXRlXzhhYmVkZDEwNDNiNDEwNWQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5kZWxldGUoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0VGltZW91dF9kNmZjZjBkOTA2N2I4ZTY0ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuc2V0VGltZW91dChnZXRPYmplY3QoYXJnMSksIGFyZzIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jbGVhclRpbWVvdXRfN2Q2ZjdiZmVlZDM0YjM0OCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmNsZWFyVGltZW91dChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld3dpdGhzdHJhbmRpbml0XzA1ZDcxODA3ODg0MjBjNDAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBSZXF1ZXN0KGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaGVhZGVyc184NTgyNGU5OTNhYTczOWJmID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuaGVhZGVycztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF85OTJjMWQzMTU4NmIyOTU3ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuc2V0KGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzMsIGFyZzQpKTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZmV0Y2hfMGZlMDQ5MDVjY2NmYzJhYSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmZldGNoKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbnN0YW5jZW9mX1Jlc3BvbnNlX2VhYTQyNjIyMDg0OGEzOWUgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBnZXRPYmplY3QoYXJnMCkgaW5zdGFuY2VvZiBSZXNwb25zZTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdGF0dXNfYzRlZjNkZDU5MWU2MzQzNSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnN0YXR1cztcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3VybF83NDI4NWRkZjI3NDdjYjNkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMSkudXJsO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gcHRyMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldG9udmVyc2lvbmNoYW5nZV84NDBkNjVjZDA4ODhkZmIwID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub252ZXJzaW9uY2hhbmdlID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0b251cGdyYWRlbmVlZGVkXzE3ZDBiOTUzMGYxZTBjYWMgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbnVwZ3JhZGVuZWVkZWQgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRvbmJsb2NrZWRfZTY2ZDZiZTVjODc5OTgwZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9uYmxvY2tlZCA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX21lc3NhZ2VfYTdhZjNlZTBjYzBmZTI4ZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzEpLm1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChyZXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAxXSA9IGxlbjA7XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMF0gPSBwdHIwO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfV2luZG93XzU2ODQzNDFmZjZkZmUzYWQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5XaW5kb3c7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19Xb3JrZXJHbG9iYWxTY29wZV9lMDQ0N2ZmY2FlOGJiMjcyID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuV29ya2VyR2xvYmFsU2NvcGU7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbmRleGVkREJfMDUwZjA5NjJhYjYwN2FjNSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmluZGV4ZWREQjtcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luZGV4ZWREQl84ZDllOWFiNDYxNmRmN2YwID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuaW5kZXhlZERCO1xuICAgICAgICByZXR1cm4gaXNMaWtlTm9uZShyZXQpID8gMCA6IGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfb3Blbl9hMzFjM2ZlMWZkYzI0NGViID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkub3BlbihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXd3aXRoc3RyX2Q1YjVmOWI5ODVlZTg0ZmIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBXZWJTb2NrZXQoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpLCBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMiwgYXJnMykpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfZDI5ZTUwN2Y2NjA2ZGU5MSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFdlYlNvY2tldChnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRvbm1lc3NhZ2VfYzVhODA2YjYyYTBjNTYwNyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9ubWVzc2FnZSA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldG9ub3Blbl85Y2U0OGRjZTU3ZTU0OWI1ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub25vcGVuID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0b25lcnJvcl8wMjM5MzI2MGIzZTI5OTcyID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub25lcnJvciA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NlbmRfODBiMjU2ZDg3YTY3NzllNSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnNlbmQoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpKTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZGF0YV83YjFmMDFmNGU2YTY0ZmJlID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZGF0YTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N0cmluZ2lmeV9kNjQ3MWQzMDBkZWQ5YjY4ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBKU09OLnN0cmluZ2lmeShnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19vYmplY3RTdG9yZU5hbWVzXzhjMDZjNDBkMmIwNTE0MWMgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5vYmplY3RTdG9yZU5hbWVzO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY3JlYXRlT2JqZWN0U3RvcmVfZDNlMjc4OWMxM2RkZTFmYyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNyZWF0ZU9iamVjdFN0b3JlKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luc3RhbmNlb2ZfRXJyb3JfNTZiNDk2YTEwYTU2ZGU2NiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGdldE9iamVjdChhcmcwKSBpbnN0YW5jZW9mIEVycm9yO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFRpbWV6b25lT2Zmc2V0Xzg5YmQ0Mjc1ZTFjYTgzNDEgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9kZWJ1Z19zdHJpbmcgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGRlYnVnU3RyaW5nKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChyZXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAxXSA9IGxlbjA7XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMF0gPSBwdHIwO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl90aHJvdyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190aGVuX2NlZGFkMjBmYmJkOTQxOGEgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS50aGVuKGdldE9iamVjdChhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Jlc29sdmVfOTlmZTE3OTY0ZjMxZmZjMCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gUHJvbWlzZS5yZXNvbHZlKGdldE9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190aGVuXzExZjdhNTRkNjdiNGJmYWQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS50aGVuKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZXN1bHRfOWUzOTljMTQ2NzY5NzBkOSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnJlc3VsdDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZXJyb3JfYWFjZjVhYzE5MWU1NGVkMCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmVycm9yO1xuICAgICAgICByZXR1cm4gaXNMaWtlTm9uZShyZXQpID8gMCA6IGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0XzYyODViZjQ1OGExZWU3NTggPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5nZXQoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zdGFuY2VvZl9XaW5kb3dfYWNjOTdmZjlmNWQyYzdiNCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY2xvc2VfNDVkMDUzYmVhNTllNzc0NiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmNsb3NlKCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3RleHRfMTE2OWQ3NTJjYzY5NzkwMyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnRleHQoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jbG9zdXJlX3dyYXBwZXI5NDcgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG1ha2VDbG9zdXJlKGFyZzAsIGFyZzEsIDQ0LCBfX3diZ19hZGFwdGVyXzUwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2xvc3VyZV93cmFwcGVyOTU4ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBtYWtlQ2xvc3VyZShhcmcwLCBhcmcxLCA0NywgX193YmdfYWRhcHRlcl81Myk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nsb3N1cmVfd3JhcHBlcjYxNTkgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG1ha2VNdXRDbG9zdXJlKGFyZzAsIGFyZzEsIDIzOCwgX193YmdfYWRhcHRlcl81Nik7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nsb3N1cmVfd3JhcHBlcjY4MjQgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG1ha2VNdXRDbG9zdXJlKGFyZzAsIGFyZzEsIDI0NywgX193YmdfYWRhcHRlcl81OSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nsb3N1cmVfd3JhcHBlcjY4NzQgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG1ha2VNdXRDbG9zdXJlKGFyZzAsIGFyZzEsIDI0NCwgX193YmdfYWRhcHRlcl82Mik7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nsb3N1cmVfd3JhcHBlcjY4NzUgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG1ha2VNdXRDbG9zdXJlKGFyZzAsIGFyZzEsIDEyMDYsIF9fd2JnX2FkYXB0ZXJfNjUpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jbG9zdXJlX3dyYXBwZXI2ODc2ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCAyNDEsIF9fd2JnX2FkYXB0ZXJfNjgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW1wb3J0cztcbn1cblxuZnVuY3Rpb24gaW5pdE1lbW9yeShpbXBvcnRzLCBtYXliZV9tZW1vcnkpIHtcblxufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZUluaXQoaW5zdGFuY2UsIG1vZHVsZSkge1xuICAgIHdhc20gPSBpbnN0YW5jZS5leHBvcnRzO1xuICAgIGluaXQuX193YmluZGdlbl93YXNtX21vZHVsZSA9IG1vZHVsZTtcbiAgICBjYWNoZWRCaWdJbnQ2NE1lbW9yeTAgPSBuZXcgQmlnSW50NjRBcnJheSgpO1xuICAgIGNhY2hlZEZsb2F0NjRNZW1vcnkwID0gbmV3IEZsb2F0NjRBcnJheSgpO1xuICAgIGNhY2hlZEludDMyTWVtb3J5MCA9IG5ldyBJbnQzMkFycmF5KCk7XG4gICAgY2FjaGVkVWludDhNZW1vcnkwID0gbmV3IFVpbnQ4QXJyYXkoKTtcblxuXG4gICAgcmV0dXJuIHdhc207XG59XG5cbmZ1bmN0aW9uIGluaXRTeW5jKG1vZHVsZSkge1xuICAgIGNvbnN0IGltcG9ydHMgPSBnZXRJbXBvcnRzKCk7XG5cbiAgICBpbml0TWVtb3J5KGltcG9ydHMpO1xuXG4gICAgaWYgKCEobW9kdWxlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTW9kdWxlKSkge1xuICAgICAgICBtb2R1bGUgPSBuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG1vZHVsZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobW9kdWxlLCBpbXBvcnRzKTtcblxuICAgIHJldHVybiBmaW5hbGl6ZUluaXQoaW5zdGFuY2UsIG1vZHVsZSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGluaXQoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJykgeyAgICB9XG4gICAgY29uc3QgaW1wb3J0cyA9IGdldEltcG9ydHMoKTtcblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8ICh0eXBlb2YgUmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHx8ICh0eXBlb2YgVVJMID09PSAnZnVuY3Rpb24nICYmIGlucHV0IGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICBpbnB1dCA9IGZldGNoKGlucHV0KTtcbiAgICB9XG5cbiAgICBpbml0TWVtb3J5KGltcG9ydHMpO1xuXG4gICAgY29uc3QgeyBpbnN0YW5jZSwgbW9kdWxlIH0gPSBhd2FpdCBsb2FkKGF3YWl0IGlucHV0LCBpbXBvcnRzKTtcblxuICAgIHJldHVybiBmaW5hbGl6ZUluaXQoaW5zdGFuY2UsIG1vZHVsZSk7XG59XG5cblxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogV1JBUFBFUiBFTkRcbiAgICBmdW5jdGlvbiByZXBsYWNlVW5kZWZpbmVkV2l0aE51bGxzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBbXSA6IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHJlcGxhY2VVbmRlZmluZWRXaXRoTnVsbHModmFsdWVba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZXBsYWNlQmxvYnNXaXRoQXJyYXlCdWZmZXJzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB2YWx1ZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICYmIHZhbHVlID4gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBbXSA6IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGF3YWl0IHJlcGxhY2VCbG9ic1dpdGhBcnJheUJ1ZmZlcnModmFsdWVba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cblxuICAgIGxldCBkZWZlcnJlZENyZWF0ZUNvbnRleHQgPSBbXTtcbiAgICBsZXQgcmVzcG9uc2VIYW5kbGVyID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGNvcmVfcmVzcG9uc2VfaGFuZGxlcihyZXF1ZXN0X2lkLCBwYXJhbXMsIHJlc3BvbnNlX3R5cGUsIGZpbmlzaGVkKSB7XG4gICAgICAgIGlmIChyZXNwb25zZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlSGFuZGxlcihcbiAgICAgICAgICAgICAgICByZXF1ZXN0X2lkLFxuICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgICByZXNwb25zZV90eXBlLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGluaXQoYXdhaXQgbG9hZE1vZHVsZSgpKTtcbiAgICAgICAgZm9yIChjb25zdCBjcmVhdGVDb250ZXh0IG9mIGRlZmVycmVkQ3JlYXRlQ29udGV4dCkge1xuICAgICAgICAgICAgY3JlYXRlQ29udGV4dC5yZXNvbHZlKGNvcmVfY3JlYXRlX2NvbnRleHQoY3JlYXRlQ29udGV4dC5jb25maWdKc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmZXJyZWRDcmVhdGVDb250ZXh0ID0gbnVsbDtcbiAgICB9KSgpO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIHNldFJlc3BvbnNlUGFyYW1zSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHJlc3BvbnNlSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZUNvbnRleHQ6IChjb25maWdKc29uKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWRDcmVhdGVDb250ZXh0ID09PSBudWxsXG4gICAgICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoY29yZV9jcmVhdGVfY29udGV4dChjb25maWdKc29uKSlcbiAgICAgICAgICAgICAgICA6IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ3JlYXRlQ29udGV4dC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0pzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveUNvbnRleHQ6IChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBjb3JlX2Rlc3Ryb3lfY29udGV4dChjb250ZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZFJlcXVlc3RQYXJhbXM6IChjb250ZXh0LCByZXF1ZXN0SWQsIGZ1bmN0aW9uTmFtZSwgZnVuY3Rpb25QYXJhbXMpID0+IHtcbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29yZV9yZXF1ZXN0KFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlcGxhY2VCbG9ic1dpdGhBcnJheUJ1ZmZlcnMoZnVuY3Rpb25QYXJhbXMpLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpYldlYigpIHtcbiAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmRpc2FibGVTZXBhcmF0ZVdvcmtlciA/IHdpdGhvdXRTZXBhcmF0ZVdvcmtlcigpIDogd2l0aFNlcGFyYXRlV29ya2VyKCk7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///113\n")},437:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// NAMESPACE OBJECT: ./src/scripts/ever.js\nvar ever_namespaceObject = {};\n__webpack_require__.r(ever_namespaceObject);\n__webpack_require__.d(ever_namespaceObject, {\n  \"attkCell\": () => (attkCell),\n  \"getAddressCells\": () => (getAddressCells),\n  \"getDetailsCell\": () => (getDetailsCell),\n  \"helpCell\": () => (helpCell),\n  \"init\": () => (init),\n  \"markCell\": () => (markCell),\n  \"newGame\": () => (newGame),\n  \"routerDetails\": () => (routerDetails),\n  \"subscribeAllCellState\": () => (subscribeAllCellState),\n  \"subscribePermissionsChanged\": () => (subscribePermissionsChanged),\n  \"upgradeCell\": () => (upgradeCell)\n});\n\n;// CONCATENATED MODULE: ./node_modules/honeycomb-grid/dist/honeycomb-grid.mjs\nconst l = (r) => Number.isFinite(r) && !Number.isNaN(r), w = (r) => typeof r == \"object\" && r !== null, Ot = (r) => w(r) && l(r.q) && l(r.r), k = (r) => typeof r == \"function\", S = (r) => w(r) && l(r.col) && l(r.row), V = (r) => w(r) && l(r.x) && l(r.y), H = (r) => Array.isArray(r) && l(r[0]) && l(r[1]), P = (r, t) => t + r * (t & 1) >> 1;\nfunction Z(r, t) {\n  return (r % t + t) % t;\n}\nconst X = (r, t) => Z(r + t, 8), E = ([r, t, e = -r - t]) => ({ q: r, r: t, s: e });\nfunction p({ q: r, r: t, s: e }) {\n  const n = l(r), s = l(t), o = l(e);\n  if (n && s && o)\n    return { q: r, r: t, s: e };\n  if (n && s)\n    return { q: r, r: t, s: -r - t };\n  if (n && o)\n    return { q: r, r: -r - e, s: e };\n  if (s && o)\n    return { q: -t - e, r: t, s: e };\n  throw new TypeError(\n    `Can't determine three cube coordinates from less than two coordinates. Received: { q: ${r}, r: ${t}, s: ${e} }.`\n  );\n}\nvar g = /* @__PURE__ */ ((r) => (r.FLAT = \"FLAT\", r.POINTY = \"POINTY\", r))(g || {});\nfunction G(r, t) {\n  if (w(r) && r.xRadius > 0 && r.yRadius > 0)\n    return r;\n  if (w(r) && r.width > 0 && r.height > 0) {\n    const { width: e, height: n } = r;\n    return t === g.POINTY ? { xRadius: e / Math.sqrt(3), yRadius: n / 2 } : { xRadius: e / 2, yRadius: n / Math.sqrt(3) };\n  }\n  if (r > 0)\n    return { xRadius: r, yRadius: r };\n  throw new TypeError(\n    `Invalid dimensions: ${JSON.stringify(\n      r\n    )}. Dimensions must be expressed as an Ellipse ({ xRadius: number, yRadius: number }), a Rectangle ({ width: number, height: number }) or a number.`\n  );\n}\nfunction D(r, t) {\n  if (V(r))\n    return r;\n  if (!t)\n    throw new TypeError(\n      `Supply a bounding box ({ width: number, height: number }). Received: ${JSON.stringify(t)}`\n    );\n  if (r === \"topLeft\")\n    return { x: t.width * -0.5, y: t.height * -0.5 };\n  throw new TypeError(\n    `Invalid origin: ${JSON.stringify(\n      r\n    )}. Origin must be expressed as a Point ({ x: number, y: number }) or the string 'topLeft'.`\n  );\n}\nclass $ {\n  static get settings() {\n    const { dimensions: t, orientation: e, origin: n, offset: s } = this.prototype;\n    return { dimensions: t, orientation: e, origin: n, offset: s };\n  }\n  get center() {\n    const { width: t, height: e, x: n, y: s } = this;\n    return { x: t / 2 - n, y: e / 2 - s };\n  }\n  get col() {\n    return W(this).col;\n  }\n  get corners() {\n    const { orientation: t, width: e, height: n, x: s, y: o } = this;\n    return t === g.POINTY ? tt(e, n, s, o) : rt(e, n, s, o);\n  }\n  get dimensions() {\n    return T.dimensions;\n  }\n  get height() {\n    const {\n      orientation: t,\n      dimensions: { yRadius: e }\n    } = this;\n    return t === g.POINTY ? e * 2 : e * Math.sqrt(3);\n  }\n  get isFlat() {\n    return this.orientation === g.FLAT;\n  }\n  get isPointy() {\n    return this.orientation === g.POINTY;\n  }\n  get orientation() {\n    return T.orientation;\n  }\n  get origin() {\n    return T.origin;\n  }\n  get offset() {\n    return T.offset;\n  }\n  get row() {\n    return W(this).row;\n  }\n  get width() {\n    const {\n      orientation: t,\n      dimensions: { xRadius: e }\n    } = this;\n    return t === g.POINTY ? e * Math.sqrt(3) : e * 2;\n  }\n  get x() {\n    return J(this).x;\n  }\n  get y() {\n    return J(this).y;\n  }\n  get s() {\n    return -this.q - this.r;\n  }\n  q;\n  r;\n  constructor(t = [0, 0]) {\n    const { q: e, r: n } = C(this, t);\n    this.q = e, this.r = n;\n  }\n  clone(t = this) {\n    return new this.constructor(t);\n  }\n  equals(t) {\n    return nt(this, S(t) ? j(this, t) : t);\n  }\n  toString() {\n    return `${this.constructor.name}(${this.q},${this.r})`;\n  }\n  translate(t) {\n    return ct(this, t);\n  }\n}\nconst T = {\n  dimensions: { xRadius: 1, yRadius: 1 },\n  orientation: g.POINTY,\n  origin: { x: 0, y: 0 },\n  offset: -1\n}, tt = (r, t, e, n) => [\n  { x: e + r * 0.5, y: n - t * 0.25 },\n  { x: e + r * 0.5, y: n + t * 0.25 },\n  { x: e, y: n + t * 0.5 },\n  { x: e - r * 0.5, y: n + t * 0.25 },\n  { x: e - r * 0.5, y: n - t * 0.25 },\n  { x: e, y: n - t * 0.5 }\n], rt = (r, t, e, n) => [\n  { x: e + r * 0.25, y: n - t * 0.5 },\n  { x: e + r * 0.5, y: n },\n  { x: e + r * 0.25, y: n + t * 0.5 },\n  { x: e - r * 0.25, y: n + t * 0.5 },\n  { x: e - r * 0.5, y: n },\n  { x: e - r * 0.25, y: n - t * 0.5 }\n];\nfunction et(r) {\n  const { dimensions: t, orientation: e, origin: n, offset: s } = { ...T, ...r };\n  return class extends $ {\n    get dimensions() {\n      return G(t, e);\n    }\n    get orientation() {\n      return e;\n    }\n    get origin() {\n      return D(n, this);\n    }\n    get offset() {\n      return s;\n    }\n  };\n}\nfunction nt(r, t) {\n  if (S(r) && S(t))\n    return r.col === t.col && r.row === t.row;\n  if (Object.hasOwn(r, \"col\") || Object.hasOwn(t, \"col\"))\n    throw new Error(\n      `Can't compare coordinates where one are offset coordinates. Either pass two offset coordinates or two axial/cube coordinates. Received: ${JSON.stringify(\n        r\n      )} and ${JSON.stringify(t)}`\n    );\n  const e = H(r) ? E(r) : r, n = H(t) ? E(t) : t;\n  return e.q === n.q && e.r === n.r;\n}\nconst st = (r, t, e) => ({\n  col: r + P(e, t),\n  row: t\n}), ot = (r, t, e) => ({\n  col: r,\n  row: t + P(e, r)\n}), W = ({ q: r, r: t, offset: e, isPointy: n }) => n ? st(r, t, e) : ot(r, t, e), J = ({ orientation: r, dimensions: { xRadius: t, yRadius: e }, origin: { x: n, y: s }, q: o, r: i }) => r === g.POINTY ? {\n  x: t * Math.sqrt(3) * (o + i / 2) - n,\n  y: e * 3 / 2 * i - s\n} : {\n  x: t * 3 / 2 * o - n,\n  y: e * Math.sqrt(3) * (i + o / 2) - s\n}, z = (r, t, e) => {\n  const n = r - P(e, t), s = t, o = -n - s;\n  return { q: n, r: s, s: o };\n}, _ = (r, t, e) => {\n  const n = r, s = t - P(e, r), o = -n - s;\n  return { q: n, r: s, s: o };\n}, j = ({ offset: r, orientation: t }, { col: e, row: n }) => t === g.POINTY ? z(e, n, r) : _(e, n, r), F = (r) => {\n  const { q: t, r: e, s: n } = p(r);\n  let s = Math.round(t), o = Math.round(e), i = Math.round(n);\n  const c = Math.abs(t - s), u = Math.abs(e - o), h = Math.abs(n - i);\n  return c > u && c > h ? s = -o - i : u > h ? o = -s - i : i = -s - o, { q: s, r: o, s: i };\n}, it = ({ dimensions: { xRadius: r, yRadius: t }, origin: e, orientation: n }, { x: s, y: o }) => (s += e.x, o += e.y, n === g.POINTY ? F({ q: Math.sqrt(3) * s / (3 * r) - o / (3 * t), r: 2 / 3 * (o / t) }) : F({ q: 2 / 3 * (s / r), r: Math.sqrt(3) * o / (3 * t) - s / (3 * r) }));\nfunction C(r, t) {\n  return H(t) ? E(t) : S(t) ? j(r, t) : p(t);\n}\nfunction ct(r, t) {\n  const { q: e, r: n, s } = p(r), { q: o, r: i, s: c } = p(t), u = { q: e + o, r: n + i, s: s + c };\n  return r instanceof $ ? r.clone(u) : u;\n}\nfunction R(r, t, e) {\n  const { q: n, r: s, s: o } = C(r, t), { q: i, r: c, s: u } = C(r, e);\n  return Math.max(Math.abs(n - i), Math.abs(s - c), Math.abs(o - u));\n}\nvar L = /* @__PURE__ */ ((r) => (r.CLOCKWISE = \"CLOCKWISE\", r.COUNTERCLOCKWISE = \"COUNTERCLOCKWISE\", r))(L || {}), f = /* @__PURE__ */ ((r) => (r[r.N = 0] = \"N\", r[r.NE = 1] = \"NE\", r[r.E = 2] = \"E\", r[r.SE = 3] = \"SE\", r[r.S = 4] = \"S\", r[r.SW = 5] = \"SW\", r[r.W = 6] = \"W\", r[r.NW = 7] = \"NW\", r))(f || {});\nconst ut = [\n  null,\n  { q: 1, r: -1 },\n  { q: 1, r: 0 },\n  { q: 0, r: 1 },\n  null,\n  { q: -1, r: 1 },\n  { q: -1, r: 0 },\n  { q: 0, r: -1 }\n], ht = [\n  { q: 0, r: -1 },\n  { q: 1, r: -1 },\n  null,\n  { q: 1, r: 0 },\n  { q: 0, r: 1 },\n  { q: -1, r: 1 },\n  null,\n  { q: -1, r: 0 }\n], ft = ({ offset: r, q: t, r: e, col: n, row: s }, o) => {\n  if (o === f.S || o === f.N) {\n    const c = o === f.S ? s + 1 : s - 1;\n    return z(n, c, r);\n  }\n  const i = ut[o];\n  return { q: t + i.q, r: e + i.r };\n}, at = ({ offset: r, q: t, r: e, col: n, row: s }, o) => {\n  if (o === f.E || o === f.W) {\n    const c = o === f.E ? n + 1 : n - 1;\n    return _(c, s, r);\n  }\n  const i = ht[o];\n  return { q: t + i.q, r: e + i.r };\n}, I = (r, t) => r.clone(r.isPointy ? ft(r, t) : at(r, t));\nfunction N(r) {\n  return Array.isArray(r) ? function(e, n) {\n    const s = [];\n    let o = n;\n    for (const i of r)\n      for (const c of i(e, o))\n        s.push(o = c);\n    return s;\n  } : r;\n}\nconst Tt = (...r) => (t) => r.map(t);\nfunction v(r) {\n  return lt(r) ? gt(r) : xt(r);\n}\nfunction lt(r) {\n  return r.direction in f;\n}\nfunction gt({ start: r, direction: t, length: e }) {\n  return function(s, o) {\n    const i = [];\n    let u = s(r ?? o);\n    !r && o && (u = I(u, t));\n    for (let h = 0; h < e; h++)\n      i.push(u), u = I(u, t);\n    return i;\n  };\n}\nfunction xt({ start: r, stop: t }) {\n  return function(n, s) {\n    const o = [], i = n(r ?? s), c = B(i), u = B(C(i, t)), h = dt(c, u), x = R(i, i, t), y = 1 / Math.max(x, 1);\n    let m = !r && s ? 1 : 0;\n    for (m; m <= x; m++) {\n      const a = F(h(y * m));\n      o.push(n(a));\n    }\n    return o;\n  };\n}\nfunction B({ q: r, r: t, s: e }) {\n  return { q: r + 1e-6, r: t + 1e-6, s: e + -2e-6 };\n}\nfunction dt(r, t) {\n  return (e) => {\n    const n = r.q * (1 - e) + t.q * e, s = r.r * (1 - e) + t.r * e;\n    return { q: n, r: s };\n  };\n}\nconst wt = (r) => (t, e) => [I(t(e), r)];\nfunction U(r, t, { includeSource: e = !0 } = {}) {\n  return function(s, o) {\n    const i = [];\n    for (const c of N(r)(s, o)) {\n      e && i.push(c);\n      for (const u of N(t)(s, c))\n        i.push(u);\n    }\n    return i;\n  };\n}\nfunction St(r, t) {\n  return function(n, s) {\n    const {\n      width: o,\n      height: i,\n      start: c,\n      direction: u = f.E\n    } = t ? mt(r, t, n()) : r, h = c ?? s ?? [0, 0], x = U(\n      v({ start: h, direction: X(u, 2), length: i }),\n      v({ direction: u, length: o - 1 })\n    )(n, h);\n    return !c && s ? x.slice(1) : x;\n  };\n}\nfunction mt(r, t, { isPointy: e, offset: n }) {\n  const { col: s, row: o } = K(r, e, n), { col: i, row: c } = K(t, e, n), u = s < i ? \"A\" : \"B\", h = o < c ? \"A\" : \"B\", x = u + h, { swapWidthHeight: y, direction: m } = qt[x], a = Math.abs(s - i) + 1, b = Math.abs(o - c) + 1;\n  return {\n    width: y ? b : a,\n    height: y ? a : b,\n    start: r,\n    direction: m\n  };\n}\nfunction K(r, t, e) {\n  if (S(r))\n    return r;\n  const { q: n, r: s } = H(r) ? E(r) : p(r);\n  return W({ q: n, r: s, isPointy: t, offset: e });\n}\nconst qt = {\n  AA: {\n    swapWidthHeight: !1,\n    direction: f.E\n  },\n  AB: {\n    swapWidthHeight: !0,\n    direction: f.N\n  },\n  BA: {\n    swapWidthHeight: !0,\n    direction: f.S\n  },\n  BB: {\n    swapWidthHeight: !1,\n    direction: f.W\n  }\n};\nfunction pt(r, t) {\n  return N(Array.from({ length: r }, () => N(t)));\n}\nfunction yt(r) {\n  const { center: t, rotation: e = L.CLOCKWISE } = r;\n  return function(s, o) {\n    const i = e.toUpperCase(), c = [];\n    let { radius: u } = r, h;\n    l(u) ? h = s(t).translate({ q: u, s: -u }) : (h = s(r.start ?? o), u = R(h, t, h));\n    const { q: x, r: y, s: m } = C(h, t);\n    let a = s({ q: x, r: y - u, s: m + u });\n    if (i === L.CLOCKWISE)\n      for (let d = 0; d < 6; d++)\n        for (let O = 0; O < u; O++) {\n          const { q: A, r: M } = Q[d];\n          a = s({ q: a.q + A, r: a.r + M }), c.push(a);\n        }\n    else\n      for (let d = 5; d >= 0; d--)\n        for (let O = 0; O < u; O++) {\n          const { q: A, r: M } = Q[d];\n          a = s({ q: a.q - A, r: a.r - M }), c.push(a);\n        }\n    const b = !r.start && o, Y = c.findIndex((d) => d.equals(h));\n    return c.slice(Y + (b ? 1 : 0)).concat(c.slice(0, Y));\n  };\n}\nconst Q = [\n  { q: 1, r: 0 },\n  { q: 0, r: 1 },\n  { q: -1, r: 1 },\n  { q: -1, r: 0 },\n  { q: 0, r: -1 },\n  { q: 1, r: -1 }\n];\nfunction Ct({ radius: r, start: t, rotation: e }) {\n  return function(s, o) {\n    const i = t ?? o ?? [0, 0], c = !t && o ? r : r + 1;\n    return U(v({ start: t, direction: f.N, length: c }), yt({ center: i, rotation: e }))(s, o);\n  };\n}\nclass q {\n  static fromIterable(t) {\n    const e = t[Symbol.iterator]().next().value;\n    if (!e)\n      throw new TypeError(`Can't create grid from empty iterable: ${JSON.stringify(t)}`);\n    return new q(e.constructor, t);\n  }\n  static fromJSON({ hexSettings: t, coordinates: e }) {\n    const n = et(t);\n    return new q(\n      n,\n      e.map((s) => new n(s))\n    );\n  }\n  get size() {\n    return this.#r.size;\n  }\n  get pixelWidth() {\n    if (this.size === 0)\n      return 0;\n    const { isPointy: t, width: e } = this.hexPrototype, n = this.toArray(), {\n      0: s,\n      length: o,\n      [o - 1]: i\n    } = t ? n.sort((c, u) => u.s - c.s || c.q - u.q) : n.sort((c, u) => c.q - u.q);\n    return i.x - s.x + e;\n  }\n  get pixelHeight() {\n    if (this.size === 0)\n      return 0;\n    const { isPointy: t, height: e } = this.hexPrototype, n = this.toArray(), {\n      0: s,\n      length: o,\n      [o - 1]: i\n    } = t ? n.sort((c, u) => c.r - u.r) : n.sort((c, u) => u.s - c.s || c.r - u.r);\n    return i.y - s.y + e;\n  }\n  [Symbol.iterator]() {\n    return this.#r.values();\n  }\n  get hexPrototype() {\n    return this.#t.prototype;\n  }\n  #t;\n  #r = /* @__PURE__ */ new Map();\n  constructor(t, e = []) {\n    if (t instanceof q) {\n      this.#t = t.#t, this.setHexes(t);\n      return;\n    }\n    this.#t = t, this.setHexes(this.#n(e));\n  }\n  createHex(t) {\n    return new this.#t(t);\n  }\n  getHex(t) {\n    const e = this.createHex(t);\n    return this.#r.get(e.toString());\n  }\n  hasHex(t) {\n    return this.#r.has(t.toString());\n  }\n  setHexes(t) {\n    for (const e of t) {\n      const n = e instanceof $ ? e : new this.#t(e);\n      this.#e(n);\n    }\n    return this;\n  }\n  filter(t) {\n    const e = new q(this.#t);\n    for (const n of this)\n      t(n) && e.#e(n);\n    return e;\n  }\n  map(t) {\n    const e = new q(this.#t);\n    for (const n of this)\n      e.#e(t(n));\n    return e;\n  }\n  traverse(t, { bail: e = !1 } = {}) {\n    const n = new q(this.#t);\n    for (const s of this.#n(t)) {\n      const o = this.getHex(s);\n      if (o)\n        n.#e(o);\n      else if (e)\n        return n;\n    }\n    return n;\n  }\n  forEach(t) {\n    for (const e of this)\n      t(e);\n    return this;\n  }\n  reduce(t, e) {\n    if (e === void 0) {\n      let s, o, i;\n      for (const c of this)\n        o = i, i = c, o && (s = t(o, i));\n      return s;\n    }\n    let n = e;\n    for (const s of this)\n      n = t(n, s);\n    return n;\n  }\n  toArray() {\n    return Array.from(this);\n  }\n  toJSON() {\n    const { dimensions: t, orientation: e, origin: n, offset: s } = this.hexPrototype;\n    return { hexSettings: { dimensions: t, orientation: e, origin: n, offset: s }, coordinates: this.toArray() };\n  }\n  toString() {\n    return `${this.constructor.name}(${this.size})`;\n  }\n  pointToHex(t, { allowOutside: e = !0 } = {}) {\n    const n = it(this.hexPrototype, t), s = this.getHex(n);\n    return e ? s ?? this.createHex(n) : s;\n  }\n  distance(t, e, { allowOutside: n = !0 } = {}) {\n    if (n)\n      return R(this.hexPrototype, t, e);\n    const s = this.getHex(t), o = this.getHex(e);\n    if (!(!s || !o))\n      return R(this.hexPrototype, s, o);\n  }\n  neighborOf(t, e, { allowOutside: n = !0 } = {}) {\n    const s = I(this.createHex(t), e), o = this.getHex(s);\n    return n ? o ?? s : o;\n  }\n  #e(t) {\n    this.#r.set(t.toString(), t);\n  }\n  #n(t) {\n    return this.#s(t) ? this.#o(t) : Array.isArray(t) && this.#s(t[0]) ? this.#o(N(t)) : t;\n  }\n  #s(t) {\n    return k(t);\n  }\n  #o(t) {\n    return t(this.createHex.bind(this));\n  }\n}\n\n\n;// CONCATENATED MODULE: ./src/scripts/display.js\n//Imports\n //Public variables\n\nconst camera = {\n  x: 0,\n  y: 0,\n  zoom: 1\n};\nlet currentMap;\nconst Hex = et({\n  dimensions: 60,\n  orientation: 'FLAT',\n  origin: {\n    x: -500,\n    y: -400\n  }\n}); //Private variables\n\nconst mainCanvas = document.querySelector(\"#mainCanvas\");\nconst animCanvas = document.querySelector(\"#animationCanvas\");\nconst mainCtx = mainCanvas.getContext(\"2d\");\nconst animCtx = animCanvas.getContext(\"2d\");\nlet scales = [];\nlet hexSize;\nlet a_full, b_full, c_full, a_hex, b_hex, c_hex;\nlet halfCanvasWidth, halfCanvasHeight;\nlet grid = new q(Hex);\nlet PROVIDER;\nlet isdblclick = false;\n\nasync function sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction getMap(radius) {\n  let map = new q(Hex, Ct({\n    radius: radius\n  })); //Basic water layer\n\n  for (let hex of map) {\n    hex.type = \"64, 128, 255\";\n    hex.highlight = false;\n  }\n\n  return map;\n} //Public functions\n\nasync function initiateMap(ever) {\n  currentMap = getMap(5);\n  mainCanvas.width = window.innerWidth;\n  mainCanvas.height = window.innerHeight;\n  animCanvas.width = window.innerWidth;\n  animCanvas.height = window.innerHeight;\n  calculateHexDimensions();\n  windowResizeUpdate();\n  zoomUpdate();\n  drawMap();\n  camera.x = halfCanvasWidth;\n  camera.y = halfCanvasHeight;\n  PROVIDER = ever;\n  await PROVIDER.init(currentMap);\n  recalcEnergy();\n}\n\nfunction recalcEnergy() {\n  for (let hex of currentMap) {\n    if (!hex.details) continue;\n    calculateEnergy(hex);\n  }\n\n  setTimeout(recalcEnergy, 1000);\n}\n\nfunction calculateEnergy(hex) {\n  let dateNow = Math.round(Date.now() / 1000);\n\n  if (1 * hex.details.energy >= 1 * hex.details.energyMax || 1 * hex.details.lastCalcTime >= dateNow) {\n    return;\n  }\n\n  let energy = Math.min(1 * hex.details.energy + hex.details.energySec * (dateNow - hex.details.lastCalcTime), 1 * hex.details.energyMax);\n  hex.details.lastCalcTime = dateNow;\n  hex.details.energy = energy;\n}\n\nfunction zoomUpdate() {\n  const hex = grid.pointToHex({\n    x: camera.x,\n    y: camera.y\n  });\n  const x = hex.x;\n  const y = hex.y;\n  hexSize = scales[camera.zoom];\n  calculateHexDimensions();\n  let replacementMap = new q(Hex, Ct({\n    radius: currentMap.radius\n  }));\n\n  for (let i = 0; i < currentMap.length; i++) {\n    currentMap[i].size = replacementMap[i].size;\n\n    if (currentMap[i].x === x && currentMap[i].y === y) {\n      camera.x = Math.round(J(currentMap[i]).x + b_full + hexSize / 2);\n      camera.y = Math.round(J(currentMap[i]).y + c_full);\n    }\n  }\n} //Private functions\n\nfunction drawMap() {\n  //Clearing\n  mainCtx.setTransform(1, 0, 0, 1, 0, 0);\n  mainCtx.fillStyle = \"black\";\n  mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height); //Positioning the camera\n\n  mainCtx.translate(-camera.x + halfCanvasWidth, -camera.y + halfCanvasHeight);\n\n  for (let hex of currentMap) {\n    //Hex is ignored if it wasn't seen yet\n    //if (hex.visibility === 'unseen') continue\n    // console.log('hex', hex)\n    // console.log('hexToPoint', hexToPoint(hex))\n    let x = J(hex).x,\n        y = J(hex).y; //Checking if hex is visible within canvas\n\n    if (Math.abs(x - camera.x) > halfCanvasWidth + hexSize || Math.abs(y - camera.y) > halfCanvasHeight + hexSize) continue; //Drawing highlight around hex\n\n    if (hex.highlight) {\n      mainCtx.strokeStyle = \"white\";\n      mainCtx.beginPath();\n      mainCtx.moveTo(x + a_full, y - c_full);\n      mainCtx.lineTo(x + b_full, y);\n      mainCtx.lineTo(x + a_full, y + c_full);\n      mainCtx.lineTo(x - a_full, y + c_full);\n      mainCtx.lineTo(x - b_full, y);\n      mainCtx.lineTo(x - a_full, y - c_full);\n      mainCtx.closePath();\n      mainCtx.stroke();\n    } //Drawing the hex\n\n\n    let color = hex.details ? `${hex.details.color.r}, ${hex.details.color.g}, ${hex.details.color.b}` : hex.type;\n    mainCtx.fillStyle = `rgba(${color},1)`;\n    mainCtx.beginPath();\n    mainCtx.moveTo(x + a_hex, y - c_hex);\n    mainCtx.lineTo(x + b_hex, y);\n    mainCtx.lineTo(x + a_hex, y + c_hex);\n    mainCtx.lineTo(x - a_hex, y + c_hex);\n    mainCtx.lineTo(x - b_hex, y);\n    mainCtx.lineTo(x - a_hex, y - c_hex);\n    mainCtx.closePath();\n    mainCtx.fill();\n    setText(mainCtx, x, y - hexSize / 2, `${hex.q};${hex.r}`);\n\n    if (hex.details) {\n      setText(mainCtx, x, y, `${hex.details.energy}`);\n      setText(mainCtx, x, y + hexSize / 2, `lvl: ${1 * hex.details.level + 1}`);\n    }\n  }\n\n  requestAnimationFrame(drawMap);\n}\n\nfunction setText(ctx, x, y, txt, fontSize = 10, style = \"white\", align = 'center') {\n  let _font = `${fontSize * (camera.zoom + 1)}px Georgia`;\n  ctx.font = _font;\n  ctx.fillStyle = style;\n  ctx.textAlign = align;\n  ctx.fillText(txt, x, y, hexSize);\n}\n\nfunction calculateHexDimensions() {\n  a_full = hexSize / 2;\n  b_full = hexSize;\n  c_full = hexSize / 2 * Math.sqrt(3);\n  a_hex = a_full * 0.95;\n  b_hex = b_full * 0.95;\n  c_hex = c_full * 0.95;\n}\n\nfunction windowResizeUpdate() {\n  mainCanvas.width = window.innerWidth;\n  mainCanvas.height = window.innerHeight;\n  animCanvas.width = window.innerWidth;\n  animCanvas.height = window.innerHeight;\n  halfCanvasWidth = mainCanvas.width / 2;\n  halfCanvasHeight = mainCanvas.height / 2;\n  const min = Math.min(halfCanvasWidth, halfCanvasHeight);\n  scales = [min / 10, min / 7, min / 5];\n} //Hex Highlighting\n\n\nanimCanvas.addEventListener('click', async ({\n  offsetX,\n  offsetY\n}) => {\n  console.log('click', isdblclick);\n  await sleep(500);\n  console.log('click', isdblclick);\n\n  if (isdblclick) {\n    return;\n  }\n\n  offsetX += camera.x - mainCanvas.width / 2;\n  offsetY += camera.y - mainCanvas.height / 2;\n  const hexCoordinates = grid.pointToHex({\n    x: offsetX,\n    y: offsetY\n  });\n\n  for (let hex of currentMap) {\n    if (hex.x == hexCoordinates.x && hex.y == hexCoordinates.y) {\n      hex.highlight = !hex.highlight;\n    } else {\n      hex.highlight = false;\n    }\n  }\n});\nanimCanvas.addEventListener('dblclick', async ({\n  offsetX,\n  offsetY\n}) => {\n  isdblclick = true;\n  console.log('dblclick', isdblclick);\n  await sleep(500);\n  isdblclick = false;\n  console.log('dblclick', isdblclick);\n  offsetX += camera.x - mainCanvas.width / 2;\n  offsetY += camera.y - mainCanvas.height / 2;\n  const hexCoordinates = grid.pointToHex({\n    x: offsetX,\n    y: offsetY\n  });\n  console.log(hexCoordinates);\n  let hHex;\n  let tHex;\n\n  for (let hex of currentMap) {\n    if (hex.highlight) {\n      hHex = hex;\n    }\n\n    if (hex.x == hexCoordinates.x && hex.y == hexCoordinates.y) {\n      tHex = hex;\n    }\n  }\n\n  if (!tHex) return;\n  if (hHex && !hHex.details) return;\n  console.log('hHex', hHex);\n  console.log('tHex', tHex);\n  let cellCoord = {\n    x: hexCoordinates.q,\n    y: hexCoordinates.r,\n    z: hexCoordinates.s\n  };\n\n  if (!hHex) {\n    if (!tHex.details) {\n      await PROVIDER.newGame(cellCoord);\n    }\n  } else if (hHex.address.toString() == tHex.address.toString()) {\n    await PROVIDER.upgradeCell(tHex.address);\n  } else {\n    if (!isNeighborHex(hHex, tHex)) return;\n    let energy = 1000;\n\n    if (!tHex.details) {\n      await PROVIDER.markCell(hHex.address, cellCoord, energy);\n    } else if (colorIsEqual(hHex.details.color, tHex.details.color)) {\n      //       \n      await PROVIDER.helpCell(hHex.address, cellCoord, energy);\n    } else {\n      await PROVIDER.attkCell(hHex.address, cellCoord, energy);\n    }\n  }\n});\n\nfunction colorIsEqual(color1, color2) {\n  return color1.r == color2.r && color1.g == color2.g && color1.b == color2.b;\n}\n\nfunction isNeighborHex(hex1, hex2) {\n  return cube_distance(hex1, hex2) == 1;\n}\n\nfunction cube_distance(hex1, hex2) {\n  return Math.max(Math.abs(hex1.q - hex2.q), Math.abs(hex1.r - hex2.r), Math.abs(hex1.s - hex2.s));\n}\n\nwindow.addEventListener('resize', () => {\n  windowResizeUpdate();\n  zoomUpdate();\n}); //http://jsfiddle.net/gfcarv/QKgHs/ or http://jsfiddle.net/gfcarv/tAwQV/\n//https://jsfiddle.net/931wk75n/2/\n;// CONCATENATED MODULE: ./src/scripts/controls.js\n//Imports\n //Public variables\n//-\n//Private variables\n//-\n//Public functions\n\nfunction initiateControls() {\n  //Camera position controls\n  let timer = null;\n  document.addEventListener('mouseup', () => {\n    clearInterval(timer);\n  });\n  document.addEventListener('keyup', () => {\n    clearInterval(timer);\n  }); //Keyboard controls\n\n  document.addEventListener('keydown', e => {\n    switch (e.code) {\n      case \"ArrowUp\":\n        clearInterval(timer);\n        timer = setInterval(() => {\n          camera.y -= 5;\n        }, 10);\n        break;\n\n      case \"ArrowLeft\":\n        clearInterval(timer);\n        timer = setInterval(() => {\n          camera.x -= 5;\n        }, 10);\n        break;\n\n      case \"ArrowRight\":\n        clearInterval(timer);\n        timer = setInterval(() => {\n          camera.x += 5;\n        }, 10);\n        break;\n\n      case \"ArrowDown\":\n        clearInterval(timer);\n        timer = setInterval(() => {\n          camera.y += 5;\n        }, 10);\n        break;\n    }\n  });\n} //Private functions\n// EXTERNAL MODULE: ./node_modules/everscale-inpage-provider/dist/index.js\nvar dist = __webpack_require__(511);\n// EXTERNAL MODULE: ./node_modules/everscale-standalone-client/index.js\nvar everscale_standalone_client = __webpack_require__(91);\n;// CONCATENATED MODULE: ./src/scripts/ever.js\n\n\n\nconst {\n  TonClient,\n  signerKeys,\n  signerNone\n} = __webpack_require__(206); //const { libNode } = require(\"@eversdk/lib-node\");\n\n\nconst {\n  libWeb\n} = __webpack_require__(113);\n\nconst {\n  Account\n} = __webpack_require__(253);\n\nTonClient.useBinaryLibrary(libWeb);\n\nconst routerAbi = __webpack_require__(750);\n\nconst cellAbi = __webpack_require__(579);\n\nconst Config = __webpack_require__(150);\n\nlet ever_currentMap;\nconst ever = new dist.ProviderRpcClient({});\nlet everClient;\nlet subscribeAcc;\n\nconst createClient = endpoint => {\n  let client = new TonClient({\n    network: {\n      endpoints: [endpoint],\n      message_retries_count: 3,\n      message_processing_timeout: 60000\n    }\n  });\n  return client;\n};\n\nconst getAccount = (abi, address = '', keys = null) => {\n  try {\n    return new Account({\n      abi\n    }, {\n      address: address,\n      signer: keys ? signerKeys(keys) : signerNone(),\n      client: everClient\n    });\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nconst getAccArr = async addreses => {\n  try {\n    const result = (await everClient.net.query_collection({\n      collection: \"accounts\",\n      filter: {\n        id: {\n          in: addreses\n        }\n      },\n      result: \"id acc_type balance boc\"\n    })).result;\n    return result;\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nconst runLocal = async (abi, address, functionName, input = {}, log = true, boc = null) => {\n  try {\n    const [account, message] = await Promise.all([boc || everClient.net.query_collection({\n      collection: \"accounts\",\n      filter: {\n        id: {\n          eq: address\n        }\n      },\n      result: \"boc\"\n    }).then(({\n      result\n    }) => result[0].boc).catch(() => {\n      return undefined;\n    }), everClient.abi.encode_message({\n      abi: {\n        type: 'Contract',\n        value: abi\n      },\n      address,\n      call_set: {\n        function_name: functionName,\n        input: input\n      },\n      signer: {\n        type: \"None\"\n      }\n    }).then(({\n      message\n    }) => message)]);\n    if (!account) return undefined;\n    let response = await everClient.tvm.run_tvm({\n      message: message,\n      account: account,\n      abi: {\n        type: 'Contract',\n        value: abi\n      }\n    });\n    if (log) console.log(\"output:\", response.decoded.output);\n    return response.decoded.output;\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nfunction behavior(name, fn) {\n  document.querySelectorAll(`[data-behavior=${name}]`).forEach(fn);\n}\n\nconst innerText = text => elem => {\n  elem.innerText = text;\n};\n\nfunction requestPermissions() {\n  return ever.requestPermissions({\n    permissions: ['basic', 'accountInteraction']\n  });\n}\n\nasync function disconnectAction() {\n  console.log('disconnectAction');\n  await ever.disconnect();\n}\n\nasync function getRoutersAction() {\n  console.log('getRoutersAction');\n  const providerState = await ever.getProviderState();\n  let details = await ever.getAccountsByCodeHash({\n    codeHash: Config[providerState.selectedConnection].codeHash,\n    limit: 10\n  });\n  console.log('routers', details);\n}\n\nasync function connect() {\n  await ever.requestPermissions({\n    permissions: ['basic', 'accountInteraction']\n  });\n}\n\nasync function checkConnect() {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  const network = providerState.selectedConnection;\n\n  if (!contractAddress(network) || !permissions.accountInteraction) {\n    behavior('connect', elem => elem.onclick = requestPermissions);\n    switchScreen(\"login\");\n\n    const connectText = elem => {\n      const disabled = !contractAddress(network);\n      elem.disabled = disabled;\n      elem.innerText = disabled ? `Contract not found` : `Connect with ${network}`;\n    };\n\n    behavior('connect', connectText);\n  } else {\n    // INFO for transactionsFound and contractStateChanged need permissions\n    const providerState = await ever.getProviderState();\n    (await ever.subscribe('transactionsFound', {\n      address: contractAddress(providerState.selectedConnection)\n    })).on('data', event => {\n      console.log(':', {\n        address: event.address,\n        transactions: event.transactions,\n        info: event.info\n      });\n    });\n    (await ever.subscribe('contractStateChanged', {\n      address: contractAddress(providerState.selectedConnection)\n    })).on('data', event => {\n      console.log('permissionsChanged:', {\n        address: event.address,\n        state: event.state\n      });\n    });\n    switchScreen(\"main\");\n    const account = permissions.accountInteraction;\n    let address = account.address.toString();\n    let pubkey = account.address.toString();\n    behavior('address', innerText(`${address.substr(0, 6)}...${address.substr(-4, 4)}`));\n    behavior('publicKey', innerText(`${pubkey.substr(0, 6)}...${pubkey.substr(-4, 4)}`));\n    behavior('disconnectAction', elem => elem.onclick = disconnectAction);\n    behavior('getRoutersAction', elem => elem.onclick = getRoutersAction);\n    console.log('endpoint:', Config[network].endpoint);\n    everClient = createClient(Config[network].endpoint);\n    subscribeAcc = getAccount({});\n    loadMap();\n  }\n}\n\nasync function setNetworkChanged(network) {\n  const mod = network === 'mainnet' ? 'success' : 'secondary';\n  const out = `<span class=\"badge bg-${mod}\">${network}</span>`;\n  behavior('network', elem => elem.innerHTML = out);\n  await checkConnect();\n}\n\nfunction contractAddress(network, name = \"router\") {\n  if (Config[network] && Config[network][name]) {\n    return new dist.Address(Config[network][name]);\n  }\n\n  return null;\n}\n\nfunction switchScreen(to) {\n  console.log('switchScreen:', to);\n  [\"extension\", \"login\", \"main\"].forEach(screen => {\n    const switcher = elem => elem.style.display = to === screen ? 'table-row' : 'none';\n\n    behavior(screen, switcher);\n  });\n}\n\nasync function mainFlow() {\n  const providerState = await ever.getProviderState();\n  console.log('selectedConnection:', providerState.selectedConnection);\n  await setNetworkChanged(providerState.selectedConnection);\n  (await ever.subscribe('networkChanged')).on('data', event => {\n    console.log('networkChanged:', event.selectedConnection);\n    setNetworkChanged(event.selectedConnection);\n  });\n  (await ever.subscribe('permissionsChanged')).on('data', async event => {\n    console.log('permissionsChanged:', event.permissions);\n    await checkConnect();\n  });\n}\n\nasync function loadMap() {\n  await routerDetails();\n  let coords = [];\n\n  for (const hex of ever_currentMap) {\n    coords.push({\n      x: hex.q,\n      y: hex.r,\n      z: hex.s\n    });\n  }\n\n  let addreses = await getAddressCells(coords);\n  addreses = addreses.map(el => el.toString());\n  let i = 0;\n\n  for (const hex of ever_currentMap) {\n    hex.address = addreses[i];\n    i++;\n  }\n\n  await subscribeAllCellState(addreses);\n  let accs = await getAccArr(addreses);\n  console.log('accs', accs);\n\n  for (let i = 0; i < accs.length; i++) {\n    let details = await getDetailsCell(accs[i].id, accs[i].boc);\n\n    if (details) {\n      let hex = findHex(accs[i].id);\n      console.log('hex', hex);\n\n      if (hex) {\n        hex.details = details;\n      }\n    }\n  }\n}\n\nasync function init(map) {\n  ever_currentMap = map;\n\n  if (await ever.hasProvider()) {\n    try {\n      await ever.ensureInitialized();\n      await mainFlow();\n    } catch (error) {\n      throw error; // TODO handle it\n    }\n  } else {\n    switchScreen(\"extension\");\n  }\n}\n\nfunction findHex(address) {\n  let _hex;\n\n  for (const hex of ever_currentMap) {\n    if (hex.address == address) {\n      _hex = hex;\n      break;\n    }\n  }\n\n  return _hex;\n}\n\nasync function routerDetails() {\n  const providerState = await ever.getProviderState();\n  const router = new ever.Contract(routerAbi, contractAddress(providerState.selectedConnection, 'router'));\n\n  try {\n    let details;\n    details = await router.methods.getDetails({}).call();\n    console.log('getDetails router', details);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function subscribeAllCellState(arrAcc) {\n  try {\n    await subscribeAcc.free();\n    await subscribeAcc.subscribe(\"accounts\", {\n      id: {\n        in: arrAcc\n      }\n    }, \"id boc\", async msg => {\n      console.log(`onAcc:`, msg.id);\n      let hex = findHex(msg.id);\n      console.log('hex', hex);\n\n      if (hex) {\n        hex.details = await getDetailsCell(msg.id, msg.boc);\n      }\n    }, async msg => {\n      console.log(`onError:`, msg);\n    });\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function getAddressCells(coords) {\n  const providerState = await ever.getProviderState();\n  const router = new ever.Contract(routerAbi, contractAddress(providerState.selectedConnection, 'router'));\n\n  try {\n    let details;\n    details = await router.methods.getAddressCells({\n      coords\n    }).call();\n    console.log('getAddressCells router', details);\n    return details.addreses;\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function newGame(cellCoord) {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  if (!permissions.accountInteraction) return;\n  const account = permissions.accountInteraction;\n  const router = new ever.Contract(routerAbi, contractAddress(providerState.selectedConnection, 'router'));\n\n  try {\n    console.log('newGame', 1);\n    let res = await router.methods.newGame({\n      sendGasTo: account.address.toString(),\n      baseCoord: cellCoord\n    }).send({\n      from: account.address.toString(),\n      amount: '2000000000'\n    });\n    console.log('newGame', res);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function markCell(address, cellCoord, energy) {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  if (!permissions.accountInteraction) return;\n  const account = permissions.accountInteraction;\n  const cell = new ever.Contract(cellAbi, address);\n\n  try {\n    console.log('markCell', 1);\n    let res = await cell.methods.markCell({\n      sendGasTo: account.address.toString(),\n      targetCoord: cellCoord,\n      energy: energy\n    }).send({\n      from: account.address.toString(),\n      amount: '2000000000'\n    });\n    console.log('markCell', res);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function upgradeCell(address) {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  if (!permissions.accountInteraction) return;\n  const account = permissions.accountInteraction;\n  const cell = new ever.Contract(cellAbi, address);\n\n  try {\n    console.log('upgradeCell', 1);\n    let res = await cell.methods.upgradeCell({\n      sendGasTo: account.address.toString()\n    }).send({\n      from: account.address.toString(),\n      amount: '1000000000'\n    });\n    console.log('upgradeCell', res);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function helpCell(address, cellCoord, energy) {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  if (!permissions.accountInteraction) return;\n  const account = permissions.accountInteraction;\n  const cell = new ever.Contract(cellAbi, address);\n\n  try {\n    console.log('helpCell', 1);\n    let res = await cell.methods.helpCell({\n      sendGasTo: account.address.toString(),\n      targetCoord: cellCoord,\n      energy: energy\n    }).send({\n      from: account.address.toString(),\n      amount: '1000000000'\n    });\n    console.log('helpCell', res);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function attkCell(address, cellCoord, energy) {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  if (!permissions.accountInteraction) return;\n  const account = permissions.accountInteraction;\n  const cell = new ever.Contract(cellAbi, address);\n\n  try {\n    console.log('attkCell', 1);\n    let res = await cell.methods.attkCell({\n      sendGasTo: account.address.toString(),\n      targetCoord: cellCoord,\n      energy: energy\n    }).send({\n      from: account.address.toString(),\n      amount: '1000000000'\n    });\n    console.log('attkCell', res);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function getDetailsCell(address, boc = null) {\n  if (boc) {\n    try {\n      const output = await runLocal(cellAbi, address, \"getDetails\", {}, true, boc);\n      return output;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  const cell = new ever.Contract(cellAbi, address);\n\n  try {\n    const stateRes = await cell.getFullState();\n\n    if (stateRes.state == null || !stateRes.state.isDeployed) {\n      return null;\n    } //console.log('state', stateRes.state);\n\n\n    let details;\n    details = await cell.methods.getDetails({}).call();\n    console.log('getDetails cell', details);\n    return details;\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function subscribePermissionsChanged() {\n  await ever.subscribe('permissionsChanged').on('data', permissions => {\n    console.log(permissions);\n  });\n}\n;// CONCATENATED MODULE: ./src/index.js\n //Import CSS\n\n //Import JS\n\n\n\n //https://github.com/flauwekeul/honeycomb\n//console.clear();\n\ninitiateMap(ever_namespaceObject);\ninitiateControls();\n\nif (false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDM3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2hvbmV5Y29tYi1ncmlkL2Rpc3QvaG9uZXljb21iLWdyaWQubWpzPzJhZDMiLCJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vc3JjL3NjcmlwdHMvZGlzcGxheS5qcz8zMjc5Iiwid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL3NyYy9zY3JpcHRzL2NvbnRyb2xzLmpzPzA3MTQiLCJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vc3JjL3NjcmlwdHMvZXZlci5qcz8wOWQxIiwid2VicGFjazovL2hleC1iYXR0bGUtZ2FtZS8uL3NyYy9pbmRleC5qcz85NWI1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGwgPSAocikgPT4gTnVtYmVyLmlzRmluaXRlKHIpICYmICFOdW1iZXIuaXNOYU4ociksIHcgPSAocikgPT4gdHlwZW9mIHIgPT0gXCJvYmplY3RcIiAmJiByICE9PSBudWxsLCBPdCA9IChyKSA9PiB3KHIpICYmIGwoci5xKSAmJiBsKHIuciksIGsgPSAocikgPT4gdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiLCBTID0gKHIpID0+IHcocikgJiYgbChyLmNvbCkgJiYgbChyLnJvdyksIFYgPSAocikgPT4gdyhyKSAmJiBsKHIueCkgJiYgbChyLnkpLCBIID0gKHIpID0+IEFycmF5LmlzQXJyYXkocikgJiYgbChyWzBdKSAmJiBsKHJbMV0pLCBQID0gKHIsIHQpID0+IHQgKyByICogKHQgJiAxKSA+PiAxO1xuZnVuY3Rpb24gWihyLCB0KSB7XG4gIHJldHVybiAociAlIHQgKyB0KSAlIHQ7XG59XG5jb25zdCBYID0gKHIsIHQpID0+IFoociArIHQsIDgpLCBFID0gKFtyLCB0LCBlID0gLXIgLSB0XSkgPT4gKHsgcTogciwgcjogdCwgczogZSB9KTtcbmZ1bmN0aW9uIHAoeyBxOiByLCByOiB0LCBzOiBlIH0pIHtcbiAgY29uc3QgbiA9IGwociksIHMgPSBsKHQpLCBvID0gbChlKTtcbiAgaWYgKG4gJiYgcyAmJiBvKVxuICAgIHJldHVybiB7IHE6IHIsIHI6IHQsIHM6IGUgfTtcbiAgaWYgKG4gJiYgcylcbiAgICByZXR1cm4geyBxOiByLCByOiB0LCBzOiAtciAtIHQgfTtcbiAgaWYgKG4gJiYgbylcbiAgICByZXR1cm4geyBxOiByLCByOiAtciAtIGUsIHM6IGUgfTtcbiAgaWYgKHMgJiYgbylcbiAgICByZXR1cm4geyBxOiAtdCAtIGUsIHI6IHQsIHM6IGUgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICBgQ2FuJ3QgZGV0ZXJtaW5lIHRocmVlIGN1YmUgY29vcmRpbmF0ZXMgZnJvbSBsZXNzIHRoYW4gdHdvIGNvb3JkaW5hdGVzLiBSZWNlaXZlZDogeyBxOiAke3J9LCByOiAke3R9LCBzOiAke2V9IH0uYFxuICApO1xufVxudmFyIGcgPSAvKiBAX19QVVJFX18gKi8gKChyKSA9PiAoci5GTEFUID0gXCJGTEFUXCIsIHIuUE9JTlRZID0gXCJQT0lOVFlcIiwgcikpKGcgfHwge30pO1xuZnVuY3Rpb24gRyhyLCB0KSB7XG4gIGlmICh3KHIpICYmIHIueFJhZGl1cyA+IDAgJiYgci55UmFkaXVzID4gMClcbiAgICByZXR1cm4gcjtcbiAgaWYgKHcocikgJiYgci53aWR0aCA+IDAgJiYgci5oZWlnaHQgPiAwKSB7XG4gICAgY29uc3QgeyB3aWR0aDogZSwgaGVpZ2h0OiBuIH0gPSByO1xuICAgIHJldHVybiB0ID09PSBnLlBPSU5UWSA/IHsgeFJhZGl1czogZSAvIE1hdGguc3FydCgzKSwgeVJhZGl1czogbiAvIDIgfSA6IHsgeFJhZGl1czogZSAvIDIsIHlSYWRpdXM6IG4gLyBNYXRoLnNxcnQoMykgfTtcbiAgfVxuICBpZiAociA+IDApXG4gICAgcmV0dXJuIHsgeFJhZGl1czogciwgeVJhZGl1czogciB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgIGBJbnZhbGlkIGRpbWVuc2lvbnM6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICByXG4gICAgKX0uIERpbWVuc2lvbnMgbXVzdCBiZSBleHByZXNzZWQgYXMgYW4gRWxsaXBzZSAoeyB4UmFkaXVzOiBudW1iZXIsIHlSYWRpdXM6IG51bWJlciB9KSwgYSBSZWN0YW5nbGUgKHsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfSkgb3IgYSBudW1iZXIuYFxuICApO1xufVxuZnVuY3Rpb24gRChyLCB0KSB7XG4gIGlmIChWKHIpKVxuICAgIHJldHVybiByO1xuICBpZiAoIXQpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBTdXBwbHkgYSBib3VuZGluZyBib3ggKHsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfSkuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHQpfWBcbiAgICApO1xuICBpZiAociA9PT0gXCJ0b3BMZWZ0XCIpXG4gICAgcmV0dXJuIHsgeDogdC53aWR0aCAqIC0wLjUsIHk6IHQuaGVpZ2h0ICogLTAuNSB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgIGBJbnZhbGlkIG9yaWdpbjogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgIHJcbiAgICApfS4gT3JpZ2luIG11c3QgYmUgZXhwcmVzc2VkIGFzIGEgUG9pbnQgKHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSkgb3IgdGhlIHN0cmluZyAndG9wTGVmdCcuYFxuICApO1xufVxuY2xhc3MgJCB7XG4gIHN0YXRpYyBnZXQgc2V0dGluZ3MoKSB7XG4gICAgY29uc3QgeyBkaW1lbnNpb25zOiB0LCBvcmllbnRhdGlvbjogZSwgb3JpZ2luOiBuLCBvZmZzZXQ6IHMgfSA9IHRoaXMucHJvdG90eXBlO1xuICAgIHJldHVybiB7IGRpbWVuc2lvbnM6IHQsIG9yaWVudGF0aW9uOiBlLCBvcmlnaW46IG4sIG9mZnNldDogcyB9O1xuICB9XG4gIGdldCBjZW50ZXIoKSB7XG4gICAgY29uc3QgeyB3aWR0aDogdCwgaGVpZ2h0OiBlLCB4OiBuLCB5OiBzIH0gPSB0aGlzO1xuICAgIHJldHVybiB7IHg6IHQgLyAyIC0gbiwgeTogZSAvIDIgLSBzIH07XG4gIH1cbiAgZ2V0IGNvbCgpIHtcbiAgICByZXR1cm4gVyh0aGlzKS5jb2w7XG4gIH1cbiAgZ2V0IGNvcm5lcnMoKSB7XG4gICAgY29uc3QgeyBvcmllbnRhdGlvbjogdCwgd2lkdGg6IGUsIGhlaWdodDogbiwgeDogcywgeTogbyB9ID0gdGhpcztcbiAgICByZXR1cm4gdCA9PT0gZy5QT0lOVFkgPyB0dChlLCBuLCBzLCBvKSA6IHJ0KGUsIG4sIHMsIG8pO1xuICB9XG4gIGdldCBkaW1lbnNpb25zKCkge1xuICAgIHJldHVybiBULmRpbWVuc2lvbnM7XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcmllbnRhdGlvbjogdCxcbiAgICAgIGRpbWVuc2lvbnM6IHsgeVJhZGl1czogZSB9XG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHQgPT09IGcuUE9JTlRZID8gZSAqIDIgOiBlICogTWF0aC5zcXJ0KDMpO1xuICB9XG4gIGdldCBpc0ZsYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb24gPT09IGcuRkxBVDtcbiAgfVxuICBnZXQgaXNQb2ludHkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb24gPT09IGcuUE9JTlRZO1xuICB9XG4gIGdldCBvcmllbnRhdGlvbigpIHtcbiAgICByZXR1cm4gVC5vcmllbnRhdGlvbjtcbiAgfVxuICBnZXQgb3JpZ2luKCkge1xuICAgIHJldHVybiBULm9yaWdpbjtcbiAgfVxuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiBULm9mZnNldDtcbiAgfVxuICBnZXQgcm93KCkge1xuICAgIHJldHVybiBXKHRoaXMpLnJvdztcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3JpZW50YXRpb246IHQsXG4gICAgICBkaW1lbnNpb25zOiB7IHhSYWRpdXM6IGUgfVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiB0ID09PSBnLlBPSU5UWSA/IGUgKiBNYXRoLnNxcnQoMykgOiBlICogMjtcbiAgfVxuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gSih0aGlzKS54O1xuICB9XG4gIGdldCB5KCkge1xuICAgIHJldHVybiBKKHRoaXMpLnk7XG4gIH1cbiAgZ2V0IHMoKSB7XG4gICAgcmV0dXJuIC10aGlzLnEgLSB0aGlzLnI7XG4gIH1cbiAgcTtcbiAgcjtcbiAgY29uc3RydWN0b3IodCA9IFswLCAwXSkge1xuICAgIGNvbnN0IHsgcTogZSwgcjogbiB9ID0gQyh0aGlzLCB0KTtcbiAgICB0aGlzLnEgPSBlLCB0aGlzLnIgPSBuO1xuICB9XG4gIGNsb25lKHQgPSB0aGlzKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHQpO1xuICB9XG4gIGVxdWFscyh0KSB7XG4gICAgcmV0dXJuIG50KHRoaXMsIFModCkgPyBqKHRoaXMsIHQpIDogdCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0oJHt0aGlzLnF9LCR7dGhpcy5yfSlgO1xuICB9XG4gIHRyYW5zbGF0ZSh0KSB7XG4gICAgcmV0dXJuIGN0KHRoaXMsIHQpO1xuICB9XG59XG5jb25zdCBUID0ge1xuICBkaW1lbnNpb25zOiB7IHhSYWRpdXM6IDEsIHlSYWRpdXM6IDEgfSxcbiAgb3JpZW50YXRpb246IGcuUE9JTlRZLFxuICBvcmlnaW46IHsgeDogMCwgeTogMCB9LFxuICBvZmZzZXQ6IC0xXG59LCB0dCA9IChyLCB0LCBlLCBuKSA9PiBbXG4gIHsgeDogZSArIHIgKiAwLjUsIHk6IG4gLSB0ICogMC4yNSB9LFxuICB7IHg6IGUgKyByICogMC41LCB5OiBuICsgdCAqIDAuMjUgfSxcbiAgeyB4OiBlLCB5OiBuICsgdCAqIDAuNSB9LFxuICB7IHg6IGUgLSByICogMC41LCB5OiBuICsgdCAqIDAuMjUgfSxcbiAgeyB4OiBlIC0gciAqIDAuNSwgeTogbiAtIHQgKiAwLjI1IH0sXG4gIHsgeDogZSwgeTogbiAtIHQgKiAwLjUgfVxuXSwgcnQgPSAociwgdCwgZSwgbikgPT4gW1xuICB7IHg6IGUgKyByICogMC4yNSwgeTogbiAtIHQgKiAwLjUgfSxcbiAgeyB4OiBlICsgciAqIDAuNSwgeTogbiB9LFxuICB7IHg6IGUgKyByICogMC4yNSwgeTogbiArIHQgKiAwLjUgfSxcbiAgeyB4OiBlIC0gciAqIDAuMjUsIHk6IG4gKyB0ICogMC41IH0sXG4gIHsgeDogZSAtIHIgKiAwLjUsIHk6IG4gfSxcbiAgeyB4OiBlIC0gciAqIDAuMjUsIHk6IG4gLSB0ICogMC41IH1cbl07XG5mdW5jdGlvbiBldChyKSB7XG4gIGNvbnN0IHsgZGltZW5zaW9uczogdCwgb3JpZW50YXRpb246IGUsIG9yaWdpbjogbiwgb2Zmc2V0OiBzIH0gPSB7IC4uLlQsIC4uLnIgfTtcbiAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgJCB7XG4gICAgZ2V0IGRpbWVuc2lvbnMoKSB7XG4gICAgICByZXR1cm4gRyh0LCBlKTtcbiAgICB9XG4gICAgZ2V0IG9yaWVudGF0aW9uKCkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIGdldCBvcmlnaW4oKSB7XG4gICAgICByZXR1cm4gRChuLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IG9mZnNldCgpIHtcbiAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG50KHIsIHQpIHtcbiAgaWYgKFMocikgJiYgUyh0KSlcbiAgICByZXR1cm4gci5jb2wgPT09IHQuY29sICYmIHIucm93ID09PSB0LnJvdztcbiAgaWYgKE9iamVjdC5oYXNPd24ociwgXCJjb2xcIikgfHwgT2JqZWN0Lmhhc093bih0LCBcImNvbFwiKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2FuJ3QgY29tcGFyZSBjb29yZGluYXRlcyB3aGVyZSBvbmUgYXJlIG9mZnNldCBjb29yZGluYXRlcy4gRWl0aGVyIHBhc3MgdHdvIG9mZnNldCBjb29yZGluYXRlcyBvciB0d28gYXhpYWwvY3ViZSBjb29yZGluYXRlcy4gUmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHJcbiAgICAgICl9IGFuZCAke0pTT04uc3RyaW5naWZ5KHQpfWBcbiAgICApO1xuICBjb25zdCBlID0gSChyKSA/IEUocikgOiByLCBuID0gSCh0KSA/IEUodCkgOiB0O1xuICByZXR1cm4gZS5xID09PSBuLnEgJiYgZS5yID09PSBuLnI7XG59XG5jb25zdCBzdCA9IChyLCB0LCBlKSA9PiAoe1xuICBjb2w6IHIgKyBQKGUsIHQpLFxuICByb3c6IHRcbn0pLCBvdCA9IChyLCB0LCBlKSA9PiAoe1xuICBjb2w6IHIsXG4gIHJvdzogdCArIFAoZSwgcilcbn0pLCBXID0gKHsgcTogciwgcjogdCwgb2Zmc2V0OiBlLCBpc1BvaW50eTogbiB9KSA9PiBuID8gc3QociwgdCwgZSkgOiBvdChyLCB0LCBlKSwgSiA9ICh7IG9yaWVudGF0aW9uOiByLCBkaW1lbnNpb25zOiB7IHhSYWRpdXM6IHQsIHlSYWRpdXM6IGUgfSwgb3JpZ2luOiB7IHg6IG4sIHk6IHMgfSwgcTogbywgcjogaSB9KSA9PiByID09PSBnLlBPSU5UWSA/IHtcbiAgeDogdCAqIE1hdGguc3FydCgzKSAqIChvICsgaSAvIDIpIC0gbixcbiAgeTogZSAqIDMgLyAyICogaSAtIHNcbn0gOiB7XG4gIHg6IHQgKiAzIC8gMiAqIG8gLSBuLFxuICB5OiBlICogTWF0aC5zcXJ0KDMpICogKGkgKyBvIC8gMikgLSBzXG59LCB6ID0gKHIsIHQsIGUpID0+IHtcbiAgY29uc3QgbiA9IHIgLSBQKGUsIHQpLCBzID0gdCwgbyA9IC1uIC0gcztcbiAgcmV0dXJuIHsgcTogbiwgcjogcywgczogbyB9O1xufSwgXyA9IChyLCB0LCBlKSA9PiB7XG4gIGNvbnN0IG4gPSByLCBzID0gdCAtIFAoZSwgciksIG8gPSAtbiAtIHM7XG4gIHJldHVybiB7IHE6IG4sIHI6IHMsIHM6IG8gfTtcbn0sIGogPSAoeyBvZmZzZXQ6IHIsIG9yaWVudGF0aW9uOiB0IH0sIHsgY29sOiBlLCByb3c6IG4gfSkgPT4gdCA9PT0gZy5QT0lOVFkgPyB6KGUsIG4sIHIpIDogXyhlLCBuLCByKSwgRiA9IChyKSA9PiB7XG4gIGNvbnN0IHsgcTogdCwgcjogZSwgczogbiB9ID0gcChyKTtcbiAgbGV0IHMgPSBNYXRoLnJvdW5kKHQpLCBvID0gTWF0aC5yb3VuZChlKSwgaSA9IE1hdGgucm91bmQobik7XG4gIGNvbnN0IGMgPSBNYXRoLmFicyh0IC0gcyksIHUgPSBNYXRoLmFicyhlIC0gbyksIGggPSBNYXRoLmFicyhuIC0gaSk7XG4gIHJldHVybiBjID4gdSAmJiBjID4gaCA/IHMgPSAtbyAtIGkgOiB1ID4gaCA/IG8gPSAtcyAtIGkgOiBpID0gLXMgLSBvLCB7IHE6IHMsIHI6IG8sIHM6IGkgfTtcbn0sIGl0ID0gKHsgZGltZW5zaW9uczogeyB4UmFkaXVzOiByLCB5UmFkaXVzOiB0IH0sIG9yaWdpbjogZSwgb3JpZW50YXRpb246IG4gfSwgeyB4OiBzLCB5OiBvIH0pID0+IChzICs9IGUueCwgbyArPSBlLnksIG4gPT09IGcuUE9JTlRZID8gRih7IHE6IE1hdGguc3FydCgzKSAqIHMgLyAoMyAqIHIpIC0gbyAvICgzICogdCksIHI6IDIgLyAzICogKG8gLyB0KSB9KSA6IEYoeyBxOiAyIC8gMyAqIChzIC8gciksIHI6IE1hdGguc3FydCgzKSAqIG8gLyAoMyAqIHQpIC0gcyAvICgzICogcikgfSkpO1xuZnVuY3Rpb24gQyhyLCB0KSB7XG4gIHJldHVybiBIKHQpID8gRSh0KSA6IFModCkgPyBqKHIsIHQpIDogcCh0KTtcbn1cbmZ1bmN0aW9uIGN0KHIsIHQpIHtcbiAgY29uc3QgeyBxOiBlLCByOiBuLCBzIH0gPSBwKHIpLCB7IHE6IG8sIHI6IGksIHM6IGMgfSA9IHAodCksIHUgPSB7IHE6IGUgKyBvLCByOiBuICsgaSwgczogcyArIGMgfTtcbiAgcmV0dXJuIHIgaW5zdGFuY2VvZiAkID8gci5jbG9uZSh1KSA6IHU7XG59XG5mdW5jdGlvbiBSKHIsIHQsIGUpIHtcbiAgY29uc3QgeyBxOiBuLCByOiBzLCBzOiBvIH0gPSBDKHIsIHQpLCB7IHE6IGksIHI6IGMsIHM6IHUgfSA9IEMociwgZSk7XG4gIHJldHVybiBNYXRoLm1heChNYXRoLmFicyhuIC0gaSksIE1hdGguYWJzKHMgLSBjKSwgTWF0aC5hYnMobyAtIHUpKTtcbn1cbnZhciBMID0gLyogQF9fUFVSRV9fICovICgocikgPT4gKHIuQ0xPQ0tXSVNFID0gXCJDTE9DS1dJU0VcIiwgci5DT1VOVEVSQ0xPQ0tXSVNFID0gXCJDT1VOVEVSQ0xPQ0tXSVNFXCIsIHIpKShMIHx8IHt9KSwgZiA9IC8qIEBfX1BVUkVfXyAqLyAoKHIpID0+IChyW3IuTiA9IDBdID0gXCJOXCIsIHJbci5ORSA9IDFdID0gXCJORVwiLCByW3IuRSA9IDJdID0gXCJFXCIsIHJbci5TRSA9IDNdID0gXCJTRVwiLCByW3IuUyA9IDRdID0gXCJTXCIsIHJbci5TVyA9IDVdID0gXCJTV1wiLCByW3IuVyA9IDZdID0gXCJXXCIsIHJbci5OVyA9IDddID0gXCJOV1wiLCByKSkoZiB8fCB7fSk7XG5jb25zdCB1dCA9IFtcbiAgbnVsbCxcbiAgeyBxOiAxLCByOiAtMSB9LFxuICB7IHE6IDEsIHI6IDAgfSxcbiAgeyBxOiAwLCByOiAxIH0sXG4gIG51bGwsXG4gIHsgcTogLTEsIHI6IDEgfSxcbiAgeyBxOiAtMSwgcjogMCB9LFxuICB7IHE6IDAsIHI6IC0xIH1cbl0sIGh0ID0gW1xuICB7IHE6IDAsIHI6IC0xIH0sXG4gIHsgcTogMSwgcjogLTEgfSxcbiAgbnVsbCxcbiAgeyBxOiAxLCByOiAwIH0sXG4gIHsgcTogMCwgcjogMSB9LFxuICB7IHE6IC0xLCByOiAxIH0sXG4gIG51bGwsXG4gIHsgcTogLTEsIHI6IDAgfVxuXSwgZnQgPSAoeyBvZmZzZXQ6IHIsIHE6IHQsIHI6IGUsIGNvbDogbiwgcm93OiBzIH0sIG8pID0+IHtcbiAgaWYgKG8gPT09IGYuUyB8fCBvID09PSBmLk4pIHtcbiAgICBjb25zdCBjID0gbyA9PT0gZi5TID8gcyArIDEgOiBzIC0gMTtcbiAgICByZXR1cm4geihuLCBjLCByKTtcbiAgfVxuICBjb25zdCBpID0gdXRbb107XG4gIHJldHVybiB7IHE6IHQgKyBpLnEsIHI6IGUgKyBpLnIgfTtcbn0sIGF0ID0gKHsgb2Zmc2V0OiByLCBxOiB0LCByOiBlLCBjb2w6IG4sIHJvdzogcyB9LCBvKSA9PiB7XG4gIGlmIChvID09PSBmLkUgfHwgbyA9PT0gZi5XKSB7XG4gICAgY29uc3QgYyA9IG8gPT09IGYuRSA/IG4gKyAxIDogbiAtIDE7XG4gICAgcmV0dXJuIF8oYywgcywgcik7XG4gIH1cbiAgY29uc3QgaSA9IGh0W29dO1xuICByZXR1cm4geyBxOiB0ICsgaS5xLCByOiBlICsgaS5yIH07XG59LCBJID0gKHIsIHQpID0+IHIuY2xvbmUoci5pc1BvaW50eSA/IGZ0KHIsIHQpIDogYXQociwgdCkpO1xuZnVuY3Rpb24gTihyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHIpID8gZnVuY3Rpb24oZSwgbikge1xuICAgIGNvbnN0IHMgPSBbXTtcbiAgICBsZXQgbyA9IG47XG4gICAgZm9yIChjb25zdCBpIG9mIHIpXG4gICAgICBmb3IgKGNvbnN0IGMgb2YgaShlLCBvKSlcbiAgICAgICAgcy5wdXNoKG8gPSBjKTtcbiAgICByZXR1cm4gcztcbiAgfSA6IHI7XG59XG5jb25zdCBUdCA9ICguLi5yKSA9PiAodCkgPT4gci5tYXAodCk7XG5mdW5jdGlvbiB2KHIpIHtcbiAgcmV0dXJuIGx0KHIpID8gZ3QocikgOiB4dChyKTtcbn1cbmZ1bmN0aW9uIGx0KHIpIHtcbiAgcmV0dXJuIHIuZGlyZWN0aW9uIGluIGY7XG59XG5mdW5jdGlvbiBndCh7IHN0YXJ0OiByLCBkaXJlY3Rpb246IHQsIGxlbmd0aDogZSB9KSB7XG4gIHJldHVybiBmdW5jdGlvbihzLCBvKSB7XG4gICAgY29uc3QgaSA9IFtdO1xuICAgIGxldCB1ID0gcyhyID8/IG8pO1xuICAgICFyICYmIG8gJiYgKHUgPSBJKHUsIHQpKTtcbiAgICBmb3IgKGxldCBoID0gMDsgaCA8IGU7IGgrKylcbiAgICAgIGkucHVzaCh1KSwgdSA9IEkodSwgdCk7XG4gICAgcmV0dXJuIGk7XG4gIH07XG59XG5mdW5jdGlvbiB4dCh7IHN0YXJ0OiByLCBzdG9wOiB0IH0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG4sIHMpIHtcbiAgICBjb25zdCBvID0gW10sIGkgPSBuKHIgPz8gcyksIGMgPSBCKGkpLCB1ID0gQihDKGksIHQpKSwgaCA9IGR0KGMsIHUpLCB4ID0gUihpLCBpLCB0KSwgeSA9IDEgLyBNYXRoLm1heCh4LCAxKTtcbiAgICBsZXQgbSA9ICFyICYmIHMgPyAxIDogMDtcbiAgICBmb3IgKG07IG0gPD0geDsgbSsrKSB7XG4gICAgICBjb25zdCBhID0gRihoKHkgKiBtKSk7XG4gICAgICBvLnB1c2gobihhKSk7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9O1xufVxuZnVuY3Rpb24gQih7IHE6IHIsIHI6IHQsIHM6IGUgfSkge1xuICByZXR1cm4geyBxOiByICsgMWUtNiwgcjogdCArIDFlLTYsIHM6IGUgKyAtMmUtNiB9O1xufVxuZnVuY3Rpb24gZHQociwgdCkge1xuICByZXR1cm4gKGUpID0+IHtcbiAgICBjb25zdCBuID0gci5xICogKDEgLSBlKSArIHQucSAqIGUsIHMgPSByLnIgKiAoMSAtIGUpICsgdC5yICogZTtcbiAgICByZXR1cm4geyBxOiBuLCByOiBzIH07XG4gIH07XG59XG5jb25zdCB3dCA9IChyKSA9PiAodCwgZSkgPT4gW0kodChlKSwgcildO1xuZnVuY3Rpb24gVShyLCB0LCB7IGluY2x1ZGVTb3VyY2U6IGUgPSAhMCB9ID0ge30pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHMsIG8pIHtcbiAgICBjb25zdCBpID0gW107XG4gICAgZm9yIChjb25zdCBjIG9mIE4ocikocywgbykpIHtcbiAgICAgIGUgJiYgaS5wdXNoKGMpO1xuICAgICAgZm9yIChjb25zdCB1IG9mIE4odCkocywgYykpXG4gICAgICAgIGkucHVzaCh1KTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH07XG59XG5mdW5jdGlvbiBTdChyLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbihuLCBzKSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGg6IG8sXG4gICAgICBoZWlnaHQ6IGksXG4gICAgICBzdGFydDogYyxcbiAgICAgIGRpcmVjdGlvbjogdSA9IGYuRVxuICAgIH0gPSB0ID8gbXQociwgdCwgbigpKSA6IHIsIGggPSBjID8/IHMgPz8gWzAsIDBdLCB4ID0gVShcbiAgICAgIHYoeyBzdGFydDogaCwgZGlyZWN0aW9uOiBYKHUsIDIpLCBsZW5ndGg6IGkgfSksXG4gICAgICB2KHsgZGlyZWN0aW9uOiB1LCBsZW5ndGg6IG8gLSAxIH0pXG4gICAgKShuLCBoKTtcbiAgICByZXR1cm4gIWMgJiYgcyA/IHguc2xpY2UoMSkgOiB4O1xuICB9O1xufVxuZnVuY3Rpb24gbXQociwgdCwgeyBpc1BvaW50eTogZSwgb2Zmc2V0OiBuIH0pIHtcbiAgY29uc3QgeyBjb2w6IHMsIHJvdzogbyB9ID0gSyhyLCBlLCBuKSwgeyBjb2w6IGksIHJvdzogYyB9ID0gSyh0LCBlLCBuKSwgdSA9IHMgPCBpID8gXCJBXCIgOiBcIkJcIiwgaCA9IG8gPCBjID8gXCJBXCIgOiBcIkJcIiwgeCA9IHUgKyBoLCB7IHN3YXBXaWR0aEhlaWdodDogeSwgZGlyZWN0aW9uOiBtIH0gPSBxdFt4XSwgYSA9IE1hdGguYWJzKHMgLSBpKSArIDEsIGIgPSBNYXRoLmFicyhvIC0gYykgKyAxO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiB5ID8gYiA6IGEsXG4gICAgaGVpZ2h0OiB5ID8gYSA6IGIsXG4gICAgc3RhcnQ6IHIsXG4gICAgZGlyZWN0aW9uOiBtXG4gIH07XG59XG5mdW5jdGlvbiBLKHIsIHQsIGUpIHtcbiAgaWYgKFMocikpXG4gICAgcmV0dXJuIHI7XG4gIGNvbnN0IHsgcTogbiwgcjogcyB9ID0gSChyKSA/IEUocikgOiBwKHIpO1xuICByZXR1cm4gVyh7IHE6IG4sIHI6IHMsIGlzUG9pbnR5OiB0LCBvZmZzZXQ6IGUgfSk7XG59XG5jb25zdCBxdCA9IHtcbiAgQUE6IHtcbiAgICBzd2FwV2lkdGhIZWlnaHQ6ICExLFxuICAgIGRpcmVjdGlvbjogZi5FXG4gIH0sXG4gIEFCOiB7XG4gICAgc3dhcFdpZHRoSGVpZ2h0OiAhMCxcbiAgICBkaXJlY3Rpb246IGYuTlxuICB9LFxuICBCQToge1xuICAgIHN3YXBXaWR0aEhlaWdodDogITAsXG4gICAgZGlyZWN0aW9uOiBmLlNcbiAgfSxcbiAgQkI6IHtcbiAgICBzd2FwV2lkdGhIZWlnaHQ6ICExLFxuICAgIGRpcmVjdGlvbjogZi5XXG4gIH1cbn07XG5mdW5jdGlvbiBwdChyLCB0KSB7XG4gIHJldHVybiBOKEFycmF5LmZyb20oeyBsZW5ndGg6IHIgfSwgKCkgPT4gTih0KSkpO1xufVxuZnVuY3Rpb24geXQocikge1xuICBjb25zdCB7IGNlbnRlcjogdCwgcm90YXRpb246IGUgPSBMLkNMT0NLV0lTRSB9ID0gcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKHMsIG8pIHtcbiAgICBjb25zdCBpID0gZS50b1VwcGVyQ2FzZSgpLCBjID0gW107XG4gICAgbGV0IHsgcmFkaXVzOiB1IH0gPSByLCBoO1xuICAgIGwodSkgPyBoID0gcyh0KS50cmFuc2xhdGUoeyBxOiB1LCBzOiAtdSB9KSA6IChoID0gcyhyLnN0YXJ0ID8/IG8pLCB1ID0gUihoLCB0LCBoKSk7XG4gICAgY29uc3QgeyBxOiB4LCByOiB5LCBzOiBtIH0gPSBDKGgsIHQpO1xuICAgIGxldCBhID0gcyh7IHE6IHgsIHI6IHkgLSB1LCBzOiBtICsgdSB9KTtcbiAgICBpZiAoaSA9PT0gTC5DTE9DS1dJU0UpXG4gICAgICBmb3IgKGxldCBkID0gMDsgZCA8IDY7IGQrKylcbiAgICAgICAgZm9yIChsZXQgTyA9IDA7IE8gPCB1OyBPKyspIHtcbiAgICAgICAgICBjb25zdCB7IHE6IEEsIHI6IE0gfSA9IFFbZF07XG4gICAgICAgICAgYSA9IHMoeyBxOiBhLnEgKyBBLCByOiBhLnIgKyBNIH0pLCBjLnB1c2goYSk7XG4gICAgICAgIH1cbiAgICBlbHNlXG4gICAgICBmb3IgKGxldCBkID0gNTsgZCA+PSAwOyBkLS0pXG4gICAgICAgIGZvciAobGV0IE8gPSAwOyBPIDwgdTsgTysrKSB7XG4gICAgICAgICAgY29uc3QgeyBxOiBBLCByOiBNIH0gPSBRW2RdO1xuICAgICAgICAgIGEgPSBzKHsgcTogYS5xIC0gQSwgcjogYS5yIC0gTSB9KSwgYy5wdXNoKGEpO1xuICAgICAgICB9XG4gICAgY29uc3QgYiA9ICFyLnN0YXJ0ICYmIG8sIFkgPSBjLmZpbmRJbmRleCgoZCkgPT4gZC5lcXVhbHMoaCkpO1xuICAgIHJldHVybiBjLnNsaWNlKFkgKyAoYiA/IDEgOiAwKSkuY29uY2F0KGMuc2xpY2UoMCwgWSkpO1xuICB9O1xufVxuY29uc3QgUSA9IFtcbiAgeyBxOiAxLCByOiAwIH0sXG4gIHsgcTogMCwgcjogMSB9LFxuICB7IHE6IC0xLCByOiAxIH0sXG4gIHsgcTogLTEsIHI6IDAgfSxcbiAgeyBxOiAwLCByOiAtMSB9LFxuICB7IHE6IDEsIHI6IC0xIH1cbl07XG5mdW5jdGlvbiBDdCh7IHJhZGl1czogciwgc3RhcnQ6IHQsIHJvdGF0aW9uOiBlIH0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHMsIG8pIHtcbiAgICBjb25zdCBpID0gdCA/PyBvID8/IFswLCAwXSwgYyA9ICF0ICYmIG8gPyByIDogciArIDE7XG4gICAgcmV0dXJuIFUodih7IHN0YXJ0OiB0LCBkaXJlY3Rpb246IGYuTiwgbGVuZ3RoOiBjIH0pLCB5dCh7IGNlbnRlcjogaSwgcm90YXRpb246IGUgfSkpKHMsIG8pO1xuICB9O1xufVxuY2xhc3MgcSB7XG4gIHN0YXRpYyBmcm9tSXRlcmFibGUodCkge1xuICAgIGNvbnN0IGUgPSB0W1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCkudmFsdWU7XG4gICAgaWYgKCFlKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuJ3QgY3JlYXRlIGdyaWQgZnJvbSBlbXB0eSBpdGVyYWJsZTogJHtKU09OLnN0cmluZ2lmeSh0KX1gKTtcbiAgICByZXR1cm4gbmV3IHEoZS5jb25zdHJ1Y3RvciwgdCk7XG4gIH1cbiAgc3RhdGljIGZyb21KU09OKHsgaGV4U2V0dGluZ3M6IHQsIGNvb3JkaW5hdGVzOiBlIH0pIHtcbiAgICBjb25zdCBuID0gZXQodCk7XG4gICAgcmV0dXJuIG5ldyBxKFxuICAgICAgbixcbiAgICAgIGUubWFwKChzKSA9PiBuZXcgbihzKSlcbiAgICApO1xuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLiNyLnNpemU7XG4gIH1cbiAgZ2V0IHBpeGVsV2lkdGgoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMClcbiAgICAgIHJldHVybiAwO1xuICAgIGNvbnN0IHsgaXNQb2ludHk6IHQsIHdpZHRoOiBlIH0gPSB0aGlzLmhleFByb3RvdHlwZSwgbiA9IHRoaXMudG9BcnJheSgpLCB7XG4gICAgICAwOiBzLFxuICAgICAgbGVuZ3RoOiBvLFxuICAgICAgW28gLSAxXTogaVxuICAgIH0gPSB0ID8gbi5zb3J0KChjLCB1KSA9PiB1LnMgLSBjLnMgfHwgYy5xIC0gdS5xKSA6IG4uc29ydCgoYywgdSkgPT4gYy5xIC0gdS5xKTtcbiAgICByZXR1cm4gaS54IC0gcy54ICsgZTtcbiAgfVxuICBnZXQgcGl4ZWxIZWlnaHQoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMClcbiAgICAgIHJldHVybiAwO1xuICAgIGNvbnN0IHsgaXNQb2ludHk6IHQsIGhlaWdodDogZSB9ID0gdGhpcy5oZXhQcm90b3R5cGUsIG4gPSB0aGlzLnRvQXJyYXkoKSwge1xuICAgICAgMDogcyxcbiAgICAgIGxlbmd0aDogbyxcbiAgICAgIFtvIC0gMV06IGlcbiAgICB9ID0gdCA/IG4uc29ydCgoYywgdSkgPT4gYy5yIC0gdS5yKSA6IG4uc29ydCgoYywgdSkgPT4gdS5zIC0gYy5zIHx8IGMuciAtIHUucik7XG4gICAgcmV0dXJuIGkueSAtIHMueSArIGU7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3IudmFsdWVzKCk7XG4gIH1cbiAgZ2V0IGhleFByb3RvdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jdC5wcm90b3R5cGU7XG4gIH1cbiAgI3Q7XG4gICNyID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IodCwgZSA9IFtdKSB7XG4gICAgaWYgKHQgaW5zdGFuY2VvZiBxKSB7XG4gICAgICB0aGlzLiN0ID0gdC4jdCwgdGhpcy5zZXRIZXhlcyh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdCA9IHQsIHRoaXMuc2V0SGV4ZXModGhpcy4jbihlKSk7XG4gIH1cbiAgY3JlYXRlSGV4KHQpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuI3QodCk7XG4gIH1cbiAgZ2V0SGV4KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVIZXgodCk7XG4gICAgcmV0dXJuIHRoaXMuI3IuZ2V0KGUudG9TdHJpbmcoKSk7XG4gIH1cbiAgaGFzSGV4KHQpIHtcbiAgICByZXR1cm4gdGhpcy4jci5oYXModC50b1N0cmluZygpKTtcbiAgfVxuICBzZXRIZXhlcyh0KSB7XG4gICAgZm9yIChjb25zdCBlIG9mIHQpIHtcbiAgICAgIGNvbnN0IG4gPSBlIGluc3RhbmNlb2YgJCA/IGUgOiBuZXcgdGhpcy4jdChlKTtcbiAgICAgIHRoaXMuI2Uobik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZpbHRlcih0KSB7XG4gICAgY29uc3QgZSA9IG5ldyBxKHRoaXMuI3QpO1xuICAgIGZvciAoY29uc3QgbiBvZiB0aGlzKVxuICAgICAgdChuKSAmJiBlLiNlKG4pO1xuICAgIHJldHVybiBlO1xuICB9XG4gIG1hcCh0KSB7XG4gICAgY29uc3QgZSA9IG5ldyBxKHRoaXMuI3QpO1xuICAgIGZvciAoY29uc3QgbiBvZiB0aGlzKVxuICAgICAgZS4jZSh0KG4pKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICB0cmF2ZXJzZSh0LCB7IGJhaWw6IGUgPSAhMSB9ID0ge30pIHtcbiAgICBjb25zdCBuID0gbmV3IHEodGhpcy4jdCk7XG4gICAgZm9yIChjb25zdCBzIG9mIHRoaXMuI24odCkpIHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLmdldEhleChzKTtcbiAgICAgIGlmIChvKVxuICAgICAgICBuLiNlKG8pO1xuICAgICAgZWxzZSBpZiAoZSlcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIGZvckVhY2godCkge1xuICAgIGZvciAoY29uc3QgZSBvZiB0aGlzKVxuICAgICAgdChlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWR1Y2UodCwgZSkge1xuICAgIGlmIChlID09PSB2b2lkIDApIHtcbiAgICAgIGxldCBzLCBvLCBpO1xuICAgICAgZm9yIChjb25zdCBjIG9mIHRoaXMpXG4gICAgICAgIG8gPSBpLCBpID0gYywgbyAmJiAocyA9IHQobywgaSkpO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGxldCBuID0gZTtcbiAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcylcbiAgICAgIG4gPSB0KG4sIHMpO1xuICAgIHJldHVybiBuO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcyk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IHsgZGltZW5zaW9uczogdCwgb3JpZW50YXRpb246IGUsIG9yaWdpbjogbiwgb2Zmc2V0OiBzIH0gPSB0aGlzLmhleFByb3RvdHlwZTtcbiAgICByZXR1cm4geyBoZXhTZXR0aW5nczogeyBkaW1lbnNpb25zOiB0LCBvcmllbnRhdGlvbjogZSwgb3JpZ2luOiBuLCBvZmZzZXQ6IHMgfSwgY29vcmRpbmF0ZXM6IHRoaXMudG9BcnJheSgpIH07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0oJHt0aGlzLnNpemV9KWA7XG4gIH1cbiAgcG9pbnRUb0hleCh0LCB7IGFsbG93T3V0c2lkZTogZSA9ICEwIH0gPSB7fSkge1xuICAgIGNvbnN0IG4gPSBpdCh0aGlzLmhleFByb3RvdHlwZSwgdCksIHMgPSB0aGlzLmdldEhleChuKTtcbiAgICByZXR1cm4gZSA/IHMgPz8gdGhpcy5jcmVhdGVIZXgobikgOiBzO1xuICB9XG4gIGRpc3RhbmNlKHQsIGUsIHsgYWxsb3dPdXRzaWRlOiBuID0gITAgfSA9IHt9KSB7XG4gICAgaWYgKG4pXG4gICAgICByZXR1cm4gUih0aGlzLmhleFByb3RvdHlwZSwgdCwgZSk7XG4gICAgY29uc3QgcyA9IHRoaXMuZ2V0SGV4KHQpLCBvID0gdGhpcy5nZXRIZXgoZSk7XG4gICAgaWYgKCEoIXMgfHwgIW8pKVxuICAgICAgcmV0dXJuIFIodGhpcy5oZXhQcm90b3R5cGUsIHMsIG8pO1xuICB9XG4gIG5laWdoYm9yT2YodCwgZSwgeyBhbGxvd091dHNpZGU6IG4gPSAhMCB9ID0ge30pIHtcbiAgICBjb25zdCBzID0gSSh0aGlzLmNyZWF0ZUhleCh0KSwgZSksIG8gPSB0aGlzLmdldEhleChzKTtcbiAgICByZXR1cm4gbiA/IG8gPz8gcyA6IG87XG4gIH1cbiAgI2UodCkge1xuICAgIHRoaXMuI3Iuc2V0KHQudG9TdHJpbmcoKSwgdCk7XG4gIH1cbiAgI24odCkge1xuICAgIHJldHVybiB0aGlzLiNzKHQpID8gdGhpcy4jbyh0KSA6IEFycmF5LmlzQXJyYXkodCkgJiYgdGhpcy4jcyh0WzBdKSA/IHRoaXMuI28oTih0KSkgOiB0O1xuICB9XG4gICNzKHQpIHtcbiAgICByZXR1cm4gayh0KTtcbiAgfVxuICAjbyh0KSB7XG4gICAgcmV0dXJuIHQodGhpcy5jcmVhdGVIZXguYmluZCh0aGlzKSk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIGYgYXMgRGlyZWN0aW9uLFxuICBxIGFzIEdyaWQsXG4gICQgYXMgSGV4LFxuICBnIGFzIE9yaWVudGF0aW9uLFxuICBMIGFzIFJvdGF0aW9uLFxuICBwIGFzIGNvbXBsZXRlQ3ViZSxcbiAgTiBhcyBjb25jYXQsXG4gIEcgYXMgY3JlYXRlSGV4RGltZW5zaW9ucyxcbiAgRCBhcyBjcmVhdGVIZXhPcmlnaW4sXG4gIFQgYXMgZGVmYXVsdEhleFNldHRpbmdzLFxuICBldCBhcyBkZWZpbmVIZXgsXG4gIFIgYXMgZGlzdGFuY2UsXG4gIG50IGFzIGVxdWFscyxcbiAgVHQgYXMgZnJvbUNvb3JkaW5hdGVzLFxuICBXIGFzIGhleFRvT2Zmc2V0LFxuICBKIGFzIGhleFRvUG9pbnQsXG4gIE90IGFzIGlzQXhpYWwsXG4gIFMgYXMgaXNPZmZzZXQsXG4gIFYgYXMgaXNQb2ludCxcbiAgSCBhcyBpc1R1cGxlLFxuICB2IGFzIGxpbmUsXG4gIHd0IGFzIG1vdmUsXG4gIEkgYXMgbmVpZ2hib3JPZixcbiAgUCBhcyBvZmZzZXRGcm9tWmVybyxcbiAgaiBhcyBvZmZzZXRUb0N1YmUsXG4gIF8gYXMgb2Zmc2V0VG9DdWJlRmxhdCxcbiAgeiBhcyBvZmZzZXRUb0N1YmVQb2ludHksXG4gIGl0IGFzIHBvaW50VG9DdWJlLFxuICBTdCBhcyByZWN0YW5nbGUsXG4gIHB0IGFzIHJlcGVhdCxcbiAgVSBhcyByZXBlYXRXaXRoLFxuICB5dCBhcyByaW5nLFxuICBGIGFzIHJvdW5kLFxuICBDdCBhcyBzcGlyYWwsXG4gIEMgYXMgdG9DdWJlLFxuICBjdCBhcyB0cmFuc2xhdGUsXG4gIEUgYXMgdHVwbGVUb0N1YmVcbn07XG4iLCIvL0ltcG9ydHNcbmltcG9ydCB7IGRlZmluZUhleCwgR3JpZCwgc3BpcmFsLCBoZXhUb1BvaW50IH0gZnJvbSAnaG9uZXljb21iLWdyaWQnOyAvL1B1YmxpYyB2YXJpYWJsZXNcblxuZXhwb3J0IGNvbnN0IGNhbWVyYSA9IHtcbiAgeDogMCxcbiAgeTogMCxcbiAgem9vbTogMVxufTtcbmV4cG9ydCBsZXQgY3VycmVudE1hcDtcbmNvbnN0IEhleCA9IGRlZmluZUhleCh7XG4gIGRpbWVuc2lvbnM6IDYwLFxuICBvcmllbnRhdGlvbjogJ0ZMQVQnLFxuICBvcmlnaW46IHtcbiAgICB4OiAtNTAwLFxuICAgIHk6IC00MDBcbiAgfVxufSk7IC8vUHJpdmF0ZSB2YXJpYWJsZXNcblxuY29uc3QgbWFpbkNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjbWFpbkNhbnZhc1wiKTtcbmNvbnN0IGFuaW1DYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2FuaW1hdGlvbkNhbnZhc1wiKTtcbmNvbnN0IG1haW5DdHggPSBtYWluQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbmNvbnN0IGFuaW1DdHggPSBhbmltQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbmxldCBzY2FsZXMgPSBbXTtcbmxldCBoZXhTaXplO1xubGV0IGFfZnVsbCwgYl9mdWxsLCBjX2Z1bGwsIGFfaGV4LCBiX2hleCwgY19oZXg7XG5sZXQgaGFsZkNhbnZhc1dpZHRoLCBoYWxmQ2FudmFzSGVpZ2h0O1xubGV0IGdyaWQgPSBuZXcgR3JpZChIZXgpO1xubGV0IFBST1ZJREVSO1xubGV0IGlzZGJsY2xpY2sgPSBmYWxzZTtcblxuYXN5bmMgZnVuY3Rpb24gc2xlZXAobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFwKHJhZGl1cykge1xuICBsZXQgbWFwID0gbmV3IEdyaWQoSGV4LCBzcGlyYWwoe1xuICAgIHJhZGl1czogcmFkaXVzXG4gIH0pKTsgLy9CYXNpYyB3YXRlciBsYXllclxuXG4gIGZvciAobGV0IGhleCBvZiBtYXApIHtcbiAgICBoZXgudHlwZSA9IFwiNjQsIDEyOCwgMjU1XCI7XG4gICAgaGV4LmhpZ2hsaWdodCA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG1hcDtcbn0gLy9QdWJsaWMgZnVuY3Rpb25zXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWF0ZU1hcChldmVyKSB7XG4gIGN1cnJlbnRNYXAgPSBnZXRNYXAoNSk7XG4gIG1haW5DYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgbWFpbkNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIGFuaW1DYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgYW5pbUNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIGNhbGN1bGF0ZUhleERpbWVuc2lvbnMoKTtcbiAgd2luZG93UmVzaXplVXBkYXRlKCk7XG4gIHpvb21VcGRhdGUoKTtcbiAgZHJhd01hcCgpO1xuICBjYW1lcmEueCA9IGhhbGZDYW52YXNXaWR0aDtcbiAgY2FtZXJhLnkgPSBoYWxmQ2FudmFzSGVpZ2h0O1xuICBQUk9WSURFUiA9IGV2ZXI7XG4gIGF3YWl0IFBST1ZJREVSLmluaXQoY3VycmVudE1hcCk7XG4gIHJlY2FsY0VuZXJneSgpO1xufVxuXG5mdW5jdGlvbiByZWNhbGNFbmVyZ3koKSB7XG4gIGZvciAobGV0IGhleCBvZiBjdXJyZW50TWFwKSB7XG4gICAgaWYgKCFoZXguZGV0YWlscykgY29udGludWU7XG4gICAgY2FsY3VsYXRlRW5lcmd5KGhleCk7XG4gIH1cblxuICBzZXRUaW1lb3V0KHJlY2FsY0VuZXJneSwgMTAwMCk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUVuZXJneShoZXgpIHtcbiAgbGV0IGRhdGVOb3cgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKTtcblxuICBpZiAoMSAqIGhleC5kZXRhaWxzLmVuZXJneSA+PSAxICogaGV4LmRldGFpbHMuZW5lcmd5TWF4IHx8IDEgKiBoZXguZGV0YWlscy5sYXN0Q2FsY1RpbWUgPj0gZGF0ZU5vdykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBlbmVyZ3kgPSBNYXRoLm1pbigxICogaGV4LmRldGFpbHMuZW5lcmd5ICsgaGV4LmRldGFpbHMuZW5lcmd5U2VjICogKGRhdGVOb3cgLSBoZXguZGV0YWlscy5sYXN0Q2FsY1RpbWUpLCAxICogaGV4LmRldGFpbHMuZW5lcmd5TWF4KTtcbiAgaGV4LmRldGFpbHMubGFzdENhbGNUaW1lID0gZGF0ZU5vdztcbiAgaGV4LmRldGFpbHMuZW5lcmd5ID0gZW5lcmd5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gem9vbVVwZGF0ZSgpIHtcbiAgY29uc3QgaGV4ID0gZ3JpZC5wb2ludFRvSGV4KHtcbiAgICB4OiBjYW1lcmEueCxcbiAgICB5OiBjYW1lcmEueVxuICB9KTtcbiAgY29uc3QgeCA9IGhleC54O1xuICBjb25zdCB5ID0gaGV4Lnk7XG4gIGhleFNpemUgPSBzY2FsZXNbY2FtZXJhLnpvb21dO1xuICBjYWxjdWxhdGVIZXhEaW1lbnNpb25zKCk7XG4gIGxldCByZXBsYWNlbWVudE1hcCA9IG5ldyBHcmlkKEhleCwgc3BpcmFsKHtcbiAgICByYWRpdXM6IGN1cnJlbnRNYXAucmFkaXVzXG4gIH0pKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRNYXAubGVuZ3RoOyBpKyspIHtcbiAgICBjdXJyZW50TWFwW2ldLnNpemUgPSByZXBsYWNlbWVudE1hcFtpXS5zaXplO1xuXG4gICAgaWYgKGN1cnJlbnRNYXBbaV0ueCA9PT0geCAmJiBjdXJyZW50TWFwW2ldLnkgPT09IHkpIHtcbiAgICAgIGNhbWVyYS54ID0gTWF0aC5yb3VuZChoZXhUb1BvaW50KGN1cnJlbnRNYXBbaV0pLnggKyBiX2Z1bGwgKyBoZXhTaXplIC8gMik7XG4gICAgICBjYW1lcmEueSA9IE1hdGgucm91bmQoaGV4VG9Qb2ludChjdXJyZW50TWFwW2ldKS55ICsgY19mdWxsKTtcbiAgICB9XG4gIH1cbn0gLy9Qcml2YXRlIGZ1bmN0aW9uc1xuXG5mdW5jdGlvbiBkcmF3TWFwKCkge1xuICAvL0NsZWFyaW5nXG4gIG1haW5DdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICBtYWluQ3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgbWFpbkN0eC5maWxsUmVjdCgwLCAwLCBtYWluQ2FudmFzLndpZHRoLCBtYWluQ2FudmFzLmhlaWdodCk7IC8vUG9zaXRpb25pbmcgdGhlIGNhbWVyYVxuXG4gIG1haW5DdHgudHJhbnNsYXRlKC1jYW1lcmEueCArIGhhbGZDYW52YXNXaWR0aCwgLWNhbWVyYS55ICsgaGFsZkNhbnZhc0hlaWdodCk7XG5cbiAgZm9yIChsZXQgaGV4IG9mIGN1cnJlbnRNYXApIHtcbiAgICAvL0hleCBpcyBpZ25vcmVkIGlmIGl0IHdhc24ndCBzZWVuIHlldFxuICAgIC8vaWYgKGhleC52aXNpYmlsaXR5ID09PSAndW5zZWVuJykgY29udGludWVcbiAgICAvLyBjb25zb2xlLmxvZygnaGV4JywgaGV4KVxuICAgIC8vIGNvbnNvbGUubG9nKCdoZXhUb1BvaW50JywgaGV4VG9Qb2ludChoZXgpKVxuICAgIGxldCB4ID0gaGV4VG9Qb2ludChoZXgpLngsXG4gICAgICAgIHkgPSBoZXhUb1BvaW50KGhleCkueTsgLy9DaGVja2luZyBpZiBoZXggaXMgdmlzaWJsZSB3aXRoaW4gY2FudmFzXG5cbiAgICBpZiAoTWF0aC5hYnMoeCAtIGNhbWVyYS54KSA+IGhhbGZDYW52YXNXaWR0aCArIGhleFNpemUgfHwgTWF0aC5hYnMoeSAtIGNhbWVyYS55KSA+IGhhbGZDYW52YXNIZWlnaHQgKyBoZXhTaXplKSBjb250aW51ZTsgLy9EcmF3aW5nIGhpZ2hsaWdodCBhcm91bmQgaGV4XG5cbiAgICBpZiAoaGV4LmhpZ2hsaWdodCkge1xuICAgICAgbWFpbkN0eC5zdHJva2VTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgIG1haW5DdHguYmVnaW5QYXRoKCk7XG4gICAgICBtYWluQ3R4Lm1vdmVUbyh4ICsgYV9mdWxsLCB5IC0gY19mdWxsKTtcbiAgICAgIG1haW5DdHgubGluZVRvKHggKyBiX2Z1bGwsIHkpO1xuICAgICAgbWFpbkN0eC5saW5lVG8oeCArIGFfZnVsbCwgeSArIGNfZnVsbCk7XG4gICAgICBtYWluQ3R4LmxpbmVUbyh4IC0gYV9mdWxsLCB5ICsgY19mdWxsKTtcbiAgICAgIG1haW5DdHgubGluZVRvKHggLSBiX2Z1bGwsIHkpO1xuICAgICAgbWFpbkN0eC5saW5lVG8oeCAtIGFfZnVsbCwgeSAtIGNfZnVsbCk7XG4gICAgICBtYWluQ3R4LmNsb3NlUGF0aCgpO1xuICAgICAgbWFpbkN0eC5zdHJva2UoKTtcbiAgICB9IC8vRHJhd2luZyB0aGUgaGV4XG5cblxuICAgIGxldCBjb2xvciA9IGhleC5kZXRhaWxzID8gYCR7aGV4LmRldGFpbHMuY29sb3Iucn0sICR7aGV4LmRldGFpbHMuY29sb3IuZ30sICR7aGV4LmRldGFpbHMuY29sb3IuYn1gIDogaGV4LnR5cGU7XG4gICAgbWFpbkN0eC5maWxsU3R5bGUgPSBgcmdiYSgke2NvbG9yfSwxKWA7XG4gICAgbWFpbkN0eC5iZWdpblBhdGgoKTtcbiAgICBtYWluQ3R4Lm1vdmVUbyh4ICsgYV9oZXgsIHkgLSBjX2hleCk7XG4gICAgbWFpbkN0eC5saW5lVG8oeCArIGJfaGV4LCB5KTtcbiAgICBtYWluQ3R4LmxpbmVUbyh4ICsgYV9oZXgsIHkgKyBjX2hleCk7XG4gICAgbWFpbkN0eC5saW5lVG8oeCAtIGFfaGV4LCB5ICsgY19oZXgpO1xuICAgIG1haW5DdHgubGluZVRvKHggLSBiX2hleCwgeSk7XG4gICAgbWFpbkN0eC5saW5lVG8oeCAtIGFfaGV4LCB5IC0gY19oZXgpO1xuICAgIG1haW5DdHguY2xvc2VQYXRoKCk7XG4gICAgbWFpbkN0eC5maWxsKCk7XG4gICAgc2V0VGV4dChtYWluQ3R4LCB4LCB5IC0gaGV4U2l6ZSAvIDIsIGAke2hleC5xfTske2hleC5yfWApO1xuXG4gICAgaWYgKGhleC5kZXRhaWxzKSB7XG4gICAgICBzZXRUZXh0KG1haW5DdHgsIHgsIHksIGAke2hleC5kZXRhaWxzLmVuZXJneX1gKTtcbiAgICAgIHNldFRleHQobWFpbkN0eCwgeCwgeSArIGhleFNpemUgLyAyLCBgbHZsOiAkezEgKiBoZXguZGV0YWlscy5sZXZlbCArIDF9YCk7XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXdNYXApO1xufVxuXG5mdW5jdGlvbiBzZXRUZXh0KGN0eCwgeCwgeSwgdHh0LCBmb250U2l6ZSA9IDEwLCBzdHlsZSA9IFwid2hpdGVcIiwgYWxpZ24gPSAnY2VudGVyJykge1xuICBsZXQgX2ZvbnQgPSBgJHtmb250U2l6ZSAqIChjYW1lcmEuem9vbSArIDEpfXB4IEdlb3JnaWFgO1xuICBjdHguZm9udCA9IF9mb250O1xuICBjdHguZmlsbFN0eWxlID0gc3R5bGU7XG4gIGN0eC50ZXh0QWxpZ24gPSBhbGlnbjtcbiAgY3R4LmZpbGxUZXh0KHR4dCwgeCwgeSwgaGV4U2l6ZSk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUhleERpbWVuc2lvbnMoKSB7XG4gIGFfZnVsbCA9IGhleFNpemUgLyAyO1xuICBiX2Z1bGwgPSBoZXhTaXplO1xuICBjX2Z1bGwgPSBoZXhTaXplIC8gMiAqIE1hdGguc3FydCgzKTtcbiAgYV9oZXggPSBhX2Z1bGwgKiAwLjk1O1xuICBiX2hleCA9IGJfZnVsbCAqIDAuOTU7XG4gIGNfaGV4ID0gY19mdWxsICogMC45NTtcbn1cblxuZnVuY3Rpb24gd2luZG93UmVzaXplVXBkYXRlKCkge1xuICBtYWluQ2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gIG1haW5DYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICBhbmltQ2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gIGFuaW1DYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICBoYWxmQ2FudmFzV2lkdGggPSBtYWluQ2FudmFzLndpZHRoIC8gMjtcbiAgaGFsZkNhbnZhc0hlaWdodCA9IG1haW5DYW52YXMuaGVpZ2h0IC8gMjtcbiAgY29uc3QgbWluID0gTWF0aC5taW4oaGFsZkNhbnZhc1dpZHRoLCBoYWxmQ2FudmFzSGVpZ2h0KTtcbiAgc2NhbGVzID0gW21pbiAvIDEwLCBtaW4gLyA3LCBtaW4gLyA1XTtcbn0gLy9IZXggSGlnaGxpZ2h0aW5nXG5cblxuYW5pbUNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICh7XG4gIG9mZnNldFgsXG4gIG9mZnNldFlcbn0pID0+IHtcbiAgY29uc29sZS5sb2coJ2NsaWNrJywgaXNkYmxjbGljayk7XG4gIGF3YWl0IHNsZWVwKDUwMCk7XG4gIGNvbnNvbGUubG9nKCdjbGljaycsIGlzZGJsY2xpY2spO1xuXG4gIGlmIChpc2RibGNsaWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb2Zmc2V0WCArPSBjYW1lcmEueCAtIG1haW5DYW52YXMud2lkdGggLyAyO1xuICBvZmZzZXRZICs9IGNhbWVyYS55IC0gbWFpbkNhbnZhcy5oZWlnaHQgLyAyO1xuICBjb25zdCBoZXhDb29yZGluYXRlcyA9IGdyaWQucG9pbnRUb0hleCh7XG4gICAgeDogb2Zmc2V0WCxcbiAgICB5OiBvZmZzZXRZXG4gIH0pO1xuXG4gIGZvciAobGV0IGhleCBvZiBjdXJyZW50TWFwKSB7XG4gICAgaWYgKGhleC54ID09IGhleENvb3JkaW5hdGVzLnggJiYgaGV4LnkgPT0gaGV4Q29vcmRpbmF0ZXMueSkge1xuICAgICAgaGV4LmhpZ2hsaWdodCA9ICFoZXguaGlnaGxpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBoZXguaGlnaGxpZ2h0ID0gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcbmFuaW1DYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBhc3luYyAoe1xuICBvZmZzZXRYLFxuICBvZmZzZXRZXG59KSA9PiB7XG4gIGlzZGJsY2xpY2sgPSB0cnVlO1xuICBjb25zb2xlLmxvZygnZGJsY2xpY2snLCBpc2RibGNsaWNrKTtcbiAgYXdhaXQgc2xlZXAoNTAwKTtcbiAgaXNkYmxjbGljayA9IGZhbHNlO1xuICBjb25zb2xlLmxvZygnZGJsY2xpY2snLCBpc2RibGNsaWNrKTtcbiAgb2Zmc2V0WCArPSBjYW1lcmEueCAtIG1haW5DYW52YXMud2lkdGggLyAyO1xuICBvZmZzZXRZICs9IGNhbWVyYS55IC0gbWFpbkNhbnZhcy5oZWlnaHQgLyAyO1xuICBjb25zdCBoZXhDb29yZGluYXRlcyA9IGdyaWQucG9pbnRUb0hleCh7XG4gICAgeDogb2Zmc2V0WCxcbiAgICB5OiBvZmZzZXRZXG4gIH0pO1xuICBjb25zb2xlLmxvZyhoZXhDb29yZGluYXRlcyk7XG4gIGxldCBoSGV4O1xuICBsZXQgdEhleDtcblxuICBmb3IgKGxldCBoZXggb2YgY3VycmVudE1hcCkge1xuICAgIGlmIChoZXguaGlnaGxpZ2h0KSB7XG4gICAgICBoSGV4ID0gaGV4O1xuICAgIH1cblxuICAgIGlmIChoZXgueCA9PSBoZXhDb29yZGluYXRlcy54ICYmIGhleC55ID09IGhleENvb3JkaW5hdGVzLnkpIHtcbiAgICAgIHRIZXggPSBoZXg7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0SGV4KSByZXR1cm47XG4gIGlmIChoSGV4ICYmICFoSGV4LmRldGFpbHMpIHJldHVybjtcbiAgY29uc29sZS5sb2coJ2hIZXgnLCBoSGV4KTtcbiAgY29uc29sZS5sb2coJ3RIZXgnLCB0SGV4KTtcbiAgbGV0IGNlbGxDb29yZCA9IHtcbiAgICB4OiBoZXhDb29yZGluYXRlcy5xLFxuICAgIHk6IGhleENvb3JkaW5hdGVzLnIsXG4gICAgejogaGV4Q29vcmRpbmF0ZXMuc1xuICB9O1xuXG4gIGlmICghaEhleCkge1xuICAgIGlmICghdEhleC5kZXRhaWxzKSB7XG4gICAgICBhd2FpdCBQUk9WSURFUi5uZXdHYW1lKGNlbGxDb29yZCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGhIZXguYWRkcmVzcy50b1N0cmluZygpID09IHRIZXguYWRkcmVzcy50b1N0cmluZygpKSB7XG4gICAgYXdhaXQgUFJPVklERVIudXBncmFkZUNlbGwodEhleC5hZGRyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWlzTmVpZ2hib3JIZXgoaEhleCwgdEhleCkpIHJldHVybjtcbiAgICBsZXQgZW5lcmd5ID0gMTAwMDtcblxuICAgIGlmICghdEhleC5kZXRhaWxzKSB7XG4gICAgICBhd2FpdCBQUk9WSURFUi5tYXJrQ2VsbChoSGV4LmFkZHJlc3MsIGNlbGxDb29yZCwgZW5lcmd5KTtcbiAgICB9IGVsc2UgaWYgKGNvbG9ySXNFcXVhbChoSGV4LmRldGFpbHMuY29sb3IsIHRIZXguZGV0YWlscy5jb2xvcikpIHtcbiAgICAgIC8vINC/0LXRgNC10L/QuNGB0LDRgtGMINGD0YHQu9C+0LLQuNC1INC/0L4g0LLQu9Cw0LTQtdC70YzRhtGDINGP0YfQtdC50LrQuCDQuCDRhtCy0LXRgtCwXG4gICAgICBhd2FpdCBQUk9WSURFUi5oZWxwQ2VsbChoSGV4LmFkZHJlc3MsIGNlbGxDb29yZCwgZW5lcmd5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgUFJPVklERVIuYXR0a0NlbGwoaEhleC5hZGRyZXNzLCBjZWxsQ29vcmQsIGVuZXJneSk7XG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gY29sb3JJc0VxdWFsKGNvbG9yMSwgY29sb3IyKSB7XG4gIHJldHVybiBjb2xvcjEuciA9PSBjb2xvcjIuciAmJiBjb2xvcjEuZyA9PSBjb2xvcjIuZyAmJiBjb2xvcjEuYiA9PSBjb2xvcjIuYjtcbn1cblxuZnVuY3Rpb24gaXNOZWlnaGJvckhleChoZXgxLCBoZXgyKSB7XG4gIHJldHVybiBjdWJlX2Rpc3RhbmNlKGhleDEsIGhleDIpID09IDE7XG59XG5cbmZ1bmN0aW9uIGN1YmVfZGlzdGFuY2UoaGV4MSwgaGV4Mikge1xuICByZXR1cm4gTWF0aC5tYXgoTWF0aC5hYnMoaGV4MS5xIC0gaGV4Mi5xKSwgTWF0aC5hYnMoaGV4MS5yIC0gaGV4Mi5yKSwgTWF0aC5hYnMoaGV4MS5zIC0gaGV4Mi5zKSk7XG59XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB7XG4gIHdpbmRvd1Jlc2l6ZVVwZGF0ZSgpO1xuICB6b29tVXBkYXRlKCk7XG59KTsgLy9odHRwOi8vanNmaWRkbGUubmV0L2dmY2Fydi9RS2dIcy8gb3IgaHR0cDovL2pzZmlkZGxlLm5ldC9nZmNhcnYvdEF3UVYvXG4vL2h0dHBzOi8vanNmaWRkbGUubmV0LzkzMXdrNzVuLzIvIiwiLy9JbXBvcnRzXG5pbXBvcnQgKiBhcyBESVNQTEFZIGZyb20gJy4uL3NjcmlwdHMvZGlzcGxheS5qcyc7IC8vUHVibGljIHZhcmlhYmxlc1xuLy8tXG4vL1ByaXZhdGUgdmFyaWFibGVzXG4vLy1cbi8vUHVibGljIGZ1bmN0aW9uc1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhdGVDb250cm9scygpIHtcbiAgLy9DYW1lcmEgcG9zaXRpb24gY29udHJvbHNcbiAgbGV0IHRpbWVyID0gbnVsbDtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICgpID0+IHtcbiAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgfSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKCkgPT4ge1xuICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICB9KTsgLy9LZXlib2FyZCBjb250cm9sc1xuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBlID0+IHtcbiAgICBzd2l0Y2ggKGUuY29kZSkge1xuICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgIERJU1BMQVkuY2FtZXJhLnkgLT0gNTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIkFycm93TGVmdFwiOlxuICAgICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgICAgdGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgRElTUExBWS5jYW1lcmEueCAtPSA1O1xuICAgICAgICB9LCAxMCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOlxuICAgICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgICAgdGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgRElTUExBWS5jYW1lcmEueCArPSA1O1xuICAgICAgICB9LCAxMCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICB0aW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICBESVNQTEFZLmNhbWVyYS55ICs9IDU7XG4gICAgICAgIH0sIDEwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbn0gLy9Qcml2YXRlIGZ1bmN0aW9ucyIsImltcG9ydCB7IEFkZHJlc3MsIFByb3ZpZGVyUnBjQ2xpZW50LCBUdm1FeGNlcHRpb24gfSBmcm9tICdldmVyc2NhbGUtaW5wYWdlLXByb3ZpZGVyJztcbmltcG9ydCB7IEV2ZXJzY2FsZVN0YW5kYWxvbmVDbGllbnQsIFNpbXBsZUtleXN0b3JlLCBTaW1wbGVBY2NvdW50c1N0b3JhZ2UsIFdhbGxldFYzQWNjb3VudCB9IGZyb20gJ2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudCc7XG5cbmNvbnN0IHtcbiAgVG9uQ2xpZW50LFxuICBzaWduZXJLZXlzLFxuICBzaWduZXJOb25lXG59ID0gcmVxdWlyZShcIkBldmVyc2RrL2NvcmVcIik7IC8vY29uc3QgeyBsaWJOb2RlIH0gPSByZXF1aXJlKFwiQGV2ZXJzZGsvbGliLW5vZGVcIik7XG5cblxuY29uc3Qge1xuICBsaWJXZWJcbn0gPSByZXF1aXJlKFwiQGV2ZXJzZGsvbGliLXdlYlwiKTtcblxuY29uc3Qge1xuICBBY2NvdW50XG59ID0gcmVxdWlyZShcIkBldmVyc2RrL2FwcGtpdFwiKTtcblxuVG9uQ2xpZW50LnVzZUJpbmFyeUxpYnJhcnkobGliV2ViKTtcblxuY29uc3Qgcm91dGVyQWJpID0gcmVxdWlyZSgnLi4vLi4vY29udHJhY3RzL2J1aWxkL1JvdXRlci5hYmkuanNvbicpO1xuXG5jb25zdCBjZWxsQWJpID0gcmVxdWlyZSgnLi4vLi4vY29udHJhY3RzL2J1aWxkL0NlbGwuYWJpLmpzb24nKTtcblxuY29uc3QgQ29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NvbmZpZy5qc29uXCIpO1xuXG5sZXQgY3VycmVudE1hcDtcbmNvbnN0IGV2ZXIgPSBuZXcgUHJvdmlkZXJScGNDbGllbnQoe30pO1xubGV0IGV2ZXJDbGllbnQ7XG5sZXQgc3Vic2NyaWJlQWNjO1xuXG5jb25zdCBjcmVhdGVDbGllbnQgPSBlbmRwb2ludCA9PiB7XG4gIGxldCBjbGllbnQgPSBuZXcgVG9uQ2xpZW50KHtcbiAgICBuZXR3b3JrOiB7XG4gICAgICBlbmRwb2ludHM6IFtlbmRwb2ludF0sXG4gICAgICBtZXNzYWdlX3JldHJpZXNfY291bnQ6IDMsXG4gICAgICBtZXNzYWdlX3Byb2Nlc3NpbmdfdGltZW91dDogNjAwMDBcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2xpZW50O1xufTtcblxuY29uc3QgZ2V0QWNjb3VudCA9IChhYmksIGFkZHJlc3MgPSAnJywga2V5cyA9IG51bGwpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEFjY291bnQoe1xuICAgICAgYWJpXG4gICAgfSwge1xuICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgIHNpZ25lcjoga2V5cyA/IHNpZ25lcktleXMoa2V5cykgOiBzaWduZXJOb25lKCksXG4gICAgICBjbGllbnQ6IGV2ZXJDbGllbnRcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuY29uc3QgZ2V0QWNjQXJyID0gYXN5bmMgYWRkcmVzZXMgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IChhd2FpdCBldmVyQ2xpZW50Lm5ldC5xdWVyeV9jb2xsZWN0aW9uKHtcbiAgICAgIGNvbGxlY3Rpb246IFwiYWNjb3VudHNcIixcbiAgICAgIGZpbHRlcjoge1xuICAgICAgICBpZDoge1xuICAgICAgICAgIGluOiBhZGRyZXNlc1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzdWx0OiBcImlkIGFjY190eXBlIGJhbGFuY2UgYm9jXCJcbiAgICB9KSkucmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmNvbnN0IHJ1bkxvY2FsID0gYXN5bmMgKGFiaSwgYWRkcmVzcywgZnVuY3Rpb25OYW1lLCBpbnB1dCA9IHt9LCBsb2cgPSB0cnVlLCBib2MgPSBudWxsKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgW2FjY291bnQsIG1lc3NhZ2VdID0gYXdhaXQgUHJvbWlzZS5hbGwoW2JvYyB8fCBldmVyQ2xpZW50Lm5ldC5xdWVyeV9jb2xsZWN0aW9uKHtcbiAgICAgIGNvbGxlY3Rpb246IFwiYWNjb3VudHNcIixcbiAgICAgIGZpbHRlcjoge1xuICAgICAgICBpZDoge1xuICAgICAgICAgIGVxOiBhZGRyZXNzXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXN1bHQ6IFwiYm9jXCJcbiAgICB9KS50aGVuKCh7XG4gICAgICByZXN1bHRcbiAgICB9KSA9PiByZXN1bHRbMF0uYm9jKS5jYXRjaCgoKSA9PiB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pLCBldmVyQ2xpZW50LmFiaS5lbmNvZGVfbWVzc2FnZSh7XG4gICAgICBhYmk6IHtcbiAgICAgICAgdHlwZTogJ0NvbnRyYWN0JyxcbiAgICAgICAgdmFsdWU6IGFiaVxuICAgICAgfSxcbiAgICAgIGFkZHJlc3MsXG4gICAgICBjYWxsX3NldDoge1xuICAgICAgICBmdW5jdGlvbl9uYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgIGlucHV0OiBpbnB1dFxuICAgICAgfSxcbiAgICAgIHNpZ25lcjoge1xuICAgICAgICB0eXBlOiBcIk5vbmVcIlxuICAgICAgfVxuICAgIH0pLnRoZW4oKHtcbiAgICAgIG1lc3NhZ2VcbiAgICB9KSA9PiBtZXNzYWdlKV0pO1xuICAgIGlmICghYWNjb3VudCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBldmVyQ2xpZW50LnR2bS5ydW5fdHZtKHtcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBhY2NvdW50OiBhY2NvdW50LFxuICAgICAgYWJpOiB7XG4gICAgICAgIHR5cGU6ICdDb250cmFjdCcsXG4gICAgICAgIHZhbHVlOiBhYmlcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobG9nKSBjb25zb2xlLmxvZyhcIm91dHB1dDpcIiwgcmVzcG9uc2UuZGVjb2RlZC5vdXRwdXQpO1xuICAgIHJldHVybiByZXNwb25zZS5kZWNvZGVkLm91dHB1dDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYmVoYXZpb3IobmFtZSwgZm4pIHtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtYmVoYXZpb3I9JHtuYW1lfV1gKS5mb3JFYWNoKGZuKTtcbn1cblxuY29uc3QgaW5uZXJUZXh0ID0gdGV4dCA9PiBlbGVtID0+IHtcbiAgZWxlbS5pbm5lclRleHQgPSB0ZXh0O1xufTtcblxuZnVuY3Rpb24gcmVxdWVzdFBlcm1pc3Npb25zKCkge1xuICByZXR1cm4gZXZlci5yZXF1ZXN0UGVybWlzc2lvbnMoe1xuICAgIHBlcm1pc3Npb25zOiBbJ2Jhc2ljJywgJ2FjY291bnRJbnRlcmFjdGlvbiddXG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkaXNjb25uZWN0QWN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnZGlzY29ubmVjdEFjdGlvbicpO1xuICBhd2FpdCBldmVyLmRpc2Nvbm5lY3QoKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0Um91dGVyc0FjdGlvbigpIHtcbiAgY29uc29sZS5sb2coJ2dldFJvdXRlcnNBY3Rpb24nKTtcbiAgY29uc3QgcHJvdmlkZXJTdGF0ZSA9IGF3YWl0IGV2ZXIuZ2V0UHJvdmlkZXJTdGF0ZSgpO1xuICBsZXQgZGV0YWlscyA9IGF3YWl0IGV2ZXIuZ2V0QWNjb3VudHNCeUNvZGVIYXNoKHtcbiAgICBjb2RlSGFzaDogQ29uZmlnW3Byb3ZpZGVyU3RhdGUuc2VsZWN0ZWRDb25uZWN0aW9uXS5jb2RlSGFzaCxcbiAgICBsaW1pdDogMTBcbiAgfSk7XG4gIGNvbnNvbGUubG9nKCdyb3V0ZXJzJywgZGV0YWlscyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gIGF3YWl0IGV2ZXIucmVxdWVzdFBlcm1pc3Npb25zKHtcbiAgICBwZXJtaXNzaW9uczogWydiYXNpYycsICdhY2NvdW50SW50ZXJhY3Rpb24nXVxuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tDb25uZWN0KCkge1xuICBjb25zdCBwcm92aWRlclN0YXRlID0gYXdhaXQgZXZlci5nZXRQcm92aWRlclN0YXRlKCk7XG4gIGNvbnN0IHBlcm1pc3Npb25zID0gcHJvdmlkZXJTdGF0ZS5wZXJtaXNzaW9ucztcbiAgY29uc3QgbmV0d29yayA9IHByb3ZpZGVyU3RhdGUuc2VsZWN0ZWRDb25uZWN0aW9uO1xuXG4gIGlmICghY29udHJhY3RBZGRyZXNzKG5ldHdvcmspIHx8ICFwZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb24pIHtcbiAgICBiZWhhdmlvcignY29ubmVjdCcsIGVsZW0gPT4gZWxlbS5vbmNsaWNrID0gcmVxdWVzdFBlcm1pc3Npb25zKTtcbiAgICBzd2l0Y2hTY3JlZW4oXCJsb2dpblwiKTtcblxuICAgIGNvbnN0IGNvbm5lY3RUZXh0ID0gZWxlbSA9PiB7XG4gICAgICBjb25zdCBkaXNhYmxlZCA9ICFjb250cmFjdEFkZHJlc3MobmV0d29yayk7XG4gICAgICBlbGVtLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgICBlbGVtLmlubmVyVGV4dCA9IGRpc2FibGVkID8gYENvbnRyYWN0IG5vdCBmb3VuZGAgOiBgQ29ubmVjdCB3aXRoICR7bmV0d29ya31gO1xuICAgIH07XG5cbiAgICBiZWhhdmlvcignY29ubmVjdCcsIGNvbm5lY3RUZXh0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJTkZPIGZvciB0cmFuc2FjdGlvbnNGb3VuZCBhbmQgY29udHJhY3RTdGF0ZUNoYW5nZWQgbmVlZCBwZXJtaXNzaW9uc1xuICAgIGNvbnN0IHByb3ZpZGVyU3RhdGUgPSBhd2FpdCBldmVyLmdldFByb3ZpZGVyU3RhdGUoKTtcbiAgICAoYXdhaXQgZXZlci5zdWJzY3JpYmUoJ3RyYW5zYWN0aW9uc0ZvdW5kJywge1xuICAgICAgYWRkcmVzczogY29udHJhY3RBZGRyZXNzKHByb3ZpZGVyU3RhdGUuc2VsZWN0ZWRDb25uZWN0aW9uKVxuICAgIH0pKS5vbignZGF0YScsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCc6Jywge1xuICAgICAgICBhZGRyZXNzOiBldmVudC5hZGRyZXNzLFxuICAgICAgICB0cmFuc2FjdGlvbnM6IGV2ZW50LnRyYW5zYWN0aW9ucyxcbiAgICAgICAgaW5mbzogZXZlbnQuaW5mb1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgKGF3YWl0IGV2ZXIuc3Vic2NyaWJlKCdjb250cmFjdFN0YXRlQ2hhbmdlZCcsIHtcbiAgICAgIGFkZHJlc3M6IGNvbnRyYWN0QWRkcmVzcyhwcm92aWRlclN0YXRlLnNlbGVjdGVkQ29ubmVjdGlvbilcbiAgICB9KSkub24oJ2RhdGEnLCBldmVudCA9PiB7XG4gICAgICBjb25zb2xlLmxvZygncGVybWlzc2lvbnNDaGFuZ2VkOicsIHtcbiAgICAgICAgYWRkcmVzczogZXZlbnQuYWRkcmVzcyxcbiAgICAgICAgc3RhdGU6IGV2ZW50LnN0YXRlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBzd2l0Y2hTY3JlZW4oXCJtYWluXCIpO1xuICAgIGNvbnN0IGFjY291bnQgPSBwZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb247XG4gICAgbGV0IGFkZHJlc3MgPSBhY2NvdW50LmFkZHJlc3MudG9TdHJpbmcoKTtcbiAgICBsZXQgcHVia2V5ID0gYWNjb3VudC5hZGRyZXNzLnRvU3RyaW5nKCk7XG4gICAgYmVoYXZpb3IoJ2FkZHJlc3MnLCBpbm5lclRleHQoYCR7YWRkcmVzcy5zdWJzdHIoMCwgNil9Li4uJHthZGRyZXNzLnN1YnN0cigtNCwgNCl9YCkpO1xuICAgIGJlaGF2aW9yKCdwdWJsaWNLZXknLCBpbm5lclRleHQoYCR7cHVia2V5LnN1YnN0cigwLCA2KX0uLi4ke3B1YmtleS5zdWJzdHIoLTQsIDQpfWApKTtcbiAgICBiZWhhdmlvcignZGlzY29ubmVjdEFjdGlvbicsIGVsZW0gPT4gZWxlbS5vbmNsaWNrID0gZGlzY29ubmVjdEFjdGlvbik7XG4gICAgYmVoYXZpb3IoJ2dldFJvdXRlcnNBY3Rpb24nLCBlbGVtID0+IGVsZW0ub25jbGljayA9IGdldFJvdXRlcnNBY3Rpb24pO1xuICAgIGNvbnNvbGUubG9nKCdlbmRwb2ludDonLCBDb25maWdbbmV0d29ya10uZW5kcG9pbnQpO1xuICAgIGV2ZXJDbGllbnQgPSBjcmVhdGVDbGllbnQoQ29uZmlnW25ldHdvcmtdLmVuZHBvaW50KTtcbiAgICBzdWJzY3JpYmVBY2MgPSBnZXRBY2NvdW50KHt9KTtcbiAgICBsb2FkTWFwKCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gc2V0TmV0d29ya0NoYW5nZWQobmV0d29yaykge1xuICBjb25zdCBtb2QgPSBuZXR3b3JrID09PSAnbWFpbm5ldCcgPyAnc3VjY2VzcycgOiAnc2Vjb25kYXJ5JztcbiAgY29uc3Qgb3V0ID0gYDxzcGFuIGNsYXNzPVwiYmFkZ2UgYmctJHttb2R9XCI+JHtuZXR3b3JrfTwvc3Bhbj5gO1xuICBiZWhhdmlvcignbmV0d29yaycsIGVsZW0gPT4gZWxlbS5pbm5lckhUTUwgPSBvdXQpO1xuICBhd2FpdCBjaGVja0Nvbm5lY3QoKTtcbn1cblxuZnVuY3Rpb24gY29udHJhY3RBZGRyZXNzKG5ldHdvcmssIG5hbWUgPSBcInJvdXRlclwiKSB7XG4gIGlmIChDb25maWdbbmV0d29ya10gJiYgQ29uZmlnW25ldHdvcmtdW25hbWVdKSB7XG4gICAgcmV0dXJuIG5ldyBBZGRyZXNzKENvbmZpZ1tuZXR3b3JrXVtuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gc3dpdGNoU2NyZWVuKHRvKSB7XG4gIGNvbnNvbGUubG9nKCdzd2l0Y2hTY3JlZW46JywgdG8pO1xuICBbXCJleHRlbnNpb25cIiwgXCJsb2dpblwiLCBcIm1haW5cIl0uZm9yRWFjaChzY3JlZW4gPT4ge1xuICAgIGNvbnN0IHN3aXRjaGVyID0gZWxlbSA9PiBlbGVtLnN0eWxlLmRpc3BsYXkgPSB0byA9PT0gc2NyZWVuID8gJ3RhYmxlLXJvdycgOiAnbm9uZSc7XG5cbiAgICBiZWhhdmlvcihzY3JlZW4sIHN3aXRjaGVyKTtcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG1haW5GbG93KCkge1xuICBjb25zdCBwcm92aWRlclN0YXRlID0gYXdhaXQgZXZlci5nZXRQcm92aWRlclN0YXRlKCk7XG4gIGNvbnNvbGUubG9nKCdzZWxlY3RlZENvbm5lY3Rpb246JywgcHJvdmlkZXJTdGF0ZS5zZWxlY3RlZENvbm5lY3Rpb24pO1xuICBhd2FpdCBzZXROZXR3b3JrQ2hhbmdlZChwcm92aWRlclN0YXRlLnNlbGVjdGVkQ29ubmVjdGlvbik7XG4gIChhd2FpdCBldmVyLnN1YnNjcmliZSgnbmV0d29ya0NoYW5nZWQnKSkub24oJ2RhdGEnLCBldmVudCA9PiB7XG4gICAgY29uc29sZS5sb2coJ25ldHdvcmtDaGFuZ2VkOicsIGV2ZW50LnNlbGVjdGVkQ29ubmVjdGlvbik7XG4gICAgc2V0TmV0d29ya0NoYW5nZWQoZXZlbnQuc2VsZWN0ZWRDb25uZWN0aW9uKTtcbiAgfSk7XG4gIChhd2FpdCBldmVyLnN1YnNjcmliZSgncGVybWlzc2lvbnNDaGFuZ2VkJykpLm9uKCdkYXRhJywgYXN5bmMgZXZlbnQgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdwZXJtaXNzaW9uc0NoYW5nZWQ6JywgZXZlbnQucGVybWlzc2lvbnMpO1xuICAgIGF3YWl0IGNoZWNrQ29ubmVjdCgpO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZE1hcCgpIHtcbiAgYXdhaXQgcm91dGVyRGV0YWlscygpO1xuICBsZXQgY29vcmRzID0gW107XG5cbiAgZm9yIChjb25zdCBoZXggb2YgY3VycmVudE1hcCkge1xuICAgIGNvb3Jkcy5wdXNoKHtcbiAgICAgIHg6IGhleC5xLFxuICAgICAgeTogaGV4LnIsXG4gICAgICB6OiBoZXguc1xuICAgIH0pO1xuICB9XG5cbiAgbGV0IGFkZHJlc2VzID0gYXdhaXQgZ2V0QWRkcmVzc0NlbGxzKGNvb3Jkcyk7XG4gIGFkZHJlc2VzID0gYWRkcmVzZXMubWFwKGVsID0+IGVsLnRvU3RyaW5nKCkpO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yIChjb25zdCBoZXggb2YgY3VycmVudE1hcCkge1xuICAgIGhleC5hZGRyZXNzID0gYWRkcmVzZXNbaV07XG4gICAgaSsrO1xuICB9XG5cbiAgYXdhaXQgc3Vic2NyaWJlQWxsQ2VsbFN0YXRlKGFkZHJlc2VzKTtcbiAgbGV0IGFjY3MgPSBhd2FpdCBnZXRBY2NBcnIoYWRkcmVzZXMpO1xuICBjb25zb2xlLmxvZygnYWNjcycsIGFjY3MpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWNjcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBkZXRhaWxzID0gYXdhaXQgZ2V0RGV0YWlsc0NlbGwoYWNjc1tpXS5pZCwgYWNjc1tpXS5ib2MpO1xuXG4gICAgaWYgKGRldGFpbHMpIHtcbiAgICAgIGxldCBoZXggPSBmaW5kSGV4KGFjY3NbaV0uaWQpO1xuICAgICAgY29uc29sZS5sb2coJ2hleCcsIGhleCk7XG5cbiAgICAgIGlmIChoZXgpIHtcbiAgICAgICAgaGV4LmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdChtYXApIHtcbiAgY3VycmVudE1hcCA9IG1hcDtcblxuICBpZiAoYXdhaXQgZXZlci5oYXNQcm92aWRlcigpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGV2ZXIuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGF3YWl0IG1haW5GbG93KCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yOyAvLyBUT0RPIGhhbmRsZSBpdFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2hTY3JlZW4oXCJleHRlbnNpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEhleChhZGRyZXNzKSB7XG4gIGxldCBfaGV4O1xuXG4gIGZvciAoY29uc3QgaGV4IG9mIGN1cnJlbnRNYXApIHtcbiAgICBpZiAoaGV4LmFkZHJlc3MgPT0gYWRkcmVzcykge1xuICAgICAgX2hleCA9IGhleDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfaGV4O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcm91dGVyRGV0YWlscygpIHtcbiAgY29uc3QgcHJvdmlkZXJTdGF0ZSA9IGF3YWl0IGV2ZXIuZ2V0UHJvdmlkZXJTdGF0ZSgpO1xuICBjb25zdCByb3V0ZXIgPSBuZXcgZXZlci5Db250cmFjdChyb3V0ZXJBYmksIGNvbnRyYWN0QWRkcmVzcyhwcm92aWRlclN0YXRlLnNlbGVjdGVkQ29ubmVjdGlvbiwgJ3JvdXRlcicpKTtcblxuICB0cnkge1xuICAgIGxldCBkZXRhaWxzO1xuICAgIGRldGFpbHMgPSBhd2FpdCByb3V0ZXIubWV0aG9kcy5nZXREZXRhaWxzKHt9KS5jYWxsKCk7XG4gICAgY29uc29sZS5sb2coJ2dldERldGFpbHMgcm91dGVyJywgZGV0YWlscyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBUdm1FeGNlcHRpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZS5jb2RlKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdWJzY3JpYmVBbGxDZWxsU3RhdGUoYXJyQWNjKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgc3Vic2NyaWJlQWNjLmZyZWUoKTtcbiAgICBhd2FpdCBzdWJzY3JpYmVBY2Muc3Vic2NyaWJlKFwiYWNjb3VudHNcIiwge1xuICAgICAgaWQ6IHtcbiAgICAgICAgaW46IGFyckFjY1xuICAgICAgfVxuICAgIH0sIFwiaWQgYm9jXCIsIGFzeW5jIG1zZyA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhgb25BY2M6YCwgbXNnLmlkKTtcbiAgICAgIGxldCBoZXggPSBmaW5kSGV4KG1zZy5pZCk7XG4gICAgICBjb25zb2xlLmxvZygnaGV4JywgaGV4KTtcblxuICAgICAgaWYgKGhleCkge1xuICAgICAgICBoZXguZGV0YWlscyA9IGF3YWl0IGdldERldGFpbHNDZWxsKG1zZy5pZCwgbXNnLmJvYyk7XG4gICAgICB9XG4gICAgfSwgYXN5bmMgbXNnID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGBvbkVycm9yOmAsIG1zZyk7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBUdm1FeGNlcHRpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZS5jb2RlKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBZGRyZXNzQ2VsbHMoY29vcmRzKSB7XG4gIGNvbnN0IHByb3ZpZGVyU3RhdGUgPSBhd2FpdCBldmVyLmdldFByb3ZpZGVyU3RhdGUoKTtcbiAgY29uc3Qgcm91dGVyID0gbmV3IGV2ZXIuQ29udHJhY3Qocm91dGVyQWJpLCBjb250cmFjdEFkZHJlc3MocHJvdmlkZXJTdGF0ZS5zZWxlY3RlZENvbm5lY3Rpb24sICdyb3V0ZXInKSk7XG5cbiAgdHJ5IHtcbiAgICBsZXQgZGV0YWlscztcbiAgICBkZXRhaWxzID0gYXdhaXQgcm91dGVyLm1ldGhvZHMuZ2V0QWRkcmVzc0NlbGxzKHtcbiAgICAgIGNvb3Jkc1xuICAgIH0pLmNhbGwoKTtcbiAgICBjb25zb2xlLmxvZygnZ2V0QWRkcmVzc0NlbGxzIHJvdXRlcicsIGRldGFpbHMpO1xuICAgIHJldHVybiBkZXRhaWxzLmFkZHJlc2VzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcblxuICAgIGlmIChlIGluc3RhbmNlb2YgVHZtRXhjZXB0aW9uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUuY29kZSk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbmV3R2FtZShjZWxsQ29vcmQpIHtcbiAgY29uc3QgcHJvdmlkZXJTdGF0ZSA9IGF3YWl0IGV2ZXIuZ2V0UHJvdmlkZXJTdGF0ZSgpO1xuICBjb25zdCBwZXJtaXNzaW9ucyA9IHByb3ZpZGVyU3RhdGUucGVybWlzc2lvbnM7XG4gIGlmICghcGVybWlzc2lvbnMuYWNjb3VudEludGVyYWN0aW9uKSByZXR1cm47XG4gIGNvbnN0IGFjY291bnQgPSBwZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb247XG4gIGNvbnN0IHJvdXRlciA9IG5ldyBldmVyLkNvbnRyYWN0KHJvdXRlckFiaSwgY29udHJhY3RBZGRyZXNzKHByb3ZpZGVyU3RhdGUuc2VsZWN0ZWRDb25uZWN0aW9uLCAncm91dGVyJykpO1xuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ25ld0dhbWUnLCAxKTtcbiAgICBsZXQgcmVzID0gYXdhaXQgcm91dGVyLm1ldGhvZHMubmV3R2FtZSh7XG4gICAgICBzZW5kR2FzVG86IGFjY291bnQuYWRkcmVzcy50b1N0cmluZygpLFxuICAgICAgYmFzZUNvb3JkOiBjZWxsQ29vcmRcbiAgICB9KS5zZW5kKHtcbiAgICAgIGZyb206IGFjY291bnQuYWRkcmVzcy50b1N0cmluZygpLFxuICAgICAgYW1vdW50OiAnMjAwMDAwMDAwMCdcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZygnbmV3R2FtZScsIHJlcyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBUdm1FeGNlcHRpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZS5jb2RlKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtYXJrQ2VsbChhZGRyZXNzLCBjZWxsQ29vcmQsIGVuZXJneSkge1xuICBjb25zdCBwcm92aWRlclN0YXRlID0gYXdhaXQgZXZlci5nZXRQcm92aWRlclN0YXRlKCk7XG4gIGNvbnN0IHBlcm1pc3Npb25zID0gcHJvdmlkZXJTdGF0ZS5wZXJtaXNzaW9ucztcbiAgaWYgKCFwZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb24pIHJldHVybjtcbiAgY29uc3QgYWNjb3VudCA9IHBlcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbjtcbiAgY29uc3QgY2VsbCA9IG5ldyBldmVyLkNvbnRyYWN0KGNlbGxBYmksIGFkZHJlc3MpO1xuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ21hcmtDZWxsJywgMSk7XG4gICAgbGV0IHJlcyA9IGF3YWl0IGNlbGwubWV0aG9kcy5tYXJrQ2VsbCh7XG4gICAgICBzZW5kR2FzVG86IGFjY291bnQuYWRkcmVzcy50b1N0cmluZygpLFxuICAgICAgdGFyZ2V0Q29vcmQ6IGNlbGxDb29yZCxcbiAgICAgIGVuZXJneTogZW5lcmd5XG4gICAgfSkuc2VuZCh7XG4gICAgICBmcm9tOiBhY2NvdW50LmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgIGFtb3VudDogJzIwMDAwMDAwMDAnXG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coJ21hcmtDZWxsJywgcmVzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoZSk7XG5cbiAgICBpZiAoZSBpbnN0YW5jZW9mIFR2bUV4Y2VwdGlvbikge1xuICAgICAgY29uc29sZS5lcnJvcihlLmNvZGUpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZ3JhZGVDZWxsKGFkZHJlc3MpIHtcbiAgY29uc3QgcHJvdmlkZXJTdGF0ZSA9IGF3YWl0IGV2ZXIuZ2V0UHJvdmlkZXJTdGF0ZSgpO1xuICBjb25zdCBwZXJtaXNzaW9ucyA9IHByb3ZpZGVyU3RhdGUucGVybWlzc2lvbnM7XG4gIGlmICghcGVybWlzc2lvbnMuYWNjb3VudEludGVyYWN0aW9uKSByZXR1cm47XG4gIGNvbnN0IGFjY291bnQgPSBwZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb247XG4gIGNvbnN0IGNlbGwgPSBuZXcgZXZlci5Db250cmFjdChjZWxsQWJpLCBhZGRyZXNzKTtcblxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCd1cGdyYWRlQ2VsbCcsIDEpO1xuICAgIGxldCByZXMgPSBhd2FpdCBjZWxsLm1ldGhvZHMudXBncmFkZUNlbGwoe1xuICAgICAgc2VuZEdhc1RvOiBhY2NvdW50LmFkZHJlc3MudG9TdHJpbmcoKVxuICAgIH0pLnNlbmQoe1xuICAgICAgZnJvbTogYWNjb3VudC5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICBhbW91bnQ6ICcxMDAwMDAwMDAwJ1xuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKCd1cGdyYWRlQ2VsbCcsIHJlcyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBUdm1FeGNlcHRpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZS5jb2RlKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoZWxwQ2VsbChhZGRyZXNzLCBjZWxsQ29vcmQsIGVuZXJneSkge1xuICBjb25zdCBwcm92aWRlclN0YXRlID0gYXdhaXQgZXZlci5nZXRQcm92aWRlclN0YXRlKCk7XG4gIGNvbnN0IHBlcm1pc3Npb25zID0gcHJvdmlkZXJTdGF0ZS5wZXJtaXNzaW9ucztcbiAgaWYgKCFwZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb24pIHJldHVybjtcbiAgY29uc3QgYWNjb3VudCA9IHBlcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbjtcbiAgY29uc3QgY2VsbCA9IG5ldyBldmVyLkNvbnRyYWN0KGNlbGxBYmksIGFkZHJlc3MpO1xuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ2hlbHBDZWxsJywgMSk7XG4gICAgbGV0IHJlcyA9IGF3YWl0IGNlbGwubWV0aG9kcy5oZWxwQ2VsbCh7XG4gICAgICBzZW5kR2FzVG86IGFjY291bnQuYWRkcmVzcy50b1N0cmluZygpLFxuICAgICAgdGFyZ2V0Q29vcmQ6IGNlbGxDb29yZCxcbiAgICAgIGVuZXJneTogZW5lcmd5XG4gICAgfSkuc2VuZCh7XG4gICAgICBmcm9tOiBhY2NvdW50LmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgIGFtb3VudDogJzEwMDAwMDAwMDAnXG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coJ2hlbHBDZWxsJywgcmVzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoZSk7XG5cbiAgICBpZiAoZSBpbnN0YW5jZW9mIFR2bUV4Y2VwdGlvbikge1xuICAgICAgY29uc29sZS5lcnJvcihlLmNvZGUpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF0dGtDZWxsKGFkZHJlc3MsIGNlbGxDb29yZCwgZW5lcmd5KSB7XG4gIGNvbnN0IHByb3ZpZGVyU3RhdGUgPSBhd2FpdCBldmVyLmdldFByb3ZpZGVyU3RhdGUoKTtcbiAgY29uc3QgcGVybWlzc2lvbnMgPSBwcm92aWRlclN0YXRlLnBlcm1pc3Npb25zO1xuICBpZiAoIXBlcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbikgcmV0dXJuO1xuICBjb25zdCBhY2NvdW50ID0gcGVybWlzc2lvbnMuYWNjb3VudEludGVyYWN0aW9uO1xuICBjb25zdCBjZWxsID0gbmV3IGV2ZXIuQ29udHJhY3QoY2VsbEFiaSwgYWRkcmVzcyk7XG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnYXR0a0NlbGwnLCAxKTtcbiAgICBsZXQgcmVzID0gYXdhaXQgY2VsbC5tZXRob2RzLmF0dGtDZWxsKHtcbiAgICAgIHNlbmRHYXNUbzogYWNjb3VudC5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICB0YXJnZXRDb29yZDogY2VsbENvb3JkLFxuICAgICAgZW5lcmd5OiBlbmVyZ3lcbiAgICB9KS5zZW5kKHtcbiAgICAgIGZyb206IGFjY291bnQuYWRkcmVzcy50b1N0cmluZygpLFxuICAgICAgYW1vdW50OiAnMTAwMDAwMDAwMCdcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZygnYXR0a0NlbGwnLCByZXMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcblxuICAgIGlmIChlIGluc3RhbmNlb2YgVHZtRXhjZXB0aW9uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUuY29kZSk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGV0YWlsc0NlbGwoYWRkcmVzcywgYm9jID0gbnVsbCkge1xuICBpZiAoYm9jKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJ1bkxvY2FsKGNlbGxBYmksIGFkZHJlc3MsIFwiZ2V0RGV0YWlsc1wiLCB7fSwgdHJ1ZSwgYm9jKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNlbGwgPSBuZXcgZXZlci5Db250cmFjdChjZWxsQWJpLCBhZGRyZXNzKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHN0YXRlUmVzID0gYXdhaXQgY2VsbC5nZXRGdWxsU3RhdGUoKTtcblxuICAgIGlmIChzdGF0ZVJlcy5zdGF0ZSA9PSBudWxsIHx8ICFzdGF0ZVJlcy5zdGF0ZS5pc0RlcGxveWVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vY29uc29sZS5sb2coJ3N0YXRlJywgc3RhdGVSZXMuc3RhdGUpO1xuXG5cbiAgICBsZXQgZGV0YWlscztcbiAgICBkZXRhaWxzID0gYXdhaXQgY2VsbC5tZXRob2RzLmdldERldGFpbHMoe30pLmNhbGwoKTtcbiAgICBjb25zb2xlLmxvZygnZ2V0RGV0YWlscyBjZWxsJywgZGV0YWlscyk7XG4gICAgcmV0dXJuIGRldGFpbHM7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBUdm1FeGNlcHRpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZS5jb2RlKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdWJzY3JpYmVQZXJtaXNzaW9uc0NoYW5nZWQoKSB7XG4gIGF3YWl0IGV2ZXIuc3Vic2NyaWJlKCdwZXJtaXNzaW9uc0NoYW5nZWQnKS5vbignZGF0YScsIHBlcm1pc3Npb25zID0+IHtcbiAgICBjb25zb2xlLmxvZyhwZXJtaXNzaW9ucyk7XG4gIH0pO1xufSIsIlwidXNlIHN0cmljdFwiOyAvL0ltcG9ydCBDU1NcblxuaW1wb3J0ICcuL3N0eWxlcy9tYWluLnNjc3MnOyAvL0ltcG9ydCBKU1xuXG5pbXBvcnQgKiBhcyBESVNQTEFZIGZyb20gJy4vc2NyaXB0cy9kaXNwbGF5LmpzJztcbmltcG9ydCAqIGFzIENPTlRST0xTIGZyb20gJy4vc2NyaXB0cy9jb250cm9scy5qcyc7XG5pbXBvcnQgKiBhcyBQUk9WSURFUiBmcm9tICcuL3NjcmlwdHMvZXZlci5qcyc7IC8vaHR0cHM6Ly9naXRodWIuY29tL2ZsYXV3ZWtldWwvaG9uZXljb21iXG4vL2NvbnNvbGUuY2xlYXIoKTtcblxuRElTUExBWS5pbml0aWF0ZU1hcChQUk9WSURFUik7XG5DT05UUk9MUy5pbml0aWF0ZUNvbnRyb2xzKCk7XG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KCk7XG59Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF1Q0E7OztBQ25rQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///437\n")},431:function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;;(function (globalObject) {\r\n  'use strict';\r\n\r\n/*\r\n *      bignumber.js v9.1.0\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\n  var BigNumber,\r\n    isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n    mathceil = Math.ceil,\r\n    mathfloor = Math.floor,\r\n\r\n    bignumberError = '[BigNumber Error] ',\r\n    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n    BASE = 1e14,\r\n    LOG_BASE = 14,\r\n    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n    SQRT_BASE = 1e7,\r\n\r\n    // EDITABLE\r\n    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n    // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n    MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n  /*\r\n   * Create and return a BigNumber constructor.\r\n   */\r\n  function clone(configObject) {\r\n    var div, convertBase, parseNumeric,\r\n      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n      ONE = new BigNumber(1),\r\n\r\n\r\n      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n      // The default values below must be integers within the inclusive ranges stated.\r\n      // The values can also be changed at run-time using BigNumber.set.\r\n\r\n      // The maximum number of decimal places for operations involving division.\r\n      DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n      // The rounding mode used when rounding to the above decimal places, and when using\r\n      // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n      // UP         0 Away from zero.\r\n      // DOWN       1 Towards zero.\r\n      // CEIL       2 Towards +Infinity.\r\n      // FLOOR      3 Towards -Infinity.\r\n      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n      // The exponent value at and beneath which toString returns exponential notation.\r\n      // Number type: -7\r\n      TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n      // The exponent value at and above which toString returns exponential notation.\r\n      // Number type: 21\r\n      TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n      // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // Number type: -324  (5e-324)\r\n      MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // Number type:  308  (1.7976931348623157e+308)\r\n      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n      MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      CRYPTO = false,                          // true or false\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN      1 The remainder has the same sign as the dividend.\r\n      //             This modulo mode is commonly known as 'truncated division' and is\r\n      //             equivalent to (a % n) in JavaScript.\r\n      // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n      //             The remainder is always positive.\r\n      //\r\n      // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n      // modes are commonly used for the modulus operation.\r\n      // Although the other rounding modes can also be used, they may not give useful results.\r\n      MODULO_MODE = 1,                         // 0 to 9\r\n\r\n      // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n      // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n      POW_PRECISION = 0,                       // 0 to MAX\r\n\r\n      // The format specification used by the BigNumber.prototype.toFormat method.\r\n      FORMAT = {\r\n        prefix: '',\r\n        groupSize: 3,\r\n        secondaryGroupSize: 0,\r\n        groupSeparator: ',',\r\n        decimalSeparator: '.',\r\n        fractionGroupSize: 0,\r\n        fractionGroupSeparator: '\\xA0',        // non-breaking space\r\n        suffix: ''\r\n      },\r\n\r\n      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n      // '-', '.', whitespace, or repeated character.\r\n      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',\r\n      alphabetHasNormalDecimalDigits = true;\r\n\r\n\r\n    //------------------------------------------------------------------------------------------\r\n\r\n\r\n    // CONSTRUCTOR\r\n\r\n\r\n    /*\r\n     * The BigNumber constructor and exported function.\r\n     * Create and return a new instance of a BigNumber object.\r\n     *\r\n     * v {number|string|BigNumber} A numeric value.\r\n     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n     */\r\n    function BigNumber(v, b) {\r\n      var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n        x = this;\r\n\r\n      // Enable constructor call without `new`.\r\n      if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n      if (b == null) {\r\n\r\n        if (v && v._isBigNumber === true) {\r\n          x.s = v.s;\r\n\r\n          if (!v.c || v.e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else if (v.e < MIN_EXP) {\r\n            x.c = [x.e = 0];\r\n          } else {\r\n            x.e = v.e;\r\n            x.c = v.c.slice();\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n          // Use `1 / n` to handle minus zero also.\r\n          x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n          // Fast path for integers, where n < 2147483648 (2**31).\r\n          if (v === ~~v) {\r\n            for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n            if (e > MAX_EXP) {\r\n              x.c = x.e = null;\r\n            } else {\r\n              x.e = e;\r\n              x.c = [v];\r\n            }\r\n\r\n            return;\r\n          }\r\n\r\n          str = String(v);\r\n        } else {\r\n\r\n          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n        // Exponential form?\r\n        if ((i = str.search(/e/i)) > 0) {\r\n\r\n          // Determine exponent.\r\n          if (e < 0) e = i;\r\n          e += +str.slice(i + 1);\r\n          str = str.substring(0, i);\r\n        } else if (e < 0) {\r\n\r\n          // Integer.\r\n          e = str.length;\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n        // Allow exponential notation to be used with base 10 argument, while\r\n        // also rounding to DECIMAL_PLACES as with other bases.\r\n        if (b == 10 && alphabetHasNormalDecimalDigits) {\r\n          x = new BigNumber(v);\r\n          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n        }\r\n\r\n        str = String(v);\r\n\r\n        if (isNum = typeof v == 'number') {\r\n\r\n          // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n          if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n            throw Error\r\n             (tooManyDigits + v);\r\n          }\r\n        } else {\r\n          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        alphabet = ALPHABET.slice(0, b);\r\n        e = i = 0;\r\n\r\n        // Check that str is a valid base b number.\r\n        // Don't use RegExp, so alphabet can contain special characters.\r\n        for (len = str.length; i < len; i++) {\r\n          if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n            if (c == '.') {\r\n\r\n              // If '.' is not the first character and it has not be found before.\r\n              if (i > e) {\r\n                e = len;\r\n                continue;\r\n              }\r\n            } else if (!caseChanged) {\r\n\r\n              // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                  str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n                caseChanged = true;\r\n                i = -1;\r\n                e = 0;\r\n                continue;\r\n              }\r\n            }\r\n\r\n            return parseNumeric(x, String(v), isNum, b);\r\n          }\r\n        }\r\n\r\n        // Prevent later check for length on converted number.\r\n        isNum = false;\r\n        str = convertBase(str, b, 10, x.s);\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n        else e = str.length;\r\n      }\r\n\r\n      // Determine leading zeros.\r\n      for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n      // Determine trailing zeros.\r\n      for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n      if (str = str.slice(i, ++len)) {\r\n        len -= i;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (isNum && BigNumber.DEBUG &&\r\n          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n            throw Error\r\n             (tooManyDigits + (x.s * v));\r\n        }\r\n\r\n         // Overflow?\r\n        if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n          // Infinity.\r\n          x.c = x.e = null;\r\n\r\n        // Underflow?\r\n        } else if (e < MIN_EXP) {\r\n\r\n          // Zero.\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = e;\r\n          x.c = [];\r\n\r\n          // Transform base\r\n\r\n          // e is the base 10 exponent.\r\n          // i is where to slice str to get the first element of the coefficient array.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n          if (i < len) {\r\n            if (i) x.c.push(+str.slice(0, i));\r\n\r\n            for (len -= LOG_BASE; i < len;) {\r\n              x.c.push(+str.slice(i, i += LOG_BASE));\r\n            }\r\n\r\n            i = LOG_BASE - (str = str.slice(i)).length;\r\n          } else {\r\n            i -= len;\r\n          }\r\n\r\n          for (; i--; str += '0');\r\n          x.c.push(+str);\r\n        }\r\n      } else {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n\r\n    // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n    BigNumber.clone = clone;\r\n\r\n    BigNumber.ROUND_UP = 0;\r\n    BigNumber.ROUND_DOWN = 1;\r\n    BigNumber.ROUND_CEIL = 2;\r\n    BigNumber.ROUND_FLOOR = 3;\r\n    BigNumber.ROUND_HALF_UP = 4;\r\n    BigNumber.ROUND_HALF_DOWN = 5;\r\n    BigNumber.ROUND_HALF_EVEN = 6;\r\n    BigNumber.ROUND_HALF_CEIL = 7;\r\n    BigNumber.ROUND_HALF_FLOOR = 8;\r\n    BigNumber.EUCLID = 9;\r\n\r\n\r\n    /*\r\n     * Configure infrequently-changing library-wide settings.\r\n     *\r\n     * Accept an object with the following optional properties (if the value of a property is\r\n     * a number, it must be an integer within the inclusive range stated):\r\n     *\r\n     *   DECIMAL_PLACES   {number}           0 to MAX\r\n     *   ROUNDING_MODE    {number}           0 to 8\r\n     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n     *   CRYPTO           {boolean}          true or false\r\n     *   MODULO_MODE      {number}           0 to 9\r\n     *   POW_PRECISION       {number}           0 to MAX\r\n     *   ALPHABET         {string}           A string of two or more unique characters which does\r\n     *                                       not contain '.'.\r\n     *   FORMAT           {object}           An object with some of the following properties:\r\n     *     prefix                 {string}\r\n     *     groupSize              {number}\r\n     *     secondaryGroupSize     {number}\r\n     *     groupSeparator         {string}\r\n     *     decimalSeparator       {string}\r\n     *     fractionGroupSize      {number}\r\n     *     fractionGroupSeparator {string}\r\n     *     suffix                 {string}\r\n     *\r\n     * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n     *\r\n     * E.g.\r\n     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n     *\r\n     * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n     *\r\n     * Return an object with the properties current values.\r\n     */\r\n    BigNumber.config = BigNumber.set = function (obj) {\r\n      var p, v;\r\n\r\n      if (obj != null) {\r\n\r\n        if (typeof obj == 'object') {\r\n\r\n          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            DECIMAL_PLACES = v;\r\n          }\r\n\r\n          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 8, p);\r\n            ROUNDING_MODE = v;\r\n          }\r\n\r\n          // EXPONENTIAL_AT {number|number[]}\r\n          // Integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, 0, p);\r\n              intCheck(v[1], 0, MAX, p);\r\n              TO_EXP_NEG = v[0];\r\n              TO_EXP_POS = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n            }\r\n          }\r\n\r\n          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n          if (obj.hasOwnProperty(p = 'RANGE')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, -1, p);\r\n              intCheck(v[1], 1, MAX, p);\r\n              MIN_EXP = v[0];\r\n              MAX_EXP = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              if (v) {\r\n                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n              } else {\r\n                throw Error\r\n                 (bignumberError + p + ' cannot be zero: ' + v);\r\n              }\r\n            }\r\n          }\r\n\r\n          // CRYPTO {boolean} true or false.\r\n          // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n          // '[BigNumber Error] crypto unavailable'\r\n          if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n            v = obj[p];\r\n            if (v === !!v) {\r\n              if (v) {\r\n                if (typeof crypto != 'undefined' && crypto &&\r\n                 (crypto.getRandomValues || crypto.randomBytes)) {\r\n                  CRYPTO = v;\r\n                } else {\r\n                  CRYPTO = !v;\r\n                  throw Error\r\n                   (bignumberError + 'crypto unavailable');\r\n                }\r\n              } else {\r\n                CRYPTO = v;\r\n              }\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' not true or false: ' + v);\r\n            }\r\n          }\r\n\r\n          // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 9, p);\r\n            MODULO_MODE = v;\r\n          }\r\n\r\n          // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            POW_PRECISION = v;\r\n          }\r\n\r\n          // FORMAT {object}\r\n          // '[BigNumber Error] FORMAT not an object: {v}'\r\n          if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n            v = obj[p];\r\n            if (typeof v == 'object') FORMAT = v;\r\n            else throw Error\r\n             (bignumberError + p + ' not an object: ' + v);\r\n          }\r\n\r\n          // ALPHABET {string}\r\n          // '[BigNumber Error] ALPHABET invalid: {v}'\r\n          if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n            v = obj[p];\r\n\r\n            // Disallow if less than two characters,\r\n            // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n            if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';\r\n              ALPHABET = v;\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' invalid: ' + v);\r\n            }\r\n          }\r\n\r\n        } else {\r\n\r\n          // '[BigNumber Error] Object expected: {v}'\r\n          throw Error\r\n           (bignumberError + 'Object expected: ' + obj);\r\n        }\r\n      }\r\n\r\n      return {\r\n        DECIMAL_PLACES: DECIMAL_PLACES,\r\n        ROUNDING_MODE: ROUNDING_MODE,\r\n        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n        RANGE: [MIN_EXP, MAX_EXP],\r\n        CRYPTO: CRYPTO,\r\n        MODULO_MODE: MODULO_MODE,\r\n        POW_PRECISION: POW_PRECISION,\r\n        FORMAT: FORMAT,\r\n        ALPHABET: ALPHABET\r\n      };\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if v is a BigNumber instance, otherwise return false.\r\n     *\r\n     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n     *\r\n     * v {any}\r\n     *\r\n     * '[BigNumber Error] Invalid BigNumber: {v}'\r\n     */\r\n    BigNumber.isBigNumber = function (v) {\r\n      if (!v || v._isBigNumber !== true) return false;\r\n      if (!BigNumber.DEBUG) return true;\r\n\r\n      var i, n,\r\n        c = v.c,\r\n        e = v.e,\r\n        s = v.s;\r\n\r\n      out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n          // If the first element is zero, the BigNumber value must be zero.\r\n          if (c[0] === 0) {\r\n            if (e === 0 && c.length === 1) return true;\r\n            break out;\r\n          }\r\n\r\n          // Calculate number of digits that c[0] should have, based on the exponent.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (i < 1) i += LOG_BASE;\r\n\r\n          // Calculate number of digits of c[0].\r\n          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n          if (String(c[0]).length == i) {\r\n\r\n            for (i = 0; i < c.length; i++) {\r\n              n = c[i];\r\n              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n            }\r\n\r\n            // Last element cannot be zero, unless it is the only element.\r\n            if (n !== 0) return true;\r\n          }\r\n        }\r\n\r\n      // Infinity/NaN\r\n      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n        return true;\r\n      }\r\n\r\n      throw Error\r\n        (bignumberError + 'Invalid BigNumber: ' + v);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the maximum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.maximum = BigNumber.max = function () {\r\n      return maxOrMin(arguments, P.lt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the minimum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.minimum = BigNumber.min = function () {\r\n      return maxOrMin(arguments, P.gt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n     * zeros are produced).\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n     * '[BigNumber Error] crypto unavailable'\r\n     */\r\n    BigNumber.random = (function () {\r\n      var pow2_53 = 0x20000000000000;\r\n\r\n      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n      // Check if Math.random() produces more than 32 bits of randomness.\r\n      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n       ? function () { return mathfloor(Math.random() * pow2_53); }\r\n       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n         (Math.random() * 0x800000 | 0); };\r\n\r\n      return function (dp) {\r\n        var a, b, e, k, v,\r\n          i = 0,\r\n          c = [],\r\n          rand = new BigNumber(ONE);\r\n\r\n        if (dp == null) dp = DECIMAL_PLACES;\r\n        else intCheck(dp, 0, MAX);\r\n\r\n        k = mathceil(dp / LOG_BASE);\r\n\r\n        if (CRYPTO) {\r\n\r\n          // Browsers supporting crypto.getRandomValues.\r\n          if (crypto.getRandomValues) {\r\n\r\n            a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n            for (; i < k;) {\r\n\r\n              // 53 bits:\r\n              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n              // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n              //                                     11111 11111111 11111111\r\n              // 0x20000 is 2^21.\r\n              v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n              // Rejection sampling:\r\n              // 0 <= v < 9007199254740992\r\n              // Probability that v >= 9e15, is\r\n              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n              if (v >= 9e15) {\r\n                b = crypto.getRandomValues(new Uint32Array(2));\r\n                a[i] = b[0];\r\n                a[i + 1] = b[1];\r\n              } else {\r\n\r\n                // 0 <= v <= 8999999999999999\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 2;\r\n              }\r\n            }\r\n            i = k / 2;\r\n\r\n          // Node.js supporting crypto.randomBytes.\r\n          } else if (crypto.randomBytes) {\r\n\r\n            // buffer\r\n            a = crypto.randomBytes(k *= 7);\r\n\r\n            for (; i < k;) {\r\n\r\n              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n              // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n              // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n              // 0 <= v < 9007199254740992\r\n              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n              if (v >= 9e15) {\r\n                crypto.randomBytes(7).copy(a, i);\r\n              } else {\r\n\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 7;\r\n              }\r\n            }\r\n            i = k / 7;\r\n          } else {\r\n            CRYPTO = false;\r\n            throw Error\r\n             (bignumberError + 'crypto unavailable');\r\n          }\r\n        }\r\n\r\n        // Use Math.random.\r\n        if (!CRYPTO) {\r\n\r\n          for (; i < k;) {\r\n            v = random53bitInt();\r\n            if (v < 9e15) c[i++] = v % 1e14;\r\n          }\r\n        }\r\n\r\n        k = c[--i];\r\n        dp %= LOG_BASE;\r\n\r\n        // Convert trailing digits to zeros according to dp.\r\n        if (k && dp) {\r\n          v = POWS_TEN[LOG_BASE - dp];\r\n          c[i] = mathfloor(k / v) * v;\r\n        }\r\n\r\n        // Remove trailing elements which are zero.\r\n        for (; c[i] === 0; c.pop(), i--);\r\n\r\n        // Zero?\r\n        if (i < 0) {\r\n          c = [e = 0];\r\n        } else {\r\n\r\n          // Remove leading elements which are zero and adjust exponent accordingly.\r\n          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n          // Count the digits of the first element of c to determine leading zeros, and...\r\n          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n          // adjust the exponent accordingly.\r\n          if (i < LOG_BASE) e -= LOG_BASE - i;\r\n        }\r\n\r\n        rand.e = e;\r\n        rand.c = c;\r\n        return rand;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the sum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.sum = function () {\r\n      var i = 1,\r\n        args = arguments,\r\n        sum = new BigNumber(args[0]);\r\n      for (; i < args.length;) sum = sum.plus(args[i++]);\r\n      return sum;\r\n    };\r\n\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n\r\n    // Called by BigNumber and BigNumber.prototype.toString.\r\n    convertBase = (function () {\r\n      var decimal = '0123456789';\r\n\r\n      /*\r\n       * Convert string of baseIn to an array of numbers of baseOut.\r\n       * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n       */\r\n      function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n        var j,\r\n          arr = [0],\r\n          arrL,\r\n          i = 0,\r\n          len = str.length;\r\n\r\n        for (; i < len;) {\r\n          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n          arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n          for (j = 0; j < arr.length; j++) {\r\n\r\n            if (arr[j] > baseOut - 1) {\r\n              if (arr[j + 1] == null) arr[j + 1] = 0;\r\n              arr[j + 1] += arr[j] / baseOut | 0;\r\n              arr[j] %= baseOut;\r\n            }\r\n          }\r\n        }\r\n\r\n        return arr.reverse();\r\n      }\r\n\r\n      // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n      // If the caller is toString, we are converting from base 10 to baseOut.\r\n      // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n      return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n        var alphabet, d, e, k, r, x, xc, y,\r\n          i = str.indexOf('.'),\r\n          dp = DECIMAL_PLACES,\r\n          rm = ROUNDING_MODE;\r\n\r\n        // Non-integer.\r\n        if (i >= 0) {\r\n          k = POW_PRECISION;\r\n\r\n          // Unlimited precision.\r\n          POW_PRECISION = 0;\r\n          str = str.replace('.', '');\r\n          y = new BigNumber(baseIn);\r\n          x = y.pow(str.length - i);\r\n          POW_PRECISION = k;\r\n\r\n          // Convert str as if an integer, then restore the fraction part by dividing the\r\n          // result by its base raised to a power.\r\n\r\n          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n           10, baseOut, decimal);\r\n          y.e = y.c.length;\r\n        }\r\n\r\n        // Convert the number as integer.\r\n\r\n        xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n         ? (alphabet = ALPHABET, decimal)\r\n         : (alphabet = decimal, ALPHABET));\r\n\r\n        // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n        e = k = xc.length;\r\n\r\n        // Remove trailing zeros.\r\n        for (; xc[--k] == 0; xc.pop());\r\n\r\n        // Zero?\r\n        if (!xc[0]) return alphabet.charAt(0);\r\n\r\n        // Does str represent an integer? If so, no need for the division.\r\n        if (i < 0) {\r\n          --e;\r\n        } else {\r\n          x.c = xc;\r\n          x.e = e;\r\n\r\n          // The sign is needed for correct rounding.\r\n          x.s = sign;\r\n          x = div(x, y, dp, rm, baseOut);\r\n          xc = x.c;\r\n          r = x.r;\r\n          e = x.e;\r\n        }\r\n\r\n        // xc now represents str converted to baseOut.\r\n\r\n        // THe index of the rounding digit.\r\n        d = e + dp + 1;\r\n\r\n        // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n        i = xc[d];\r\n\r\n        // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n        k = baseOut / 2;\r\n        r = r || d < 0 || xc[d + 1] != null;\r\n\r\n        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n               rm == (x.s < 0 ? 8 : 7));\r\n\r\n        // If the index of the rounding digit is not greater than zero, or xc represents\r\n        // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n        // such as 0.00001.\r\n        if (d < 1 || !xc[0]) {\r\n\r\n          // 1^-dp or 0\r\n          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n        } else {\r\n\r\n          // Truncate xc to the required number of decimal places.\r\n          xc.length = d;\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            // Rounding up may mean the previous digit has to be rounded up and so on.\r\n            for (--baseOut; ++xc[--d] > baseOut;) {\r\n              xc[d] = 0;\r\n\r\n              if (!d) {\r\n                ++e;\r\n                xc = [1].concat(xc);\r\n              }\r\n            }\r\n          }\r\n\r\n          // Determine trailing zeros.\r\n          for (k = xc.length; !xc[--k];);\r\n\r\n          // E.g. [4, 11, 15] becomes 4bf.\r\n          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n          // Add leading zeros, decimal point and trailing zeros as required.\r\n          str = toFixedPoint(str, e, alphabet.charAt(0));\r\n        }\r\n\r\n        // The caller will add the sign.\r\n        return str;\r\n      };\r\n    })();\r\n\r\n\r\n    // Perform division in the specified base. Called by div and convertBase.\r\n    div = (function () {\r\n\r\n      // Assume non-zero x and k.\r\n      function multiply(x, k, base) {\r\n        var m, temp, xlo, xhi,\r\n          carry = 0,\r\n          i = x.length,\r\n          klo = k % SQRT_BASE,\r\n          khi = k / SQRT_BASE | 0;\r\n\r\n        for (x = x.slice(); i--;) {\r\n          xlo = x[i] % SQRT_BASE;\r\n          xhi = x[i] / SQRT_BASE | 0;\r\n          m = khi * xlo + xhi * klo;\r\n          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n          x[i] = temp % base;\r\n        }\r\n\r\n        if (carry) x = [carry].concat(x);\r\n\r\n        return x;\r\n      }\r\n\r\n      function compare(a, b, aL, bL) {\r\n        var i, cmp;\r\n\r\n        if (aL != bL) {\r\n          cmp = aL > bL ? 1 : -1;\r\n        } else {\r\n\r\n          for (i = cmp = 0; i < aL; i++) {\r\n\r\n            if (a[i] != b[i]) {\r\n              cmp = a[i] > b[i] ? 1 : -1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        return cmp;\r\n      }\r\n\r\n      function subtract(a, b, aL, base) {\r\n        var i = 0;\r\n\r\n        // Subtract b from a.\r\n        for (; aL--;) {\r\n          a[aL] -= i;\r\n          i = a[aL] < b[aL] ? 1 : 0;\r\n          a[aL] = i * base + a[aL] - b[aL];\r\n        }\r\n\r\n        // Remove leading zeros.\r\n        for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n      }\r\n\r\n      // x: dividend, y: divisor.\r\n      return function (x, y, dp, rm, base) {\r\n        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n          yL, yz,\r\n          s = x.s == y.s ? 1 : -1,\r\n          xc = x.c,\r\n          yc = y.c;\r\n\r\n        // Either NaN, Infinity or 0?\r\n        if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n          return new BigNumber(\r\n\r\n           // Return NaN if either NaN, or both Infinity or 0.\r\n           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\r\n            xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n         );\r\n        }\r\n\r\n        q = new BigNumber(s);\r\n        qc = q.c = [];\r\n        e = x.e - y.e;\r\n        s = dp + e + 1;\r\n\r\n        if (!base) {\r\n          base = BASE;\r\n          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n          s = s / LOG_BASE | 0;\r\n        }\r\n\r\n        // Result exponent may be one less then the current value of e.\r\n        // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n        for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n        if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n        if (s < 0) {\r\n          qc.push(1);\r\n          more = true;\r\n        } else {\r\n          xL = xc.length;\r\n          yL = yc.length;\r\n          i = 0;\r\n          s += 2;\r\n\r\n          // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n          n = mathfloor(base / (yc[0] + 1));\r\n\r\n          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n          if (n > 1) {\r\n            yc = multiply(yc, n, base);\r\n            xc = multiply(xc, n, base);\r\n            yL = yc.length;\r\n            xL = xc.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xc.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL; rem[remL++] = 0);\r\n          yz = yc.slice();\r\n          yz = [0].concat(yz);\r\n          yc0 = yc[0];\r\n          if (yc[1] >= base / 2) yc0++;\r\n          // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n          do {\r\n            n = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yc, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, n.\r\n\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // n is how many times the divisor goes into the current remainder.\r\n              n = mathfloor(rem0 / yc0);\r\n\r\n              //  Algorithm:\r\n              //  product = divisor multiplied by trial digit (n).\r\n              //  Compare product and remainder.\r\n              //  If product is greater than remainder:\r\n              //    Subtract divisor from product, decrement trial digit.\r\n              //  Subtract product from remainder.\r\n              //  If product was less than remainder at the last compare:\r\n              //    Compare new remainder and divisor.\r\n              //    If remainder is greater than divisor:\r\n              //      Subtract divisor from remainder, increment trial digit.\r\n\r\n              if (n > 1) {\r\n\r\n                // n may be > base only when base is 3.\r\n                if (n >= base) n = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiply(yc, n, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                // If product > remainder then trial digit n too high.\r\n                // n is 1 too high about 5% of the time, and is not known to have\r\n                // ever been more than 1 too high.\r\n                while (compare(prod, rem, prodL, remL) == 1) {\r\n                  n--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                  prodL = prod.length;\r\n                  cmp = 1;\r\n                }\r\n              } else {\r\n\r\n                // n is 0 or 1, cmp is -1.\r\n                // If n is 0, there is no need to compare yc and rem again below,\r\n                // so change cmp to 1 to avoid it.\r\n                // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n                if (n == 0) {\r\n\r\n                  // divisor < remainder, so n must be at least 1.\r\n                  cmp = n = 1;\r\n                }\r\n\r\n                // product = divisor\r\n                prod = yc.slice();\r\n                prodL = prod.length;\r\n              }\r\n\r\n              if (prodL < remL) prod = [0].concat(prod);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n              remL = rem.length;\r\n\r\n               // If product was < remainder.\r\n              if (cmp == -1) {\r\n\r\n                // Compare divisor and new remainder.\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                // Trial digit n too low.\r\n                // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n                while (compare(yc, rem, yL, remL) < 1) {\r\n                  n++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                  remL = rem.length;\r\n                }\r\n              }\r\n            } else if (cmp === 0) {\r\n              n++;\r\n              rem = [0];\r\n            } // else cmp === 1 and n will be 0\r\n\r\n            // Add the next digit, n, to the result array.\r\n            qc[i++] = n;\r\n\r\n            // Update the remainder.\r\n            if (rem[0]) {\r\n              rem[remL++] = xc[xi] || 0;\r\n            } else {\r\n              rem = [xc[xi]];\r\n              remL = 1;\r\n            }\r\n          } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n          more = rem[0] != null;\r\n\r\n          // Leading zero?\r\n          if (!qc[0]) qc.splice(0, 1);\r\n        }\r\n\r\n        if (base == BASE) {\r\n\r\n          // To calculate q.e, first get the number of digits of qc[0].\r\n          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n        // Caller is convertBase.\r\n        } else {\r\n          q.e = e;\r\n          q.r = +more;\r\n        }\r\n\r\n        return q;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n     * notation rounded to the specified decimal places or significant digits.\r\n     *\r\n     * n: a BigNumber.\r\n     * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n     * rm: the rounding mode.\r\n     * id: 1 (toExponential) or 2 (toPrecision).\r\n     */\r\n    function format(n, i, rm, id) {\r\n      var c0, e, ne, len, str;\r\n\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      if (!n.c) return n.toString();\r\n\r\n      c0 = n.c[0];\r\n      ne = n.e;\r\n\r\n      if (i == null) {\r\n        str = coeffToString(n.c);\r\n        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n         ? toExponential(str, ne)\r\n         : toFixedPoint(str, ne, '0');\r\n      } else {\r\n        n = round(new BigNumber(n), i, rm);\r\n\r\n        // n.e may have changed if the value was rounded up.\r\n        e = n.e;\r\n\r\n        str = coeffToString(n.c);\r\n        len = str.length;\r\n\r\n        // toPrecision returns exponential notation if the number of significant digits\r\n        // specified is less than the number of digits necessary to represent the integer\r\n        // part of the value in fixed-point notation.\r\n\r\n        // Exponential notation.\r\n        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n          // Append zeros?\r\n          for (; len < i; str += '0', len++);\r\n          str = toExponential(str, e);\r\n\r\n        // Fixed-point notation.\r\n        } else {\r\n          i -= ne;\r\n          str = toFixedPoint(str, e, '0');\r\n\r\n          // Append zeros?\r\n          if (e + 1 > len) {\r\n            if (--i > 0) for (str += '.'; i--; str += '0');\r\n          } else {\r\n            i += e - len;\r\n            if (i > 0) {\r\n              if (e + 1 == len) str += '.';\r\n              for (; i--; str += '0');\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return n.s < 0 && c0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // Handle BigNumber.max and BigNumber.min.\r\n    function maxOrMin(args, method) {\r\n      var n,\r\n        i = 1,\r\n        m = new BigNumber(args[0]);\r\n\r\n      for (; i < args.length; i++) {\r\n        n = new BigNumber(args[i]);\r\n\r\n        // If any number is NaN, return NaN.\r\n        if (!n.s) {\r\n          m = n;\r\n          break;\r\n        } else if (method.call(m, n)) {\r\n          m = n;\r\n        }\r\n      }\r\n\r\n      return m;\r\n    }\r\n\r\n\r\n    /*\r\n     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n     * Called by minus, plus and times.\r\n     */\r\n    function normalise(n, c, e) {\r\n      var i = 1,\r\n        j = c.length;\r\n\r\n       // Remove trailing zeros.\r\n      for (; !c[--j]; c.pop());\r\n\r\n      // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n      for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n      // Overflow?\r\n      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        n.c = n.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        n.c = [n.e = 0];\r\n      } else {\r\n        n.e = e;\r\n        n.c = c;\r\n      }\r\n\r\n      return n;\r\n    }\r\n\r\n\r\n    // Handle values that fail the validity test in BigNumber.\r\n    parseNumeric = (function () {\r\n      var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n        dotAfter = /^([^.]+)\\.$/,\r\n        dotBefore = /^\\.([^.]+)$/,\r\n        isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n        whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n      return function (x, str, isNum, b) {\r\n        var base,\r\n          s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n        // No exception on Infinity or NaN.\r\n        if (isInfinityOrNaN.test(s)) {\r\n          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n        } else {\r\n          if (!isNum) {\r\n\r\n            // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n            s = s.replace(basePrefix, function (m, p1, p2) {\r\n              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n              return !b || b == base ? p1 : m;\r\n            });\r\n\r\n            if (b) {\r\n              base = b;\r\n\r\n              // E.g. '1.' to '1', '.1' to '0.1'\r\n              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n            }\r\n\r\n            if (str != s) return new BigNumber(s, base);\r\n          }\r\n\r\n          // '[BigNumber Error] Not a number: {n}'\r\n          // '[BigNumber Error] Not a base {b} number: {n}'\r\n          if (BigNumber.DEBUG) {\r\n            throw Error\r\n              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n          }\r\n\r\n          // NaN\r\n          x.s = null;\r\n        }\r\n\r\n        x.c = x.e = null;\r\n      }\r\n    })();\r\n\r\n\r\n    /*\r\n     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n     * If r is truthy, it is known that there are more digits after the rounding digit.\r\n     */\r\n    function round(x, sd, rm, r) {\r\n      var d, i, j, k, n, ni, rd,\r\n        xc = x.c,\r\n        pows10 = POWS_TEN;\r\n\r\n      // if x is not Infinity or NaN...\r\n      if (xc) {\r\n\r\n        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n        // ni is the index of n within x.c.\r\n        // d is the number of digits of n.\r\n        // i is the index of rd within n including leading zeros.\r\n        // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n        out: {\r\n\r\n          // Get the number of digits of the first element of xc.\r\n          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n          i = sd - d;\r\n\r\n          // If the rounding digit is in the first element of xc...\r\n          if (i < 0) {\r\n            i += LOG_BASE;\r\n            j = sd;\r\n            n = xc[ni = 0];\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = n / pows10[d - j - 1] % 10 | 0;\r\n          } else {\r\n            ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n            if (ni >= xc.length) {\r\n\r\n              if (r) {\r\n\r\n                // Needed by sqrt.\r\n                for (; xc.length <= ni; xc.push(0));\r\n                n = rd = 0;\r\n                d = 1;\r\n                i %= LOG_BASE;\r\n                j = i - LOG_BASE + 1;\r\n              } else {\r\n                break out;\r\n              }\r\n            } else {\r\n              n = k = xc[ni];\r\n\r\n              // Get the number of digits of n.\r\n              for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n              // Get the index of rd within n.\r\n              i %= LOG_BASE;\r\n\r\n              // Get the index of rd within n, adjusted for leading zeros.\r\n              // The number of leading zeros of n is given by LOG_BASE - d.\r\n              j = i - LOG_BASE + d;\r\n\r\n              // Get the rounding digit at index j of n.\r\n              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;\r\n            }\r\n          }\r\n\r\n          r = r || sd < 0 ||\r\n\r\n          // Are there any non-zero digits after the rounding digit?\r\n          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n          r = rm < 4\r\n           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n            // Check whether the digit to the left of the rounding digit is odd.\r\n            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n          if (sd < 1 || !xc[0]) {\r\n            xc.length = 0;\r\n\r\n            if (r) {\r\n\r\n              // Convert sd to decimal places.\r\n              sd -= x.e + 1;\r\n\r\n              // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n              x.e = -sd || 0;\r\n            } else {\r\n\r\n              // Zero.\r\n              xc[0] = x.e = 0;\r\n            }\r\n\r\n            return x;\r\n          }\r\n\r\n          // Remove excess digits.\r\n          if (i == 0) {\r\n            xc.length = ni;\r\n            k = 1;\r\n            ni--;\r\n          } else {\r\n            xc.length = ni + 1;\r\n            k = pows10[LOG_BASE - i];\r\n\r\n            // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n            // j > 0 means i > number of leading zeros of n.\r\n            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n          }\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            for (; ;) {\r\n\r\n              // If the digit to be rounded up is in the first element of xc...\r\n              if (ni == 0) {\r\n\r\n                // i will be the length of xc[0] before k is added.\r\n                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n                j = xc[0] += k;\r\n                for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n                // if i != k the length has increased.\r\n                if (i != k) {\r\n                  x.e++;\r\n                  if (xc[0] == BASE) xc[0] = 1;\r\n                }\r\n\r\n                break;\r\n              } else {\r\n                xc[ni] += k;\r\n                if (xc[ni] != BASE) break;\r\n                xc[ni--] = 0;\r\n                k = 1;\r\n              }\r\n            }\r\n          }\r\n\r\n          // Remove trailing zeros.\r\n          for (i = xc.length; xc[--i] === 0; xc.pop());\r\n        }\r\n\r\n        // Overflow? Infinity.\r\n        if (x.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n\r\n        // Underflow? Zero.\r\n        } else if (x.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        }\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n\r\n    function valueOf(n) {\r\n      var str,\r\n        e = n.e;\r\n\r\n      if (e === null) return n.toString();\r\n\r\n      str = coeffToString(n.c);\r\n\r\n      str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n        ? toExponential(str, e)\r\n        : toFixedPoint(str, e, '0');\r\n\r\n      return n.s < 0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n     */\r\n    P.absoluteValue = P.abs = function () {\r\n      var x = new BigNumber(this);\r\n      if (x.s < 0) x.s = 1;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return\r\n     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     *   0 if they have the same value,\r\n     *   or null if the value of either is NaN.\r\n     */\r\n    P.comparedTo = function (y, b) {\r\n      return compare(this, new BigNumber(y, b));\r\n    };\r\n\r\n\r\n    /*\r\n     * If dp is undefined or null or true or false, return the number of decimal places of the\r\n     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n     *\r\n     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.decimalPlaces = P.dp = function (dp, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), dp + x.e + 1, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last number.\r\n      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n      if (n < 0) n = 0;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n / 0 = I\r\n     *  n / N = N\r\n     *  n / I = 0\r\n     *  0 / n = 0\r\n     *  0 / 0 = N\r\n     *  0 / N = N\r\n     *  0 / I = 0\r\n     *  N / n = N\r\n     *  N / 0 = N\r\n     *  N / N = N\r\n     *  N / I = N\r\n     *  I / n = I\r\n     *  I / 0 = I\r\n     *  I / N = N\r\n     *  I / I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.dividedBy = P.div = function (y, b) {\r\n      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n     * BigNumber by the value of BigNumber(y, b).\r\n     */\r\n    P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n      return div(this, new BigNumber(y, b), 0, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n     *\r\n     * If m is present, return the result modulo m.\r\n     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n     *\r\n     * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n     *\r\n     * n {number|string|BigNumber} The exponent. An integer.\r\n     * [m] {number|string|BigNumber} The modulus.\r\n     *\r\n     * '[BigNumber Error] Exponent not an integer: {n}'\r\n     */\r\n    P.exponentiatedBy = P.pow = function (n, m) {\r\n      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n        x = this;\r\n\r\n      n = new BigNumber(n);\r\n\r\n      // Allow NaN and Infinity, but not other non-integers.\r\n      if (n.c && !n.isInteger()) {\r\n        throw Error\r\n          (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n      }\r\n\r\n      if (m != null) m = new BigNumber(m);\r\n\r\n      // Exponent of MAX_SAFE_INTEGER is 15.\r\n      nIsBig = n.e > 14;\r\n\r\n      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.\r\n      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n        // The sign of the result of pow when x is negative depends on the evenness of n.\r\n        // If +n overflows to Infinity, the evenness of n would be not be known.\r\n        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));\r\n        return m ? y.mod(m) : y;\r\n      }\r\n\r\n      nIsNeg = n.s < 0;\r\n\r\n      if (m) {\r\n\r\n        // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n        isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n        if (isModExp) x = x.mod(m);\r\n\r\n      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.\r\n      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n        // [1, 240000000]\r\n        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n        // [80000000000000]  [99999750000000]\r\n        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n        // If x is negative and n is odd, k = -0, else k = 0.\r\n        k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n        // If x >= 1, k = Infinity.\r\n        if (x.e > -1) k = 1 / k;\r\n\r\n        // If n is negative return 0, else return Infinity.\r\n        return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n      } else if (POW_PRECISION) {\r\n\r\n        // Truncating each coefficient array to a length of k after each multiplication\r\n        // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n        // i.e. there will be a minimum of 28 guard digits retained.\r\n        k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n      }\r\n\r\n      if (nIsBig) {\r\n        half = new BigNumber(0.5);\r\n        if (nIsNeg) n.s = 1;\r\n        nIsOdd = isOdd(n);\r\n      } else {\r\n        i = Math.abs(+valueOf(n));\r\n        nIsOdd = i % 2;\r\n      }\r\n\r\n      y = new BigNumber(ONE);\r\n\r\n      // Performs 54 loop iterations for n of 9007199254740991.\r\n      for (; ;) {\r\n\r\n        if (nIsOdd) {\r\n          y = y.times(x);\r\n          if (!y.c) break;\r\n\r\n          if (k) {\r\n            if (y.c.length > k) y.c.length = k;\r\n          } else if (isModExp) {\r\n            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n          }\r\n        }\r\n\r\n        if (i) {\r\n          i = mathfloor(i / 2);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        } else {\r\n          n = n.times(half);\r\n          round(n, n.e + 1, 1);\r\n\r\n          if (n.e > 14) {\r\n            nIsOdd = isOdd(n);\r\n          } else {\r\n            i = +valueOf(n);\r\n            if (i === 0) break;\r\n            nIsOdd = i % 2;\r\n          }\r\n        }\r\n\r\n        x = x.times(x);\r\n\r\n        if (k) {\r\n          if (x.c && x.c.length > k) x.c.length = k;\r\n        } else if (isModExp) {\r\n          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (isModExp) return y;\r\n      if (nIsNeg) y = ONE.div(y);\r\n\r\n      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n     */\r\n    P.integerValue = function (rm) {\r\n      var n = new BigNumber(this);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n      return round(n, n.e + 1, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isEqualTo = P.eq = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n     */\r\n    P.isFinite = function () {\r\n      return !!this.c;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isGreaterThan = P.gt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n     */\r\n    P.isInteger = function () {\r\n      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isLessThan = P.lt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n     */\r\n    P.isNaN = function () {\r\n      return !this.s;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is negative, otherwise return false.\r\n     */\r\n    P.isNegative = function () {\r\n      return this.s < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is positive, otherwise return false.\r\n     */\r\n    P.isPositive = function () {\r\n      return this.s > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n     */\r\n    P.isZero = function () {\r\n      return !!this.c && this.c[0] == 0;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n - 0 = n\r\n     *  n - N = N\r\n     *  n - I = -I\r\n     *  0 - n = -n\r\n     *  0 - 0 = 0\r\n     *  0 - N = N\r\n     *  0 - I = -I\r\n     *  N - n = N\r\n     *  N - 0 = N\r\n     *  N - N = N\r\n     *  N - I = N\r\n     *  I - n = I\r\n     *  I - 0 = I\r\n     *  I - N = N\r\n     *  I - I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.minus = function (y, b) {\r\n      var i, j, t, xLTy,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n      if (a != b) {\r\n        y.s = -b;\r\n        return x.plus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Either Infinity?\r\n        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n        // Either zero?\r\n        if (!xc[0] || !yc[0]) {\r\n\r\n          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n           ROUNDING_MODE == 3 ? -0 : 0);\r\n        }\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Determine which is the bigger number.\r\n      if (a = xe - ye) {\r\n\r\n        if (xLTy = a < 0) {\r\n          a = -a;\r\n          t = xc;\r\n        } else {\r\n          ye = xe;\r\n          t = yc;\r\n        }\r\n\r\n        t.reverse();\r\n\r\n        // Prepend zeros to equalise exponents.\r\n        for (b = a; b--; t.push(0));\r\n        t.reverse();\r\n      } else {\r\n\r\n        // Exponents equal. Check digit by digit.\r\n        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n        for (a = b = 0; b < j; b++) {\r\n\r\n          if (xc[b] != yc[b]) {\r\n            xLTy = xc[b] < yc[b];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // x < y? Point xc to the array of the bigger number.\r\n      if (xLTy) {\r\n        t = xc;\r\n        xc = yc;\r\n        yc = t;\r\n        y.s = -y.s;\r\n      }  \r\n\r\n      b = (j = yc.length) - (i = xc.length);\r\n\r\n      // Append zeros to xc if shorter.\r\n      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n      if (b > 0) for (; b--; xc[i++] = 0);\r\n      b = BASE - 1;\r\n\r\n      // Subtract yc from xc.\r\n      for (; j > a;) {\r\n\r\n        if (xc[--j] < yc[j]) {\r\n          for (i = j; i && !xc[--i]; xc[i] = b);\r\n          --xc[i];\r\n          xc[j] += BASE;\r\n        }\r\n\r\n        xc[j] -= yc[j];\r\n      }\r\n\r\n      // Remove leading zeros and adjust exponent accordingly.\r\n      for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n      // Zero?\r\n      if (!xc[0]) {\r\n\r\n        // Following IEEE 754 (2008) 6.3,\r\n        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n        y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n        y.c = [y.e = 0];\r\n        return y;\r\n      }\r\n\r\n      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n      // for finite x and y.\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     *   n % 0 =  N\r\n     *   n % N =  N\r\n     *   n % I =  n\r\n     *   0 % n =  0\r\n     *  -0 % n = -0\r\n     *   0 % 0 =  N\r\n     *   0 % N =  N\r\n     *   0 % I =  0\r\n     *   N % n =  N\r\n     *   N % 0 =  N\r\n     *   N % N =  N\r\n     *   N % I =  N\r\n     *   I % n =  N\r\n     *   I % 0 =  N\r\n     *   I % N =  N\r\n     *   I % I =  N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n     * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n     */\r\n    P.modulo = P.mod = function (y, b) {\r\n      var q, s,\r\n        x = this;\r\n\r\n      y = new BigNumber(y, b);\r\n\r\n      // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n      if (!x.c || !y.s || y.c && !y.c[0]) {\r\n        return new BigNumber(NaN);\r\n\r\n      // Return x if y is Infinity or x is zero.\r\n      } else if (!y.c || x.c && !x.c[0]) {\r\n        return new BigNumber(x);\r\n      }\r\n\r\n      if (MODULO_MODE == 9) {\r\n\r\n        // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n        // r = x - qy    where  0 <= r < abs(y)\r\n        s = y.s;\r\n        y.s = 1;\r\n        q = div(x, y, 0, 3);\r\n        y.s = s;\r\n        q.s *= s;\r\n      } else {\r\n        q = div(x, y, 0, MODULO_MODE);\r\n      }\r\n\r\n      y = x.minus(q.times(y));\r\n\r\n      // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n      return y;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n * 0 = 0\r\n     *  n * N = N\r\n     *  n * I = I\r\n     *  0 * n = 0\r\n     *  0 * 0 = 0\r\n     *  0 * N = N\r\n     *  0 * I = N\r\n     *  N * n = N\r\n     *  N * 0 = N\r\n     *  N * N = N\r\n     *  N * I = N\r\n     *  I * n = I\r\n     *  I * 0 = N\r\n     *  I * N = N\r\n     *  I * I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n     * of BigNumber(y, b).\r\n     */\r\n    P.multipliedBy = P.times = function (y, b) {\r\n      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n        base, sqrtBase,\r\n        x = this,\r\n        xc = x.c,\r\n        yc = (y = new BigNumber(y, b)).c;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n        // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n          y.c = y.e = y.s = null;\r\n        } else {\r\n          y.s *= x.s;\r\n\r\n          // Return Infinity if either is Infinity.\r\n          if (!xc || !yc) {\r\n            y.c = y.e = null;\r\n\r\n          // Return 0 if either is 0.\r\n          } else {\r\n            y.c = [0];\r\n            y.e = 0;\r\n          }\r\n        }\r\n\r\n        return y;\r\n      }\r\n\r\n      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n      y.s *= x.s;\r\n      xcL = xc.length;\r\n      ycL = yc.length;\r\n\r\n      // Ensure xc points to longer array and xcL to its length.\r\n      if (xcL < ycL) {\r\n        zc = xc;\r\n        xc = yc;\r\n        yc = zc;\r\n        i = xcL;\r\n        xcL = ycL;\r\n        ycL = i;\r\n      }  \r\n\r\n      // Initialise the result array with zeros.\r\n      for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n      base = BASE;\r\n      sqrtBase = SQRT_BASE;\r\n\r\n      for (i = ycL; --i >= 0;) {\r\n        c = 0;\r\n        ylo = yc[i] % sqrtBase;\r\n        yhi = yc[i] / sqrtBase | 0;\r\n\r\n        for (k = xcL, j = i + k; j > i;) {\r\n          xlo = xc[--k] % sqrtBase;\r\n          xhi = xc[k] / sqrtBase | 0;\r\n          m = yhi * xlo + xhi * ylo;\r\n          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n          zc[j--] = xlo % base;\r\n        }\r\n\r\n        zc[j] = c;\r\n      }\r\n\r\n      if (c) {\r\n        ++e;\r\n      } else {\r\n        zc.splice(0, 1);\r\n      }\r\n\r\n      return normalise(y, zc, e);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n     * i.e. multiplied by -1.\r\n     */\r\n    P.negated = function () {\r\n      var x = new BigNumber(this);\r\n      x.s = -x.s || null;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n + 0 = n\r\n     *  n + N = N\r\n     *  n + I = I\r\n     *  0 + n = n\r\n     *  0 + 0 = 0\r\n     *  0 + N = N\r\n     *  0 + I = I\r\n     *  N + n = N\r\n     *  N + 0 = N\r\n     *  N + N = N\r\n     *  N + I = N\r\n     *  I + n = I\r\n     *  I + 0 = I\r\n     *  I + N = N\r\n     *  I + I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.plus = function (y, b) {\r\n      var t,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n       if (a != b) {\r\n        y.s = -b;\r\n        return x.minus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Return Infinity if either Infinity.\r\n        if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n        // Either zero?\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n      if (a = xe - ye) {\r\n        if (a > 0) {\r\n          ye = xe;\r\n          t = yc;\r\n        } else {\r\n          a = -a;\r\n          t = xc;\r\n        }\r\n\r\n        t.reverse();\r\n        for (; a--; t.push(0));\r\n        t.reverse();\r\n      }\r\n\r\n      a = xc.length;\r\n      b = yc.length;\r\n\r\n      // Point xc to the longer array, and b to the shorter length.\r\n      if (a - b < 0) {\r\n        t = yc;\r\n        yc = xc;\r\n        xc = t;\r\n        b = a;\r\n      }  \r\n\r\n      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n      for (a = 0; b;) {\r\n        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n      }\r\n\r\n      if (a) {\r\n        xc = [a].concat(xc);\r\n        ++ye;\r\n      }\r\n\r\n      // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n      // ye = MAX_EXP + 1 possible\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     * If sd is undefined or null or true or false, return the number of significant digits of\r\n     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n     * If sd is true include integer-part trailing zeros in the count.\r\n     *\r\n     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n     *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.precision = P.sd = function (sd, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (sd != null && sd !== !!sd) {\r\n        intCheck(sd, 1, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), sd, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      v = c.length - 1;\r\n      n = v * LOG_BASE + 1;\r\n\r\n      if (v = c[v]) {\r\n\r\n        // Subtract the number of trailing zeros of the last element.\r\n        for (; v % 10 == 0; v /= 10, n--);\r\n\r\n        // Add the number of digits of the first element.\r\n        for (v = c[0]; v >= 10; v /= 10, n++);\r\n      }\r\n\r\n      if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n     *\r\n     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n     */\r\n    P.shiftedBy = function (k) {\r\n      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n      return this.times('1e' + k);\r\n    };\r\n\r\n\r\n    /*\r\n     *  sqrt(-n) =  N\r\n     *  sqrt(N) =  N\r\n     *  sqrt(-I) =  N\r\n     *  sqrt(I) =  I\r\n     *  sqrt(0) =  0\r\n     *  sqrt(-0) = -0\r\n     *\r\n     * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.squareRoot = P.sqrt = function () {\r\n      var m, n, r, rep, t,\r\n        x = this,\r\n        c = x.c,\r\n        s = x.s,\r\n        e = x.e,\r\n        dp = DECIMAL_PLACES + 4,\r\n        half = new BigNumber('0.5');\r\n\r\n      // Negative/NaN/Infinity/zero?\r\n      if (s !== 1 || !c || !c[0]) {\r\n        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n      }\r\n\r\n      // Initial estimate.\r\n      s = Math.sqrt(+valueOf(x));\r\n\r\n      // Math.sqrt underflow/overflow?\r\n      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n      if (s == 0 || s == 1 / 0) {\r\n        n = coeffToString(c);\r\n        if ((n.length + e) % 2 == 0) n += '0';\r\n        s = Math.sqrt(+n);\r\n        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n        if (s == 1 / 0) {\r\n          n = '5e' + e;\r\n        } else {\r\n          n = s.toExponential();\r\n          n = n.slice(0, n.indexOf('e') + 1) + e;\r\n        }\r\n\r\n        r = new BigNumber(n);\r\n      } else {\r\n        r = new BigNumber(s + '');\r\n      }\r\n\r\n      // Check for zero.\r\n      // r could be zero if MIN_EXP is changed after the this value was created.\r\n      // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n      // coeffToString to throw.\r\n      if (r.c[0]) {\r\n        e = r.e;\r\n        s = e + dp;\r\n        if (s < 3) s = 0;\r\n\r\n        // Newton-Raphson iteration.\r\n        for (; ;) {\r\n          t = r;\r\n          r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n            // The exponent of r may here be one less than the final result exponent,\r\n            // e.g 0.0009999 (e-4) --\x3e 0.001 (e-3), so adjust s so the rounding digits\r\n            // are indexed correctly.\r\n            if (r.e < e) --s;\r\n            n = n.slice(s - 3, s + 1);\r\n\r\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n            // iteration.\r\n            if (n == '9999' || !rep && n == '4999') {\r\n\r\n              // On the first iteration only, check to see if rounding up gives the\r\n              // exact result as the nines may infinitely repeat.\r\n              if (!rep) {\r\n                round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n                if (t.times(t).eq(x)) {\r\n                  r = t;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              dp += 4;\r\n              s += 4;\r\n              rep = 1;\r\n            } else {\r\n\r\n              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n              // result. If not, then there are further digits and m will be truthy.\r\n              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n                // Truncate to the first rounding digit.\r\n                round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n                m = !r.times(r).eq(x);\r\n              }\r\n\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in exponential notation and\r\n     * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toExponential = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp++;\r\n      }\r\n      return format(this, dp, rm, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n     * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toFixed = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp = dp + this.e + 1;\r\n      }\r\n      return format(this, dp, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n     * of the format or FORMAT object (see BigNumber.set).\r\n     *\r\n     * The formatting object may contain some or all of the properties shown below.\r\n     *\r\n     * FORMAT = {\r\n     *   prefix: '',\r\n     *   groupSize: 3,\r\n     *   secondaryGroupSize: 0,\r\n     *   groupSeparator: ',',\r\n     *   decimalSeparator: '.',\r\n     *   fractionGroupSize: 0,\r\n     *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n     *   suffix: ''\r\n     * };\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     * [format] {object} Formatting options. See FORMAT pbject above.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     * '[BigNumber Error] Argument not an object: {format}'\r\n     */\r\n    P.toFormat = function (dp, rm, format) {\r\n      var str,\r\n        x = this;\r\n\r\n      if (format == null) {\r\n        if (dp != null && rm && typeof rm == 'object') {\r\n          format = rm;\r\n          rm = null;\r\n        } else if (dp && typeof dp == 'object') {\r\n          format = dp;\r\n          dp = rm = null;\r\n        } else {\r\n          format = FORMAT;\r\n        }\r\n      } else if (typeof format != 'object') {\r\n        throw Error\r\n          (bignumberError + 'Argument not an object: ' + format);\r\n      }\r\n\r\n      str = x.toFixed(dp, rm);\r\n\r\n      if (x.c) {\r\n        var i,\r\n          arr = str.split('.'),\r\n          g1 = +format.groupSize,\r\n          g2 = +format.secondaryGroupSize,\r\n          groupSeparator = format.groupSeparator || '',\r\n          intPart = arr[0],\r\n          fractionPart = arr[1],\r\n          isNeg = x.s < 0,\r\n          intDigits = isNeg ? intPart.slice(1) : intPart,\r\n          len = intDigits.length;\r\n\r\n        if (g2) {\r\n          i = g1;\r\n          g1 = g2;\r\n          g2 = i;\r\n          len -= i;\r\n        }  \r\n\r\n        if (g1 > 0 && len > 0) {\r\n          i = len % g1 || g1;\r\n          intPart = intDigits.substr(0, i);\r\n          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n          if (isNeg) intPart = '-' + intPart;\r\n        }\r\n\r\n        str = fractionPart\r\n         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n          ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n           '$&' + (format.fractionGroupSeparator || ''))\r\n          : fractionPart)\r\n         : intPart;\r\n      }\r\n\r\n      return (format.prefix || '') + str + (format.suffix || '');\r\n    };\r\n\r\n\r\n    /*\r\n     * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n     * fraction with an integer numerator and an integer denominator.\r\n     * The denominator will be a positive non-zero value less than or equal to the specified\r\n     * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n     * the lowest value necessary to represent the number exactly.\r\n     *\r\n     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n     *\r\n     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n     */\r\n    P.toFraction = function (md) {\r\n      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n        x = this,\r\n        xc = x.c;\r\n\r\n      if (md != null) {\r\n        n = new BigNumber(md);\r\n\r\n        // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n          throw Error\r\n            (bignumberError + 'Argument ' +\r\n              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n        }\r\n      }\r\n\r\n      if (!xc) return new BigNumber(x);\r\n\r\n      d = new BigNumber(ONE);\r\n      n1 = d0 = new BigNumber(ONE);\r\n      d1 = n0 = new BigNumber(ONE);\r\n      s = coeffToString(xc);\r\n\r\n      // Determine initial denominator.\r\n      // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n      e = d.e = s.length - x.e - 1;\r\n      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n      exp = MAX_EXP;\r\n      MAX_EXP = 1 / 0;\r\n      n = new BigNumber(s);\r\n\r\n      // n0 = d1 = 0\r\n      n0.c[0] = 0;\r\n\r\n      for (; ;)  {\r\n        q = div(n, d, 0, 1);\r\n        d2 = d0.plus(q.times(d1));\r\n        if (d2.comparedTo(md) == 1) break;\r\n        d0 = d1;\r\n        d1 = d2;\r\n        n1 = n0.plus(q.times(d2 = n1));\r\n        n0 = d2;\r\n        d = n.minus(q.times(d2 = d));\r\n        n = d2;\r\n      }\r\n\r\n      d2 = div(md.minus(d0), d1, 0, 1);\r\n      n0 = n0.plus(d2.times(n1));\r\n      d0 = d0.plus(d2.times(d1));\r\n      n0.s = n1.s = x.s;\r\n      e = e * 2;\r\n\r\n      // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n      MAX_EXP = exp;\r\n\r\n      return r;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return the value of this BigNumber converted to a number primitive.\r\n     */\r\n    P.toNumber = function () {\r\n      return +valueOf(this);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n     * necessary to represent the integer part of the value in fixed-point notation, then use\r\n     * exponential notation.\r\n     *\r\n     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.toPrecision = function (sd, rm) {\r\n      if (sd != null) intCheck(sd, 1, MAX);\r\n      return format(this, sd, rm, 2);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n     * TO_EXP_NEG, return exponential notation.\r\n     *\r\n     * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n     *\r\n     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n     */\r\n    P.toString = function (b) {\r\n      var str,\r\n        n = this,\r\n        s = n.s,\r\n        e = n.e;\r\n\r\n      // Infinity or NaN?\r\n      if (e === null) {\r\n        if (s) {\r\n          str = 'Infinity';\r\n          if (s < 0) str = '-' + str;\r\n        } else {\r\n          str = 'NaN';\r\n        }\r\n      } else {\r\n        if (b == null) {\r\n          str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n           ? toExponential(coeffToString(n.c), e)\r\n           : toFixedPoint(coeffToString(n.c), e, '0');\r\n        } else if (b === 10 && alphabetHasNormalDecimalDigits) {\r\n          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n          str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n        } else {\r\n          intCheck(b, 2, ALPHABET.length, 'Base');\r\n          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n        }\r\n\r\n        if (s < 0 && n.c[0]) str = '-' + str;\r\n      }\r\n\r\n      return str;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return as toString, but do not accept a base argument, and include the minus sign for\r\n     * negative zero.\r\n     */\r\n    P.valueOf = P.toJSON = function () {\r\n      return valueOf(this);\r\n    };\r\n\r\n\r\n    P._isBigNumber = true;\r\n\r\n    if (configObject != null) BigNumber.set(configObject);\r\n\r\n    return BigNumber;\r\n  }\r\n\r\n\r\n  // PRIVATE HELPER FUNCTIONS\r\n\r\n  // These functions don't need access to variables,\r\n  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\n  function bitFloor(n) {\r\n    var i = n | 0;\r\n    return n > 0 || n === i ? i : i - 1;\r\n  }\r\n\r\n\r\n  // Return a coefficient array as a string of base 10 digits.\r\n  function coeffToString(a) {\r\n    var s, z,\r\n      i = 1,\r\n      j = a.length,\r\n      r = a[0] + '';\r\n\r\n    for (; i < j;) {\r\n      s = a[i++] + '';\r\n      z = LOG_BASE - s.length;\r\n      for (; z--; s = '0' + s);\r\n      r += s;\r\n    }\r\n\r\n    // Determine trailing zeros.\r\n    for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n    return r.slice(0, j + 1 || 1);\r\n  }\r\n\r\n\r\n  // Compare the value of BigNumbers x and y.\r\n  function compare(x, y) {\r\n    var a, b,\r\n      xc = x.c,\r\n      yc = y.c,\r\n      i = x.s,\r\n      j = y.s,\r\n      k = x.e,\r\n      l = y.e;\r\n\r\n    // Either NaN?\r\n    if (!i || !j) return null;\r\n\r\n    a = xc && !xc[0];\r\n    b = yc && !yc[0];\r\n\r\n    // Either zero?\r\n    if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n    // Signs differ?\r\n    if (i != j) return i;\r\n\r\n    a = i < 0;\r\n    b = k == l;\r\n\r\n    // Either Infinity?\r\n    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n    // Compare exponents.\r\n    if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n    j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n    // Compare lengths.\r\n    return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n   */\r\n  function intCheck(n, min, max, name) {\r\n    if (n < min || n > max || n !== mathfloor(n)) {\r\n      throw Error\r\n       (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n         ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n         : ' not a primitive number: ') + String(n));\r\n    }\r\n  }\r\n\r\n\r\n  // Assumes finite n.\r\n  function isOdd(n) {\r\n    var k = n.c.length - 1;\r\n    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n  }\r\n\r\n\r\n  function toExponential(str, e) {\r\n    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n     (e < 0 ? 'e' : 'e+') + e;\r\n  }\r\n\r\n\r\n  function toFixedPoint(str, e, z) {\r\n    var len, zs;\r\n\r\n    // Negative exponent?\r\n    if (e < 0) {\r\n\r\n      // Prepend zeros.\r\n      for (zs = z + '.'; ++e; zs += z);\r\n      str = zs + str;\r\n\r\n    // Positive exponent\r\n    } else {\r\n      len = str.length;\r\n\r\n      // Append zeros.\r\n      if (++e > len) {\r\n        for (zs = z, e -= len; --e; zs += z);\r\n        str += zs;\r\n      } else if (e < len) {\r\n        str = str.slice(0, e) + '.' + str.slice(e);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // EXPORT\r\n\r\n\r\n  BigNumber = clone();\r\n  BigNumber['default'] = BigNumber.BigNumber = BigNumber;\r\n\r\n  // AMD.\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n  // Node.js and other environments that support module.exports.\r\n  } else {}\r\n})(this);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanM/Y2NlZCJdLCJzb3VyY2VzQ29udGVudCI6WyI7KGZ1bmN0aW9uIChnbG9iYWxPYmplY3QpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4vKlxyXG4gKiAgICAgIGJpZ251bWJlci5qcyB2OS4xLjBcclxuICogICAgICBBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBhcml0aG1ldGljLlxyXG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qc1xyXG4gKiAgICAgIENvcHlyaWdodCAoYykgMjAyMiBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gKiAgICAgIE1JVCBMaWNlbnNlZC5cclxuICpcclxuICogICAgICBCaWdOdW1iZXIucHJvdG90eXBlIG1ldGhvZHMgICAgIHwgIEJpZ051bWJlciBtZXRob2RzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgYWJzb2x1dGVWYWx1ZSAgICAgICAgICAgIGFicyAgICB8ICBjbG9uZVxyXG4gKiAgICAgIGNvbXBhcmVkVG8gICAgICAgICAgICAgICAgICAgICAgfCAgY29uZmlnICAgICAgICAgICAgICAgc2V0XHJcbiAqICAgICAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgIGRwICAgICB8ICAgICAgREVDSU1BTF9QTEFDRVNcclxuICogICAgICBkaXZpZGVkQnkgICAgICAgICAgICAgICAgZGl2ICAgIHwgICAgICBST1VORElOR19NT0RFXHJcbiAqICAgICAgZGl2aWRlZFRvSW50ZWdlckJ5ICAgICAgIGlkaXYgICB8ICAgICAgRVhQT05FTlRJQUxfQVRcclxuICogICAgICBleHBvbmVudGlhdGVkQnkgICAgICAgICAgcG93ICAgIHwgICAgICBSQU5HRVxyXG4gKiAgICAgIGludGVnZXJWYWx1ZSAgICAgICAgICAgICAgICAgICAgfCAgICAgIENSWVBUT1xyXG4gKiAgICAgIGlzRXF1YWxUbyAgICAgICAgICAgICAgICBlcSAgICAgfCAgICAgIE1PRFVMT19NT0RFXHJcbiAqICAgICAgaXNGaW5pdGUgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgUE9XX1BSRUNJU0lPTlxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW4gICAgICAgICAgICBndCAgICAgfCAgICAgIEZPUk1BVFxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW5PckVxdWFsVG8gICBndGUgICAgfCAgICAgIEFMUEhBQkVUXHJcbiAqICAgICAgaXNJbnRlZ2VyICAgICAgICAgICAgICAgICAgICAgICB8ICBpc0JpZ051bWJlclxyXG4gKiAgICAgIGlzTGVzc1RoYW4gICAgICAgICAgICAgICBsdCAgICAgfCAgbWF4aW11bSAgICAgICAgICAgICAgbWF4XHJcbiAqICAgICAgaXNMZXNzVGhhbk9yRXF1YWxUbyAgICAgIGx0ZSAgICB8ICBtaW5pbXVtICAgICAgICAgICAgICBtaW5cclxuICogICAgICBpc05hTiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJhbmRvbVxyXG4gKiAgICAgIGlzTmVnYXRpdmUgICAgICAgICAgICAgICAgICAgICAgfCAgc3VtXHJcbiAqICAgICAgaXNQb3NpdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgaXNaZXJvICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbWludXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbW9kdWxvICAgICAgICAgICAgICAgICAgIG1vZCAgICB8XHJcbiAqICAgICAgbXVsdGlwbGllZEJ5ICAgICAgICAgICAgIHRpbWVzICB8XHJcbiAqICAgICAgbmVnYXRlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcGx1cyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcHJlY2lzaW9uICAgICAgICAgICAgICAgIHNkICAgICB8XHJcbiAqICAgICAgc2hpZnRlZEJ5ICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgc3F1YXJlUm9vdCAgICAgICAgICAgICAgIHNxcnQgICB8XHJcbiAqICAgICAgdG9FeHBvbmVudGlhbCAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GaXhlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9Gb3JtYXQgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GcmFjdGlvbiAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9KU09OICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9OdW1iZXIgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9QcmVjaXNpb24gICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9TdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdmFsdWVPZiAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcbiAgdmFyIEJpZ051bWJlcixcclxuICAgIGlzTnVtZXJpYyA9IC9eLT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86ZVsrLV0/XFxkKyk/JC9pLFxyXG4gICAgbWF0aGNlaWwgPSBNYXRoLmNlaWwsXHJcbiAgICBtYXRoZmxvb3IgPSBNYXRoLmZsb29yLFxyXG5cclxuICAgIGJpZ251bWJlckVycm9yID0gJ1tCaWdOdW1iZXIgRXJyb3JdICcsXHJcbiAgICB0b29NYW55RGlnaXRzID0gYmlnbnVtYmVyRXJyb3IgKyAnTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czogJyxcclxuXHJcbiAgICBCQVNFID0gMWUxNCxcclxuICAgIExPR19CQVNFID0gMTQsXHJcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZiwgICAgICAgICAvLyAyXjUzIC0gMVxyXG4gICAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcclxuICAgIFBPV1NfVEVOID0gWzEsIDEwLCAxMDAsIDFlMywgMWU0LCAxZTUsIDFlNiwgMWU3LCAxZTgsIDFlOSwgMWUxMCwgMWUxMSwgMWUxMiwgMWUxM10sXHJcbiAgICBTUVJUX0JBU0UgPSAxZTcsXHJcblxyXG4gICAgLy8gRURJVEFCTEVcclxuICAgIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgREVDSU1BTF9QTEFDRVMsIFRPX0VYUF9ORUcsIFRPX0VYUF9QT1MsIE1JTl9FWFAsIE1BWF9FWFAsIGFuZFxyXG4gICAgLy8gdGhlIGFyZ3VtZW50cyB0byB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCwgYW5kIHRvUHJlY2lzaW9uLlxyXG4gICAgTUFYID0gMUU5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhfSU5UMzJcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2xvbmUoY29uZmlnT2JqZWN0KSB7XHJcbiAgICB2YXIgZGl2LCBjb252ZXJ0QmFzZSwgcGFyc2VOdW1lcmljLFxyXG4gICAgICBQID0gQmlnTnVtYmVyLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IEJpZ051bWJlciwgdG9TdHJpbmc6IG51bGwsIHZhbHVlT2Y6IG51bGwgfSxcclxuICAgICAgT05FID0gbmV3IEJpZ051bWJlcigxKSxcclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVESVRBQkxFIENPTkZJRyBERUZBVUxUUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2VzIHN0YXRlZC5cclxuICAgICAgLy8gVGhlIHZhbHVlcyBjYW4gYWxzbyBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIEJpZ051bWJlci5zZXQuXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxyXG4gICAgICBERUNJTUFMX1BMQUNFUyA9IDIwLCAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLCBhbmQgd2hlbiB1c2luZ1xyXG4gICAgICAvLyB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXHJcbiAgICAgIC8vIFVQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgICAgLy8gRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgICAgLy8gQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBGTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAgIC8vIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgICAgLy8gSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgICAvLyBIQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICBST1VORElOR19NT0RFID0gNCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC03XHJcbiAgICAgIFRPX0VYUF9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAyMVxyXG4gICAgICBUT19FWFBfUE9TID0gMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxyXG5cclxuICAgICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcclxuICAgICAgTUlOX0VYUCA9IC0xZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogIDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXHJcbiAgICAgIE1BWF9FWFAgPSAxZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcclxuXHJcbiAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cclxuICAgICAgQ1JZUFRPID0gZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIG9yIGZhbHNlXHJcblxyXG4gICAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cclxuICAgICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVVAgICAgICAgIDAgVGhlIHJlbWFpbmRlciBpcyBwb3NpdGl2ZSBpZiB0aGUgZGl2aWRlbmQgaXMgbmVnYXRpdmUsIGVsc2UgaXMgbmVnYXRpdmUuXHJcbiAgICAgIC8vIERPV04gICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGlzIG1vZHVsbyBtb2RlIGlzIGNvbW1vbmx5IGtub3duIGFzICd0cnVuY2F0ZWQgZGl2aXNpb24nIGFuZCBpc1xyXG4gICAgICAvLyAgICAgICAgICAgICBlcXVpdmFsZW50IHRvIChhICUgbikgaW4gSmF2YVNjcmlwdC5cclxuICAgICAgLy8gRkxPT1IgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gNiBUaGlzIG1vZHVsbyBtb2RlIGltcGxlbWVudHMgdGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgICAgLy8gRVVDTElEICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGUgcmVtYWluZGVyIGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVGhlIHRydW5jYXRlZCBkaXZpc2lvbiwgZmxvb3JlZCBkaXZpc2lvbiwgRXVjbGlkaWFuIGRpdmlzaW9uIGFuZCBJRUVFIDc1NCByZW1haW5kZXJcclxuICAgICAgLy8gbW9kZXMgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi5cclxuICAgICAgLy8gQWx0aG91Z2ggdGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvIGJlIHVzZWQsIHRoZXkgbWF5IG5vdCBnaXZlIHVzZWZ1bCByZXN1bHRzLlxyXG4gICAgICBNT0RVTE9fTU9ERSA9IDEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSBleHBvbmVudGlhdGVkQnkgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBJZiBQT1dfUFJFQ0lTSU9OIGlzIDAsIHRoZXJlIHdpbGwgYmUgdW5saW1pdGVkIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAgUE9XX1BSRUNJU0lPTiA9IDAsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxyXG4gICAgICBGT1JNQVQgPSB7XHJcbiAgICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgICBncm91cFNpemU6IDMsXHJcbiAgICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgICBzdWZmaXg6ICcnXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBUaGUgYWxwaGFiZXQgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLiBJdCBtdXN0IGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBsb25nLCB3aXRoIG5vICcrJyxcclxuICAgICAgLy8gJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgLy8gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8nXHJcbiAgICAgIEFMUEhBQkVUID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXHJcbiAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHRydWU7XHJcblxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgQmlnTnVtYmVyIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiB2IHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gQSBudW1lcmljIHZhbHVlLlxyXG4gICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIHYuIEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQmlnTnVtYmVyKHYsIGIpIHtcclxuICAgICAgdmFyIGFscGhhYmV0LCBjLCBjYXNlQ2hhbmdlZCwgZSwgaSwgaXNOdW0sIGxlbiwgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBgbmV3YC5cclxuICAgICAgaWYgKCEoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikpIHJldHVybiBuZXcgQmlnTnVtYmVyKHYsIGIpO1xyXG5cclxuICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodiAmJiB2Ll9pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgeC5zID0gdi5zO1xyXG5cclxuICAgICAgICAgIGlmICghdi5jIHx8IHYuZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodi5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgICAgIHguYyA9IHYuYy5zbGljZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykgJiYgdiAqIDAgPT0gMCkge1xyXG5cclxuICAgICAgICAgIC8vIFVzZSBgMSAvIG5gIHRvIGhhbmRsZSBtaW51cyB6ZXJvIGFsc28uXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAodiA9IC12LCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgaW50ZWdlcnMsIHdoZXJlIG4gPCAyMTQ3NDgzNjQ4ICgyKiozMSkuXHJcbiAgICAgICAgICBpZiAodiA9PT0gfn52KSB7XHJcbiAgICAgICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwLCBlKyspO1xyXG5cclxuICAgICAgICAgICAgaWYgKGUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICAgIHguYyA9IFt2XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGlmICghaXNOdW1lcmljLnRlc3Qoc3RyID0gU3RyaW5nKHYpKSkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICAgICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcblxyXG4gICAgICAgIC8vIEFsbG93IGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGJlIHVzZWQgd2l0aCBiYXNlIDEwIGFyZ3VtZW50LCB3aGlsZVxyXG4gICAgICAgIC8vIGFsc28gcm91bmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgICBpZiAoYiA9PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKHYpO1xyXG4gICAgICAgICAgcmV0dXJuIHJvdW5kKHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcblxyXG4gICAgICAgIGlmIChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXZvaWQgcG90ZW50aWFsIGludGVycHJldGF0aW9uIG9mIEluZmluaXR5IGFuZCBOYU4gYXMgYmFzZSA0NCsgdmFsdWVzLlxyXG4gICAgICAgICAgaWYgKHYgKiAwICE9IDApIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSwgYik7XHJcblxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRyAmJiBzdHIucmVwbGFjZSgvXjBcXC4wKnxcXC4vLCAnJykubGVuZ3RoID4gMTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhbHBoYWJldCA9IEFMUEhBQkVULnNsaWNlKDAsIGIpO1xyXG4gICAgICAgIGUgPSBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBzdHIgaXMgYSB2YWxpZCBiYXNlIGIgbnVtYmVyLlxyXG4gICAgICAgIC8vIERvbid0IHVzZSBSZWdFeHAsIHNvIGFscGhhYmV0IGNhbiBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoYyA9IHN0ci5jaGFyQXQoaSkpIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgJy4nIGlzIG5vdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpdCBoYXMgbm90IGJlIGZvdW5kIGJlZm9yZS5cclxuICAgICAgICAgICAgICBpZiAoaSA+IGUpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBsZW47XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNhc2VDaGFuZ2VkKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEFsbG93IGUuZy4gaGV4YWRlY2ltYWwgJ0ZGJyBhcyB3ZWxsIGFzICdmZicuXHJcbiAgICAgICAgICAgICAgaWYgKHN0ciA9PSBzdHIudG9VcHBlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgICAgICAgIHN0ciA9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBTdHJpbmcodiksIGlzTnVtLCBiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxyXG4gICAgICAgIGlzTnVtID0gZmFsc2U7XHJcbiAgICAgICAgc3RyID0gY29udmVydEJhc2Uoc3RyLCBiLCAxMCwgeC5zKTtcclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICBlbHNlIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KC0tbGVuKSA9PT0gNDg7KTtcclxuXHJcbiAgICAgIGlmIChzdHIgPSBzdHIuc2xpY2UoaSwgKytsZW4pKSB7XHJcbiAgICAgICAgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgaWYgKGlzTnVtICYmIEJpZ051bWJlci5ERUJVRyAmJlxyXG4gICAgICAgICAgbGVuID4gMTUgJiYgKHYgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHYgIT09IG1hdGhmbG9vcih2KSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgKHgucyAqIHYpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgICBpZiAoKGUgPSBlIC0gaSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcclxuXHJcbiAgICAgICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxyXG4gICAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoZSA8IDApIGkgKz0gTE9HX0JBU0U7ICAvLyBpIDwgMVxyXG5cclxuICAgICAgICAgIGlmIChpIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChpKSB4LmMucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgICAgIHguYy5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpID0gTE9HX0JBU0UgLSAoc3RyID0gc3RyLnNsaWNlKGkpKS5sZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpIC09IGxlbjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIHguYy5wdXNoKCtzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1IgUFJPUEVSVElFU1xyXG5cclxuXHJcbiAgICBCaWdOdW1iZXIuY2xvbmUgPSBjbG9uZTtcclxuXHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfVVAgPSAwO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0NFSUwgPSAyO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0ZMT09SID0gMztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0RPV04gPSA1O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0ZMT09SID0gODtcclxuICAgIEJpZ051bWJlci5FVUNMSUQgPSA5O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogQ29uZmlndXJlIGluZnJlcXVlbnRseS1jaGFuZ2luZyBsaWJyYXJ5LXdpZGUgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQWNjZXB0IGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgcHJvcGVydGllcyAoaWYgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaXNcclxuICAgICAqIGEgbnVtYmVyLCBpdCBtdXN0IGJlIGFuIGludGVnZXIgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2Ugc3RhdGVkKTpcclxuICAgICAqXHJcbiAgICAgKiAgIERFQ0lNQUxfUExBQ0VTICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIFJPVU5ESU5HX01PREUgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOFxyXG4gICAgICogICBFWFBPTkVOVElBTF9BVCAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAgb3IgIFstTUFYIHRvIDAsIDAgdG8gTUFYXVxyXG4gICAgICogICBSQU5HRSAgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAobm90IHplcm8pICBvciAgWy1NQVggdG8gLTEsIDEgdG8gTUFYXVxyXG4gICAgICogICBDUllQVE8gICAgICAgICAgIHtib29sZWFufSAgICAgICAgICB0cnVlIG9yIGZhbHNlXHJcbiAgICAgKiAgIE1PRFVMT19NT0RFICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOVxyXG4gICAgICogICBQT1dfUFJFQ0lTSU9OICAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBBTFBIQUJFVCAgICAgICAgIHtzdHJpbmd9ICAgICAgICAgICBBIHN0cmluZyBvZiB0d28gb3IgbW9yZSB1bmlxdWUgY2hhcmFjdGVycyB3aGljaCBkb2VzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBjb250YWluICcuJy5cclxuICAgICAqICAgRk9STUFUICAgICAgICAgICB7b2JqZWN0fSAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggc29tZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiAgICAgcHJlZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGdyb3VwU2l6ZSAgICAgICAgICAgICAge251bWJlcn1cclxuICAgICAqICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZ3JvdXBTZXBhcmF0b3IgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGRlY2ltYWxTZXBhcmF0b3IgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB7c3RyaW5nfVxyXG4gICAgICogICAgIHN1ZmZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqXHJcbiAgICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAgICpcclxuICAgICAqIEUuZy5cclxuICAgICAqIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUyA6IDIwLCBST1VORElOR19NT0RFIDogNCB9KVxyXG4gICAgICpcclxuICAgICAqIElnbm9yZSBwcm9wZXJ0aWVzL3BhcmFtZXRlcnMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLCBleGNlcHQgZm9yIEFMUEhBQkVULlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmNvbmZpZyA9IEJpZ051bWJlci5zZXQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgIHZhciBwLCB2O1xyXG5cclxuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgLy8gREVDSU1BTF9QTEFDRVMge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIERFQ0lNQUxfUExBQ0VTIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdERUNJTUFMX1BMQUNFUycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBST1VORElOR19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUk9VTkRJTkdfTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUk9VTkRJTkdfTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDgsIHApO1xyXG4gICAgICAgICAgICBST1VORElOR19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxyXG4gICAgICAgICAgLy8gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbHVzaXZlLCAwIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEVYUE9ORU5USUFMX0FUIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdFWFBPTkVOVElBTF9BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgMCwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXTtcclxuICAgICAgICAgICAgICBUT19FWFBfUE9TID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSAtKFRPX0VYUF9QT1MgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSQU5HRSB7bnVtYmVyfG51bWJlcltdfSBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUkFOR0Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfGNhbm5vdCBiZSB6ZXJvfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JBTkdFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAtMSwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMSwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBNSU5fRVhQID0gdlswXTtcclxuICAgICAgICAgICAgICBNQVhfRVhQID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBNSU5fRVhQID0gLShNQVhfRVhQID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGNhbm5vdCBiZSB6ZXJvOiAnICsgdik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ1JZUFRPIHtib29sZWFufSB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIENSWVBUTyBub3QgdHJ1ZSBvciBmYWxzZToge3Z9J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdDUllQVE8nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gISF2KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0byAmJlxyXG4gICAgICAgICAgICAgICAgIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9ICF2O1xyXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgdHJ1ZSBvciBmYWxzZTogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTU9EVUxPX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA5IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBNT0RVTE9fTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnTU9EVUxPX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA5LCBwKTtcclxuICAgICAgICAgICAgTU9EVUxPX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFBPV19QUkVDSVNJT04ge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1BPV19QUkVDSVNJT04nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBGT1JNQVQge29iamVjdH1cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBGT1JNQVQgbm90IGFuIG9iamVjdDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0ZPUk1BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnb2JqZWN0JykgRk9STUFUID0gdjtcclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IGFuIG9iamVjdDogJyArIHYpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFMUEhBQkVUIHtzdHJpbmd9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQUxQSEFCRVQgaW52YWxpZDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0FMUEhBQkVUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIERpc2FsbG93IGlmIGxlc3MgdGhhbiB0d28gY2hhcmFjdGVycyxcclxuICAgICAgICAgICAgLy8gb3IgaWYgaXQgY29udGFpbnMgJysnLCAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgYSByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnc3RyaW5nJyAmJiAhL14uPyR8WytcXC0uXFxzXXwoLikuKlxcMS8udGVzdCh2KSkge1xyXG4gICAgICAgICAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHYuc2xpY2UoMCwgMTApID09ICcwMTIzNDU2Nzg5JztcclxuICAgICAgICAgICAgICBBTFBIQUJFVCA9IHY7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgaW52YWxpZDogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE9iamVjdCBleHBlY3RlZDoge3Z9J1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnT2JqZWN0IGV4cGVjdGVkOiAnICsgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgREVDSU1BTF9QTEFDRVM6IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgIFJPVU5ESU5HX01PREU6IFJPVU5ESU5HX01PREUsXHJcbiAgICAgICAgRVhQT05FTlRJQUxfQVQ6IFtUT19FWFBfTkVHLCBUT19FWFBfUE9TXSxcclxuICAgICAgICBSQU5HRTogW01JTl9FWFAsIE1BWF9FWFBdLFxyXG4gICAgICAgIENSWVBUTzogQ1JZUFRPLFxyXG4gICAgICAgIE1PRFVMT19NT0RFOiBNT0RVTE9fTU9ERSxcclxuICAgICAgICBQT1dfUFJFQ0lTSU9OOiBQT1dfUFJFQ0lTSU9OLFxyXG4gICAgICAgIEZPUk1BVDogRk9STUFULFxyXG4gICAgICAgIEFMUEhBQkVUOiBBTFBIQUJFVFxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHYgaXMgYSBCaWdOdW1iZXIgaW5zdGFuY2UsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogSWYgQmlnTnVtYmVyLkRFQlVHIGlzIHRydWUsIHRocm93IGlmIGEgQmlnTnVtYmVyIGluc3RhbmNlIGlzIG5vdCB3ZWxsLWZvcm1lZC5cclxuICAgICAqXHJcbiAgICAgKiB2IHthbnl9XHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEludmFsaWQgQmlnTnVtYmVyOiB7dn0nXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgIGlmICghdiB8fCB2Ll9pc0JpZ051bWJlciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoIUJpZ051bWJlci5ERUJVRykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICB2YXIgaSwgbixcclxuICAgICAgICBjID0gdi5jLFxyXG4gICAgICAgIGUgPSB2LmUsXHJcbiAgICAgICAgcyA9IHYucztcclxuXHJcbiAgICAgIG91dDogaWYgKHt9LnRvU3RyaW5nLmNhbGwoYykgPT0gJ1tvYmplY3QgQXJyYXldJykge1xyXG5cclxuICAgICAgICBpZiAoKHMgPT09IDEgfHwgcyA9PT0gLTEpICYmIGUgPj0gLU1BWCAmJiBlIDw9IE1BWCAmJiBlID09PSBtYXRoZmxvb3IoZSkpIHtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgZWxlbWVudCBpcyB6ZXJvLCB0aGUgQmlnTnVtYmVyIHZhbHVlIG11c3QgYmUgemVyby5cclxuICAgICAgICAgIGlmIChjWzBdID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlID09PSAwICYmIGMubGVuZ3RoID09PSAxKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIHRoYXQgY1swXSBzaG91bGQgaGF2ZSwgYmFzZWQgb24gdGhlIGV4cG9uZW50LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChpIDwgMSkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICAgICAgLy9pZiAoTWF0aC5jZWlsKE1hdGgubG9nKGNbMF0gKyAxKSAvIE1hdGguTE4xMCkgPT0gaSkge1xyXG4gICAgICAgICAgaWYgKFN0cmluZyhjWzBdKS5sZW5ndGggPT0gaSkge1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBuID0gY1tpXTtcclxuICAgICAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSBCQVNFIHx8IG4gIT09IG1hdGhmbG9vcihuKSkgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMYXN0IGVsZW1lbnQgY2Fubm90IGJlIHplcm8sIHVubGVzcyBpdCBpcyB0aGUgb25seSBlbGVtZW50LlxyXG4gICAgICAgICAgICBpZiAobiAhPT0gMCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5maW5pdHkvTmFOXHJcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gbnVsbCAmJiBlID09PSBudWxsICYmIChzID09PSBudWxsIHx8IHMgPT09IDEgfHwgcyA9PT0gLTEpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0ludmFsaWQgQmlnTnVtYmVyOiAnICsgdik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5tYXhpbXVtID0gQmlnTnVtYmVyLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5sdCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5taW5pbXVtID0gQmlnTnVtYmVyLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5ndCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSxcclxuICAgICAqIGFuZCB3aXRoIGRwLCBvciBERUNJTUFMX1BMQUNFUyBpZiBkcCBpcyBvbWl0dGVkLCBkZWNpbWFsIHBsYWNlcyAob3IgbGVzcyBpZiB0cmFpbGluZ1xyXG4gICAgICogemVyb3MgYXJlIHByb2R1Y2VkKS5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcH0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIucmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHBvdzJfNTMgPSAweDIwMDAwMDAwMDAwMDAwO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIGEgNTMgYml0IGludGVnZXIgbiwgd2hlcmUgMCA8PSBuIDwgOTAwNzE5OTI1NDc0MDk5Mi5cclxuICAgICAgLy8gQ2hlY2sgaWYgTWF0aC5yYW5kb20oKSBwcm9kdWNlcyBtb3JlIHRoYW4gMzIgYml0cyBvZiByYW5kb21uZXNzLlxyXG4gICAgICAvLyBJZiBpdCBkb2VzLCBhc3N1bWUgYXQgbGVhc3QgNTMgYml0cyBhcmUgcHJvZHVjZWQsIG90aGVyd2lzZSBhc3N1bWUgYXQgbGVhc3QgMzAgYml0cy5cclxuICAgICAgLy8gMHg0MDAwMDAwMCBpcyAyXjMwLCAweDgwMDAwMCBpcyAyXjIzLCAweDFmZmZmZiBpcyAyXjIxIC0gMS5cclxuICAgICAgdmFyIHJhbmRvbTUzYml0SW50ID0gKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKSAmIDB4MWZmZmZmXHJcbiAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhmbG9vcihNYXRoLnJhbmRvbSgpICogcG93Ml81Myk7IH1cclxuICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKChNYXRoLnJhbmRvbSgpICogMHg0MDAwMDAwMCB8IDApICogMHg4MDAwMDApICtcclxuICAgICAgICAgKE1hdGgucmFuZG9tKCkgKiAweDgwMDAwMCB8IDApOyB9O1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkcCkge1xyXG4gICAgICAgIHZhciBhLCBiLCBlLCBrLCB2LFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBjID0gW10sXHJcbiAgICAgICAgICByYW5kID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgICBpZiAoZHAgPT0gbnVsbCkgZHAgPSBERUNJTUFMX1BMQUNFUztcclxuICAgICAgICBlbHNlIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG5cclxuICAgICAgICBrID0gbWF0aGNlaWwoZHAgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgIGlmIChDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgICAgICAgICBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG5cclxuICAgICAgICAgICAgYSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGsgKj0gMikpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyA1MyBiaXRzOlxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgKiBNYXRoLnBvdygyLCAyMSkpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDBcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpID4+PiAxMSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDB4MjAwMDAgaXMgMl4yMS5cclxuICAgICAgICAgICAgICB2ID0gYVtpXSAqIDB4MjAwMDAgKyAoYVtpICsgMV0gPj4+IDExKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gUmVqZWN0aW9uIHNhbXBsaW5nOlxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICAvLyBQcm9iYWJpbGl0eSB0aGF0IHYgPj0gOWUxNSwgaXNcclxuICAgICAgICAgICAgICAvLyA3MTk5MjU0NzQwOTkyIC8gOTAwNzE5OTI1NDc0MDk5MiB+PSAwLjAwMDgsIGkuZS4gMSBpbiAxMjUxXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDIpKTtcclxuICAgICAgICAgICAgICAgIGFbaV0gPSBiWzBdO1xyXG4gICAgICAgICAgICAgICAgYVtpICsgMV0gPSBiWzFdO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSB2IDw9IDg5OTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vZGUuanMgc3VwcG9ydGluZyBjcnlwdG8ucmFuZG9tQnl0ZXMuXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyeXB0by5yYW5kb21CeXRlcykge1xyXG5cclxuICAgICAgICAgICAgLy8gYnVmZmVyXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoayAqPSA3KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAwMDAwIGlzIDJeNDgsIDB4MTAwMDAwMDAwMDAgaXMgMl40MFxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwIGlzIDJeMzIsIDB4MTAwMDAwMCBpcyAyXjI0XHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgdiA9ICgoYVtpXSAmIDMxKSAqIDB4MTAwMDAwMDAwMDAwMCkgKyAoYVtpICsgMV0gKiAweDEwMDAwMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDJdICogMHgxMDAwMDAwMDApICsgKGFbaSArIDNdICogMHgxMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDRdIDw8IDE2KSArIChhW2kgKyA1XSA8PCA4KSArIGFbaSArIDZdO1xyXG5cclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weShhLCBpKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gNztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyA3O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQ1JZUFRPID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVc2UgTWF0aC5yYW5kb20uXHJcbiAgICAgICAgaWYgKCFDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcbiAgICAgICAgICAgIHYgPSByYW5kb201M2JpdEludCgpO1xyXG4gICAgICAgICAgICBpZiAodiA8IDllMTUpIGNbaSsrXSA9IHYgJSAxZTE0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgayA9IGNbLS1pXTtcclxuICAgICAgICBkcCAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIGRwLlxyXG4gICAgICAgIGlmIChrICYmIGRwKSB7XHJcbiAgICAgICAgICB2ID0gUE9XU19URU5bTE9HX0JBU0UgLSBkcF07XHJcbiAgICAgICAgICBjW2ldID0gbWF0aGZsb29yKGsgLyB2KSAqIHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICAgICAgZm9yICg7IGNbaV0gPT09IDA7IGMucG9wKCksIGktLSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICBjID0gW2UgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBmb3IgKGUgPSAtMSA7IGNbMF0gPT09IDA7IGMuc3BsaWNlKDAsIDEpLCBlIC09IExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIGMgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MsIGFuZC4uLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgLy8gYWRqdXN0IHRoZSBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGlmIChpIDwgTE9HX0JBU0UpIGUgLT0gTE9HX0JBU0UgLSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmFuZC5lID0gZTtcclxuICAgICAgICByYW5kLmMgPSBjO1xyXG4gICAgICAgIHJldHVybiByYW5kO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnN1bSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgc3VtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDspIHN1bSA9IHN1bS5wbHVzKGFyZ3NbaSsrXSk7XHJcbiAgICAgIHJldHVybiBzdW07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyBQUklWQVRFIEZVTkNUSU9OU1xyXG5cclxuXHJcbiAgICAvLyBDYWxsZWQgYnkgQmlnTnVtYmVyIGFuZCBCaWdOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nLlxyXG4gICAgY29udmVydEJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgZGVjaW1hbCA9ICcwMTIzNDU2Nzg5JztcclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICAqIENvbnZlcnQgc3RyaW5nIG9mIGJhc2VJbiB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGJhc2VPdXQuXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJzI1NScsIDEwLCAxNikgcmV0dXJucyBbMTUsIDE1XS5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBhbHBoYWJldCkge1xyXG4gICAgICAgIHZhciBqLFxyXG4gICAgICAgICAgYXJyID0gWzBdLFxyXG4gICAgICAgICAgYXJyTCxcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07IGFyclthcnJMXSAqPSBiYXNlSW4pO1xyXG5cclxuICAgICAgICAgIGFyclswXSArPSBhbHBoYWJldC5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XHJcblxyXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGFyci5sZW5ndGg7IGorKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFycltqICsgMV0gPT0gbnVsbCkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcclxuICAgICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnZlcnQgYSBudW1lcmljIHN0cmluZyBvZiBiYXNlSW4gdG8gYSBudW1lcmljIHN0cmluZyBvZiBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIHRvU3RyaW5nLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2UgMTAgdG8gYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyBCaWdOdW1iZXIsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZUluIHRvIGJhc2UgMTAuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIHNpZ24sIGNhbGxlcklzVG9TdHJpbmcpIHtcclxuICAgICAgICB2YXIgYWxwaGFiZXQsIGQsIGUsIGssIHIsIHgsIHhjLCB5LFxyXG4gICAgICAgICAgaSA9IHN0ci5pbmRleE9mKCcuJyksXHJcbiAgICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgICAgcm0gPSBST1VORElOR19NT0RFO1xyXG5cclxuICAgICAgICAvLyBOb24taW50ZWdlci5cclxuICAgICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgICBrID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgICAvLyBVbmxpbWl0ZWQgcHJlY2lzaW9uLlxyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDA7XHJcbiAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGJhc2VJbik7XHJcbiAgICAgICAgICB4ID0geS5wb3coc3RyLmxlbmd0aCAtIGkpO1xyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IGs7XHJcblxyXG4gICAgICAgICAgLy8gQ29udmVydCBzdHIgYXMgaWYgYW4gaW50ZWdlciwgdGhlbiByZXN0b3JlIHRoZSBmcmFjdGlvbiBwYXJ0IGJ5IGRpdmlkaW5nIHRoZVxyXG4gICAgICAgICAgLy8gcmVzdWx0IGJ5IGl0cyBiYXNlIHJhaXNlZCB0byBhIHBvd2VyLlxyXG5cclxuICAgICAgICAgIHkuYyA9IHRvQmFzZU91dCh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyh4LmMpLCB4LmUsICcwJyksXHJcbiAgICAgICAgICAgMTAsIGJhc2VPdXQsIGRlY2ltYWwpO1xyXG4gICAgICAgICAgeS5lID0geS5jLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIG51bWJlciBhcyBpbnRlZ2VyLlxyXG5cclxuICAgICAgICB4YyA9IHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgY2FsbGVySXNUb1N0cmluZ1xyXG4gICAgICAgICA/IChhbHBoYWJldCA9IEFMUEhBQkVULCBkZWNpbWFsKVxyXG4gICAgICAgICA6IChhbHBoYWJldCA9IGRlY2ltYWwsIEFMUEhBQkVUKSk7XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBhcyBhbiBpbnRlZ2VyIGFuZCBjb252ZXJ0ZWQgdG8gYmFzZU91dC4gZSBpcyB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgZSA9IGsgPSB4Yy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgeGNbLS1rXSA9PSAwOyB4Yy5wb3AoKSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSkgcmV0dXJuIGFscGhhYmV0LmNoYXJBdCgwKTtcclxuXHJcbiAgICAgICAgLy8gRG9lcyBzdHIgcmVwcmVzZW50IGFuIGludGVnZXI/IElmIHNvLCBubyBuZWVkIGZvciB0aGUgZGl2aXNpb24uXHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAtLWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguYyA9IHhjO1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgc2lnbiBpcyBuZWVkZWQgZm9yIGNvcnJlY3Qgcm91bmRpbmcuXHJcbiAgICAgICAgICB4LnMgPSBzaWduO1xyXG4gICAgICAgICAgeCA9IGRpdih4LCB5LCBkcCwgcm0sIGJhc2VPdXQpO1xyXG4gICAgICAgICAgeGMgPSB4LmM7XHJcbiAgICAgICAgICByID0geC5yO1xyXG4gICAgICAgICAgZSA9IHguZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBjb252ZXJ0ZWQgdG8gYmFzZU91dC5cclxuXHJcbiAgICAgICAgLy8gVEhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICBkID0gZSArIGRwICsgMTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0OiB0aGUgZGlnaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIGkgPSB4Y1tkXTtcclxuXHJcbiAgICAgICAgLy8gTG9vayBhdCB0aGUgcm91bmRpbmcgZGlnaXRzIGFuZCBtb2RlIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJvdW5kIHVwLlxyXG5cclxuICAgICAgICBrID0gYmFzZU91dCAvIDI7XHJcbiAgICAgICAgciA9IHIgfHwgZCA8IDAgfHwgeGNbZCArIDFdICE9IG51bGw7XHJcblxyXG4gICAgICAgIHIgPSBybSA8IDQgPyAoaSAhPSBudWxsIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgICAgIDogaSA+IGsgfHwgaSA9PSBrICYmKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmIHhjW2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG5vdCBncmVhdGVyIHRoYW4gemVybywgb3IgeGMgcmVwcmVzZW50c1xyXG4gICAgICAgIC8vIHplcm8sIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgYmFzZSBjb252ZXJzaW9uIGlzIHplcm8gb3IsIGlmIHJvdW5kaW5nIHVwLCBhIHZhbHVlXHJcbiAgICAgICAgLy8gc3VjaCBhcyAwLjAwMDAxLlxyXG4gICAgICAgIGlmIChkIDwgMSB8fCAheGNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyAxXi1kcCBvciAwXHJcbiAgICAgICAgICBzdHIgPSByID8gdG9GaXhlZFBvaW50KGFscGhhYmV0LmNoYXJBdCgxKSwgLWRwLCBhbHBoYWJldC5jaGFyQXQoMCkpIDogYWxwaGFiZXQuY2hhckF0KDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gVHJ1bmNhdGUgeGMgdG8gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgIHhjLmxlbmd0aCA9IGQ7XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICAgICAgZm9yICgtLWJhc2VPdXQ7ICsreGNbLS1kXSA+IGJhc2VPdXQ7KSB7XHJcbiAgICAgICAgICAgICAgeGNbZF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoIWQpIHtcclxuICAgICAgICAgICAgICAgICsrZTtcclxuICAgICAgICAgICAgICAgIHhjID0gWzFdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChrID0geGMubGVuZ3RoOyAheGNbLS1rXTspO1xyXG5cclxuICAgICAgICAgIC8vIEUuZy4gWzQsIDExLCAxNV0gYmVjb21lcyA0YmYuXHJcbiAgICAgICAgICBmb3IgKGkgPSAwLCBzdHIgPSAnJzsgaSA8PSBrOyBzdHIgKz0gYWxwaGFiZXQuY2hhckF0KHhjW2krK10pKTtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvcywgZGVjaW1hbCBwb2ludCBhbmQgdHJhaWxpbmcgemVyb3MgYXMgcmVxdWlyZWQuXHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIGFkZCB0aGUgc2lnbi5cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLy8gUGVyZm9ybSBkaXZpc2lvbiBpbiB0aGUgc3BlY2lmaWVkIGJhc2UuIENhbGxlZCBieSBkaXYgYW5kIGNvbnZlcnRCYXNlLlxyXG4gICAgZGl2ID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgIC8vIEFzc3VtZSBub24temVybyB4IGFuZCBrLlxyXG4gICAgICBmdW5jdGlvbiBtdWx0aXBseSh4LCBrLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIG0sIHRlbXAsIHhsbywgeGhpLFxyXG4gICAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgICAgaSA9IHgubGVuZ3RoLFxyXG4gICAgICAgICAga2xvID0gayAlIFNRUlRfQkFTRSxcclxuICAgICAgICAgIGtoaSA9IGsgLyBTUVJUX0JBU0UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTspIHtcclxuICAgICAgICAgIHhsbyA9IHhbaV0gJSBTUVJUX0JBU0U7XHJcbiAgICAgICAgICB4aGkgPSB4W2ldIC8gU1FSVF9CQVNFIHwgMDtcclxuICAgICAgICAgIG0gPSBraGkgKiB4bG8gKyB4aGkgKiBrbG87XHJcbiAgICAgICAgICB0ZW1wID0ga2xvICogeGxvICsgKChtICUgU1FSVF9CQVNFKSAqIFNRUlRfQkFTRSkgKyBjYXJyeTtcclxuICAgICAgICAgIGNhcnJ5ID0gKHRlbXAgLyBiYXNlIHwgMCkgKyAobSAvIFNRUlRfQkFTRSB8IDApICsga2hpICogeGhpO1xyXG4gICAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNhcnJ5KSB4ID0gW2NhcnJ5XS5jb25jYXQoeCk7XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xyXG4gICAgICAgIHZhciBpLCBjbXA7XHJcblxyXG4gICAgICAgIGlmIChhTCAhPSBiTCkge1xyXG4gICAgICAgICAgY21wID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGZvciAoaSA9IGNtcCA9IDA7IGkgPCBhTDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XHJcbiAgICAgICAgICAgICAgY21wID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGFMLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cclxuICAgICAgICBmb3IgKDsgYUwtLTspIHtcclxuICAgICAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xyXG4gICAgICAgICAgYVthTF0gPSBpICogYmFzZSArIGFbYUxdIC0gYlthTF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOyBhLnNwbGljZSgwLCAxKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHg6IGRpdmlkZW5kLCB5OiBkaXZpc29yLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHksIGRwLCBybSwgYmFzZSkge1xyXG4gICAgICAgIHZhciBjbXAsIGUsIGksIG1vcmUsIG4sIHByb2QsIHByb2RMLCBxLCBxYywgcmVtLCByZW1MLCByZW0wLCB4aSwgeEwsIHljMCxcclxuICAgICAgICAgIHlMLCB5eixcclxuICAgICAgICAgIHMgPSB4LnMgPT0geS5zID8gMSA6IC0xLFxyXG4gICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIE5hTiwgSW5maW5pdHkgb3IgMD9cclxuICAgICAgICBpZiAoIXhjIHx8ICF4Y1swXSB8fCAheWMgfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoXHJcblxyXG4gICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YykgPyBOYU4gOlxyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIMKxMCBvciB5IGlzIMKxSW5maW5pdHksIG9yIHJldHVybiDCsUluZmluaXR5IGFzIHkgaXMgwrEwLlxyXG4gICAgICAgICAgICB4YyAmJiB4Y1swXSA9PSAwIHx8ICF5YyA/IHMgKiAwIDogcyAvIDBcclxuICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHEgPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG4gICAgICAgIHFjID0gcS5jID0gW107XHJcbiAgICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgICAgICBzID0gZHAgKyBlICsgMTtcclxuXHJcbiAgICAgICAgaWYgKCFiYXNlKSB7XHJcbiAgICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgLSBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgICAgICBzID0gcyAvIExPR19CQVNFIHwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc3VsdCBleHBvbmVudCBtYXkgYmUgb25lIGxlc3MgdGhlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiBlLlxyXG4gICAgICAgIC8vIFRoZSBjb2VmZmljaWVudHMgb2YgdGhlIEJpZ051bWJlcnMgZnJvbSBjb252ZXJ0QmFzZSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGkgPSAwOyB5Y1tpXSA9PSAoeGNbaV0gfHwgMCk7IGkrKyk7XHJcblxyXG4gICAgICAgIGlmICh5Y1tpXSA+ICh4Y1tpXSB8fCAwKSkgZS0tO1xyXG5cclxuICAgICAgICBpZiAocyA8IDApIHtcclxuICAgICAgICAgIHFjLnB1c2goMSk7XHJcbiAgICAgICAgICBtb3JlID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgcyArPSAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vcm1hbGlzZSB4YyBhbmQgeWMgc28gaGlnaGVzdCBvcmRlciBkaWdpdCBvZiB5YyBpcyA+PSBiYXNlIC8gMi5cclxuXHJcbiAgICAgICAgICBuID0gbWF0aGZsb29yKGJhc2UgLyAoeWNbMF0gKyAxKSk7XHJcblxyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKGJhc2UgLyAyKSAtIDEuXHJcbiAgICAgICAgICAvLyBpZiAobiA+IDEgfHwgbisrID09IDEgJiYgeWNbMF0gPCBiYXNlIC8gMikge1xyXG4gICAgICAgICAgaWYgKG4gPiAxKSB7XHJcbiAgICAgICAgICAgIHljID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB4YyA9IG11bHRpcGx5KHhjLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHhpID0geUw7XHJcbiAgICAgICAgICByZW0gPSB4Yy5zbGljZSgwLCB5TCk7XHJcbiAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gICAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwKTtcclxuICAgICAgICAgIHl6ID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgIHl6ID0gWzBdLmNvbmNhdCh5eik7XHJcbiAgICAgICAgICB5YzAgPSB5Y1swXTtcclxuICAgICAgICAgIGlmICh5Y1sxXSA+PSBiYXNlIC8gMikgeWMwKys7XHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gcHJldmVudCB0cmlhbCBkaWdpdCBuID4gYmFzZSwgd2hlbiB1c2luZyBiYXNlIDMuXHJcbiAgICAgICAgICAvLyBlbHNlIGlmIChiYXNlID09IDMgJiYgeWMwID09IDEpIHljMCA9IDEgKyAxZS0xNTtcclxuXHJcbiAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIG4gPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBuLlxyXG5cclxuICAgICAgICAgICAgICByZW0wID0gcmVtWzBdO1xyXG4gICAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgICAvLyBuIGlzIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byB0aGUgY3VycmVudCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vcihyZW0wIC8geWMwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gIEFsZ29yaXRobTpcclxuICAgICAgICAgICAgICAvLyAgcHJvZHVjdCA9IGRpdmlzb3IgbXVsdGlwbGllZCBieSB0cmlhbCBkaWdpdCAobikuXHJcbiAgICAgICAgICAgICAgLy8gIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IGlzIGdyZWF0ZXIgdGhhbiByZW1haW5kZXI6XHJcbiAgICAgICAgICAgICAgLy8gICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QsIGRlY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAvLyAgU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCB3YXMgbGVzcyB0aGFuIHJlbWFpbmRlciBhdCB0aGUgbGFzdCBjb21wYXJlOlxyXG4gICAgICAgICAgICAgIC8vICAgIENvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvci5cclxuICAgICAgICAgICAgICAvLyAgICBJZiByZW1haW5kZXIgaXMgZ3JlYXRlciB0aGFuIGRpdmlzb3I6XHJcbiAgICAgICAgICAgICAgLy8gICAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLCBpbmNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcblxyXG4gICAgICAgICAgICAgIGlmIChuID4gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gbWF5IGJlID4gYmFzZSBvbmx5IHdoZW4gYmFzZSBpcyAzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPj0gYmFzZSkgbiA9IGJhc2UgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlciB0aGVuIHRyaWFsIGRpZ2l0IG4gdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGhpZ2ggYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCBpcyBub3Qga25vd24gdG8gaGF2ZVxyXG4gICAgICAgICAgICAgICAgLy8gZXZlciBiZWVuIG1vcmUgdGhhbiAxIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICBuLS07XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdC5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgY21wID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMCBvciAxLCBjbXAgaXMgLTEuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgICAgLy8gc28gY2hhbmdlIGNtcCB0byAxIHRvIGF2b2lkIGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAxLCBsZWF2ZSBjbXAgYXMgLTEsIHNvIHljIGFuZCByZW0gYXJlIGNvbXBhcmVkIGFnYWluLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gZGl2aXNvciA8IHJlbWFpbmRlciwgc28gbiBtdXN0IGJlIGF0IGxlYXN0IDEuXHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IG4gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yXHJcbiAgICAgICAgICAgICAgICBwcm9kID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKSBwcm9kID0gWzBdLmNvbmNhdChwcm9kKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHByb2QsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgbmV3IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gVHJpYWwgZGlnaXQgbiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBsb3cgYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCB2ZXJ5IHJhcmVseSAyIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4rKztcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5YywgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgICB9IC8vIGVsc2UgY21wID09PSAxIGFuZCBuIHdpbGwgYmUgMFxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXh0IGRpZ2l0LCBuLCB0byB0aGUgcmVzdWx0IGFycmF5LlxyXG4gICAgICAgICAgICBxY1tpKytdID0gbjtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAocmVtWzBdKSB7XHJcbiAgICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZW0gPSBbeGNbeGldXTtcclxuICAgICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT0gbnVsbCkgJiYgcy0tKTtcclxuXHJcbiAgICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gTGVhZGluZyB6ZXJvP1xyXG4gICAgICAgICAgaWYgKCFxY1swXSkgcWMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJhc2UgPT0gQkFTRSkge1xyXG5cclxuICAgICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBxLmUsIGZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBxY1swXS5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICByb3VuZChxLCBkcCArIChxLmUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgKyAxLCBybSwgbW9yZSk7XHJcblxyXG4gICAgICAgIC8vIENhbGxlciBpcyBjb252ZXJ0QmFzZS5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcS5lID0gZTtcclxuICAgICAgICAgIHEuciA9ICttb3JlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyIG4gaW4gZml4ZWQtcG9pbnQgb3IgZXhwb25lbnRpYWxcclxuICAgICAqIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvciBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgKlxyXG4gICAgICogbjogYSBCaWdOdW1iZXIuXHJcbiAgICAgKiBpOiB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZGlnaXQgcmVxdWlyZWQgKGkuZS4gdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXApLlxyXG4gICAgICogcm06IHRoZSByb3VuZGluZyBtb2RlLlxyXG4gICAgICogaWQ6IDEgKHRvRXhwb25lbnRpYWwpIG9yIDIgKHRvUHJlY2lzaW9uKS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0KG4sIGksIHJtLCBpZCkge1xyXG4gICAgICB2YXIgYzAsIGUsIG5lLCBsZW4sIHN0cjtcclxuXHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgaWYgKCFuLmMpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBjMCA9IG4uY1swXTtcclxuICAgICAgbmUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoaSA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIHN0ciA9IGlkID09IDEgfHwgaWQgPT0gMiAmJiAobmUgPD0gVE9fRVhQX05FRyB8fCBuZSA+PSBUT19FWFBfUE9TKVxyXG4gICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBuZSlcclxuICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBuZSwgJzAnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgaSwgcm0pO1xyXG5cclxuICAgICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIHRvUHJlY2lzaW9uIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAgICAvLyBzcGVjaWZpZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcclxuICAgICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgaWYgKGlkID09IDEgfHwgaWQgPT0gMiAmJiAoaSA8PSBlIHx8IGUgPD0gVE9fRVhQX05FRykpIHtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBmb3IgKDsgbGVuIDwgaTsgc3RyICs9ICcwJywgbGVuKyspO1xyXG4gICAgICAgICAgc3RyID0gdG9FeHBvbmVudGlhbChzdHIsIGUpO1xyXG5cclxuICAgICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSAtPSBuZTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgaWYgKGUgKyAxID4gbGVuKSB7XHJcbiAgICAgICAgICAgIGlmICgtLWkgPiAwKSBmb3IgKHN0ciArPSAnLic7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpICs9IGUgLSBsZW47XHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgIGlmIChlICsgMSA9PSBsZW4pIHN0ciArPSAnLic7XHJcbiAgICAgICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwICYmIGMwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgQmlnTnVtYmVyLm1heCBhbmQgQmlnTnVtYmVyLm1pbi5cclxuICAgIGZ1bmN0aW9uIG1heE9yTWluKGFyZ3MsIG1ldGhvZCkge1xyXG4gICAgICB2YXIgbixcclxuICAgICAgICBpID0gMSxcclxuICAgICAgICBtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuXHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbaV0pO1xyXG5cclxuICAgICAgICAvLyBJZiBhbnkgbnVtYmVyIGlzIE5hTiwgcmV0dXJuIE5hTi5cclxuICAgICAgICBpZiAoIW4ucykge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZC5jYWxsKG0sIG4pKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICAgKiBDYWxsZWQgYnkgbWludXMsIHBsdXMgYW5kIHRpbWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpc2UobiwgYywgZSkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7ICFjWy0tal07IGMucG9wKCkpO1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgZm9yIChqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoKGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgIG4uYyA9IG4uZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICBuLmMgPSBbbi5lID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbi5lID0gZTtcclxuICAgICAgICBuLmMgPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gICAgcGFyc2VOdW1lcmljID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLFxyXG4gICAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgICAgZG90QmVmb3JlID0gL15cXC4oW14uXSspJC8sXHJcbiAgICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgc3RyLCBpc051bSwgYikge1xyXG4gICAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgICAgcyA9IGlzTnVtID8gc3RyIDogc3RyLnJlcGxhY2Uod2hpdGVzcGFjZU9yUGx1cywgJycpO1xyXG5cclxuICAgICAgICAvLyBObyBleGNlcHRpb24gb24gwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgICAgaWYgKGlzSW5maW5pdHlPck5hTi50ZXN0KHMpKSB7XHJcbiAgICAgICAgICB4LnMgPSBpc05hTihzKSA/IG51bGwgOiBzIDwgMCA/IC0xIDogMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCFpc051bSkge1xyXG5cclxuICAgICAgICAgICAgLy8gYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2lcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShiYXNlUHJlZml4LCBmdW5jdGlvbiAobSwgcDEsIHAyKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IChwMiA9IHAyLnRvTG93ZXJDYXNlKCkpID09ICd4JyA/IDE2IDogcDIgPT0gJ2InID8gMiA6IDg7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICFiIHx8IGIgPT0gYmFzZSA/IHAxIDogbTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSBiO1xyXG5cclxuICAgICAgICAgICAgICAvLyBFLmcuICcxLicgdG8gJzEnLCAnLjEnIHRvICcwLjEnXHJcbiAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShkb3RBZnRlciwgJyQxJykucmVwbGFjZShkb3RCZWZvcmUsICcwLiQxJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzdHIgIT0gcykgcmV0dXJuIG5ldyBCaWdOdW1iZXIocywgYmFzZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIG51bWJlcjoge259J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIGJhc2Uge2J9IG51bWJlcjoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRykge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdOb3QgYScgKyAoYiA/ICcgYmFzZSAnICsgYiA6ICcnKSArICcgbnVtYmVyOiAnICsgc3RyKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBOYU5cclxuICAgICAgICAgIHgucyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUm91bmQgeCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybS4gQ2hlY2sgZm9yIG92ZXIvdW5kZXItZmxvdy5cclxuICAgICAqIElmIHIgaXMgdHJ1dGh5LCBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGFyZSBtb3JlIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJvdW5kKHgsIHNkLCBybSwgcikge1xyXG4gICAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHBvd3MxMCA9IFBPV1NfVEVOO1xyXG5cclxuICAgICAgLy8gaWYgeCBpcyBub3QgSW5maW5pdHkgb3IgTmFOLi4uXHJcbiAgICAgIGlmICh4Yykge1xyXG5cclxuICAgICAgICAvLyByZCBpcyB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXHJcbiAgICAgICAgLy8gbmkgaXMgdGhlIGluZGV4IG9mIG4gd2l0aGluIHguYy5cclxuICAgICAgICAvLyBkIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgLy8gaiBpcyB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiBuIChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuICAgICAgICBvdXQ6IHtcclxuXHJcbiAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuXHJcbiAgICAgICAgICBmb3IgKGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcbiAgICAgICAgICBpID0gc2QgLSBkO1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgIGogPSBzZDtcclxuICAgICAgICAgICAgbiA9IHhjW25pID0gMF07XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgcmQgPSBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuaSA9IG1hdGhjZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgICBpZiAobmkgPj0geGMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTmVlZGVkIGJ5IHNxcnQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgeGMubGVuZ3RoIDw9IG5pOyB4Yy5wdXNoKDApKTtcclxuICAgICAgICAgICAgICAgIG4gPSByZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBkID0gMTtcclxuICAgICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBuID0gayA9IHhjW25pXTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgICAgICAgZm9yIChkID0gMTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbi5cclxuICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLCBhZGp1c3RlZCBmb3IgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgbiBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGQuXHJcbiAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIGQ7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgciA9IHIgfHwgc2QgPCAwIHx8XHJcblxyXG4gICAgICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gIG4gJSBwb3dzMTBbZCAtIGogLSAxXSAgcmV0dXJucyBhbGwgZGlnaXRzIG9mIG4gdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAvLyBvZiB0aGUgZGlnaXQgYXQgaiwgZS5nLiBpZiBuIGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvbiBnaXZlcyA3MTQuXHJcbiAgICAgICAgICAgeGNbbmkgKyAxXSAhPSBudWxsIHx8IChqIDwgMCA/IG4gOiBuICUgcG93czEwW2QgLSBqIC0gMV0pO1xyXG5cclxuICAgICAgICAgIHIgPSBybSA8IDRcclxuICAgICAgICAgICA/IChyZCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAgICAgKChpID4gMCA/IGogPiAwID8gbiAvIHBvd3MxMFtkIC0gal0gOiAwIDogeGNbbmkgLSAxXSkgJSAxMCkgJiAxIHx8XHJcbiAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgICAgaWYgKHNkIDwgMSB8fCAheGNbMF0pIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHBvd3MxMFsoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFXTtcclxuICAgICAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaTtcclxuICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgIG5pLS07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaSArIDE7XHJcbiAgICAgICAgICAgIGsgPSBwb3dzMTBbTE9HX0JBU0UgLSBpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4uXHJcbiAgICAgICAgICAgIHhjW25pXSA9IGogPiAwID8gbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGpdICUgcG93czEwW2pdKSAqIGsgOiAwO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICAgICAgaWYgKG5pID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuICAgICAgICAgICAgICAgIGogPSB4Y1swXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCwgaysrKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gaykge1xyXG4gICAgICAgICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgICAgICAgaWYgKHhjWzBdID09IEJBU0UpIHhjWzBdID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeGNbbmldICs9IGs7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGNbbmldICE9IEJBU0UpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgeGNbbmktLV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdmVyZmxvdz8gSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz8gWmVyby5cclxuICAgICAgICB9IGVsc2UgaWYgKHguZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB2YWx1ZU9mKG4pIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcblxyXG4gICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgZSlcclxuICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUFJPVE9UWVBFL0lOU1RBTkNFIE1FVEhPRFNcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuXHJcbiAgICAgKiAgIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gICAgICogICBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgICovXHJcbiAgICBQLmNvbXBhcmVkVG8gPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBkcCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGVcclxuICAgICAqIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIGRwIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2YgZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzOiBpbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgbiA9ICgodiA9IGMubGVuZ3RoIC0gMSkgLSBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IG51bWJlci5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcbiAgICAgIGlmIChuIDwgMCkgbiA9IDA7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAvIDAgPSBJXHJcbiAgICAgKiAgbiAvIE4gPSBOXHJcbiAgICAgKiAgbiAvIEkgPSAwXHJcbiAgICAgKiAgMCAvIG4gPSAwXHJcbiAgICAgKiAgMCAvIDAgPSBOXHJcbiAgICAgKiAgMCAvIE4gPSBOXHJcbiAgICAgKiAgMCAvIEkgPSAwXHJcbiAgICAgKiAgTiAvIG4gPSBOXHJcbiAgICAgKiAgTiAvIDAgPSBOXHJcbiAgICAgKiAgTiAvIE4gPSBOXHJcbiAgICAgKiAgTiAvIEkgPSBOXHJcbiAgICAgKiAgSSAvIG4gPSBJXHJcbiAgICAgKiAgSSAvIDAgPSBJXHJcbiAgICAgKiAgSSAvIE4gPSBOXHJcbiAgICAgKiAgSSAvIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciBieSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuaWRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgMCwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBleHBvbmVudGlhdGVkIGJ5IG4uXHJcbiAgICAgKlxyXG4gICAgICogSWYgbSBpcyBwcmVzZW50LCByZXR1cm4gdGhlIHJlc3VsdCBtb2R1bG8gbS5cclxuICAgICAqIElmIG4gaXMgbmVnYXRpdmUgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICogSWYgUE9XX1BSRUNJU0lPTiBpcyBub24temVybyBhbmQgbSBpcyBub3QgcHJlc2VudCwgcm91bmQgdG8gUE9XX1BSRUNJU0lPTiB1c2luZyBST1VORElOR19NT0RFLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBtb2R1bGFyIHBvd2VyIG9wZXJhdGlvbiB3b3JrcyBlZmZpY2llbnRseSB3aGVuIHgsIG4sIGFuZCBtIGFyZSBpbnRlZ2Vycywgb3RoZXJ3aXNlIGl0XHJcbiAgICAgKiBpcyBlcXVpdmFsZW50IHRvIGNhbGN1bGF0aW5nIHguZXhwb25lbnRpYXRlZEJ5KG4pLm1vZHVsbyhtKSB3aXRoIGEgUE9XX1BSRUNJU0lPTiBvZiAwLlxyXG4gICAgICpcclxuICAgICAqIG4ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgZXhwb25lbnQuIEFuIGludGVnZXIuXHJcbiAgICAgKiBbbV0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgbW9kdWx1cy5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gRXhwb25lbnQgbm90IGFuIGludGVnZXI6IHtufSdcclxuICAgICAqL1xyXG4gICAgUC5leHBvbmVudGlhdGVkQnkgPSBQLnBvdyA9IGZ1bmN0aW9uIChuLCBtKSB7XHJcbiAgICAgIHZhciBoYWxmLCBpc01vZEV4cCwgaSwgaywgbW9yZSwgbklzQmlnLCBuSXNOZWcsIG5Jc09kZCwgeSxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG5cclxuICAgICAgLy8gQWxsb3cgTmFOIGFuZCDCsUluZmluaXR5LCBidXQgbm90IG90aGVyIG5vbi1pbnRlZ2Vycy5cclxuICAgICAgaWYgKG4uYyAmJiAhbi5pc0ludGVnZXIoKSkge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnRXhwb25lbnQgbm90IGFuIGludGVnZXI6ICcgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG0gIT0gbnVsbCkgbSA9IG5ldyBCaWdOdW1iZXIobSk7XHJcblxyXG4gICAgICAvLyBFeHBvbmVudCBvZiBNQVhfU0FGRV9JTlRFR0VSIGlzIDE1LlxyXG4gICAgICBuSXNCaWcgPSBuLmUgPiAxNDtcclxuXHJcbiAgICAgIC8vIElmIHggaXMgTmFOLCDCsUluZmluaXR5LCDCsTAgb3IgwrExLCBvciBuIGlzIMKxSW5maW5pdHksIE5hTiBvciDCsTAuXHJcbiAgICAgIGlmICgheC5jIHx8ICF4LmNbMF0gfHwgeC5jWzBdID09IDEgJiYgIXguZSAmJiB4LmMubGVuZ3RoID09IDEgfHwgIW4uYyB8fCAhbi5jWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzaWduIG9mIHRoZSByZXN1bHQgb2YgcG93IHdoZW4geCBpcyBuZWdhdGl2ZSBkZXBlbmRzIG9uIHRoZSBldmVubmVzcyBvZiBuLlxyXG4gICAgICAgIC8vIElmICtuIG92ZXJmbG93cyB0byDCsUluZmluaXR5LCB0aGUgZXZlbm5lc3Mgb2YgbiB3b3VsZCBiZSBub3QgYmUga25vd24uXHJcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoTWF0aC5wb3coK3ZhbHVlT2YoeCksIG5Jc0JpZyA/IDIgLSBpc09kZChuKSA6ICt2YWx1ZU9mKG4pKSk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5Jc05lZyA9IG4ucyA8IDA7XHJcblxyXG4gICAgICBpZiAobSkge1xyXG5cclxuICAgICAgICAvLyB4ICUgbSByZXR1cm5zIE5hTiBpZiBhYnMobSkgaXMgemVybywgb3IgbSBpcyBOYU4uXHJcbiAgICAgICAgaWYgKG0uYyA/ICFtLmNbMF0gOiAhbS5zKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgICBpc01vZEV4cCA9ICFuSXNOZWcgJiYgeC5pc0ludGVnZXIoKSAmJiBtLmlzSW50ZWdlcigpO1xyXG5cclxuICAgICAgICBpZiAoaXNNb2RFeHApIHggPSB4Lm1vZChtKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93IHRvIMKxSW5maW5pdHk6ID49MioqMWUxMCBvciA+PTEuMDAwMDAyNCoqMWUxNS5cclxuICAgICAgLy8gVW5kZXJmbG93IHRvIMKxMDogPD0wLjc5KioxZTEwIG9yIDw9MC45OTk5OTc1KioxZTE1LlxyXG4gICAgICB9IGVsc2UgaWYgKG4uZSA+IDkgJiYgKHguZSA+IDAgfHwgeC5lIDwgLTEgfHwgKHguZSA9PSAwXHJcbiAgICAgICAgLy8gWzEsIDI0MDAwMDAwMF1cclxuICAgICAgICA/IHguY1swXSA+IDEgfHwgbklzQmlnICYmIHguY1sxXSA+PSAyNGU3XHJcbiAgICAgICAgLy8gWzgwMDAwMDAwMDAwMDAwXSAgWzk5OTk5NzUwMDAwMDAwXVxyXG4gICAgICAgIDogeC5jWzBdIDwgOGUxMyB8fCBuSXNCaWcgJiYgeC5jWzBdIDw9IDk5OTk5NzVlNykpKSB7XHJcblxyXG4gICAgICAgIC8vIElmIHggaXMgbmVnYXRpdmUgYW5kIG4gaXMgb2RkLCBrID0gLTAsIGVsc2UgayA9IDAuXHJcbiAgICAgICAgayA9IHgucyA8IDAgJiYgaXNPZGQobikgPyAtMCA6IDA7XHJcblxyXG4gICAgICAgIC8vIElmIHggPj0gMSwgayA9IMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IC0xKSBrID0gMSAvIGs7XHJcblxyXG4gICAgICAgIC8vIElmIG4gaXMgbmVnYXRpdmUgcmV0dXJuIMKxMCwgZWxzZSByZXR1cm4gwrFJbmZpbml0eS5cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihuSXNOZWcgPyAxIC8gayA6IGspO1xyXG5cclxuICAgICAgfSBlbHNlIGlmIChQT1dfUFJFQ0lTSU9OKSB7XHJcblxyXG4gICAgICAgIC8vIFRydW5jYXRpbmcgZWFjaCBjb2VmZmljaWVudCBhcnJheSB0byBhIGxlbmd0aCBvZiBrIGFmdGVyIGVhY2ggbXVsdGlwbGljYXRpb25cclxuICAgICAgICAvLyBlcXVhdGVzIHRvIHRydW5jYXRpbmcgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIFBPV19QUkVDSVNJT04gKyBbMjgsIDQxXSxcclxuICAgICAgICAvLyBpLmUuIHRoZXJlIHdpbGwgYmUgYSBtaW5pbXVtIG9mIDI4IGd1YXJkIGRpZ2l0cyByZXRhaW5lZC5cclxuICAgICAgICBrID0gbWF0aGNlaWwoUE9XX1BSRUNJU0lPTiAvIExPR19CQVNFICsgMik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChuSXNCaWcpIHtcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcigwLjUpO1xyXG4gICAgICAgIGlmIChuSXNOZWcpIG4ucyA9IDE7XHJcbiAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaSA9IE1hdGguYWJzKCt2YWx1ZU9mKG4pKTtcclxuICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgIC8vIFBlcmZvcm1zIDU0IGxvb3AgaXRlcmF0aW9ucyBmb3IgbiBvZiA5MDA3MTk5MjU0NzQwOTkxLlxyXG4gICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICBpZiAobklzT2RkKSB7XHJcbiAgICAgICAgICB5ID0geS50aW1lcyh4KTtcclxuICAgICAgICAgIGlmICgheS5jKSBicmVhaztcclxuXHJcbiAgICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgICBpZiAoeS5jLmxlbmd0aCA+IGspIHkuYy5sZW5ndGggPSBrO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgICB5ID0geS5tb2QobSk7ICAgIC8veSA9IHkubWludXMoZGl2KHksIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaSkge1xyXG4gICAgICAgICAgaSA9IG1hdGhmbG9vcihpIC8gMik7XHJcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IG4udGltZXMoaGFsZik7XHJcbiAgICAgICAgICByb3VuZChuLCBuLmUgKyAxLCAxKTtcclxuXHJcbiAgICAgICAgICBpZiAobi5lID4gMTQpIHtcclxuICAgICAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpID0gK3ZhbHVlT2Yobik7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4ID0geC50aW1lcyh4KTtcclxuXHJcbiAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgIGlmICh4LmMgJiYgeC5jLmxlbmd0aCA+IGspIHguYy5sZW5ndGggPSBrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgIHggPSB4Lm1vZChtKTsgICAgLy94ID0geC5taW51cyhkaXYoeCwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc01vZEV4cCkgcmV0dXJuIHk7XHJcbiAgICAgIGlmIChuSXNOZWcpIHkgPSBPTkUuZGl2KHkpO1xyXG5cclxuICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IGsgPyByb3VuZCh5LCBQT1dfUFJFQ0lTSU9OLCBST1VORElOR19NT0RFLCBtb3JlKSA6IHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhbiBpbnRlZ2VyXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7cm19J1xyXG4gICAgICovXHJcbiAgICBQLmludGVnZXJWYWx1ZSA9IGZ1bmN0aW9uIChybSkge1xyXG4gICAgICB2YXIgbiA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG4gICAgICByZXR1cm4gcm91bmQobiwgbi5lICsgMSwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0VxdWFsVG8gPSBQLmVxID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGEgZmluaXRlIG51bWJlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gMSB8fCBiID09PSAwO1xyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYW4gaW50ZWdlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0ludGVnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkgPiB0aGlzLmMubGVuZ3RoIC0gMjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW4gPSBQLmx0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IC0xIHx8IGIgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIE5hTiwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05hTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICF0aGlzLnM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIG5lZ2F0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBwb3NpdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiB0aGlzLmNbMF0gPT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAtIDAgPSBuXHJcbiAgICAgKiAgbiAtIE4gPSBOXHJcbiAgICAgKiAgbiAtIEkgPSAtSVxyXG4gICAgICogIDAgLSBuID0gLW5cclxuICAgICAqICAwIC0gMCA9IDBcclxuICAgICAqICAwIC0gTiA9IE5cclxuICAgICAqICAwIC0gSSA9IC1JXHJcbiAgICAgKiAgTiAtIG4gPSBOXHJcbiAgICAgKiAgTiAtIDAgPSBOXHJcbiAgICAgKiAgTiAtIE4gPSBOXHJcbiAgICAgKiAgTiAtIEkgPSBOXHJcbiAgICAgKiAgSSAtIG4gPSBJXHJcbiAgICAgKiAgSSAtIDAgPSBJXHJcbiAgICAgKiAgSSAtIE4gPSBOXHJcbiAgICAgKiAgSSAtIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbWludXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubWludXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgaSwgaiwgdCwgeExUeSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4geGMgPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih5YyA/IHggOiBOYU4pO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgICAgcmV0dXJuIHljWzBdID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDpcclxuXHJcbiAgICAgICAgICAgLy8gSUVFRSA3NTQgKDIwMDgpIDYuMzogbiAtIG4gPSAtMCB3aGVuIHJvdW5kaW5nIHRvIC1JbmZpbml0eVxyXG4gICAgICAgICAgIFJPVU5ESU5HX01PREUgPT0gMyA/IC0wIDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBpcyB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcblxyXG4gICAgICAgIGlmICh4TFR5ID0gYSA8IDApIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAgICAgICBmb3IgKGIgPSBhOyBiLS07IHQucHVzaCgwKSk7XHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50cyBlcXVhbC4gQ2hlY2sgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICAgICAgaiA9ICh4TFR5ID0gKGEgPSB4Yy5sZW5ndGgpIDwgKGIgPSB5Yy5sZW5ndGgpKSA/IGEgOiBiO1xyXG5cclxuICAgICAgICBmb3IgKGEgPSBiID0gMDsgYiA8IGo7IGIrKykge1xyXG5cclxuICAgICAgICAgIGlmICh4Y1tiXSAhPSB5Y1tiXSkge1xyXG4gICAgICAgICAgICB4TFR5ID0geGNbYl0gPCB5Y1tiXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4IDwgeT8gUG9pbnQgeGMgdG8gdGhlIGFycmF5IG9mIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoeExUeSkge1xyXG4gICAgICAgIHQgPSB4YztcclxuICAgICAgICB4YyA9IHljO1xyXG4gICAgICAgIHljID0gdDtcclxuICAgICAgICB5LnMgPSAteS5zO1xyXG4gICAgICB9ICBcclxuXHJcbiAgICAgIGIgPSAoaiA9IHljLmxlbmd0aCkgLSAoaSA9IHhjLmxlbmd0aCk7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci5cclxuICAgICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgICAgaWYgKGIgPiAwKSBmb3IgKDsgYi0tOyB4Y1tpKytdID0gMCk7XHJcbiAgICAgIGIgPSBCQVNFIC0gMTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICAgIGZvciAoOyBqID4gYTspIHtcclxuXHJcbiAgICAgICAgaWYgKHhjWy0tal0gPCB5Y1tqXSkge1xyXG4gICAgICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiKTtcclxuICAgICAgICAgIC0teGNbaV07XHJcbiAgICAgICAgICB4Y1tqXSArPSBCQVNFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGNbal0gLT0geWNbal07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgIGZvciAoOyB4Y1swXSA9PSAwOyB4Yy5zcGxpY2UoMCwgMSksIC0teWUpO1xyXG5cclxuICAgICAgLy8gWmVybz9cclxuICAgICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBGb2xsb3dpbmcgSUVFRSA3NTQgKDIwMDgpIDYuMyxcclxuICAgICAgICAvLyBuIC0gbiA9ICswICBidXQgIG4gLSBuID0gLTAgIHdoZW4gcm91bmRpbmcgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICAgIHkuYyA9IFt5LmUgPSAwXTtcclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgSW5maW5pdHkgYXMgK3ggLSAreSAhPSBJbmZpbml0eSAmJiAteCAtIC15ICE9IEluZmluaXR5XHJcbiAgICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICAgbiAlIDAgPSAgTlxyXG4gICAgICogICBuICUgTiA9ICBOXHJcbiAgICAgKiAgIG4gJSBJID0gIG5cclxuICAgICAqICAgMCAlIG4gPSAgMFxyXG4gICAgICogIC0wICUgbiA9IC0wXHJcbiAgICAgKiAgIDAgJSAwID0gIE5cclxuICAgICAqICAgMCAlIE4gPSAgTlxyXG4gICAgICogICAwICUgSSA9ICAwXHJcbiAgICAgKiAgIE4gJSBuID0gIE5cclxuICAgICAqICAgTiAlIDAgPSAgTlxyXG4gICAgICogICBOICUgTiA9ICBOXHJcbiAgICAgKiAgIE4gJSBJID0gIE5cclxuICAgICAqICAgSSAlIG4gPSAgTlxyXG4gICAgICogICBJICUgMCA9ICBOXHJcbiAgICAgKiAgIEkgJSBOID0gIE5cclxuICAgICAqICAgSSAlIEkgPSAgTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1vZHVsbyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBxLCBzLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgICBpZiAoIXguYyB8fCAheS5zIHx8IHkuYyAmJiAheS5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxyXG4gICAgICB9IGVsc2UgaWYgKCF5LmMgfHwgeC5jICYmICF4LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKE1PRFVMT19NT0RFID09IDkpIHtcclxuXHJcbiAgICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgICAgcyA9IHkucztcclxuICAgICAgICB5LnMgPSAxO1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgMyk7XHJcbiAgICAgICAgeS5zID0gcztcclxuICAgICAgICBxLnMgKj0gcztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIE1PRFVMT19NT0RFKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IHgubWludXMocS50aW1lcyh5KSk7XHJcblxyXG4gICAgICAvLyBUbyBtYXRjaCBKYXZhU2NyaXB0ICUsIGVuc3VyZSBzaWduIG9mIHplcm8gaXMgc2lnbiBvZiBkaXZpZGVuZC5cclxuICAgICAgaWYgKCF5LmNbMF0gJiYgTU9EVUxPX01PREUgPT0gMSkgeS5zID0geC5zO1xyXG5cclxuICAgICAgcmV0dXJuIHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKiAwID0gMFxyXG4gICAgICogIG4gKiBOID0gTlxyXG4gICAgICogIG4gKiBJID0gSVxyXG4gICAgICogIDAgKiBuID0gMFxyXG4gICAgICogIDAgKiAwID0gMFxyXG4gICAgICogIDAgKiBOID0gTlxyXG4gICAgICogIDAgKiBJID0gTlxyXG4gICAgICogIE4gKiBuID0gTlxyXG4gICAgICogIE4gKiAwID0gTlxyXG4gICAgICogIE4gKiBOID0gTlxyXG4gICAgICogIE4gKiBJID0gTlxyXG4gICAgICogIEkgKiBuID0gSVxyXG4gICAgICogIEkgKiAwID0gTlxyXG4gICAgICogIEkgKiBOID0gTlxyXG4gICAgICogIEkgKiBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG11bHRpcGxpZWQgYnkgdGhlIHZhbHVlXHJcbiAgICAgKiBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubXVsdGlwbGllZEJ5ID0gUC50aW1lcyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBjLCBlLCBpLCBqLCBrLCBtLCB4Y0wsIHhsbywgeGhpLCB5Y0wsIHlsbywgeWhpLCB6YyxcclxuICAgICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9ICh5ID0gbmV3IEJpZ051bWJlcih5LCBiKSkuYztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4sIMKxSW5maW5pdHkgb3IgwrEwP1xyXG4gICAgICBpZiAoIXhjIHx8ICF5YyB8fCAheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTiwgb3Igb25lIGlzIDAgYW5kIHRoZSBvdGhlciBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXgucyB8fCAheS5zIHx8IHhjICYmICF4Y1swXSAmJiAheWMgfHwgeWMgJiYgIXljWzBdICYmICF4Yykge1xyXG4gICAgICAgICAgeS5jID0geS5lID0geS5zID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeS5zICo9IHgucztcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgICAgIGlmICgheGMgfHwgIXljKSB7XHJcbiAgICAgICAgICAgIHkuYyA9IHkuZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeS5jID0gWzBdO1xyXG4gICAgICAgICAgICB5LmUgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgKyBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgIHkucyAqPSB4LnM7XHJcbiAgICAgIHhjTCA9IHhjLmxlbmd0aDtcclxuICAgICAgeWNMID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gRW5zdXJlIHhjIHBvaW50cyB0byBsb25nZXIgYXJyYXkgYW5kIHhjTCB0byBpdHMgbGVuZ3RoLlxyXG4gICAgICBpZiAoeGNMIDwgeWNMKSB7XHJcbiAgICAgICAgemMgPSB4YztcclxuICAgICAgICB4YyA9IHljO1xyXG4gICAgICAgIHljID0gemM7XHJcbiAgICAgICAgaSA9IHhjTDtcclxuICAgICAgICB4Y0wgPSB5Y0w7XHJcbiAgICAgICAgeWNMID0gaTtcclxuICAgICAgfSAgXHJcblxyXG4gICAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgICAgZm9yIChpID0geGNMICsgeWNMLCB6YyA9IFtdOyBpLS07IHpjLnB1c2goMCkpO1xyXG5cclxuICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgIHNxcnRCYXNlID0gU1FSVF9CQVNFO1xyXG5cclxuICAgICAgZm9yIChpID0geWNMOyAtLWkgPj0gMDspIHtcclxuICAgICAgICBjID0gMDtcclxuICAgICAgICB5bG8gPSB5Y1tpXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgIHloaSA9IHljW2ldIC8gc3FydEJhc2UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKGsgPSB4Y0wsIGogPSBpICsgazsgaiA+IGk7KSB7XHJcbiAgICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XHJcbiAgICAgICAgICB4aGkgPSB4Y1trXSAvIHNxcnRCYXNlIHwgMDtcclxuICAgICAgICAgIG0gPSB5aGkgKiB4bG8gKyB4aGkgKiB5bG87XHJcbiAgICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoKG0gJSBzcXJ0QmFzZSkgKiBzcXJ0QmFzZSkgKyB6Y1tqXSArIGM7XHJcbiAgICAgICAgICBjID0gKHhsbyAvIGJhc2UgfCAwKSArIChtIC8gc3FydEJhc2UgfCAwKSArIHloaSAqIHhoaTtcclxuICAgICAgICAgIHpjW2otLV0gPSB4bG8gJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgemNbal0gPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYykge1xyXG4gICAgICAgICsrZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB6Yy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgemMsIGUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG5lZ2F0ZWQsXHJcbiAgICAgKiBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICAgKi9cclxuICAgIFAubmVnYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICB4LnMgPSAteC5zIHx8IG51bGw7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICsgMCA9IG5cclxuICAgICAqICBuICsgTiA9IE5cclxuICAgICAqICBuICsgSSA9IElcclxuICAgICAqICAwICsgbiA9IG5cclxuICAgICAqICAwICsgMCA9IDBcclxuICAgICAqICAwICsgTiA9IE5cclxuICAgICAqICAwICsgSSA9IElcclxuICAgICAqICBOICsgbiA9IE5cclxuICAgICAqICBOICsgMCA9IE5cclxuICAgICAqICBOICsgTiA9IE5cclxuICAgICAqICBOICsgSSA9IE5cclxuICAgICAqICBJICsgbiA9IElcclxuICAgICAqICBJICsgMCA9IElcclxuICAgICAqICBJICsgTiA9IE5cclxuICAgICAqICBJICsgSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBwbHVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLnBsdXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoYSAvIDApO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkgcmV0dXJuIHljWzBdID8geSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDogYSAqIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcbiAgICAgICAgaWYgKGEgPiAwKSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgICBmb3IgKDsgYS0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhID0geGMubGVuZ3RoO1xyXG4gICAgICBiID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gUG9pbnQgeGMgdG8gdGhlIGxvbmdlciBhcnJheSwgYW5kIGIgdG8gdGhlIHNob3J0ZXIgbGVuZ3RoLlxyXG4gICAgICBpZiAoYSAtIGIgPCAwKSB7XHJcbiAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIHljID0geGM7XHJcbiAgICAgICAgeGMgPSB0O1xyXG4gICAgICAgIGIgPSBhO1xyXG4gICAgICB9ICBcclxuXHJcbiAgICAgIC8vIE9ubHkgc3RhcnQgYWRkaW5nIGF0IHljLmxlbmd0aCAtIDEgYXMgdGhlIGZ1cnRoZXIgZGlnaXRzIG9mIHhjIGNhbiBiZSBpZ25vcmVkLlxyXG4gICAgICBmb3IgKGEgPSAwOyBiOykge1xyXG4gICAgICAgIGEgPSAoeGNbLS1iXSA9IHhjW2JdICsgeWNbYl0gKyBhKSAvIEJBU0UgfCAwO1xyXG4gICAgICAgIHhjW2JdID0gQkFTRSA9PT0geGNbYl0gPyAwIDogeGNbYl0gJSBCQVNFO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYSkge1xyXG4gICAgICAgIHhjID0gW2FdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgKyt5ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG4gICAgICAvLyB5ZSA9IE1BWF9FWFAgKyAxIHBvc3NpYmxlXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBzZCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2ZcclxuICAgICAqIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKiBJZiBzZCBpcyB0cnVlIGluY2x1ZGUgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zIGluIHRoZSBjb3VudC5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIHNkIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2Ygc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogc2Qge251bWJlcnxib29sZWFufSBudW1iZXI6IHNpZ25pZmljYW50IGRpZ2l0czogaW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICBib29sZWFuOiB3aGV0aGVyIHRvIGNvdW50IGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvczogdHJ1ZSBvciBmYWxzZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChzZCAhPSBudWxsICYmIHNkICE9PSAhIXNkKSB7XHJcbiAgICAgICAgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIHNkLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgdiA9IGMubGVuZ3RoIC0gMTtcclxuICAgICAgbiA9IHYgKiBMT0dfQkFTRSArIDE7XHJcblxyXG4gICAgICBpZiAodiA9IGNbdl0pIHtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAodiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIG4rKyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZCAmJiB4LmUgKyAxID4gbikgbiA9IHguZSArIDE7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBzaGlmdGVkIGJ5IGsgcGxhY2VzXHJcbiAgICAgKiAocG93ZXJzIG9mIDEwKS4gU2hpZnQgdG8gdGhlIHJpZ2h0IGlmIG4gPiAwLCBhbmQgdG8gdGhlIGxlZnQgaWYgbiA8IDAuXHJcbiAgICAgKlxyXG4gICAgICogayB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX1NBRkVfSU5URUdFUiB0byBNQVhfU0FGRV9JTlRFR0VSIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2t9J1xyXG4gICAgICovXHJcbiAgICBQLnNoaWZ0ZWRCeSA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgIGludENoZWNrKGssIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKTtcclxuICAgICAgcmV0dXJuIHRoaXMudGltZXMoJzFlJyArIGspO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBzcXJ0KC1uKSA9ICBOXHJcbiAgICAgKiAgc3FydChOKSA9ICBOXHJcbiAgICAgKiAgc3FydCgtSSkgPSAgTlxyXG4gICAgICogIHNxcnQoSSkgPSAgSVxyXG4gICAgICogIHNxcnQoMCkgPSAgMFxyXG4gICAgICogIHNxcnQoLTApID0gLTBcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsXHJcbiAgICAgKiByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgbSwgbiwgciwgcmVwLCB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGMgPSB4LmMsXHJcbiAgICAgICAgcyA9IHgucyxcclxuICAgICAgICBlID0geC5lLFxyXG4gICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMgKyA0LFxyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKCcwLjUnKTtcclxuXHJcbiAgICAgIC8vIE5lZ2F0aXZlL05hTi9JbmZpbml0eS96ZXJvP1xyXG4gICAgICBpZiAocyAhPT0gMSB8fCAhYyB8fCAhY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCFzIHx8IHMgPCAwICYmICghYyB8fCBjWzBdKSA/IE5hTiA6IGMgPyB4IDogMSAvIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gICAgICBzID0gTWF0aC5zcXJ0KCt2YWx1ZU9mKHgpKTtcclxuXHJcbiAgICAgIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgICAgIC8vIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgICAgIGlmIChzID09IDAgfHwgcyA9PSAxIC8gMCkge1xyXG4gICAgICAgIG4gPSBjb2VmZlRvU3RyaW5nKGMpO1xyXG4gICAgICAgIGlmICgobi5sZW5ndGggKyBlKSAlIDIgPT0gMCkgbiArPSAnMCc7XHJcbiAgICAgICAgcyA9IE1hdGguc3FydCgrbik7XHJcbiAgICAgICAgZSA9IGJpdEZsb29yKChlICsgMSkgLyAyKSAtIChlIDwgMCB8fCBlICUgMik7XHJcblxyXG4gICAgICAgIGlmIChzID09IDEgLyAwKSB7XHJcbiAgICAgICAgICBuID0gJzVlJyArIGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIocyArICcnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIHplcm8uXHJcbiAgICAgIC8vIHIgY291bGQgYmUgemVybyBpZiBNSU5fRVhQIGlzIGNoYW5nZWQgYWZ0ZXIgdGhlIHRoaXMgdmFsdWUgd2FzIGNyZWF0ZWQuXHJcbiAgICAgIC8vIFRoaXMgd291bGQgY2F1c2UgYSBkaXZpc2lvbiBieSB6ZXJvICh4L3QpIGFuZCBoZW5jZSBJbmZpbml0eSBiZWxvdywgd2hpY2ggd291bGQgY2F1c2VcclxuICAgICAgLy8gY29lZmZUb1N0cmluZyB0byB0aHJvdy5cclxuICAgICAgaWYgKHIuY1swXSkge1xyXG4gICAgICAgIGUgPSByLmU7XHJcbiAgICAgICAgcyA9IGUgKyBkcDtcclxuICAgICAgICBpZiAocyA8IDMpIHMgPSAwO1xyXG5cclxuICAgICAgICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgICAgICAgZm9yICg7IDspIHtcclxuICAgICAgICAgIHQgPSByO1xyXG4gICAgICAgICAgciA9IGhhbGYudGltZXModC5wbHVzKGRpdih4LCB0LCBkcCwgMSkpKTtcclxuXHJcbiAgICAgICAgICBpZiAoY29lZmZUb1N0cmluZyh0LmMpLnNsaWNlKDAsIHMpID09PSAobiA9IGNvZWZmVG9TdHJpbmcoci5jKSkuc2xpY2UoMCwgcykpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBleHBvbmVudCBvZiByIG1heSBoZXJlIGJlIG9uZSBsZXNzIHRoYW4gdGhlIGZpbmFsIHJlc3VsdCBleHBvbmVudCxcclxuICAgICAgICAgICAgLy8gZS5nIDAuMDAwOTk5OSAoZS00KSAtLT4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgICBpZiAoci5lIDwgZSkgLS1zO1xyXG4gICAgICAgICAgICBuID0gbi5zbGljZShzIC0gMywgcyArIDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSA5OTk5IG9yIDQ5OTkgKGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSkgY29udGludWUgdGhlXHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlXHJcbiAgICAgICAgICAgICAgLy8gZXhhY3QgcmVzdWx0IGFzIHRoZSBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXHJcbiAgICAgICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgICAgIHJvdW5kKHQsIHQuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgZHAgKz0gNDtcclxuICAgICAgICAgICAgICBzICs9IDQ7XHJcbiAgICAgICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGV4YWN0XHJcbiAgICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMSk7XHJcbiAgICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMSwgUk9VTkRJTkdfTU9ERSwgbSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gYW5kXHJcbiAgICAgKiByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHArKztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRpbmdcclxuICAgICAqIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcclxuICAgICAqIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwID0gZHAgKyB0aGlzLmUgKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGVkXHJcbiAgICAgKiB1c2luZyBybSBvciBST1VORElOR19NT0RFIHRvIGRwIGRlY2ltYWwgcGxhY2VzLCBhbmQgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgcHJvcGVydGllc1xyXG4gICAgICogb2YgdGhlIGZvcm1hdCBvciBGT1JNQVQgb2JqZWN0IChzZWUgQmlnTnVtYmVyLnNldCkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGZvcm1hdHRpbmcgb2JqZWN0IG1heSBjb250YWluIHNvbWUgb3IgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIHNob3duIGJlbG93LlxyXG4gICAgICpcclxuICAgICAqIEZPUk1BVCA9IHtcclxuICAgICAqICAgcHJlZml4OiAnJyxcclxuICAgICAqICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICogICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgKiAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgKiAgIHN1ZmZpeDogJydcclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICogW2Zvcm1hdF0ge29iamVjdH0gRm9ybWF0dGluZyBvcHRpb25zLiBTZWUgRk9STUFUIHBiamVjdCBhYm92ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCBub3QgYW4gb2JqZWN0OiB7Zm9ybWF0fSdcclxuICAgICAqL1xyXG4gICAgUC50b0Zvcm1hdCA9IGZ1bmN0aW9uIChkcCwgcm0sIGZvcm1hdCkge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGRwICE9IG51bGwgJiYgcm0gJiYgdHlwZW9mIHJtID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBybTtcclxuICAgICAgICAgIHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKGRwICYmIHR5cGVvZiBkcCA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gZHA7XHJcbiAgICAgICAgICBkcCA9IHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9ybWF0ID0gRk9STUFUO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ICE9ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCBub3QgYW4gb2JqZWN0OiAnICsgZm9ybWF0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0geC50b0ZpeGVkKGRwLCBybSk7XHJcblxyXG4gICAgICBpZiAoeC5jKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICAgIGcxID0gK2Zvcm1hdC5ncm91cFNpemUsXHJcbiAgICAgICAgICBnMiA9ICtmb3JtYXQuc2Vjb25kYXJ5R3JvdXBTaXplLFxyXG4gICAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBmb3JtYXQuZ3JvdXBTZXBhcmF0b3IgfHwgJycsXHJcbiAgICAgICAgICBpbnRQYXJ0ID0gYXJyWzBdLFxyXG4gICAgICAgICAgZnJhY3Rpb25QYXJ0ID0gYXJyWzFdLFxyXG4gICAgICAgICAgaXNOZWcgPSB4LnMgPCAwLFxyXG4gICAgICAgICAgaW50RGlnaXRzID0gaXNOZWcgPyBpbnRQYXJ0LnNsaWNlKDEpIDogaW50UGFydCxcclxuICAgICAgICAgIGxlbiA9IGludERpZ2l0cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChnMikge1xyXG4gICAgICAgICAgaSA9IGcxO1xyXG4gICAgICAgICAgZzEgPSBnMjtcclxuICAgICAgICAgIGcyID0gaTtcclxuICAgICAgICAgIGxlbiAtPSBpO1xyXG4gICAgICAgIH0gIFxyXG5cclxuICAgICAgICBpZiAoZzEgPiAwICYmIGxlbiA+IDApIHtcclxuICAgICAgICAgIGkgPSBsZW4gJSBnMSB8fCBnMTtcclxuICAgICAgICAgIGludFBhcnQgPSBpbnREaWdpdHMuc3Vic3RyKDAsIGkpO1xyXG4gICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkgKz0gZzEpIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc3Vic3RyKGksIGcxKTtcclxuICAgICAgICAgIGlmIChnMiA+IDApIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc2xpY2UoaSk7XHJcbiAgICAgICAgICBpZiAoaXNOZWcpIGludFBhcnQgPSAnLScgKyBpbnRQYXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gZnJhY3Rpb25QYXJ0XHJcbiAgICAgICAgID8gaW50UGFydCArIChmb3JtYXQuZGVjaW1hbFNlcGFyYXRvciB8fCAnJykgKyAoKGcyID0gK2Zvcm1hdC5mcmFjdGlvbkdyb3VwU2l6ZSlcclxuICAgICAgICAgID8gZnJhY3Rpb25QYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXGR7JyArIGcyICsgJ31cXFxcQicsICdnJyksXHJcbiAgICAgICAgICAgJyQmJyArIChmb3JtYXQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB8fCAnJykpXHJcbiAgICAgICAgICA6IGZyYWN0aW9uUGFydClcclxuICAgICAgICAgOiBpbnRQYXJ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gKGZvcm1hdC5wcmVmaXggfHwgJycpICsgc3RyICsgKGZvcm1hdC5zdWZmaXggfHwgJycpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiB0d28gQmlnTnVtYmVycyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGFzIGEgc2ltcGxlXHJcbiAgICAgKiBmcmFjdGlvbiB3aXRoIGFuIGludGVnZXIgbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLlxyXG4gICAgICogVGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgYSBwb3NpdGl2ZSBub24temVybyB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZFxyXG4gICAgICogbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlXHJcbiAgICAgKiB0aGUgbG93ZXN0IHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAgICpcclxuICAgICAqIFttZF0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBJbnRlZ2VyID49IDEsIG9yIEluZmluaXR5LiBUaGUgbWF4aW11bSBkZW5vbWluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX0gOiB7bWR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRnJhY3Rpb24gPSBmdW5jdGlvbiAobWQpIHtcclxuICAgICAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGV4cCwgbiwgbjAsIG4xLCBxLCByLCBzLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jO1xyXG5cclxuICAgICAgaWYgKG1kICE9IG51bGwpIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XHJcblxyXG4gICAgICAgIC8vIFRocm93IGlmIG1kIGlzIGxlc3MgdGhhbiBvbmUgb3IgaXMgbm90IGFuIGludGVnZXIsIHVubGVzcyBpdCBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkgJiYgKG4uYyB8fCBuLnMgIT09IDEpIHx8IG4ubHQoT05FKSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50ICcgK1xyXG4gICAgICAgICAgICAgIChuLmlzSW50ZWdlcigpID8gJ291dCBvZiByYW5nZTogJyA6ICdub3QgYW4gaW50ZWdlcjogJykgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgheGMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG5cclxuICAgICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgbjEgPSBkMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgZDEgPSBuMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgcyA9IGNvZWZmVG9TdHJpbmcoeGMpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZGVub21pbmF0b3IuXHJcbiAgICAgIC8vIGQgaXMgYSBwb3dlciBvZiAxMCBhbmQgdGhlIG1pbmltdW0gbWF4IGRlbm9taW5hdG9yIHRoYXQgc3BlY2lmaWVzIHRoZSB2YWx1ZSBleGFjdGx5LlxyXG4gICAgICBlID0gZC5lID0gcy5sZW5ndGggLSB4LmUgLSAxO1xyXG4gICAgICBkLmNbMF0gPSBQT1dTX1RFTlsoZXhwID0gZSAlIExPR19CQVNFKSA8IDAgPyBMT0dfQkFTRSArIGV4cCA6IGV4cF07XHJcbiAgICAgIG1kID0gIW1kIHx8IG4uY29tcGFyZWRUbyhkKSA+IDAgPyAoZSA+IDAgPyBkIDogbjEpIDogbjtcclxuXHJcbiAgICAgIGV4cCA9IE1BWF9FWFA7XHJcbiAgICAgIE1BWF9FWFAgPSAxIC8gMDtcclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIocyk7XHJcblxyXG4gICAgICAvLyBuMCA9IGQxID0gMFxyXG4gICAgICBuMC5jWzBdID0gMDtcclxuXHJcbiAgICAgIGZvciAoOyA7KSAge1xyXG4gICAgICAgIHEgPSBkaXYobiwgZCwgMCwgMSk7XHJcbiAgICAgICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcclxuICAgICAgICBpZiAoZDIuY29tcGFyZWRUbyhtZCkgPT0gMSkgYnJlYWs7XHJcbiAgICAgICAgZDAgPSBkMTtcclxuICAgICAgICBkMSA9IGQyO1xyXG4gICAgICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyID0gbjEpKTtcclxuICAgICAgICBuMCA9IGQyO1xyXG4gICAgICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIgPSBkKSk7XHJcbiAgICAgICAgbiA9IGQyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkMiA9IGRpdihtZC5taW51cyhkMCksIGQxLCAwLCAxKTtcclxuICAgICAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XHJcbiAgICAgIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xyXG4gICAgICBuMC5zID0gbjEucyA9IHgucztcclxuICAgICAgZSA9IGUgKiAyO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMVxyXG4gICAgICByID0gZGl2KG4xLCBkMSwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkuY29tcGFyZWRUbyhcclxuICAgICAgICAgIGRpdihuMCwgZDAsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpKSA8IDEgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICAgICAgTUFYX0VYUCA9IGV4cDtcclxuXHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICAgICAqL1xyXG4gICAgUC50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICt2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtIG9yIFJPVU5ESU5HX01PREUuIElmIHNkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0c1xyXG4gICAgICogbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiwgdGhlbiB1c2VcclxuICAgICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIGlmIChzZCAhPSBudWxsKSBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBzZCwgcm0sIDIpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGJhc2UgYiwgb3IgYmFzZSAxMCBpZiBiIGlzXHJcbiAgICAgKiBvbWl0dGVkLiBJZiBhIGJhc2UgaXMgc3BlY2lmaWVkLCBpbmNsdWRpbmcgYmFzZSAxMCwgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxyXG4gICAgICogUk9VTkRJTkdfTU9ERS4gSWYgYSBiYXNlIGlzIG5vdCBzcGVjaWZpZWQsIGFuZCB0aGlzIEJpZ051bWJlciBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgICogdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVE9fRVhQX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW5cclxuICAgICAqIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbYl0ge251bWJlcn0gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAqL1xyXG4gICAgUC50b1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgbiA9IHRoaXMsXHJcbiAgICAgICAgcyA9IG4ucyxcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgLy8gSW5maW5pdHkgb3IgTmFOP1xyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICBzdHIgPSAnSW5maW5pdHknO1xyXG4gICAgICAgICAgaWYgKHMgPCAwKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0ciA9ICdOYU4nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XHJcbiAgICAgICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgICAgPyB0b0V4cG9uZW50aWFsKGNvZWZmVG9TdHJpbmcobi5jKSwgZSlcclxuICAgICAgICAgICA6IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBERUNJTUFMX1BMQUNFUyArIGUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIG4uZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG4gICAgICAgICAgc3RyID0gY29udmVydEJhc2UodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKSwgMTAsIGIsIHMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHMgPCAwICYmIG4uY1swXSkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhcyB0b1N0cmluZywgYnV0IGRvIG5vdCBhY2NlcHQgYSBiYXNlIGFyZ3VtZW50LCBhbmQgaW5jbHVkZSB0aGUgbWludXMgc2lnbiBmb3JcclxuICAgICAqIG5lZ2F0aXZlIHplcm8uXHJcbiAgICAgKi9cclxuICAgIFAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFAuX2lzQmlnTnVtYmVyID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoY29uZmlnT2JqZWN0ICE9IG51bGwpIEJpZ051bWJlci5zZXQoY29uZmlnT2JqZWN0KTtcclxuXHJcbiAgICByZXR1cm4gQmlnTnVtYmVyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFBSSVZBVEUgSEVMUEVSIEZVTkNUSU9OU1xyXG5cclxuICAvLyBUaGVzZSBmdW5jdGlvbnMgZG9uJ3QgbmVlZCBhY2Nlc3MgdG8gdmFyaWFibGVzLFxyXG4gIC8vIGUuZy4gREVDSU1BTF9QTEFDRVMsIGluIHRoZSBzY29wZSBvZiB0aGUgYGNsb25lYCBmdW5jdGlvbiBhYm92ZS5cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGJpdEZsb29yKG4pIHtcclxuICAgIHZhciBpID0gbiB8IDA7XHJcbiAgICByZXR1cm4gbiA+IDAgfHwgbiA9PT0gaSA/IGkgOiBpIC0gMTtcclxuICB9XHJcblxyXG5cclxuICAvLyBSZXR1cm4gYSBjb2VmZmljaWVudCBhcnJheSBhcyBhIHN0cmluZyBvZiBiYXNlIDEwIGRpZ2l0cy5cclxuICBmdW5jdGlvbiBjb2VmZlRvU3RyaW5nKGEpIHtcclxuICAgIHZhciBzLCB6LFxyXG4gICAgICBpID0gMSxcclxuICAgICAgaiA9IGEubGVuZ3RoLFxyXG4gICAgICByID0gYVswXSArICcnO1xyXG5cclxuICAgIGZvciAoOyBpIDwgajspIHtcclxuICAgICAgcyA9IGFbaSsrXSArICcnO1xyXG4gICAgICB6ID0gTE9HX0JBU0UgLSBzLmxlbmd0aDtcclxuICAgICAgZm9yICg7IHotLTsgcyA9ICcwJyArIHMpO1xyXG4gICAgICByICs9IHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChqID0gci5sZW5ndGg7IHIuY2hhckNvZGVBdCgtLWopID09PSA0ODspO1xyXG5cclxuICAgIHJldHVybiByLnNsaWNlKDAsIGogKyAxIHx8IDEpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIENvbXBhcmUgdGhlIHZhbHVlIG9mIEJpZ051bWJlcnMgeCBhbmQgeS5cclxuICBmdW5jdGlvbiBjb21wYXJlKHgsIHkpIHtcclxuICAgIHZhciBhLCBiLFxyXG4gICAgICB4YyA9IHguYyxcclxuICAgICAgeWMgPSB5LmMsXHJcbiAgICAgIGkgPSB4LnMsXHJcbiAgICAgIGogPSB5LnMsXHJcbiAgICAgIGsgPSB4LmUsXHJcbiAgICAgIGwgPSB5LmU7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTj9cclxuICAgIGlmICghaSB8fCAhaikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgYSA9IHhjICYmICF4Y1swXTtcclxuICAgIGIgPSB5YyAmJiAheWNbMF07XHJcblxyXG4gICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICBpZiAoYSB8fCBiKSByZXR1cm4gYSA/IGIgPyAwIDogLWogOiBpO1xyXG5cclxuICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgIGlmIChpICE9IGopIHJldHVybiBpO1xyXG5cclxuICAgIGEgPSBpIDwgMDtcclxuICAgIGIgPSBrID09IGw7XHJcblxyXG4gICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBiID8gMCA6ICF4YyBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgICBpZiAoIWIpIHJldHVybiBrID4gbCBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgaiA9IChrID0geGMubGVuZ3RoKSA8IChsID0geWMubGVuZ3RoKSA/IGsgOiBsO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgajsgaSsrKSBpZiAoeGNbaV0gIT0geWNbaV0pIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgICByZXR1cm4gayA9PSBsID8gMCA6IGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIENoZWNrIHRoYXQgbiBpcyBhIHByaW1pdGl2ZSBudW1iZXIsIGFuIGludGVnZXIsIGFuZCBpbiByYW5nZSwgb3RoZXJ3aXNlIHRocm93LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGludENoZWNrKG4sIG1pbiwgbWF4LCBuYW1lKSB7XHJcbiAgICBpZiAobiA8IG1pbiB8fCBuID4gbWF4IHx8IG4gIT09IG1hdGhmbG9vcihuKSkge1xyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgKGJpZ251bWJlckVycm9yICsgKG5hbWUgfHwgJ0FyZ3VtZW50JykgKyAodHlwZW9mIG4gPT0gJ251bWJlcidcclxuICAgICAgICAgPyBuIDwgbWluIHx8IG4gPiBtYXggPyAnIG91dCBvZiByYW5nZTogJyA6ICcgbm90IGFuIGludGVnZXI6ICdcclxuICAgICAgICAgOiAnIG5vdCBhIHByaW1pdGl2ZSBudW1iZXI6ICcpICsgU3RyaW5nKG4pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBBc3N1bWVzIGZpbml0ZSBuLlxyXG4gIGZ1bmN0aW9uIGlzT2RkKG4pIHtcclxuICAgIHZhciBrID0gbi5jLmxlbmd0aCAtIDE7XHJcbiAgICByZXR1cm4gYml0Rmxvb3Iobi5lIC8gTE9HX0JBU0UpID09IGsgJiYgbi5jW2tdICUgMiAhPSAwO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRXhwb25lbnRpYWwoc3RyLCBlKSB7XHJcbiAgICByZXR1cm4gKHN0ci5sZW5ndGggPiAxID8gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSA6IHN0cikgK1xyXG4gICAgIChlIDwgMCA/ICdlJyA6ICdlKycpICsgZTtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCB6KSB7XHJcbiAgICB2YXIgbGVuLCB6cztcclxuXHJcbiAgICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICAgIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcy5cclxuICAgICAgZm9yICh6cyA9IHogKyAnLic7ICsrZTsgenMgKz0geik7XHJcbiAgICAgIHN0ciA9IHpzICsgc3RyO1xyXG5cclxuICAgIC8vIFBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zLlxyXG4gICAgICBpZiAoKytlID4gbGVuKSB7XHJcbiAgICAgICAgZm9yICh6cyA9IHosIGUgLT0gbGVuOyAtLWU7IHpzICs9IHopO1xyXG4gICAgICAgIHN0ciArPSB6cztcclxuICAgICAgfSBlbHNlIGlmIChlIDwgbGVuKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIGUpICsgJy4nICsgc3RyLnNsaWNlKGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9XHJcblxyXG5cclxuICAvLyBFWFBPUlRcclxuXHJcblxyXG4gIEJpZ051bWJlciA9IGNsb25lKCk7XHJcbiAgQmlnTnVtYmVyWydkZWZhdWx0J10gPSBCaWdOdW1iZXIuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBBTUQuXHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gQmlnTnVtYmVyOyB9KTtcclxuXHJcbiAgLy8gTm9kZS5qcyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cy5cclxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBCcm93c2VyLlxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoIWdsb2JhbE9iamVjdCkge1xyXG4gICAgICBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmID8gc2VsZiA6IHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICBnbG9iYWxPYmplY3QuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG4gIH1cclxufSkodGhpcyk7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBLFdBVUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///431\n")},187:module=>{"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanM/MDk1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///187\n")},219:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXIvZGlzdC9hcGkuanM/MjhiMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///219\n')},510:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TvmException = exports.Contract = void 0;\nconst utils_1 = __webpack_require__(786);\nconst models_1 = __webpack_require__(851);\n/**\n * @category Contract\n */\nclass Contract {\n    constructor(provider, abi, address) {\n        if (!Array.isArray(abi.functions)) {\n            throw new Error('Invalid abi. Functions array required');\n        }\n        if (!Array.isArray(abi.events)) {\n            throw new Error('Invalid abi. Events array required');\n        }\n        this._provider = provider;\n        this._abi = JSON.stringify(abi);\n        this._functions = abi.functions.reduce((functions, item) => {\n            functions[item.name] = { inputs: item.inputs || [], outputs: item.outputs || [] };\n            return functions;\n        }, {});\n        this._events = abi.events.reduce((events, item) => {\n            events[item.name] = { inputs: item.inputs || [] };\n            return events;\n        }, {});\n        this._address = address;\n        this._methods = new Proxy({}, {\n            get: (_object, method) => {\n                const rawAbi = this._functions[method];\n                return (params = {}) => new ContractMethodImpl(this._provider, rawAbi, this._abi, this._address, method, params);\n            },\n        });\n    }\n    get methods() {\n        return this._methods;\n    }\n    get address() {\n        return this._address;\n    }\n    get abi() {\n        return this._abi;\n    }\n    /**\n     * Requests contract data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getFullState() {\n        await this._provider.ensureInitialized();\n        return await this._provider.rawApi.getFullContractState({\n            address: this.address.toString(),\n        });\n    }\n    /**\n     * Creates new contract transactions stream\n     *\n     * @param subscriber\n     */\n    transactions(subscriber) {\n        return subscriber.transactions(this._address)\n            .flatMap(({ transactions }) => transactions);\n    }\n    /**\n     * Creates new contract events stream\n     *\n     * @param subscriber\n     */\n    events(subscriber) {\n        return subscriber.transactions(this._address)\n            .flatMap(({ transactions }) => transactions)\n            .flatMap((tx) => this.decodeTransactionEvents({ transaction: tx }).then((events) => {\n            events.forEach((event) => event.transaction = tx);\n            return events;\n        }));\n    }\n    async waitForEvent(args = {}) {\n        const { range, filter } = args;\n        const filterFn = typeof filter === 'string'\n            ? ({ event }) => event === filter\n            : filter;\n        let subscriber = args.subscriber;\n        const hasTempSubscriber = subscriber == null;\n        if (subscriber == null) {\n            subscriber = new this._provider.Subscriber();\n        }\n        const event = await (((range === null || range === void 0 ? void 0 : range.fromLt) != null || (range === null || range === void 0 ? void 0 : range.fromUtime) != null)\n            ? subscriber.oldTransactions(this._address, range)\n                .merge(subscriber.transactions(this._address))\n            : subscriber.transactions(this.address)).flatMap(item => item.transactions)\n            .takeWhile(item => range == null ||\n            (range.fromLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.fromLt) > 0) &&\n                (range.fromUtime == null || item.createdAt > range.fromUtime) &&\n                (range.toLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.toLt) < 0) &&\n                (range.toUtime == null || item.createdAt < range.toUtime))\n            .flatMap(tx => this.decodeTransactionEvents({ transaction: tx })\n            .then((events) => {\n            events.forEach((event) => event.transaction = tx);\n            return events;\n        }))\n            .filterMap(async (event) => {\n            if (filterFn == null || (await filterFn(event))) {\n                return event;\n            }\n            else {\n                return undefined;\n            }\n        })\n            .first();\n        hasTempSubscriber && (await subscriber.unsubscribe());\n        return event;\n    }\n    async getPastEvents(args) {\n        const { range, filter, limit } = args;\n        const filterFn = typeof filter === 'string'\n            ? ({ event }) => event === filter\n            : filter;\n        const result = [];\n        let currentContinuation = args === null || args === void 0 ? void 0 : args.continuation;\n        outer: while (true) {\n            const { transactions, continuation } = await this._provider.getTransactions({\n                address: this._address,\n                continuation: currentContinuation,\n            });\n            if (transactions.length === null) {\n                break;\n            }\n            const filteredTransactions = transactions.filter((item) => (((range === null || range === void 0 ? void 0 : range.fromLt) == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.fromLt) > 0) &&\n                ((range === null || range === void 0 ? void 0 : range.fromUtime) == null || item.createdAt > range.fromUtime) &&\n                ((range === null || range === void 0 ? void 0 : range.toLt) == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.toLt) < 0) &&\n                ((range === null || range === void 0 ? void 0 : range.toUtime) == null || item.createdAt < range.toUtime)));\n            if (filteredTransactions.length > 0) {\n                const parsedEvents = await Promise.all(filteredTransactions.map(async (tx) => {\n                    return {\n                        tx, events: await this.decodeTransactionEvents({ transaction: tx }).then((events) => {\n                            events.forEach((event) => event.transaction = tx);\n                            return events;\n                        }),\n                    };\n                }));\n                for (let { tx, events } of parsedEvents) {\n                    if (filterFn != null) {\n                        events = await Promise.all(events.map(async (event) => (await filterFn(event)) ? event : undefined)).then(events => events.filter((event) => event != null));\n                    }\n                    currentContinuation = tx.id; // update continuation in case of early break\n                    for (const event of events) {\n                        if (limit != null && result.length >= limit) {\n                            break outer;\n                        }\n                        result.push(event);\n                    }\n                    if (limit != null && result.length >= limit) {\n                        break outer;\n                    }\n                }\n            }\n            currentContinuation = continuation;\n            if (currentContinuation == null) {\n                break;\n            }\n        }\n        return { events: result, continuation: currentContinuation };\n    }\n    async decodeTransaction(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeTransaction({\n                transaction: (0, models_1.serializeTransaction)(args.transaction),\n                abi: this._abi,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            const { method, input, output } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},\n                output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeTransactionEvents(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const { events } = await this._provider.rawApi.decodeTransactionEvents({\n                transaction: (0, models_1.serializeTransaction)(args.transaction),\n                abi: this._abi,\n            });\n            const result = [];\n            for (const { event, data } of events) {\n                const rawAbi = this._events[event];\n                result.push({\n                    event,\n                    data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {},\n                });\n            }\n            return result;\n        }\n        catch (_) {\n            return [];\n        }\n    }\n    async decodeInputMessage(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeInput({\n                abi: this._abi,\n                body: args.body,\n                internal: args.internal,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            const { method, input } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeOutputMessage(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeOutput({\n                abi: this._abi,\n                body: args.body,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            const { method, output } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeEvent(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeEvent({\n                abi: this.abi,\n                body: args.body,\n                event: args.events,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            const { event, data } = result;\n            const rawAbi = this._events[event];\n            return {\n                event,\n                data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n}\nexports.Contract = Contract;\n/**\n * @category Contract\n */\nclass TvmException extends Error {\n    constructor(code) {\n        super(`TvmException: ${code}`);\n        this.code = code;\n    }\n}\nexports.TvmException = TvmException;\nclass ContractMethodImpl {\n    constructor(provider, functionAbi, abi, address, method, params) {\n        this.provider = provider;\n        this.functionAbi = functionAbi;\n        this.abi = abi;\n        this.address = address;\n        this.method = method;\n        this.params = (0, models_1.serializeTokensObject)(params);\n    }\n    async send(args) {\n        await this.provider.ensureInitialized();\n        const { transaction } = await this.provider.rawApi.sendMessage({\n            sender: args.from.toString(),\n            recipient: this.address.toString(),\n            amount: args.amount,\n            bounce: args.bounce == null ? true : args.bounce,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n        });\n        return (0, models_1.parseTransaction)(transaction);\n    }\n    async sendDelayed(args) {\n        await this.provider.ensureInitialized();\n        const transactions = new utils_1.DelayedTransactions;\n        const subscription = await this.provider.subscribe('messageStatusUpdated');\n        subscription.on('data', (data) => {\n            if (!data.address.equals(args.from)) {\n                return;\n            }\n            transactions.fillTransaction(data.hash, data.transaction);\n        });\n        const { message } = await this.provider.rawApi.sendMessageDelayed({\n            sender: args.from.toString(),\n            recipient: this.address.toString(),\n            amount: args.amount,\n            bounce: args.bounce == null ? true : args.bounce,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n        }).catch(e => {\n            subscription.unsubscribe().catch(console.error);\n            throw e;\n        });\n        const transaction = transactions\n            .waitTransaction(this.address, message.hash)\n            .finally(() => subscription.unsubscribe().catch(console.error));\n        return {\n            messageHash: message.hash,\n            expireAt: message.expireAt,\n            transaction,\n        };\n    }\n    async sendWithResult(args) {\n        await this.provider.ensureInitialized();\n        let subscriber = args.subscriber;\n        const hasTempSubscriber = subscriber == null;\n        if (subscriber == null) {\n            subscriber = new this.provider.Subscriber();\n        }\n        try {\n            // Parent transaction from wallet\n            let parentTransaction = undefined;\n            // Child transaction promise\n            let resolveChildTransactionPromise;\n            const childTransactionPromise = new Promise((resolve) => {\n                resolveChildTransactionPromise = (tx) => resolve(tx);\n            });\n            // Array for collecting transactions on target before parent transaction promise resolution\n            const possibleChildren = [];\n            // Subscribe to this account\n            subscriber.transactions(this.address)\n                .flatMap(batch => batch.transactions)\n                // Listen only messages from sender\n                .filter(item => { var _a; return ((_a = item.inMessage.src) === null || _a === void 0 ? void 0 : _a.equals(args.from)) || false; })\n                .on((tx) => {\n                if (parentTransaction == null) {\n                    // If we don't known whether the message was sent just collect all transactions from the sender\n                    possibleChildren.push(tx);\n                }\n                else if (parentTransaction.possibleMessages.findIndex((msg) => msg.hash == tx.inMessage.hash) >= 0) {\n                    // Resolve promise if transaction was found\n                    resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(tx);\n                }\n            });\n            // Send message\n            const transaction = await this.send(args);\n            // Extract all outgoing messages from the parent transaction to this contract\n            const possibleMessages = transaction.outMessages.filter(msg => { var _a; return ((_a = msg.dst) === null || _a === void 0 ? void 0 : _a.equals(this.address)) || false; });\n            // Update stream state\n            parentTransaction = {\n                transaction,\n                possibleMessages,\n            };\n            // Check whether child transaction was already found\n            const alreadyReceived = possibleChildren.find((tx) => {\n                return possibleMessages.findIndex((msg) => msg.hash == tx.inMessage.hash) >= 0;\n            });\n            if (alreadyReceived != null) {\n                resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(alreadyReceived);\n            }\n            const childTransaction = await childTransactionPromise;\n            // Parse output\n            let output = undefined;\n            try {\n                const result = await this.provider.rawApi.decodeTransaction({\n                    transaction: (0, models_1.serializeTransaction)(childTransaction),\n                    abi: this.abi,\n                    method: this.method,\n                });\n                if (result != null) {\n                    output = this.functionAbi.outputs != null\n                        ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, result.output)\n                        : {};\n                }\n            }\n            catch (e) {\n                console.error(e);\n            }\n            // Done\n            return {\n                parentTransaction: parentTransaction.transaction,\n                childTransaction,\n                output,\n            };\n        }\n        finally {\n            hasTempSubscriber && (await subscriber.unsubscribe());\n        }\n    }\n    async estimateFees(args) {\n        await this.provider.ensureInitialized();\n        const { fees } = await this.provider.rawApi.estimateFees({\n            sender: args.from.toString(),\n            recipient: this.address.toString(),\n            amount: args.amount,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n        });\n        return fees;\n    }\n    async sendExternal(args) {\n        await this.provider.ensureInitialized();\n        const method = args.withoutSignature === true\n            ? this.provider.rawApi.sendUnsignedExternalMessage\n            : this.provider.rawApi.sendExternalMessage;\n        const { transaction, output } = await method({\n            publicKey: args.publicKey,\n            recipient: this.address.toString(),\n            stateInit: args.stateInit,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n            local: args.local,\n        });\n        return {\n            transaction: (0, models_1.parseTransaction)(transaction),\n            output: output != null ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, output) : undefined,\n        };\n    }\n    async sendExternalDelayed(args) {\n        await this.provider.ensureInitialized();\n        const transactions = new utils_1.DelayedTransactions;\n        const subscription = await this.provider.subscribe('messageStatusUpdated');\n        subscription.on('data', (data) => {\n            if (!data.address.equals(this.address)) {\n                return;\n            }\n            transactions.fillTransaction(data.hash, data.transaction);\n        });\n        const { message } = await this.provider.rawApi.sendExternalMessageDelayed({\n            publicKey: args.publicKey,\n            recipient: this.address.toString(),\n            stateInit: args.stateInit,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n        }).catch(e => {\n            subscription.unsubscribe().catch(console.error);\n            throw e;\n        });\n        const transaction = transactions\n            .waitTransaction(this.address, message.hash)\n            .finally(() => subscription.unsubscribe().catch(console.error));\n        return {\n            messageHash: message.hash,\n            expireAt: message.expireAt,\n            transaction,\n        };\n    }\n    async call(args = {}) {\n        await this.provider.ensureInitialized();\n        const { output, code } = await this.provider.rawApi.runLocal({\n            address: this.address.toString(),\n            cachedState: args.cachedState,\n            responsible: args.responsible,\n            functionCall: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n        });\n        if (output == null || code != 0) {\n            throw new TvmException(code);\n        }\n        else {\n            return (0, models_1.parseTokensObject)(this.functionAbi.outputs, output);\n        }\n    }\n    async encodeInternal() {\n        await this.provider.ensureInitialized();\n        const { boc } = await this.provider.rawApi.encodeInternalInput({\n            abi: this.abi,\n            method: this.method,\n            params: this.params,\n        });\n        return boc;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXIvZGlzdC9jb250cmFjdC5qcz9jODBkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Udm1FeGNlcHRpb24gPSBleHBvcnRzLkNvbnRyYWN0ID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgbW9kZWxzXzEgPSByZXF1aXJlKFwiLi9tb2RlbHNcIik7XG4vKipcbiAqIEBjYXRlZ29yeSBDb250cmFjdFxuICovXG5jbGFzcyBDb250cmFjdCB7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFiaSwgYWRkcmVzcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWJpLmZ1bmN0aW9ucykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhYmkuIEZ1bmN0aW9ucyBhcnJheSByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhYmkuZXZlbnRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFiaS4gRXZlbnRzIGFycmF5IHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5fYWJpID0gSlNPTi5zdHJpbmdpZnkoYWJpKTtcbiAgICAgICAgdGhpcy5fZnVuY3Rpb25zID0gYWJpLmZ1bmN0aW9ucy5yZWR1Y2UoKGZ1bmN0aW9ucywgaXRlbSkgPT4ge1xuICAgICAgICAgICAgZnVuY3Rpb25zW2l0ZW0ubmFtZV0gPSB7IGlucHV0czogaXRlbS5pbnB1dHMgfHwgW10sIG91dHB1dHM6IGl0ZW0ub3V0cHV0cyB8fCBbXSB9O1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9ucztcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBhYmkuZXZlbnRzLnJlZHVjZSgoZXZlbnRzLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICBldmVudHNbaXRlbS5uYW1lXSA9IHsgaW5wdXRzOiBpdGVtLmlucHV0cyB8fCBbXSB9O1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLl9hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5fbWV0aG9kcyA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgZ2V0OiAoX29iamVjdCwgbWV0aG9kKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3QWJpID0gdGhpcy5fZnVuY3Rpb25zW21ldGhvZF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwYXJhbXMgPSB7fSkgPT4gbmV3IENvbnRyYWN0TWV0aG9kSW1wbCh0aGlzLl9wcm92aWRlciwgcmF3QWJpLCB0aGlzLl9hYmksIHRoaXMuX2FkZHJlc3MsIG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWV0aG9kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGhvZHM7XG4gICAgfVxuICAgIGdldCBhZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkcmVzcztcbiAgICB9XG4gICAgZ2V0IGFiaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FiaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgY29udHJhY3QgZGF0YVxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBnZXRGdWxsU3RhdGUoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3Byb3ZpZGVyLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9wcm92aWRlci5yYXdBcGkuZ2V0RnVsbENvbnRyYWN0U3RhdGUoe1xuICAgICAgICAgICAgYWRkcmVzczogdGhpcy5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG5ldyBjb250cmFjdCB0cmFuc2FjdGlvbnMgc3RyZWFtXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3Vic2NyaWJlclxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9ucyhzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyLnRyYW5zYWN0aW9ucyh0aGlzLl9hZGRyZXNzKVxuICAgICAgICAgICAgLmZsYXRNYXAoKHsgdHJhbnNhY3Rpb25zIH0pID0+IHRyYW5zYWN0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IGNvbnRyYWN0IGV2ZW50cyBzdHJlYW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJzY3JpYmVyXG4gICAgICovXG4gICAgZXZlbnRzKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXIudHJhbnNhY3Rpb25zKHRoaXMuX2FkZHJlc3MpXG4gICAgICAgICAgICAuZmxhdE1hcCgoeyB0cmFuc2FjdGlvbnMgfSkgPT4gdHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgLmZsYXRNYXAoKHR4KSA9PiB0aGlzLmRlY29kZVRyYW5zYWN0aW9uRXZlbnRzKHsgdHJhbnNhY3Rpb246IHR4IH0pLnRoZW4oKGV2ZW50cykgPT4ge1xuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiBldmVudC50cmFuc2FjdGlvbiA9IHR4KTtcbiAgICAgICAgICAgIHJldHVybiBldmVudHM7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgd2FpdEZvckV2ZW50KGFyZ3MgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHJhbmdlLCBmaWx0ZXIgfSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IGZpbHRlckZuID0gdHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gKHsgZXZlbnQgfSkgPT4gZXZlbnQgPT09IGZpbHRlclxuICAgICAgICAgICAgOiBmaWx0ZXI7XG4gICAgICAgIGxldCBzdWJzY3JpYmVyID0gYXJncy5zdWJzY3JpYmVyO1xuICAgICAgICBjb25zdCBoYXNUZW1wU3Vic2NyaWJlciA9IHN1YnNjcmliZXIgPT0gbnVsbDtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlciA9IG5ldyB0aGlzLl9wcm92aWRlci5TdWJzY3JpYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnQgPSBhd2FpdCAoKChyYW5nZSA9PT0gbnVsbCB8fCByYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFuZ2UuZnJvbUx0KSAhPSBudWxsIHx8IChyYW5nZSA9PT0gbnVsbCB8fCByYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFuZ2UuZnJvbVV0aW1lKSAhPSBudWxsKVxuICAgICAgICAgICAgPyBzdWJzY3JpYmVyLm9sZFRyYW5zYWN0aW9ucyh0aGlzLl9hZGRyZXNzLCByYW5nZSlcbiAgICAgICAgICAgICAgICAubWVyZ2Uoc3Vic2NyaWJlci50cmFuc2FjdGlvbnModGhpcy5fYWRkcmVzcykpXG4gICAgICAgICAgICA6IHN1YnNjcmliZXIudHJhbnNhY3Rpb25zKHRoaXMuYWRkcmVzcykpLmZsYXRNYXAoaXRlbSA9PiBpdGVtLnRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIC50YWtlV2hpbGUoaXRlbSA9PiByYW5nZSA9PSBudWxsIHx8XG4gICAgICAgICAgICAocmFuZ2UuZnJvbUx0ID09IG51bGwgfHwgdXRpbHNfMS5MVF9DT0xMQVRPUi5jb21wYXJlKGl0ZW0uaWQubHQsIHJhbmdlLmZyb21MdCkgPiAwKSAmJlxuICAgICAgICAgICAgICAgIChyYW5nZS5mcm9tVXRpbWUgPT0gbnVsbCB8fCBpdGVtLmNyZWF0ZWRBdCA+IHJhbmdlLmZyb21VdGltZSkgJiZcbiAgICAgICAgICAgICAgICAocmFuZ2UudG9MdCA9PSBudWxsIHx8IHV0aWxzXzEuTFRfQ09MTEFUT1IuY29tcGFyZShpdGVtLmlkLmx0LCByYW5nZS50b0x0KSA8IDApICYmXG4gICAgICAgICAgICAgICAgKHJhbmdlLnRvVXRpbWUgPT0gbnVsbCB8fCBpdGVtLmNyZWF0ZWRBdCA8IHJhbmdlLnRvVXRpbWUpKVxuICAgICAgICAgICAgLmZsYXRNYXAodHggPT4gdGhpcy5kZWNvZGVUcmFuc2FjdGlvbkV2ZW50cyh7IHRyYW5zYWN0aW9uOiB0eCB9KVxuICAgICAgICAgICAgLnRoZW4oKGV2ZW50cykgPT4ge1xuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiBldmVudC50cmFuc2FjdGlvbiA9IHR4KTtcbiAgICAgICAgICAgIHJldHVybiBldmVudHM7XG4gICAgICAgIH0pKVxuICAgICAgICAgICAgLmZpbHRlck1hcChhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJGbiA9PSBudWxsIHx8IChhd2FpdCBmaWx0ZXJGbihldmVudCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maXJzdCgpO1xuICAgICAgICBoYXNUZW1wU3Vic2NyaWJlciAmJiAoYXdhaXQgc3Vic2NyaWJlci51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgICBhc3luYyBnZXRQYXN0RXZlbnRzKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgeyByYW5nZSwgZmlsdGVyLCBsaW1pdCB9ID0gYXJncztcbiAgICAgICAgY29uc3QgZmlsdGVyRm4gPSB0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyAoeyBldmVudCB9KSA9PiBldmVudCA9PT0gZmlsdGVyXG4gICAgICAgICAgICA6IGZpbHRlcjtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBjdXJyZW50Q29udGludWF0aW9uID0gYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLmNvbnRpbnVhdGlvbjtcbiAgICAgICAgb3V0ZXI6IHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9ucywgY29udGludWF0aW9uIH0gPSBhd2FpdCB0aGlzLl9wcm92aWRlci5nZXRUcmFuc2FjdGlvbnMoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuX2FkZHJlc3MsXG4gICAgICAgICAgICAgICAgY29udGludWF0aW9uOiBjdXJyZW50Q29udGludWF0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRUcmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMuZmlsdGVyKChpdGVtKSA9PiAoKChyYW5nZSA9PT0gbnVsbCB8fCByYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFuZ2UuZnJvbUx0KSA9PSBudWxsIHx8IHV0aWxzXzEuTFRfQ09MTEFUT1IuY29tcGFyZShpdGVtLmlkLmx0LCByYW5nZS5mcm9tTHQpID4gMCkgJiZcbiAgICAgICAgICAgICAgICAoKHJhbmdlID09PSBudWxsIHx8IHJhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByYW5nZS5mcm9tVXRpbWUpID09IG51bGwgfHwgaXRlbS5jcmVhdGVkQXQgPiByYW5nZS5mcm9tVXRpbWUpICYmXG4gICAgICAgICAgICAgICAgKChyYW5nZSA9PT0gbnVsbCB8fCByYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFuZ2UudG9MdCkgPT0gbnVsbCB8fCB1dGlsc18xLkxUX0NPTExBVE9SLmNvbXBhcmUoaXRlbS5pZC5sdCwgcmFuZ2UudG9MdCkgPCAwKSAmJlxuICAgICAgICAgICAgICAgICgocmFuZ2UgPT09IG51bGwgfHwgcmFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhbmdlLnRvVXRpbWUpID09IG51bGwgfHwgaXRlbS5jcmVhdGVkQXQgPCByYW5nZS50b1V0aW1lKSkpO1xuICAgICAgICAgICAgaWYgKGZpbHRlcmVkVHJhbnNhY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRFdmVudHMgPSBhd2FpdCBQcm9taXNlLmFsbChmaWx0ZXJlZFRyYW5zYWN0aW9ucy5tYXAoYXN5bmMgKHR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eCwgZXZlbnRzOiBhd2FpdCB0aGlzLmRlY29kZVRyYW5zYWN0aW9uRXZlbnRzKHsgdHJhbnNhY3Rpb246IHR4IH0pLnRoZW4oKGV2ZW50cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4gZXZlbnQudHJhbnNhY3Rpb24gPSB0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB7IHR4LCBldmVudHMgfSBvZiBwYXJzZWRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlckZuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cyA9IGF3YWl0IFByb21pc2UuYWxsKGV2ZW50cy5tYXAoYXN5bmMgKGV2ZW50KSA9PiAoYXdhaXQgZmlsdGVyRm4oZXZlbnQpKSA/IGV2ZW50IDogdW5kZWZpbmVkKSkudGhlbihldmVudHMgPT4gZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IGV2ZW50ICE9IG51bGwpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGludWF0aW9uID0gdHguaWQ7IC8vIHVwZGF0ZSBjb250aW51YXRpb24gaW4gY2FzZSBvZiBlYXJseSBicmVha1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbWl0ICE9IG51bGwgJiYgcmVzdWx0Lmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCAhPSBudWxsICYmIHJlc3VsdC5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudENvbnRpbnVhdGlvbiA9IGNvbnRpbnVhdGlvbjtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29udGludWF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBldmVudHM6IHJlc3VsdCwgY29udGludWF0aW9uOiBjdXJyZW50Q29udGludWF0aW9uIH07XG4gICAgfVxuICAgIGFzeW5jIGRlY29kZVRyYW5zYWN0aW9uKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fcHJvdmlkZXIuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3Byb3ZpZGVyLnJhd0FwaS5kZWNvZGVUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246ICgwLCBtb2RlbHNfMS5zZXJpYWxpemVUcmFuc2FjdGlvbikoYXJncy50cmFuc2FjdGlvbiksXG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLl9hYmksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBhcmdzLm1ldGhvZHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IG1ldGhvZCwgaW5wdXQsIG91dHB1dCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgcmF3QWJpID0gdGhpcy5fZnVuY3Rpb25zW21ldGhvZF07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBpbnB1dDogcmF3QWJpLmlucHV0cyAhPSBudWxsID8gKDAsIG1vZGVsc18xLnBhcnNlVG9rZW5zT2JqZWN0KShyYXdBYmkuaW5wdXRzLCBpbnB1dCkgOiB7fSxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHJhd0FiaS5vdXRwdXRzICE9IG51bGwgPyAoMCwgbW9kZWxzXzEucGFyc2VUb2tlbnNPYmplY3QpKHJhd0FiaS5vdXRwdXRzLCBvdXRwdXQpIDoge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlY29kZVRyYW5zYWN0aW9uRXZlbnRzKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fcHJvdmlkZXIuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXZlbnRzIH0gPSBhd2FpdCB0aGlzLl9wcm92aWRlci5yYXdBcGkuZGVjb2RlVHJhbnNhY3Rpb25FdmVudHMoe1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiAoMCwgbW9kZWxzXzEuc2VyaWFsaXplVHJhbnNhY3Rpb24pKGFyZ3MudHJhbnNhY3Rpb24pLFxuICAgICAgICAgICAgICAgIGFiaTogdGhpcy5fYWJpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBldmVudCwgZGF0YSB9IG9mIGV2ZW50cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhd0FiaSA9IHRoaXMuX2V2ZW50c1tldmVudF07XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogcmF3QWJpLmlucHV0cyAhPSBudWxsID8gKDAsIG1vZGVsc18xLnBhcnNlVG9rZW5zT2JqZWN0KShyYXdBYmkuaW5wdXRzLCBkYXRhKSA6IHt9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlY29kZUlucHV0TWVzc2FnZShhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3Byb3ZpZGVyLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9wcm92aWRlci5yYXdBcGkuZGVjb2RlSW5wdXQoe1xuICAgICAgICAgICAgICAgIGFiaTogdGhpcy5fYWJpLFxuICAgICAgICAgICAgICAgIGJvZHk6IGFyZ3MuYm9keSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbDogYXJncy5pbnRlcm5hbCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGFyZ3MubWV0aG9kcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgbWV0aG9kLCBpbnB1dCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgcmF3QWJpID0gdGhpcy5fZnVuY3Rpb25zW21ldGhvZF07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBpbnB1dDogcmF3QWJpLmlucHV0cyAhPSBudWxsID8gKDAsIG1vZGVsc18xLnBhcnNlVG9rZW5zT2JqZWN0KShyYXdBYmkuaW5wdXRzLCBpbnB1dCkgOiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVjb2RlT3V0cHV0TWVzc2FnZShhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3Byb3ZpZGVyLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9wcm92aWRlci5yYXdBcGkuZGVjb2RlT3V0cHV0KHtcbiAgICAgICAgICAgICAgICBhYmk6IHRoaXMuX2FiaSxcbiAgICAgICAgICAgICAgICBib2R5OiBhcmdzLmJvZHksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBhcmdzLm1ldGhvZHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IG1ldGhvZCwgb3V0cHV0IH0gPSByZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCByYXdBYmkgPSB0aGlzLl9mdW5jdGlvbnNbbWV0aG9kXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgIG91dHB1dDogcmF3QWJpLm91dHB1dHMgIT0gbnVsbCA/ICgwLCBtb2RlbHNfMS5wYXJzZVRva2Vuc09iamVjdCkocmF3QWJpLm91dHB1dHMsIG91dHB1dCkgOiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVjb2RlRXZlbnQoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLl9wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fcHJvdmlkZXIucmF3QXBpLmRlY29kZUV2ZW50KHtcbiAgICAgICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgICAgIGJvZHk6IGFyZ3MuYm9keSxcbiAgICAgICAgICAgICAgICBldmVudDogYXJncy5ldmVudHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGV2ZW50LCBkYXRhIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCByYXdBYmkgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBkYXRhOiByYXdBYmkuaW5wdXRzICE9IG51bGwgPyAoMCwgbW9kZWxzXzEucGFyc2VUb2tlbnNPYmplY3QpKHJhd0FiaS5pbnB1dHMsIGRhdGEpIDoge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Db250cmFjdCA9IENvbnRyYWN0O1xuLyoqXG4gKiBAY2F0ZWdvcnkgQ29udHJhY3RcbiAqL1xuY2xhc3MgVHZtRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICAgICAgc3VwZXIoYFR2bUV4Y2VwdGlvbjogJHtjb2RlfWApO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuVHZtRXhjZXB0aW9uID0gVHZtRXhjZXB0aW9uO1xuY2xhc3MgQ29udHJhY3RNZXRob2RJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZnVuY3Rpb25BYmksIGFiaSwgYWRkcmVzcywgbWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uQWJpID0gZnVuY3Rpb25BYmk7XG4gICAgICAgIHRoaXMuYWJpID0gYWJpO1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSAoMCwgbW9kZWxzXzEuc2VyaWFsaXplVG9rZW5zT2JqZWN0KShwYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJhd0FwaS5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICBzZW5kZXI6IGFyZ3MuZnJvbS50b1N0cmluZygpLFxuICAgICAgICAgICAgcmVjaXBpZW50OiB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGFtb3VudDogYXJncy5hbW91bnQsXG4gICAgICAgICAgICBib3VuY2U6IGFyZ3MuYm91bmNlID09IG51bGwgPyB0cnVlIDogYXJncy5ib3VuY2UsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogdGhpcy5wYXJhbXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgwLCBtb2RlbHNfMS5wYXJzZVRyYW5zYWN0aW9uKSh0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIHNlbmREZWxheWVkKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBuZXcgdXRpbHNfMS5EZWxheWVkVHJhbnNhY3Rpb25zO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnN1YnNjcmliZSgnbWVzc2FnZVN0YXR1c1VwZGF0ZWQnKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmICghZGF0YS5hZGRyZXNzLmVxdWFscyhhcmdzLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNhY3Rpb25zLmZpbGxUcmFuc2FjdGlvbihkYXRhLmhhc2gsIGRhdGEudHJhbnNhY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJhd0FwaS5zZW5kTWVzc2FnZURlbGF5ZWQoe1xuICAgICAgICAgICAgc2VuZGVyOiBhcmdzLmZyb20udG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHJlY2lwaWVudDogdGhpcy5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBhbW91bnQ6IGFyZ3MuYW1vdW50LFxuICAgICAgICAgICAgYm91bmNlOiBhcmdzLmJvdW5jZSA9PSBudWxsID8gdHJ1ZSA6IGFyZ3MuYm91bmNlLFxuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgIGFiaTogdGhpcy5hYmksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHRoaXMucGFyYW1zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgLndhaXRUcmFuc2FjdGlvbih0aGlzLmFkZHJlc3MsIG1lc3NhZ2UuaGFzaClcbiAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpLmNhdGNoKGNvbnNvbGUuZXJyb3IpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2VIYXNoOiBtZXNzYWdlLmhhc2gsXG4gICAgICAgICAgICBleHBpcmVBdDogbWVzc2FnZS5leHBpcmVBdCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzZW5kV2l0aFJlc3VsdChhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXIuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgbGV0IHN1YnNjcmliZXIgPSBhcmdzLnN1YnNjcmliZXI7XG4gICAgICAgIGNvbnN0IGhhc1RlbXBTdWJzY3JpYmVyID0gc3Vic2NyaWJlciA9PSBudWxsO1xuICAgICAgICBpZiAoc3Vic2NyaWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyID0gbmV3IHRoaXMucHJvdmlkZXIuU3Vic2NyaWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBQYXJlbnQgdHJhbnNhY3Rpb24gZnJvbSB3YWxsZXRcbiAgICAgICAgICAgIGxldCBwYXJlbnRUcmFuc2FjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIENoaWxkIHRyYW5zYWN0aW9uIHByb21pc2VcbiAgICAgICAgICAgIGxldCByZXNvbHZlQ2hpbGRUcmFuc2FjdGlvblByb21pc2U7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFRyYW5zYWN0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNoaWxkVHJhbnNhY3Rpb25Qcm9taXNlID0gKHR4KSA9PiByZXNvbHZlKHR4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQXJyYXkgZm9yIGNvbGxlY3RpbmcgdHJhbnNhY3Rpb25zIG9uIHRhcmdldCBiZWZvcmUgcGFyZW50IHRyYW5zYWN0aW9uIHByb21pc2UgcmVzb2x1dGlvblxuICAgICAgICAgICAgY29uc3QgcG9zc2libGVDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoaXMgYWNjb3VudFxuICAgICAgICAgICAgc3Vic2NyaWJlci50cmFuc2FjdGlvbnModGhpcy5hZGRyZXNzKVxuICAgICAgICAgICAgICAgIC5mbGF0TWFwKGJhdGNoID0+IGJhdGNoLnRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgICAgICAvLyBMaXN0ZW4gb25seSBtZXNzYWdlcyBmcm9tIHNlbmRlclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSBpdGVtLmluTWVzc2FnZS5zcmMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lcXVhbHMoYXJncy5mcm9tKSkgfHwgZmFsc2U7IH0pXG4gICAgICAgICAgICAgICAgLm9uKCh0eCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGtub3duIHdoZXRoZXIgdGhlIG1lc3NhZ2Ugd2FzIHNlbnQganVzdCBjb2xsZWN0IGFsbCB0cmFuc2FjdGlvbnMgZnJvbSB0aGUgc2VuZGVyXG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2hpbGRyZW4ucHVzaCh0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudFRyYW5zYWN0aW9uLnBvc3NpYmxlTWVzc2FnZXMuZmluZEluZGV4KChtc2cpID0+IG1zZy5oYXNoID09IHR4LmluTWVzc2FnZS5oYXNoKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgcHJvbWlzZSBpZiB0cmFuc2FjdGlvbiB3YXMgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNoaWxkVHJhbnNhY3Rpb25Qcm9taXNlID09PSBudWxsIHx8IHJlc29sdmVDaGlsZFRyYW5zYWN0aW9uUHJvbWlzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzb2x2ZUNoaWxkVHJhbnNhY3Rpb25Qcm9taXNlKHR4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFNlbmQgbWVzc2FnZVxuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLnNlbmQoYXJncyk7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IGFsbCBvdXRnb2luZyBtZXNzYWdlcyBmcm9tIHRoZSBwYXJlbnQgdHJhbnNhY3Rpb24gdG8gdGhpcyBjb250cmFjdFxuICAgICAgICAgICAgY29uc3QgcG9zc2libGVNZXNzYWdlcyA9IHRyYW5zYWN0aW9uLm91dE1lc3NhZ2VzLmZpbHRlcihtc2cgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gbXNnLmRzdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVxdWFscyh0aGlzLmFkZHJlc3MpKSB8fCBmYWxzZTsgfSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgc3RyZWFtIHN0YXRlXG4gICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBwb3NzaWJsZU1lc3NhZ2VzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgY2hpbGQgdHJhbnNhY3Rpb24gd2FzIGFscmVhZHkgZm91bmRcbiAgICAgICAgICAgIGNvbnN0IGFscmVhZHlSZWNlaXZlZCA9IHBvc3NpYmxlQ2hpbGRyZW4uZmluZCgodHgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zc2libGVNZXNzYWdlcy5maW5kSW5kZXgoKG1zZykgPT4gbXNnLmhhc2ggPT0gdHguaW5NZXNzYWdlLmhhc2gpID49IDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhbHJlYWR5UmVjZWl2ZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVDaGlsZFRyYW5zYWN0aW9uUHJvbWlzZSA9PT0gbnVsbCB8fCByZXNvbHZlQ2hpbGRUcmFuc2FjdGlvblByb21pc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc29sdmVDaGlsZFRyYW5zYWN0aW9uUHJvbWlzZShhbHJlYWR5UmVjZWl2ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hpbGRUcmFuc2FjdGlvbiA9IGF3YWl0IGNoaWxkVHJhbnNhY3Rpb25Qcm9taXNlO1xuICAgICAgICAgICAgLy8gUGFyc2Ugb3V0cHV0XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJhd0FwaS5kZWNvZGVUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiAoMCwgbW9kZWxzXzEuc2VyaWFsaXplVHJhbnNhY3Rpb24pKGNoaWxkVHJhbnNhY3Rpb24pLFxuICAgICAgICAgICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLmZ1bmN0aW9uQWJpLm91dHB1dHMgIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoMCwgbW9kZWxzXzEucGFyc2VUb2tlbnNPYmplY3QpKHRoaXMuZnVuY3Rpb25BYmkub3V0cHV0cywgcmVzdWx0Lm91dHB1dClcbiAgICAgICAgICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG9uZVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbjogcGFyZW50VHJhbnNhY3Rpb24udHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgY2hpbGRUcmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaGFzVGVtcFN1YnNjcmliZXIgJiYgKGF3YWl0IHN1YnNjcmliZXIudW5zdWJzY3JpYmUoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZXN0aW1hdGVGZWVzKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IGZlZXMgfSA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmF3QXBpLmVzdGltYXRlRmVlcyh7XG4gICAgICAgICAgICBzZW5kZXI6IGFyZ3MuZnJvbS50b1N0cmluZygpLFxuICAgICAgICAgICAgcmVjaXBpZW50OiB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGFtb3VudDogYXJncy5hbW91bnQsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogdGhpcy5wYXJhbXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZlZXM7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRFeHRlcm5hbChhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXIuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gYXJncy53aXRob3V0U2lnbmF0dXJlID09PSB0cnVlXG4gICAgICAgICAgICA/IHRoaXMucHJvdmlkZXIucmF3QXBpLnNlbmRVbnNpZ25lZEV4dGVybmFsTWVzc2FnZVxuICAgICAgICAgICAgOiB0aGlzLnByb3ZpZGVyLnJhd0FwaS5zZW5kRXh0ZXJuYWxNZXNzYWdlO1xuICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9uLCBvdXRwdXQgfSA9IGF3YWl0IG1ldGhvZCh7XG4gICAgICAgICAgICBwdWJsaWNLZXk6IGFyZ3MucHVibGljS2V5LFxuICAgICAgICAgICAgcmVjaXBpZW50OiB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHN0YXRlSW5pdDogYXJncy5zdGF0ZUluaXQsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogdGhpcy5wYXJhbXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9jYWw6IGFyZ3MubG9jYWwsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246ICgwLCBtb2RlbHNfMS5wYXJzZVRyYW5zYWN0aW9uKSh0cmFuc2FjdGlvbiksXG4gICAgICAgICAgICBvdXRwdXQ6IG91dHB1dCAhPSBudWxsID8gKDAsIG1vZGVsc18xLnBhcnNlVG9rZW5zT2JqZWN0KSh0aGlzLmZ1bmN0aW9uQWJpLm91dHB1dHMsIG91dHB1dCkgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHNlbmRFeHRlcm5hbERlbGF5ZWQoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLnByb3ZpZGVyLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IG5ldyB1dGlsc18xLkRlbGF5ZWRUcmFuc2FjdGlvbnM7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IHRoaXMucHJvdmlkZXIuc3Vic2NyaWJlKCdtZXNzYWdlU3RhdHVzVXBkYXRlZCcpO1xuICAgICAgICBzdWJzY3JpcHRpb24ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkYXRhLmFkZHJlc3MuZXF1YWxzKHRoaXMuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2FjdGlvbnMuZmlsbFRyYW5zYWN0aW9uKGRhdGEuaGFzaCwgZGF0YS50cmFuc2FjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmF3QXBpLnNlbmRFeHRlcm5hbE1lc3NhZ2VEZWxheWVkKHtcbiAgICAgICAgICAgIHB1YmxpY0tleTogYXJncy5wdWJsaWNLZXksXG4gICAgICAgICAgICByZWNpcGllbnQ6IHRoaXMuYWRkcmVzcy50b1N0cmluZygpLFxuICAgICAgICAgICAgc3RhdGVJbml0OiBhcmdzLnN0YXRlSW5pdCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB0aGlzLnBhcmFtcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgIC53YWl0VHJhbnNhY3Rpb24odGhpcy5hZGRyZXNzLCBtZXNzYWdlLmhhc2gpXG4gICAgICAgICAgICAuZmluYWxseSgoKSA9PiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKS5jYXRjaChjb25zb2xlLmVycm9yKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlSGFzaDogbWVzc2FnZS5oYXNoLFxuICAgICAgICAgICAgZXhwaXJlQXQ6IG1lc3NhZ2UuZXhwaXJlQXQsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbChhcmdzID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IG91dHB1dCwgY29kZSB9ID0gYXdhaXQgdGhpcy5wcm92aWRlci5yYXdBcGkucnVuTG9jYWwoe1xuICAgICAgICAgICAgYWRkcmVzczogdGhpcy5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBjYWNoZWRTdGF0ZTogYXJncy5jYWNoZWRTdGF0ZSxcbiAgICAgICAgICAgIHJlc3BvbnNpYmxlOiBhcmdzLnJlc3BvbnNpYmxlLFxuICAgICAgICAgICAgZnVuY3Rpb25DYWxsOiB7XG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogdGhpcy5wYXJhbXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dHB1dCA9PSBudWxsIHx8IGNvZGUgIT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR2bUV4Y2VwdGlvbihjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgbW9kZWxzXzEucGFyc2VUb2tlbnNPYmplY3QpKHRoaXMuZnVuY3Rpb25BYmkub3V0cHV0cywgb3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBlbmNvZGVJbnRlcm5hbCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IGJvYyB9ID0gYXdhaXQgdGhpcy5wcm92aWRlci5yYXdBcGkuZW5jb2RlSW50ZXJuYWxJbnB1dCh7XG4gICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy5wYXJhbXMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYm9jO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///510\n")},511:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ProviderNotInitializedException = exports.ProviderNotFoundException = exports.ProviderRpcClient = exports.hasEverscaleProvider = exports.LT_COLLATOR = exports.mergeTransactions = exports.MessageExpiredException = exports.AddressLiteral = exports.Address = exports.Subscriber = void 0;\nconst models_1 = __webpack_require__(851);\nconst utils_1 = __webpack_require__(786);\nconst subscriber = __importStar(__webpack_require__(25));\nconst contract = __importStar(__webpack_require__(510));\n__exportStar(__webpack_require__(219), exports);\n__exportStar(__webpack_require__(851), exports);\n__exportStar(__webpack_require__(510), exports);\nvar stream_1 = __webpack_require__(25);\nObject.defineProperty(exports, \"Subscriber\", ({ enumerable: true, get: function () { return stream_1.Subscriber; } }));\nvar utils_2 = __webpack_require__(786);\nObject.defineProperty(exports, \"Address\", ({ enumerable: true, get: function () { return utils_2.Address; } }));\nObject.defineProperty(exports, \"AddressLiteral\", ({ enumerable: true, get: function () { return utils_2.AddressLiteral; } }));\nObject.defineProperty(exports, \"MessageExpiredException\", ({ enumerable: true, get: function () { return utils_2.MessageExpiredException; } }));\nObject.defineProperty(exports, \"mergeTransactions\", ({ enumerable: true, get: function () { return utils_2.mergeTransactions; } }));\nObject.defineProperty(exports, \"LT_COLLATOR\", ({ enumerable: true, get: function () { return utils_2.LT_COLLATOR; } }));\nconst isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\nlet ensurePageLoaded;\nif (!isBrowser || document.readyState === 'complete') {\n    ensurePageLoaded = Promise.resolve();\n}\nelse {\n    ensurePageLoaded = new Promise((resolve) => {\n        window.addEventListener('load', () => {\n            resolve();\n        });\n    });\n}\nconst getProvider = () => isBrowser ? window.__ever || window.ton : undefined;\n/**\n * @category Provider\n */\nasync function hasEverscaleProvider() {\n    if (!isBrowser) {\n        return false;\n    }\n    await ensurePageLoaded;\n    return window.__hasEverscaleProvider === true || window.hasTonProvider === true;\n}\nexports.hasEverscaleProvider = hasEverscaleProvider;\n/**\n * @category Provider\n */\nclass ProviderRpcClient {\n    constructor(properties = {}) {\n        this._subscriptions = {\n            connected: new Map(),\n            disconnected: new Map(),\n            transactionsFound: new Map(),\n            contractStateChanged: new Map(),\n            messageStatusUpdated: new Map(),\n            networkChanged: new Map(),\n            permissionsChanged: new Map(),\n            loggedOut: new Map(),\n        };\n        this._contractSubscriptions = new Map();\n        this._properties = properties;\n        const self = this;\n        // Create contract proxy type\n        class ProviderContract extends contract.Contract {\n            constructor(abi, address) {\n                super(self, abi, address);\n            }\n        }\n        this.Contract = ProviderContract;\n        // Create subscriber proxy type\n        class ProviderSubscriber extends subscriber.Subscriber {\n            constructor() {\n                super(self);\n            }\n        }\n        this.Subscriber = ProviderSubscriber;\n        // Wrap provider requests\n        this._api = new Proxy({}, {\n            get: (_object, method) => (params) => {\n                if (this._provider != null) {\n                    return this._provider.request({ method, params });\n                }\n                else {\n                    throw new ProviderNotInitializedException();\n                }\n            },\n        });\n        if (properties.forceUseFallback === true) {\n            this._initializationPromise = properties.fallback != null\n                ? properties.fallback()\n                    .then((provider) => {\n                    this._provider = provider;\n                })\n                : Promise.resolve();\n        }\n        else {\n            // Initialize provider with injected object by default\n            this._provider = getProvider();\n            if (this._provider != null) {\n                // Provider as already injected\n                this._initializationPromise = Promise.resolve();\n            }\n            else {\n                // Wait until page is loaded and initialization complete\n                this._initializationPromise = hasEverscaleProvider()\n                    .then((hasProvider) => new Promise((resolve) => {\n                    if (!hasProvider) {\n                        // Fully loaded page doesn't even contain provider flag\n                        return resolve();\n                    }\n                    // Wait injected provider initialization otherwise\n                    this._provider = getProvider();\n                    if (this._provider != null) {\n                        resolve();\n                    }\n                    else {\n                        const eventName = window.__hasEverscaleProvider === true ? 'ever#initialized' : 'ton#initialized';\n                        window.addEventListener(eventName, (_) => {\n                            this._provider = getProvider();\n                            resolve();\n                        });\n                    }\n                }))\n                    .then(async () => {\n                    if (this._provider == null && properties.fallback != null) {\n                        this._provider = await properties.fallback();\n                    }\n                });\n            }\n        }\n        // Will only register handlers for successfully loaded injected provider\n        this._initializationPromise.then(() => {\n            if (this._provider != null) {\n                this._registerEventHandlers(this._provider);\n            }\n        });\n    }\n    /**\n     * Checks whether this page has injected Everscale provider or\n     * there is a fallback provider.\n     */\n    async hasProvider() {\n        if (this._properties.fallback != null) {\n            return true;\n        }\n        return hasEverscaleProvider();\n    }\n    /**\n     * Waits until provider api will be available. Calls `fallback` if no provider was found\n     *\n     * @throws ProviderNotFoundException when no provider found\n     */\n    async ensureInitialized() {\n        await this._initializationPromise;\n        if (this._provider == null) {\n            throw new ProviderNotFoundException();\n        }\n    }\n    /**\n     * Whether provider api is ready\n     */\n    get isInitialized() {\n        return this._provider != null;\n    }\n    /**\n     * Raw provider\n     */\n    get raw() {\n        if (this._provider != null) {\n            return this._provider;\n        }\n        else {\n            throw new ProviderNotInitializedException();\n        }\n    }\n    /**\n     * Raw provider api\n     */\n    get rawApi() {\n        return this._api;\n    }\n    /**\n     * Creates typed contract wrapper.\n     *\n     * @param abi Readonly object (must be declared with `as const`)\n     * @param address Default contract address\n     *\n     * @deprecated `new ever.Contract(abi, address)` should be used instead\n     */\n    createContract(abi, address) {\n        return new this.Contract(abi, address);\n    }\n    /**\n     * Creates subscriptions group\n     *\n     * @deprecated `new ever.Subscriber()` should be used instead\n     */\n    createSubscriber() {\n        return new this.Subscriber();\n    }\n    /**\n     * Requests new permissions for current origin.\n     * Shows an approval window to the user.\n     * Will overwrite already existing permissions\n     *\n     * ---\n     * Required permissions: none\n     */\n    async requestPermissions(args) {\n        await this.ensureInitialized();\n        const result = await this._api.requestPermissions({\n            permissions: args.permissions,\n        });\n        return (0, models_1.parsePermissions)(result);\n    }\n    /**\n     * Updates `accountInteraction` permission value\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async changeAccount() {\n        await this.ensureInitialized();\n        await this._api.changeAccount();\n    }\n    /**\n     * Removes all permissions for current origin and stops all subscriptions\n     */\n    async disconnect() {\n        await this.ensureInitialized();\n        await this._api.disconnect();\n    }\n    async subscribe(eventName, params) {\n        class SubscriptionImpl {\n            constructor(_subscribe, _unsubscribe) {\n                this._subscribe = _subscribe;\n                this._unsubscribe = _unsubscribe;\n                this._listeners = {\n                    data: [],\n                    subscribed: [],\n                    unsubscribed: [],\n                };\n                this._subscribed = false;\n                this.subscribe = async () => {\n                    if (this._subscribed) {\n                        return;\n                    }\n                    this._subscribed = true;\n                    await this._subscribe(this);\n                    for (const handler of this._listeners['subscribed']) {\n                        handler();\n                    }\n                };\n                this.unsubscribe = async () => {\n                    if (!this._subscribed) {\n                        return;\n                    }\n                    this._subscribed = false;\n                    await this._unsubscribe();\n                    for (const handler of this._listeners['unsubscribed']) {\n                        handler();\n                    }\n                };\n            }\n            on(eventName, listener) {\n                this._listeners[eventName].push(listener);\n                return this;\n            }\n            notify(data) {\n                for (const handler of this._listeners['data']) {\n                    handler(data);\n                }\n            }\n        }\n        const existingSubscriptions = this._subscriptions[eventName];\n        const id = (0, utils_1.getUniqueId)();\n        switch (eventName) {\n            case 'connected':\n            case 'disconnected':\n            case 'messageStatusUpdated':\n            case 'networkChanged':\n            case 'permissionsChanged':\n            case 'loggedOut': {\n                const subscription = new SubscriptionImpl(async (subscription) => {\n                    if (existingSubscriptions.has(id)) {\n                        return;\n                    }\n                    existingSubscriptions.set(id, (data) => {\n                        subscription.notify(data);\n                    });\n                }, async () => {\n                    existingSubscriptions.delete(id);\n                });\n                await subscription.subscribe();\n                return subscription;\n            }\n            case 'transactionsFound':\n            case 'contractStateChanged': {\n                if (params == null) {\n                    throw new Error('Address must be specified for the subscription');\n                }\n                await this.ensureInitialized();\n                const address = params.address.toString();\n                const subscription = new SubscriptionImpl(async (subscription) => {\n                    if (existingSubscriptions.has(id)) {\n                        return;\n                    }\n                    existingSubscriptions.set(id, ((data) => {\n                        if (data.address.toString() === address) {\n                            subscription.notify(data);\n                        }\n                    }));\n                    let contractSubscriptions = this._contractSubscriptions.get(address);\n                    if (contractSubscriptions == null) {\n                        contractSubscriptions = new Map();\n                        this._contractSubscriptions.set(address, contractSubscriptions);\n                    }\n                    const subscriptionState = {\n                        state: eventName === 'contractStateChanged',\n                        transactions: eventName === 'transactionsFound',\n                    };\n                    contractSubscriptions.set(id, subscriptionState);\n                    const { total, withoutExcluded, } = foldSubscriptions(contractSubscriptions.values(), subscriptionState);\n                    try {\n                        if (total.transactions !== withoutExcluded.transactions || total.state !== withoutExcluded.state) {\n                            await this.rawApi.subscribe({ address, subscriptions: total });\n                        }\n                    }\n                    catch (e) {\n                        existingSubscriptions.delete(id);\n                        contractSubscriptions.delete(id);\n                        throw e;\n                    }\n                }, async () => {\n                    existingSubscriptions.delete(id);\n                    const contractSubscriptions = this._contractSubscriptions.get(address);\n                    if (contractSubscriptions == null) {\n                        return;\n                    }\n                    const updates = contractSubscriptions.get(id);\n                    const { total, withoutExcluded } = foldSubscriptions(contractSubscriptions.values(), updates);\n                    contractSubscriptions.delete(id);\n                    if (!withoutExcluded.transactions && !withoutExcluded.state) {\n                        await this.rawApi.unsubscribe({ address });\n                    }\n                    else if (total.transactions !== withoutExcluded.transactions || total.state !== withoutExcluded.state) {\n                        await this.rawApi.subscribe({ address, subscriptions: withoutExcluded });\n                    }\n                });\n                await subscription.subscribe();\n                return subscription;\n            }\n            default: {\n                throw new Error(`Unknown event ${eventName}`);\n            }\n        }\n    }\n    /**\n     * Returns provider api state\n     *\n     * ---\n     * Required permissions: none\n     */\n    async getProviderState() {\n        await this.ensureInitialized();\n        const state = await this._api.getProviderState();\n        return {\n            ...state,\n            permissions: (0, models_1.parsePermissions)(state.permissions),\n        };\n    }\n    /**\n     * Requests contract balance\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getBalance(address) {\n        const { state } = await this.getFullContractState({\n            address,\n        });\n        return state == null ? '0' : state === null || state === void 0 ? void 0 : state.balance;\n    }\n    /**\n     * Requests contract data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getFullContractState(args) {\n        await this.ensureInitialized();\n        return await this._api.getFullContractState({\n            address: args.address.toString(),\n        });\n    }\n    /**\n     * Requests accounts with specified code hash\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getAccountsByCodeHash(args) {\n        await this.ensureInitialized();\n        const { accounts, continuation } = await this._api.getAccountsByCodeHash({\n            ...args,\n        });\n        return {\n            accounts: accounts.map((address) => new utils_1.Address(address)),\n            continuation,\n        };\n    }\n    /**\n     * Requests contract transactions\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getTransactions(args) {\n        await this.ensureInitialized();\n        const { transactions, continuation, info } = await this._api.getTransactions({\n            ...args,\n            address: args.address.toString(),\n        });\n        return {\n            transactions: transactions.map(models_1.parseTransaction),\n            continuation,\n            info,\n        };\n    }\n    /**\n     * Searches transaction by hash\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getTransaction(args) {\n        await this.ensureInitialized();\n        const { transaction } = await this._api.getTransaction({\n            ...args,\n        });\n        return {\n            transaction: transaction ? (0, models_1.parseTransaction)(transaction) : undefined,\n        };\n    }\n    /**\n     * Computes contract address from code and init params\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getExpectedAddress(abi, args) {\n        const { address } = await this.getStateInit(abi, args);\n        return address;\n    }\n    /**\n     * Computes contract address and state from code and init params\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getStateInit(abi, args) {\n        await this.ensureInitialized();\n        const { address, stateInit } = await this._api.getExpectedAddress({\n            abi: JSON.stringify(abi),\n            ...args,\n            initParams: (0, models_1.serializeTokensObject)(args.initParams),\n        });\n        return {\n            address: new utils_1.Address(address),\n            stateInit,\n        };\n    }\n    /**\n     * Computes hash of base64 encoded BOC\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getBocHash(boc) {\n        await this.ensureInitialized();\n        return await this._api.getBocHash({\n            boc,\n        }).then(({ hash }) => hash);\n    }\n    /**\n     * Creates base64 encoded BOC\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async packIntoCell(args) {\n        await this.ensureInitialized();\n        return await this._api.packIntoCell({\n            abiVersion: args.abiVersion,\n            structure: args.structure,\n            data: (0, models_1.serializeTokensObject)(args.data),\n        });\n    }\n    /**\n     * Decodes base64 encoded BOC\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async unpackFromCell(args) {\n        await this.ensureInitialized();\n        const { data } = await this._api.unpackFromCell({\n            ...args,\n            structure: args.structure,\n        });\n        return {\n            data: (0, models_1.parseTokensObject)(args.structure, data),\n        };\n    }\n    /**\n     * Extracts public key from raw account state\n     *\n     * **NOTE:** can only be used on contracts which are deployed and has `pubkey` header\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async extractPublicKey(boc) {\n        await this.ensureInitialized();\n        const { publicKey } = await this._api.extractPublicKey({\n            boc,\n        });\n        return publicKey;\n    }\n    /**\n     * Converts base64 encoded contract code into tvc with default init data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async codeToTvc(code) {\n        await this.ensureInitialized();\n        const { tvc } = await this._api.codeToTvc({\n            code,\n        });\n        return tvc;\n    }\n    /**\n     * Merges code and data into state init\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async mergeTvc(args) {\n        await this.ensureInitialized();\n        return await this._api.mergeTvc(args);\n    }\n    /**\n     * Splits base64 encoded state init into code and data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async splitTvc(tvc) {\n        await this.ensureInitialized();\n        return await this._api.splitTvc({\n            tvc,\n        });\n    }\n    /**\n     * Merges code and data into state init\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async setCodeSalt(args) {\n        let salt;\n        if (typeof args.salt === 'string') {\n            await this.ensureInitialized();\n            salt = args.salt;\n        }\n        else {\n            const { boc } = await this.packIntoCell(args.salt);\n            salt = boc;\n        }\n        return await this._api.setCodeSalt({ code: args.code, salt });\n    }\n    /**\n     * Retrieves salt from code. Returns undefined if code doesn't contain salt\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getCodeSalt(args) {\n        await this.ensureInitialized();\n        const { salt } = await this.rawApi.getCodeSalt({\n            code: args.code,\n        });\n        return salt;\n    }\n    /**\n     * Adds asset to the selected account\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async addAsset(args) {\n        await this.ensureInitialized();\n        let params;\n        switch (args.type) {\n            case 'tip3_token': {\n                params = {\n                    rootContract: args.params.rootContract.toString(),\n                };\n                break;\n            }\n            default:\n                throw new Error('Unknown asset type');\n        }\n        return await this._api.addAsset({\n            account: args.account.toString(),\n            type: args.type,\n            params,\n        });\n    }\n    async verifySignature(args) {\n        await this.ensureInitialized();\n        return await this._api.verifySignature(args);\n    }\n    /**\n     * Signs arbitrary data.\n     *\n     * NOTE: hashes data before signing. Use `signDataRaw` to sign without hash.\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async signData(args) {\n        await this.ensureInitialized();\n        return await this._api.signData(args);\n    }\n    /**\n     * Signs arbitrary data without hashing it\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async signDataRaw(args) {\n        await this.ensureInitialized();\n        return await this._api.signDataRaw(args);\n    }\n    /**\n     * Encrypts arbitrary data with specified algorithm for each specified recipient\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async encryptData(args) {\n        await this.ensureInitialized();\n        const { encryptedData } = await this._api.encryptData(args);\n        return encryptedData;\n    }\n    /**\n     * Decrypts encrypted data. Returns base64 encoded data\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async decryptData(encryptedData) {\n        await this.ensureInitialized();\n        const { data } = await this._api.decryptData({ encryptedData });\n        return data;\n    }\n    /**\n     * Sends an internal message from the user account.\n     * Shows an approval window to the user.\n     *\n     * ---\n     * Required permissions: `accountInteraction`\n     */\n    async sendMessage(args) {\n        await this.ensureInitialized();\n        const { transaction } = await this._api.sendMessage({\n            sender: args.sender.toString(),\n            recipient: args.recipient.toString(),\n            amount: args.amount,\n            bounce: args.bounce,\n            payload: args.payload ? ({\n                abi: args.payload.abi,\n                method: args.payload.method,\n                params: (0, models_1.serializeTokensObject)(args.payload.params),\n            }) : undefined,\n        });\n        return {\n            transaction: (0, models_1.parseTransaction)(transaction),\n        };\n    }\n    /**\n     * Sends an internal message from the user account without waiting for the transaction.\n     * Shows an approval window to the user.\n     *\n     * @see messageStatusUpdated\n     *\n     * ---\n     * Required permissions: `accountInteraction`\n     */\n    async sendMessageDelayed(args) {\n        await this.ensureInitialized();\n        const transactions = new utils_1.DelayedTransactions;\n        const subscription = await this.subscribe('messageStatusUpdated');\n        subscription.on('data', (data) => {\n            if (!data.address.equals(args.sender)) {\n                return;\n            }\n            transactions.fillTransaction(data.hash, data.transaction);\n        });\n        const { message } = await this._api.sendMessageDelayed({\n            sender: args.sender.toString(),\n            recipient: args.recipient.toString(),\n            amount: args.amount,\n            bounce: args.bounce,\n            payload: args.payload ? ({\n                abi: args.payload.abi,\n                method: args.payload.method,\n                params: (0, models_1.serializeTokensObject)(args.payload.params),\n            }) : undefined,\n        }).catch(e => {\n            subscription.unsubscribe().catch(console.error);\n            throw e;\n        });\n        const transaction = transactions\n            .waitTransaction(args.sender, message.hash)\n            .finally(() => subscription.unsubscribe().catch(console.error));\n        return {\n            messageHash: message.hash,\n            expireAt: message.expireAt,\n            transaction,\n        };\n    }\n    _registerEventHandlers(provider) {\n        const knownEvents = {\n            'connected': (data) => data,\n            'disconnected': (data) => data,\n            'transactionsFound': (data) => ({\n                address: new utils_1.Address(data.address),\n                transactions: data.transactions.map(models_1.parseTransaction),\n                info: data.info,\n            }),\n            'contractStateChanged': (data) => ({\n                address: new utils_1.Address(data.address),\n                state: data.state,\n            }),\n            'messageStatusUpdated': (data) => ({\n                address: new utils_1.Address(data.address),\n                hash: data.hash,\n                transaction: data.transaction != null ? (0, models_1.parseTransaction)(data.transaction) : undefined,\n            }),\n            'networkChanged': data => data,\n            'permissionsChanged': (data) => ({\n                permissions: (0, models_1.parsePermissions)(data.permissions),\n            }),\n            'loggedOut': data => data,\n        };\n        for (const [eventName, extractor] of Object.entries(knownEvents)) {\n            provider.addListener(eventName, (data) => {\n                const handlers = this._subscriptions[eventName];\n                const parsed = extractor(data);\n                for (const handler of handlers.values()) {\n                    handler(parsed);\n                }\n            });\n        }\n    }\n}\nexports.ProviderRpcClient = ProviderRpcClient;\n/**\n * @category Provider\n */\nclass ProviderNotFoundException extends Error {\n    constructor() {\n        super('Everscale provider was not found');\n    }\n}\nexports.ProviderNotFoundException = ProviderNotFoundException;\n/**\n * @category Provider\n */\nclass ProviderNotInitializedException extends Error {\n    constructor() {\n        super('Everscale provider was not initialized yet');\n    }\n}\nexports.ProviderNotInitializedException = ProviderNotInitializedException;\nfunction foldSubscriptions(subscriptions, except) {\n    const total = { state: false, transactions: false };\n    const withoutExcluded = Object.assign({}, total);\n    for (const item of subscriptions) {\n        if (withoutExcluded.transactions && withoutExcluded.state) {\n            break;\n        }\n        total.state || (total.state = item.state);\n        total.transactions || (total.transactions = item.transactions);\n        if (item !== except) {\n            withoutExcluded.state || (withoutExcluded.state = item.state);\n            withoutExcluded.transactions || (withoutExcluded.transactions = item.transactions);\n        }\n    }\n    return { total, withoutExcluded };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTExLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXIvZGlzdC9pbmRleC5qcz83MTM1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm92aWRlck5vdEluaXRpYWxpemVkRXhjZXB0aW9uID0gZXhwb3J0cy5Qcm92aWRlck5vdEZvdW5kRXhjZXB0aW9uID0gZXhwb3J0cy5Qcm92aWRlclJwY0NsaWVudCA9IGV4cG9ydHMuaGFzRXZlcnNjYWxlUHJvdmlkZXIgPSBleHBvcnRzLkxUX0NPTExBVE9SID0gZXhwb3J0cy5tZXJnZVRyYW5zYWN0aW9ucyA9IGV4cG9ydHMuTWVzc2FnZUV4cGlyZWRFeGNlcHRpb24gPSBleHBvcnRzLkFkZHJlc3NMaXRlcmFsID0gZXhwb3J0cy5BZGRyZXNzID0gZXhwb3J0cy5TdWJzY3JpYmVyID0gdm9pZCAwO1xuY29uc3QgbW9kZWxzXzEgPSByZXF1aXJlKFwiLi9tb2RlbHNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBzdWJzY3JpYmVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3N0cmVhbVwiKSk7XG5jb25zdCBjb250cmFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9jb250cmFjdFwiKSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXBpXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnRyYWN0XCIpLCBleHBvcnRzKTtcbnZhciBzdHJlYW1fMSA9IHJlcXVpcmUoXCIuL3N0cmVhbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN1YnNjcmliZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmVhbV8xLlN1YnNjcmliZXI7IH0gfSk7XG52YXIgdXRpbHNfMiA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5BZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWRkcmVzc0xpdGVyYWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuQWRkcmVzc0xpdGVyYWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlRXhwaXJlZEV4Y2VwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5NZXNzYWdlRXhwaXJlZEV4Y2VwdGlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1lcmdlVHJhbnNhY3Rpb25zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLm1lcmdlVHJhbnNhY3Rpb25zOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTFRfQ09MTEFUT1JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuTFRfQ09MTEFUT1I7IH0gfSk7XG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbmxldCBlbnN1cmVQYWdlTG9hZGVkO1xuaWYgKCFpc0Jyb3dzZXIgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgIGVuc3VyZVBhZ2VMb2FkZWQgPSBQcm9taXNlLnJlc29sdmUoKTtcbn1cbmVsc2Uge1xuICAgIGVuc3VyZVBhZ2VMb2FkZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5jb25zdCBnZXRQcm92aWRlciA9ICgpID0+IGlzQnJvd3NlciA/IHdpbmRvdy5fX2V2ZXIgfHwgd2luZG93LnRvbiA6IHVuZGVmaW5lZDtcbi8qKlxuICogQGNhdGVnb3J5IFByb3ZpZGVyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhc0V2ZXJzY2FsZVByb3ZpZGVyKCkge1xuICAgIGlmICghaXNCcm93c2VyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXdhaXQgZW5zdXJlUGFnZUxvYWRlZDtcbiAgICByZXR1cm4gd2luZG93Ll9faGFzRXZlcnNjYWxlUHJvdmlkZXIgPT09IHRydWUgfHwgd2luZG93Lmhhc1RvblByb3ZpZGVyID09PSB0cnVlO1xufVxuZXhwb3J0cy5oYXNFdmVyc2NhbGVQcm92aWRlciA9IGhhc0V2ZXJzY2FsZVByb3ZpZGVyO1xuLyoqXG4gKiBAY2F0ZWdvcnkgUHJvdmlkZXJcbiAqL1xuY2xhc3MgUHJvdmlkZXJScGNDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMgPSB7fSkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0ge1xuICAgICAgICAgICAgY29ubmVjdGVkOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBkaXNjb25uZWN0ZWQ6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uc0ZvdW5kOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBjb250cmFjdFN0YXRlQ2hhbmdlZDogbmV3IE1hcCgpLFxuICAgICAgICAgICAgbWVzc2FnZVN0YXR1c1VwZGF0ZWQ6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIG5ldHdvcmtDaGFuZ2VkOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBwZXJtaXNzaW9uc0NoYW5nZWQ6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGxvZ2dlZE91dDogbmV3IE1hcCgpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jb250cmFjdFN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgLy8gQ3JlYXRlIGNvbnRyYWN0IHByb3h5IHR5cGVcbiAgICAgICAgY2xhc3MgUHJvdmlkZXJDb250cmFjdCBleHRlbmRzIGNvbnRyYWN0LkNvbnRyYWN0IHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKGFiaSwgYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHN1cGVyKHNlbGYsIGFiaSwgYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5Db250cmFjdCA9IFByb3ZpZGVyQ29udHJhY3Q7XG4gICAgICAgIC8vIENyZWF0ZSBzdWJzY3JpYmVyIHByb3h5IHR5cGVcbiAgICAgICAgY2xhc3MgUHJvdmlkZXJTdWJzY3JpYmVyIGV4dGVuZHMgc3Vic2NyaWJlci5TdWJzY3JpYmVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuU3Vic2NyaWJlciA9IFByb3ZpZGVyU3Vic2NyaWJlcjtcbiAgICAgICAgLy8gV3JhcCBwcm92aWRlciByZXF1ZXN0c1xuICAgICAgICB0aGlzLl9hcGkgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgIGdldDogKF9vYmplY3QsIG1ldGhvZCkgPT4gKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcm92aWRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm92aWRlci5yZXF1ZXN0KHsgbWV0aG9kLCBwYXJhbXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUHJvdmlkZXJOb3RJbml0aWFsaXplZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvcGVydGllcy5mb3JjZVVzZUZhbGxiYWNrID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXphdGlvblByb21pc2UgPSBwcm9wZXJ0aWVzLmZhbGxiYWNrICE9IG51bGxcbiAgICAgICAgICAgICAgICA/IHByb3BlcnRpZXMuZmFsbGJhY2soKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigocHJvdmlkZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHByb3ZpZGVyIHdpdGggaW5qZWN0ZWQgb2JqZWN0IGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIHRoaXMuX3Byb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcm92aWRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJvdmlkZXIgYXMgYWxyZWFkeSBpbmplY3RlZFxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemF0aW9uUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCBwYWdlIGlzIGxvYWRlZCBhbmQgaW5pdGlhbGl6YXRpb24gY29tcGxldGVcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXphdGlvblByb21pc2UgPSBoYXNFdmVyc2NhbGVQcm92aWRlcigpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChoYXNQcm92aWRlcikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRnVsbHkgbG9hZGVkIHBhZ2UgZG9lc24ndCBldmVuIGNvbnRhaW4gcHJvdmlkZXIgZmxhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IGluamVjdGVkIHByb3ZpZGVyIGluaXRpYWxpemF0aW9uIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm92aWRlciA9IGdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcm92aWRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudE5hbWUgPSB3aW5kb3cuX19oYXNFdmVyc2NhbGVQcm92aWRlciA9PT0gdHJ1ZSA/ICdldmVyI2luaXRpYWxpemVkJyA6ICd0b24jaW5pdGlhbGl6ZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCAoXykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcm92aWRlciA9PSBudWxsICYmIHByb3BlcnRpZXMuZmFsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBhd2FpdCBwcm9wZXJ0aWVzLmZhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXaWxsIG9ubHkgcmVnaXN0ZXIgaGFuZGxlcnMgZm9yIHN1Y2Nlc3NmdWxseSBsb2FkZWQgaW5qZWN0ZWQgcHJvdmlkZXJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Byb3ZpZGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWdpc3RlckV2ZW50SGFuZGxlcnModGhpcy5fcHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBwYWdlIGhhcyBpbmplY3RlZCBFdmVyc2NhbGUgcHJvdmlkZXIgb3JcbiAgICAgKiB0aGVyZSBpcyBhIGZhbGxiYWNrIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGFzeW5jIGhhc1Byb3ZpZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvcGVydGllcy5mYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzRXZlcnNjYWxlUHJvdmlkZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgdW50aWwgcHJvdmlkZXIgYXBpIHdpbGwgYmUgYXZhaWxhYmxlLiBDYWxscyBgZmFsbGJhY2tgIGlmIG5vIHByb3ZpZGVyIHdhcyBmb3VuZFxuICAgICAqXG4gICAgICogQHRocm93cyBQcm92aWRlck5vdEZvdW5kRXhjZXB0aW9uIHdoZW4gbm8gcHJvdmlkZXIgZm91bmRcbiAgICAgKi9cbiAgICBhc3luYyBlbnN1cmVJbml0aWFsaXplZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgICAgICBpZiAodGhpcy5fcHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFByb3ZpZGVyTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHByb3ZpZGVyIGFwaSBpcyByZWFkeVxuICAgICAqL1xuICAgIGdldCBpc0luaXRpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvdmlkZXIgIT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmF3IHByb3ZpZGVyXG4gICAgICovXG4gICAgZ2V0IHJhdygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb3ZpZGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQcm92aWRlck5vdEluaXRpYWxpemVkRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmF3IHByb3ZpZGVyIGFwaVxuICAgICAqL1xuICAgIGdldCByYXdBcGkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcGk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdHlwZWQgY29udHJhY3Qgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhYmkgUmVhZG9ubHkgb2JqZWN0IChtdXN0IGJlIGRlY2xhcmVkIHdpdGggYGFzIGNvbnN0YClcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBEZWZhdWx0IGNvbnRyYWN0IGFkZHJlc3NcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIGBuZXcgZXZlci5Db250cmFjdChhYmksIGFkZHJlc3MpYCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkXG4gICAgICovXG4gICAgY3JlYXRlQ29udHJhY3QoYWJpLCBhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5Db250cmFjdChhYmksIGFkZHJlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHN1YnNjcmlwdGlvbnMgZ3JvdXBcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIGBuZXcgZXZlci5TdWJzY3JpYmVyKClgIHNob3VsZCBiZSB1c2VkIGluc3RlYWRcbiAgICAgKi9cbiAgICBjcmVhdGVTdWJzY3JpYmVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuU3Vic2NyaWJlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBuZXcgcGVybWlzc2lvbnMgZm9yIGN1cnJlbnQgb3JpZ2luLlxuICAgICAqIFNob3dzIGFuIGFwcHJvdmFsIHdpbmRvdyB0byB0aGUgdXNlci5cbiAgICAgKiBXaWxsIG92ZXJ3cml0ZSBhbHJlYWR5IGV4aXN0aW5nIHBlcm1pc3Npb25zXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogbm9uZVxuICAgICAqL1xuICAgIGFzeW5jIHJlcXVlc3RQZXJtaXNzaW9ucyhhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fYXBpLnJlcXVlc3RQZXJtaXNzaW9ucyh7XG4gICAgICAgICAgICBwZXJtaXNzaW9uczogYXJncy5wZXJtaXNzaW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoMCwgbW9kZWxzXzEucGFyc2VQZXJtaXNzaW9ucykocmVzdWx0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBgYWNjb3VudEludGVyYWN0aW9uYCBwZXJtaXNzaW9uIHZhbHVlXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlcyBwZXJtaXNzaW9uczogYGFjY291bnRJbnRlcmFjdGlvbmBcbiAgICAgKi9cbiAgICBhc3luYyBjaGFuZ2VBY2NvdW50KCkge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2FwaS5jaGFuZ2VBY2NvdW50KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHBlcm1pc3Npb25zIGZvciBjdXJyZW50IG9yaWdpbiBhbmQgc3RvcHMgYWxsIHN1YnNjcmlwdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2FwaS5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIGFzeW5jIHN1YnNjcmliZShldmVudE5hbWUsIHBhcmFtcykge1xuICAgICAgICBjbGFzcyBTdWJzY3JpcHRpb25JbXBsIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKF9zdWJzY3JpYmUsIF91bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IF9zdWJzY3JpYmU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSBfdW5zdWJzY3JpYmU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlZDogW10sXG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlZDogW10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMuX2xpc3RlbmVyc1snc3Vic2NyaWJlZCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMuX2xpc3RlbmVyc1sndW5zdWJzY3JpYmVkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50TmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3RpZnkoZGF0YSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiB0aGlzLl9saXN0ZW5lcnNbJ2RhdGEnXSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGlzdGluZ1N1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zW2V2ZW50TmFtZV07XG4gICAgICAgIGNvbnN0IGlkID0gKDAsIHV0aWxzXzEuZ2V0VW5pcXVlSWQpKCk7XG4gICAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2VTdGF0dXNVcGRhdGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ25ldHdvcmtDaGFuZ2VkJzpcbiAgICAgICAgICAgIGNhc2UgJ3Blcm1pc3Npb25zQ2hhbmdlZCc6XG4gICAgICAgICAgICBjYXNlICdsb2dnZWRPdXQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbkltcGwoYXN5bmMgKHN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdTdWJzY3JpcHRpb25zLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1N1YnNjcmlwdGlvbnMuc2V0KGlkLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLm5vdGlmeShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1N1YnNjcmlwdGlvbnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzdWJzY3JpcHRpb24uc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3RyYW5zYWN0aW9uc0ZvdW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRyYWN0U3RhdGVDaGFuZ2VkJzoge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZHJlc3MgbXVzdCBiZSBzcGVjaWZpZWQgZm9yIHRoZSBzdWJzY3JpcHRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBwYXJhbXMuYWRkcmVzcy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25JbXBsKGFzeW5jIChzdWJzY3JpcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nU3Vic2NyaXB0aW9ucy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdTdWJzY3JpcHRpb25zLnNldChpZCwgKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5hZGRyZXNzLnRvU3RyaW5nKCkgPT09IGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24ubm90aWZ5KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250cmFjdFN1YnNjcmlwdGlvbnMgPSB0aGlzLl9jb250cmFjdFN1YnNjcmlwdGlvbnMuZ2V0KGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJhY3RTdWJzY3JpcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0U3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRyYWN0U3Vic2NyaXB0aW9ucy5zZXQoYWRkcmVzcywgY29udHJhY3RTdWJzY3JpcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25TdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBldmVudE5hbWUgPT09ICdjb250cmFjdFN0YXRlQ2hhbmdlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IGV2ZW50TmFtZSA9PT0gJ3RyYW5zYWN0aW9uc0ZvdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RTdWJzY3JpcHRpb25zLnNldChpZCwgc3Vic2NyaXB0aW9uU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRvdGFsLCB3aXRob3V0RXhjbHVkZWQsIH0gPSBmb2xkU3Vic2NyaXB0aW9ucyhjb250cmFjdFN1YnNjcmlwdGlvbnMudmFsdWVzKCksIHN1YnNjcmlwdGlvblN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbC50cmFuc2FjdGlvbnMgIT09IHdpdGhvdXRFeGNsdWRlZC50cmFuc2FjdGlvbnMgfHwgdG90YWwuc3RhdGUgIT09IHdpdGhvdXRFeGNsdWRlZC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmF3QXBpLnN1YnNjcmliZSh7IGFkZHJlc3MsIHN1YnNjcmlwdGlvbnM6IHRvdGFsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1N1YnNjcmlwdGlvbnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0U3Vic2NyaXB0aW9ucy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdTdWJzY3JpcHRpb25zLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0U3Vic2NyaXB0aW9ucyA9IHRoaXMuX2NvbnRyYWN0U3Vic2NyaXB0aW9ucy5nZXQoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cmFjdFN1YnNjcmlwdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBjb250cmFjdFN1YnNjcmlwdGlvbnMuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0b3RhbCwgd2l0aG91dEV4Y2x1ZGVkIH0gPSBmb2xkU3Vic2NyaXB0aW9ucyhjb250cmFjdFN1YnNjcmlwdGlvbnMudmFsdWVzKCksIHVwZGF0ZXMpO1xuICAgICAgICAgICAgICAgICAgICBjb250cmFjdFN1YnNjcmlwdGlvbnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3aXRob3V0RXhjbHVkZWQudHJhbnNhY3Rpb25zICYmICF3aXRob3V0RXhjbHVkZWQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmF3QXBpLnVuc3Vic2NyaWJlKHsgYWRkcmVzcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b3RhbC50cmFuc2FjdGlvbnMgIT09IHdpdGhvdXRFeGNsdWRlZC50cmFuc2FjdGlvbnMgfHwgdG90YWwuc3RhdGUgIT09IHdpdGhvdXRFeGNsdWRlZC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yYXdBcGkuc3Vic2NyaWJlKHsgYWRkcmVzcywgc3Vic2NyaXB0aW9uczogd2l0aG91dEV4Y2x1ZGVkIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3Vic2NyaXB0aW9uLnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGV2ZW50ICR7ZXZlbnROYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcHJvdmlkZXIgYXBpIHN0YXRlXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogbm9uZVxuICAgICAqL1xuICAgIGFzeW5jIGdldFByb3ZpZGVyU3RhdGUoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBhd2FpdCB0aGlzLl9hcGkuZ2V0UHJvdmlkZXJTdGF0ZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBwZXJtaXNzaW9uczogKDAsIG1vZGVsc18xLnBhcnNlUGVybWlzc2lvbnMpKHN0YXRlLnBlcm1pc3Npb25zKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgY29udHJhY3QgYmFsYW5jZVxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCYWxhbmNlKGFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gYXdhaXQgdGhpcy5nZXRGdWxsQ29udHJhY3RTdGF0ZSh7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN0YXRlID09IG51bGwgPyAnMCcgOiBzdGF0ZSA9PT0gbnVsbCB8fCBzdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdGUuYmFsYW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgY29udHJhY3QgZGF0YVxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBnZXRGdWxsQ29udHJhY3RTdGF0ZShhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FwaS5nZXRGdWxsQ29udHJhY3RTdGF0ZSh7XG4gICAgICAgICAgICBhZGRyZXNzOiBhcmdzLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGFjY291bnRzIHdpdGggc3BlY2lmaWVkIGNvZGUgaGFzaFxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY2NvdW50c0J5Q29kZUhhc2goYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGNvbnN0IHsgYWNjb3VudHMsIGNvbnRpbnVhdGlvbiB9ID0gYXdhaXQgdGhpcy5fYXBpLmdldEFjY291bnRzQnlDb2RlSGFzaCh7XG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50cy5tYXAoKGFkZHJlc3MpID0+IG5ldyB1dGlsc18xLkFkZHJlc3MoYWRkcmVzcykpLFxuICAgICAgICAgICAgY29udGludWF0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBjb250cmFjdCB0cmFuc2FjdGlvbnNcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqIFJlcXVpcmVkIHBlcm1pc3Npb25zOiBgYmFzaWNgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25zKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9ucywgY29udGludWF0aW9uLCBpbmZvIH0gPSBhd2FpdCB0aGlzLl9hcGkuZ2V0VHJhbnNhY3Rpb25zKHtcbiAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICBhZGRyZXNzOiBhcmdzLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9ucy5tYXAobW9kZWxzXzEucGFyc2VUcmFuc2FjdGlvbiksXG4gICAgICAgICAgICBjb250aW51YXRpb24sXG4gICAgICAgICAgICBpbmZvLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0cmFuc2FjdGlvbiBieSBoYXNoXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogYGJhc2ljYFxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0aGlzLl9hcGkuZ2V0VHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24gPyAoMCwgbW9kZWxzXzEucGFyc2VUcmFuc2FjdGlvbikodHJhbnNhY3Rpb24pIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBjb250cmFjdCBhZGRyZXNzIGZyb20gY29kZSBhbmQgaW5pdCBwYXJhbXNcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqIFJlcXVpcmVkIHBlcm1pc3Npb25zOiBgYmFzaWNgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RXhwZWN0ZWRBZGRyZXNzKGFiaSwgYXJncykge1xuICAgICAgICBjb25zdCB7IGFkZHJlc3MgfSA9IGF3YWl0IHRoaXMuZ2V0U3RhdGVJbml0KGFiaSwgYXJncyk7XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBjb250cmFjdCBhZGRyZXNzIGFuZCBzdGF0ZSBmcm9tIGNvZGUgYW5kIGluaXQgcGFyYW1zXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogYGJhc2ljYFxuICAgICAqL1xuICAgIGFzeW5jIGdldFN0YXRlSW5pdChhYmksIGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IGFkZHJlc3MsIHN0YXRlSW5pdCB9ID0gYXdhaXQgdGhpcy5fYXBpLmdldEV4cGVjdGVkQWRkcmVzcyh7XG4gICAgICAgICAgICBhYmk6IEpTT04uc3RyaW5naWZ5KGFiaSksXG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgaW5pdFBhcmFtczogKDAsIG1vZGVsc18xLnNlcmlhbGl6ZVRva2Vuc09iamVjdCkoYXJncy5pbml0UGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzOiBuZXcgdXRpbHNfMS5BZGRyZXNzKGFkZHJlc3MpLFxuICAgICAgICAgICAgc3RhdGVJbml0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBoYXNoIG9mIGJhc2U2NCBlbmNvZGVkIEJPQ1xuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCb2NIYXNoKGJvYykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hcGkuZ2V0Qm9jSGFzaCh7XG4gICAgICAgICAgICBib2MsXG4gICAgICAgIH0pLnRoZW4oKHsgaGFzaCB9KSA9PiBoYXNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBiYXNlNjQgZW5jb2RlZCBCT0NcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqIFJlcXVpcmVkIHBlcm1pc3Npb25zOiBgYmFzaWNgXG4gICAgICovXG4gICAgYXN5bmMgcGFja0ludG9DZWxsKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYXBpLnBhY2tJbnRvQ2VsbCh7XG4gICAgICAgICAgICBhYmlWZXJzaW9uOiBhcmdzLmFiaVZlcnNpb24sXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IGFyZ3Muc3RydWN0dXJlLFxuICAgICAgICAgICAgZGF0YTogKDAsIG1vZGVsc18xLnNlcmlhbGl6ZVRva2Vuc09iamVjdCkoYXJncy5kYXRhKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYmFzZTY0IGVuY29kZWQgQk9DXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogYGJhc2ljYFxuICAgICAqL1xuICAgIGFzeW5jIHVucGFja0Zyb21DZWxsKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHRoaXMuX2FwaS51bnBhY2tGcm9tQ2VsbCh7XG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgc3RydWN0dXJlOiBhcmdzLnN0cnVjdHVyZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiAoMCwgbW9kZWxzXzEucGFyc2VUb2tlbnNPYmplY3QpKGFyZ3Muc3RydWN0dXJlLCBkYXRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgcHVibGljIGtleSBmcm9tIHJhdyBhY2NvdW50IHN0YXRlXG4gICAgICpcbiAgICAgKiAqKk5PVEU6KiogY2FuIG9ubHkgYmUgdXNlZCBvbiBjb250cmFjdHMgd2hpY2ggYXJlIGRlcGxveWVkIGFuZCBoYXMgYHB1YmtleWAgaGVhZGVyXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogYGJhc2ljYFxuICAgICAqL1xuICAgIGFzeW5jIGV4dHJhY3RQdWJsaWNLZXkoYm9jKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgeyBwdWJsaWNLZXkgfSA9IGF3YWl0IHRoaXMuX2FwaS5leHRyYWN0UHVibGljS2V5KHtcbiAgICAgICAgICAgIGJvYyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwdWJsaWNLZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGJhc2U2NCBlbmNvZGVkIGNvbnRyYWN0IGNvZGUgaW50byB0dmMgd2l0aCBkZWZhdWx0IGluaXQgZGF0YVxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBjb2RlVG9UdmMoY29kZSkge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGNvbnN0IHsgdHZjIH0gPSBhd2FpdCB0aGlzLl9hcGkuY29kZVRvVHZjKHtcbiAgICAgICAgICAgIGNvZGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHZjO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgY29kZSBhbmQgZGF0YSBpbnRvIHN0YXRlIGluaXRcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqIFJlcXVpcmVkIHBlcm1pc3Npb25zOiBgYmFzaWNgXG4gICAgICovXG4gICAgYXN5bmMgbWVyZ2VUdmMoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hcGkubWVyZ2VUdmMoYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBiYXNlNjQgZW5jb2RlZCBzdGF0ZSBpbml0IGludG8gY29kZSBhbmQgZGF0YVxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBzcGxpdFR2Yyh0dmMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYXBpLnNwbGl0VHZjKHtcbiAgICAgICAgICAgIHR2YyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBjb2RlIGFuZCBkYXRhIGludG8gc3RhdGUgaW5pdFxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBzZXRDb2RlU2FsdChhcmdzKSB7XG4gICAgICAgIGxldCBzYWx0O1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3Muc2FsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgICAgIHNhbHQgPSBhcmdzLnNhbHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IGJvYyB9ID0gYXdhaXQgdGhpcy5wYWNrSW50b0NlbGwoYXJncy5zYWx0KTtcbiAgICAgICAgICAgIHNhbHQgPSBib2M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FwaS5zZXRDb2RlU2FsdCh7IGNvZGU6IGFyZ3MuY29kZSwgc2FsdCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHNhbHQgZnJvbSBjb2RlLiBSZXR1cm5zIHVuZGVmaW5lZCBpZiBjb2RlIGRvZXNuJ3QgY29udGFpbiBzYWx0XG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogYGJhc2ljYFxuICAgICAqL1xuICAgIGFzeW5jIGdldENvZGVTYWx0KGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IHNhbHQgfSA9IGF3YWl0IHRoaXMucmF3QXBpLmdldENvZGVTYWx0KHtcbiAgICAgICAgICAgIGNvZGU6IGFyZ3MuY29kZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzYWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFzc2V0IHRvIHRoZSBzZWxlY3RlZCBhY2NvdW50XG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlcyBwZXJtaXNzaW9uczogYGFjY291bnRJbnRlcmFjdGlvbmBcbiAgICAgKi9cbiAgICBhc3luYyBhZGRBc3NldChhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgc3dpdGNoIChhcmdzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RpcDNfdG9rZW4nOiB7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICByb290Q29udHJhY3Q6IGFyZ3MucGFyYW1zLnJvb3RDb250cmFjdC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBhc3NldCB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FwaS5hZGRBc3NldCh7XG4gICAgICAgICAgICBhY2NvdW50OiBhcmdzLmFjY291bnQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHR5cGU6IGFyZ3MudHlwZSxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeVNpZ25hdHVyZShhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FwaS52ZXJpZnlTaWduYXR1cmUoYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIGFyYml0cmFyeSBkYXRhLlxuICAgICAqXG4gICAgICogTk9URTogaGFzaGVzIGRhdGEgYmVmb3JlIHNpZ25pbmcuIFVzZSBgc2lnbkRhdGFSYXdgIHRvIHNpZ24gd2l0aG91dCBoYXNoLlxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZXMgcGVybWlzc2lvbnM6IGBhY2NvdW50SW50ZXJhY3Rpb25gXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkRhdGEoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hcGkuc2lnbkRhdGEoYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIGFyYml0cmFyeSBkYXRhIHdpdGhvdXQgaGFzaGluZyBpdFxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZXMgcGVybWlzc2lvbnM6IGBhY2NvdW50SW50ZXJhY3Rpb25gXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkRhdGFSYXcoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hcGkuc2lnbkRhdGFSYXcoYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY3J5cHRzIGFyYml0cmFyeSBkYXRhIHdpdGggc3BlY2lmaWVkIGFsZ29yaXRobSBmb3IgZWFjaCBzcGVjaWZpZWQgcmVjaXBpZW50XG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlcyBwZXJtaXNzaW9uczogYGFjY291bnRJbnRlcmFjdGlvbmBcbiAgICAgKi9cbiAgICBhc3luYyBlbmNyeXB0RGF0YShhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgeyBlbmNyeXB0ZWREYXRhIH0gPSBhd2FpdCB0aGlzLl9hcGkuZW5jcnlwdERhdGEoYXJncyk7XG4gICAgICAgIHJldHVybiBlbmNyeXB0ZWREYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNyeXB0cyBlbmNyeXB0ZWQgZGF0YS4gUmV0dXJucyBiYXNlNjQgZW5jb2RlZCBkYXRhXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlcyBwZXJtaXNzaW9uczogYGFjY291bnRJbnRlcmFjdGlvbmBcbiAgICAgKi9cbiAgICBhc3luYyBkZWNyeXB0RGF0YShlbmNyeXB0ZWREYXRhKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCB0aGlzLl9hcGkuZGVjcnlwdERhdGEoeyBlbmNyeXB0ZWREYXRhIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYW4gaW50ZXJuYWwgbWVzc2FnZSBmcm9tIHRoZSB1c2VyIGFjY291bnQuXG4gICAgICogU2hvd3MgYW4gYXBwcm92YWwgd2luZG93IHRvIHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBhY2NvdW50SW50ZXJhY3Rpb25gXG4gICAgICovXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb24gfSA9IGF3YWl0IHRoaXMuX2FwaS5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICBzZW5kZXI6IGFyZ3Muc2VuZGVyLnRvU3RyaW5nKCksXG4gICAgICAgICAgICByZWNpcGllbnQ6IGFyZ3MucmVjaXBpZW50LnRvU3RyaW5nKCksXG4gICAgICAgICAgICBhbW91bnQ6IGFyZ3MuYW1vdW50LFxuICAgICAgICAgICAgYm91bmNlOiBhcmdzLmJvdW5jZSxcbiAgICAgICAgICAgIHBheWxvYWQ6IGFyZ3MucGF5bG9hZCA/ICh7XG4gICAgICAgICAgICAgICAgYWJpOiBhcmdzLnBheWxvYWQuYWJpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogYXJncy5wYXlsb2FkLm1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6ICgwLCBtb2RlbHNfMS5zZXJpYWxpemVUb2tlbnNPYmplY3QpKGFyZ3MucGF5bG9hZC5wYXJhbXMpLFxuICAgICAgICAgICAgfSkgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246ICgwLCBtb2RlbHNfMS5wYXJzZVRyYW5zYWN0aW9uKSh0cmFuc2FjdGlvbiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGFuIGludGVybmFsIG1lc3NhZ2UgZnJvbSB0aGUgdXNlciBhY2NvdW50IHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIFNob3dzIGFuIGFwcHJvdmFsIHdpbmRvdyB0byB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBzZWUgbWVzc2FnZVN0YXR1c1VwZGF0ZWRcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqIFJlcXVpcmVkIHBlcm1pc3Npb25zOiBgYWNjb3VudEludGVyYWN0aW9uYFxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRNZXNzYWdlRGVsYXllZChhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zID0gbmV3IHV0aWxzXzEuRGVsYXllZFRyYW5zYWN0aW9ucztcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYXdhaXQgdGhpcy5zdWJzY3JpYmUoJ21lc3NhZ2VTdGF0dXNVcGRhdGVkJyk7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRhdGEuYWRkcmVzcy5lcXVhbHMoYXJncy5zZW5kZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNhY3Rpb25zLmZpbGxUcmFuc2FjdGlvbihkYXRhLmhhc2gsIGRhdGEudHJhbnNhY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBhd2FpdCB0aGlzLl9hcGkuc2VuZE1lc3NhZ2VEZWxheWVkKHtcbiAgICAgICAgICAgIHNlbmRlcjogYXJncy5zZW5kZXIudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHJlY2lwaWVudDogYXJncy5yZWNpcGllbnQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGFtb3VudDogYXJncy5hbW91bnQsXG4gICAgICAgICAgICBib3VuY2U6IGFyZ3MuYm91bmNlLFxuICAgICAgICAgICAgcGF5bG9hZDogYXJncy5wYXlsb2FkID8gKHtcbiAgICAgICAgICAgICAgICBhYmk6IGFyZ3MucGF5bG9hZC5hYmksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBhcmdzLnBheWxvYWQubWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogKDAsIG1vZGVsc18xLnNlcmlhbGl6ZVRva2Vuc09iamVjdCkoYXJncy5wYXlsb2FkLnBhcmFtcyksXG4gICAgICAgICAgICB9KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgLndhaXRUcmFuc2FjdGlvbihhcmdzLnNlbmRlciwgbWVzc2FnZS5oYXNoKVxuICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCkuY2F0Y2goY29uc29sZS5lcnJvcikpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZUhhc2g6IG1lc3NhZ2UuaGFzaCxcbiAgICAgICAgICAgIGV4cGlyZUF0OiBtZXNzYWdlLmV4cGlyZUF0LFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9yZWdpc3RlckV2ZW50SGFuZGxlcnMocHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3Qga25vd25FdmVudHMgPSB7XG4gICAgICAgICAgICAnY29ubmVjdGVkJzogKGRhdGEpID0+IGRhdGEsXG4gICAgICAgICAgICAnZGlzY29ubmVjdGVkJzogKGRhdGEpID0+IGRhdGEsXG4gICAgICAgICAgICAndHJhbnNhY3Rpb25zRm91bmQnOiAoZGF0YSkgPT4gKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBuZXcgdXRpbHNfMS5BZGRyZXNzKGRhdGEuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBkYXRhLnRyYW5zYWN0aW9ucy5tYXAobW9kZWxzXzEucGFyc2VUcmFuc2FjdGlvbiksXG4gICAgICAgICAgICAgICAgaW5mbzogZGF0YS5pbmZvLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAnY29udHJhY3RTdGF0ZUNoYW5nZWQnOiAoZGF0YSkgPT4gKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBuZXcgdXRpbHNfMS5BZGRyZXNzKGRhdGEuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgc3RhdGU6IGRhdGEuc3RhdGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICdtZXNzYWdlU3RhdHVzVXBkYXRlZCc6IChkYXRhKSA9PiAoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IG5ldyB1dGlsc18xLkFkZHJlc3MoZGF0YS5hZGRyZXNzKSxcbiAgICAgICAgICAgICAgICBoYXNoOiBkYXRhLmhhc2gsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IGRhdGEudHJhbnNhY3Rpb24gIT0gbnVsbCA/ICgwLCBtb2RlbHNfMS5wYXJzZVRyYW5zYWN0aW9uKShkYXRhLnRyYW5zYWN0aW9uKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgJ25ldHdvcmtDaGFuZ2VkJzogZGF0YSA9PiBkYXRhLFxuICAgICAgICAgICAgJ3Blcm1pc3Npb25zQ2hhbmdlZCc6IChkYXRhKSA9PiAoe1xuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiAoMCwgbW9kZWxzXzEucGFyc2VQZXJtaXNzaW9ucykoZGF0YS5wZXJtaXNzaW9ucyksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICdsb2dnZWRPdXQnOiBkYXRhID0+IGRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgW2V2ZW50TmFtZSwgZXh0cmFjdG9yXSBvZiBPYmplY3QuZW50cmllcyhrbm93bkV2ZW50cykpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuX3N1YnNjcmlwdGlvbnNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBleHRyYWN0b3IoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUHJvdmlkZXJScGNDbGllbnQgPSBQcm92aWRlclJwY0NsaWVudDtcbi8qKlxuICogQGNhdGVnb3J5IFByb3ZpZGVyXG4gKi9cbmNsYXNzIFByb3ZpZGVyTm90Rm91bmRFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdFdmVyc2NhbGUgcHJvdmlkZXIgd2FzIG5vdCBmb3VuZCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdmlkZXJOb3RGb3VuZEV4Y2VwdGlvbiA9IFByb3ZpZGVyTm90Rm91bmRFeGNlcHRpb247XG4vKipcbiAqIEBjYXRlZ29yeSBQcm92aWRlclxuICovXG5jbGFzcyBQcm92aWRlck5vdEluaXRpYWxpemVkRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignRXZlcnNjYWxlIHByb3ZpZGVyIHdhcyBub3QgaW5pdGlhbGl6ZWQgeWV0Jyk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm92aWRlck5vdEluaXRpYWxpemVkRXhjZXB0aW9uID0gUHJvdmlkZXJOb3RJbml0aWFsaXplZEV4Y2VwdGlvbjtcbmZ1bmN0aW9uIGZvbGRTdWJzY3JpcHRpb25zKHN1YnNjcmlwdGlvbnMsIGV4Y2VwdCkge1xuICAgIGNvbnN0IHRvdGFsID0geyBzdGF0ZTogZmFsc2UsIHRyYW5zYWN0aW9uczogZmFsc2UgfTtcbiAgICBjb25zdCB3aXRob3V0RXhjbHVkZWQgPSBPYmplY3QuYXNzaWduKHt9LCB0b3RhbCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgaWYgKHdpdGhvdXRFeGNsdWRlZC50cmFuc2FjdGlvbnMgJiYgd2l0aG91dEV4Y2x1ZGVkLnN0YXRlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0b3RhbC5zdGF0ZSB8fCAodG90YWwuc3RhdGUgPSBpdGVtLnN0YXRlKTtcbiAgICAgICAgdG90YWwudHJhbnNhY3Rpb25zIHx8ICh0b3RhbC50cmFuc2FjdGlvbnMgPSBpdGVtLnRyYW5zYWN0aW9ucyk7XG4gICAgICAgIGlmIChpdGVtICE9PSBleGNlcHQpIHtcbiAgICAgICAgICAgIHdpdGhvdXRFeGNsdWRlZC5zdGF0ZSB8fCAod2l0aG91dEV4Y2x1ZGVkLnN0YXRlID0gaXRlbS5zdGF0ZSk7XG4gICAgICAgICAgICB3aXRob3V0RXhjbHVkZWQudHJhbnNhY3Rpb25zIHx8ICh3aXRob3V0RXhjbHVkZWQudHJhbnNhY3Rpb25zID0gaXRlbS50cmFuc2FjdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHRvdGFsLCB3aXRob3V0RXhjbHVkZWQgfTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///511\n")},851:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseTokensObject = exports.serializeTokensObject = exports.parseAccountInteraction = exports.parsePermissions = exports.parseMessage = exports.serializeMessage = exports.parseTransaction = exports.serializeTransaction = void 0;\nconst utils_1 = __webpack_require__(786);\n/**\n * @category Models\n */\nfunction serializeTransaction(transaction) {\n    return {\n        ...transaction,\n        inMessage: serializeMessage(transaction.inMessage),\n        outMessages: transaction.outMessages.map(serializeMessage),\n    };\n}\nexports.serializeTransaction = serializeTransaction;\n/**\n * @category Models\n */\nfunction parseTransaction(transaction) {\n    return {\n        ...transaction,\n        inMessage: parseMessage(transaction.inMessage),\n        outMessages: transaction.outMessages.map(parseMessage),\n    };\n}\nexports.parseTransaction = parseTransaction;\n/**\n * @category Models\n */\nfunction serializeMessage(message) {\n    return {\n        ...message,\n        src: message.src ? message.src.toString() : undefined,\n        dst: message.dst ? message.dst.toString() : undefined,\n    };\n}\nexports.serializeMessage = serializeMessage;\n/**\n * @category Models\n */\nfunction parseMessage(message) {\n    return {\n        ...message,\n        src: message.src ? new utils_1.Address(message.src) : undefined,\n        dst: message.dst ? new utils_1.Address(message.dst) : undefined,\n    };\n}\nexports.parseMessage = parseMessage;\n/**\n * @category Models\n */\nfunction parsePermissions(permissions) {\n    return {\n        ...permissions,\n        accountInteraction: permissions.accountInteraction ? parseAccountInteraction(permissions.accountInteraction) : undefined,\n    };\n}\nexports.parsePermissions = parsePermissions;\n/**\n * @category Models\n */\nfunction parseAccountInteraction(accountInteraction) {\n    return {\n        ...accountInteraction,\n        address: new utils_1.Address(accountInteraction.address),\n    };\n}\nexports.parseAccountInteraction = parseAccountInteraction;\n/**\n * @category Models\n */\nfunction serializeTokensObject(object) {\n    return serializeTokenValue(object);\n}\nexports.serializeTokensObject = serializeTokensObject;\nfunction serializeTokenValue(token) {\n    if (token instanceof utils_1.Address) {\n        return token.toString();\n    }\n    if (Array.isArray(token)) {\n        const result = [];\n        for (const item of token) {\n            result.push(serializeTokenValue(item));\n        }\n        return result;\n    }\n    else if (token != null && typeof token === 'object') {\n        const result = {};\n        for (const [key, value] of Object.entries(token)) {\n            result[key] = serializeTokenValue(value);\n        }\n        return result;\n    }\n    else {\n        return token;\n    }\n}\n/**\n * @category Models\n */\nfunction parseTokensObject(params, object) {\n    const result = {};\n    for (const param of params) {\n        result[param.name] = parseTokenValue(param, object[param.name]);\n    }\n    return result;\n}\nexports.parseTokensObject = parseTokensObject;\nfunction parseTokenValue(param, token) {\n    if (!param.type.startsWith('map')) {\n        const isArray = param.type.endsWith('[]');\n        const isOptional = !isArray && param.type.startsWith('optional');\n        const rawType = (isArray ?\n            param.type.slice(0, -2) :\n            isOptional ?\n                param.type.slice(9, -1) :\n                param.type);\n        if (isArray) {\n            const rawParam = { name: param.name, type: rawType, components: param.components };\n            const result = [];\n            for (const item of token) {\n                result.push(parseTokenValue(rawParam, item));\n            }\n            return result;\n        }\n        else if (isOptional) {\n            if (token == null) {\n                return null;\n            }\n            else {\n                const rawParam = { name: param.name, type: rawType, components: param.components };\n                return parseTokenValue(rawParam, token);\n            }\n        }\n        else if (rawType === 'tuple') {\n            const result = {};\n            if (param.components != null) {\n                for (const component of param.components) {\n                    result[component.name] = parseTokenValue(component, token[component.name]);\n                }\n            }\n            return result;\n        }\n        else if (rawType === 'address') {\n            return new utils_1.Address(token);\n        }\n        else {\n            return token;\n        }\n    }\n    else {\n        let [keyType, valueType] = param.type.split(',');\n        keyType = keyType.slice(4);\n        valueType = valueType.slice(0, -1);\n        const result = [];\n        for (const [key, value] of token) {\n            result.push([parseTokenValue({\n                    name: '',\n                    type: keyType,\n                }, key), parseTokenValue({\n                    name: '',\n                    type: valueType,\n                    components: param.components,\n                }, value)]);\n        }\n        return result;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODUxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXIvZGlzdC9tb2RlbHMuanM/OGQ4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VUb2tlbnNPYmplY3QgPSBleHBvcnRzLnNlcmlhbGl6ZVRva2Vuc09iamVjdCA9IGV4cG9ydHMucGFyc2VBY2NvdW50SW50ZXJhY3Rpb24gPSBleHBvcnRzLnBhcnNlUGVybWlzc2lvbnMgPSBleHBvcnRzLnBhcnNlTWVzc2FnZSA9IGV4cG9ydHMuc2VyaWFsaXplTWVzc2FnZSA9IGV4cG9ydHMucGFyc2VUcmFuc2FjdGlvbiA9IGV4cG9ydHMuc2VyaWFsaXplVHJhbnNhY3Rpb24gPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIEBjYXRlZ29yeSBNb2RlbHNcbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgaW5NZXNzYWdlOiBzZXJpYWxpemVNZXNzYWdlKHRyYW5zYWN0aW9uLmluTWVzc2FnZSksXG4gICAgICAgIG91dE1lc3NhZ2VzOiB0cmFuc2FjdGlvbi5vdXRNZXNzYWdlcy5tYXAoc2VyaWFsaXplTWVzc2FnZSksXG4gICAgfTtcbn1cbmV4cG9ydHMuc2VyaWFsaXplVHJhbnNhY3Rpb24gPSBzZXJpYWxpemVUcmFuc2FjdGlvbjtcbi8qKlxuICogQGNhdGVnb3J5IE1vZGVsc1xuICovXG5mdW5jdGlvbiBwYXJzZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgIGluTWVzc2FnZTogcGFyc2VNZXNzYWdlKHRyYW5zYWN0aW9uLmluTWVzc2FnZSksXG4gICAgICAgIG91dE1lc3NhZ2VzOiB0cmFuc2FjdGlvbi5vdXRNZXNzYWdlcy5tYXAocGFyc2VNZXNzYWdlKSxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZVRyYW5zYWN0aW9uID0gcGFyc2VUcmFuc2FjdGlvbjtcbi8qKlxuICogQGNhdGVnb3J5IE1vZGVsc1xuICovXG5mdW5jdGlvbiBzZXJpYWxpemVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXNzYWdlLFxuICAgICAgICBzcmM6IG1lc3NhZ2Uuc3JjID8gbWVzc2FnZS5zcmMudG9TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZHN0OiBtZXNzYWdlLmRzdCA/IG1lc3NhZ2UuZHN0LnRvU3RyaW5nKCkgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMuc2VyaWFsaXplTWVzc2FnZSA9IHNlcmlhbGl6ZU1lc3NhZ2U7XG4vKipcbiAqIEBjYXRlZ29yeSBNb2RlbHNcbiAqL1xuZnVuY3Rpb24gcGFyc2VNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXNzYWdlLFxuICAgICAgICBzcmM6IG1lc3NhZ2Uuc3JjID8gbmV3IHV0aWxzXzEuQWRkcmVzcyhtZXNzYWdlLnNyYykgOiB1bmRlZmluZWQsXG4gICAgICAgIGRzdDogbWVzc2FnZS5kc3QgPyBuZXcgdXRpbHNfMS5BZGRyZXNzKG1lc3NhZ2UuZHN0KSA6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZU1lc3NhZ2UgPSBwYXJzZU1lc3NhZ2U7XG4vKipcbiAqIEBjYXRlZ29yeSBNb2RlbHNcbiAqL1xuZnVuY3Rpb24gcGFyc2VQZXJtaXNzaW9ucyhwZXJtaXNzaW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnBlcm1pc3Npb25zLFxuICAgICAgICBhY2NvdW50SW50ZXJhY3Rpb246IHBlcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbiA/IHBhcnNlQWNjb3VudEludGVyYWN0aW9uKHBlcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbikgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyc2VQZXJtaXNzaW9ucyA9IHBhcnNlUGVybWlzc2lvbnM7XG4vKipcbiAqIEBjYXRlZ29yeSBNb2RlbHNcbiAqL1xuZnVuY3Rpb24gcGFyc2VBY2NvdW50SW50ZXJhY3Rpb24oYWNjb3VudEludGVyYWN0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYWNjb3VudEludGVyYWN0aW9uLFxuICAgICAgICBhZGRyZXNzOiBuZXcgdXRpbHNfMS5BZGRyZXNzKGFjY291bnRJbnRlcmFjdGlvbi5hZGRyZXNzKSxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZUFjY291bnRJbnRlcmFjdGlvbiA9IHBhcnNlQWNjb3VudEludGVyYWN0aW9uO1xuLyoqXG4gKiBAY2F0ZWdvcnkgTW9kZWxzXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRva2Vuc09iamVjdChvYmplY3QpIHtcbiAgICByZXR1cm4gc2VyaWFsaXplVG9rZW5WYWx1ZShvYmplY3QpO1xufVxuZXhwb3J0cy5zZXJpYWxpemVUb2tlbnNPYmplY3QgPSBzZXJpYWxpemVUb2tlbnNPYmplY3Q7XG5mdW5jdGlvbiBzZXJpYWxpemVUb2tlblZhbHVlKHRva2VuKSB7XG4gICAgaWYgKHRva2VuIGluc3RhbmNlb2YgdXRpbHNfMS5BZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbikpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0b2tlbikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VyaWFsaXplVG9rZW5WYWx1ZShpdGVtKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSBpZiAodG9rZW4gIT0gbnVsbCAmJiB0eXBlb2YgdG9rZW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0b2tlbikpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gc2VyaWFsaXplVG9rZW5WYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG59XG4vKipcbiAqIEBjYXRlZ29yeSBNb2RlbHNcbiAqL1xuZnVuY3Rpb24gcGFyc2VUb2tlbnNPYmplY3QocGFyYW1zLCBvYmplY3QpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHBhcmFtcykge1xuICAgICAgICByZXN1bHRbcGFyYW0ubmFtZV0gPSBwYXJzZVRva2VuVmFsdWUocGFyYW0sIG9iamVjdFtwYXJhbS5uYW1lXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnBhcnNlVG9rZW5zT2JqZWN0ID0gcGFyc2VUb2tlbnNPYmplY3Q7XG5mdW5jdGlvbiBwYXJzZVRva2VuVmFsdWUocGFyYW0sIHRva2VuKSB7XG4gICAgaWYgKCFwYXJhbS50eXBlLnN0YXJ0c1dpdGgoJ21hcCcpKSB7XG4gICAgICAgIGNvbnN0IGlzQXJyYXkgPSBwYXJhbS50eXBlLmVuZHNXaXRoKCdbXScpO1xuICAgICAgICBjb25zdCBpc09wdGlvbmFsID0gIWlzQXJyYXkgJiYgcGFyYW0udHlwZS5zdGFydHNXaXRoKCdvcHRpb25hbCcpO1xuICAgICAgICBjb25zdCByYXdUeXBlID0gKGlzQXJyYXkgP1xuICAgICAgICAgICAgcGFyYW0udHlwZS5zbGljZSgwLCAtMikgOlxuICAgICAgICAgICAgaXNPcHRpb25hbCA/XG4gICAgICAgICAgICAgICAgcGFyYW0udHlwZS5zbGljZSg5LCAtMSkgOlxuICAgICAgICAgICAgICAgIHBhcmFtLnR5cGUpO1xuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgcmF3UGFyYW0gPSB7IG5hbWU6IHBhcmFtLm5hbWUsIHR5cGU6IHJhd1R5cGUsIGNvbXBvbmVudHM6IHBhcmFtLmNvbXBvbmVudHMgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRva2VuKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VUb2tlblZhbHVlKHJhd1BhcmFtLCBpdGVtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYXdQYXJhbSA9IHsgbmFtZTogcGFyYW0ubmFtZSwgdHlwZTogcmF3VHlwZSwgY29tcG9uZW50czogcGFyYW0uY29tcG9uZW50cyB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuVmFsdWUocmF3UGFyYW0sIHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyYXdUeXBlID09PSAndHVwbGUnKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChwYXJhbS5jb21wb25lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBwYXJhbS5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjb21wb25lbnQubmFtZV0gPSBwYXJzZVRva2VuVmFsdWUoY29tcG9uZW50LCB0b2tlbltjb21wb25lbnQubmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmF3VHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHV0aWxzXzEuQWRkcmVzcyh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBba2V5VHlwZSwgdmFsdWVUeXBlXSA9IHBhcmFtLnR5cGUuc3BsaXQoJywnKTtcbiAgICAgICAga2V5VHlwZSA9IGtleVR5cGUuc2xpY2UoNCk7XG4gICAgICAgIHZhbHVlVHlwZSA9IHZhbHVlVHlwZS5zbGljZSgwLCAtMSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0b2tlbikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW3BhcnNlVG9rZW5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBrZXlUeXBlLFxuICAgICAgICAgICAgICAgIH0sIGtleSksIHBhcnNlVG9rZW5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB2YWx1ZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IHBhcmFtLmNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgfSwgdmFsdWUpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///851\n")},25:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Subscriber = void 0;\nconst utils_1 = __webpack_require__(786);\nconst models_1 = __webpack_require__(851);\n/**\n * @category Stream\n */\nclass Subscriber {\n    constructor(provider) {\n        this.provider = provider;\n        this.subscriptions = new Map();\n        this.scanners = new Map();\n        this.unsubscribe = async () => this._unsubscribe();\n    }\n    /**\n     * Returns a stream of new transactions\n     */\n    transactions(address) {\n        return this._addSubscription('transactionsFound', address, false);\n    }\n    /**\n     * Returns a finite stream of child transactions\n     * @param transaction - root transaction\n     */\n    trace(transaction) {\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl((onData, onEnd) => {\n            const scanner = new TraceTransactionsScanner(this.provider, {\n                origin: transaction,\n                onData,\n                onEnd: (eof) => {\n                    this.scanners.delete(id);\n                    onEnd(eof);\n                },\n            });\n            this.scanners.set(id, scanner);\n            scanner.start();\n            // Subscription is not required\n            return Promise.resolve();\n        }, async () => {\n            const scanner = this.scanners.get(id);\n            if (scanner != null) {\n                this.scanners.delete(id);\n                await scanner.stop();\n            }\n        }, identity, true);\n    }\n    /**\n     * Returns a stream of old transactions\n     */\n    oldTransactions(address, filter) {\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl((onData, onEnd) => {\n            const scanner = new UnorderedTransactionsScanner(this.provider, {\n                address,\n                onData,\n                onEnd: (eof) => {\n                    this.scanners.delete(id);\n                    onEnd(eof);\n                },\n                ...filter,\n            });\n            this.scanners.set(id, scanner);\n            scanner.start();\n            // Subscription is not required\n            return Promise.resolve();\n        }, async () => {\n            const scanner = this.scanners.get(id);\n            if (scanner != null) {\n                this.scanners.delete(id);\n                await scanner.stop();\n            }\n        }, identity, true);\n    }\n    states(address) {\n        return this._addSubscription('contractStateChanged', address, false);\n    }\n    async _unsubscribe() {\n        const tasks = [];\n        for (const item of this.subscriptions.values()) {\n            for (const [event, eventData] of Object.entries(item)) {\n                delete item[event];\n                if (eventData != null) {\n                    tasks.push(eventData.subscription\n                        .then(item => item.unsubscribe())\n                        .catch(() => {\n                    }));\n                }\n            }\n        }\n        this.subscriptions.clear();\n        for (const scanner of this.scanners.values()) {\n            tasks.push(scanner.stop());\n        }\n        this.scanners.clear();\n        await Promise.all(tasks);\n    }\n    _addSubscription(event, address, isFinite) {\n        const rawAddress = address.toString();\n        const stopProducer = (id) => {\n            const subscriptions = this.subscriptions.get(rawAddress);\n            if (subscriptions == null) {\n                // No subscriptions for the address\n                return;\n            }\n            const eventData = subscriptions[event];\n            if (eventData != null) {\n                const handler = eventData.handlers.get(id);\n                if (handler != null) {\n                    // Remove event handler with the id\n                    eventData.handlers.delete(id);\n                    const { queue, onEnd, state } = handler;\n                    if (!state.finished) {\n                        state.finished = true;\n                        queue.clear();\n                        queue.enqueue(async () => onEnd(state.eof));\n                    }\n                }\n                // Remove event data subscription if there are none of them\n                if (eventData.handlers.size === 0) {\n                    const subscription = eventData.subscription;\n                    delete subscriptions[event];\n                    subscription\n                        .then((subscription) => subscription.unsubscribe())\n                        .catch(console.debug);\n                }\n            }\n            // Remove address subscriptions object if it is empty\n            if (subscriptions.contractStateChanged == null && subscriptions.transactionsFound == null) {\n                this.subscriptions.delete(rawAddress);\n            }\n        };\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl((onData, onEnd) => {\n            const subscriptions = this.subscriptions.get(rawAddress);\n            let eventData = subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions[event];\n            const state = { eof: false, finished: false };\n            // Create handler object\n            const handler = {\n                onData,\n                onEnd,\n                queue: new PromiseQueue(),\n                state,\n            };\n            if (eventData != null) {\n                // Add handler if there is already a handler group\n                eventData.handlers.set(id, handler);\n                return Promise.resolve();\n            }\n            // Create handlers group\n            const handlers = new Map();\n            handlers.set(id, handler);\n            // Create subscription\n            const subscription = this.provider.subscribe(event, { address })\n                .then((subscription) => {\n                subscription.on('data', (data) => {\n                    for (const { onData, queue, state } of handlers.values()) {\n                        // Skip closed streams\n                        if (state.eof || state.finished) {\n                            continue;\n                        }\n                        queue.enqueue(async () => {\n                            if (!(await onData(data))) {\n                                state.eof = true;\n                                stopProducer(id);\n                            }\n                        });\n                    }\n                });\n                subscription.on('unsubscribed', () => {\n                    for (const id of handlers.keys()) {\n                        stopProducer(id);\n                    }\n                });\n                return subscription;\n            }).catch((e) => {\n                console.error(e);\n                for (const id of handlers.keys()) {\n                    stopProducer(id);\n                }\n                throw e;\n            });\n            // Add event data to subscriptions\n            eventData = { subscription, handlers };\n            if (subscriptions == null) {\n                this.subscriptions.set(rawAddress, { [event]: eventData });\n            }\n            else {\n                subscriptions[event] = eventData;\n            }\n            // Wait until subscribed\n            return subscription.then(() => {\n            });\n        }, () => stopProducer(id), identity, isFinite);\n    }\n}\nexports.Subscriber = Subscriber;\nasync function identity(item, handler) {\n    return handler(item);\n}\nclass StreamImpl {\n    constructor(makeProducer, stopProducer, extractor, isFinite) {\n        this.makeProducer = makeProducer;\n        this.stopProducer = stopProducer;\n        this.extractor = extractor;\n        this.isFinite = isFinite;\n        /**\n         * Folds every element into an accumulator by applying an operation, returning the final result\n         */\n        this.fold = this.onlyFinite((init, f, ctx) => {\n            let state = init;\n            return new Promise((resolve, reject) => {\n                const subscribed = this.makeProducer(\n                // onData\n                (data) => this.extractor(data, async (item) => {\n                    state = await f(state, item);\n                    return true;\n                }), \n                // onEnd\n                (eof) => {\n                    if (eof) {\n                        resolve(state);\n                    }\n                    else {\n                        reject(new Error('Subscription closed'));\n                    }\n                });\n                if (ctx != null) {\n                    ctx.subscribed = subscribed;\n                }\n            });\n        });\n        /**\n         * Waits until the end of the stream\n         */\n        this.finished = this.onlyFinite((ctx) => {\n            return new Promise((resolve, reject) => {\n                const subscribed = this.makeProducer(\n                // onData\n                (data) => this.extractor(data, (_item) => true), \n                // onEnd\n                (eof) => {\n                    if (eof) {\n                        resolve(undefined);\n                    }\n                    else {\n                        reject(new Error('Subscription closed'));\n                    }\n                });\n                if (ctx != null) {\n                    ctx.subscribed = subscribed;\n                }\n            });\n        });\n    }\n    async delayed(f) {\n        const { subscribed, result } = f({\n            first: (() => {\n                const ctx = {};\n                const result = this.first(ctx);\n                return { subscribed: ctx.subscribed, result };\n            }),\n            on: (handler) => {\n                const ctx = {};\n                this.on(handler, ctx);\n                return { subscribed: ctx.subscribed, result: undefined };\n            },\n            fold: this.fold != null ? (init, f) => {\n                const ctx = {};\n                const result = this.fold(init, f, ctx);\n                return { subscribed: ctx.subscribed, result };\n            } : undefined,\n            finished: this.finished != null ? () => {\n                const ctx = {};\n                const result = this.finished(ctx);\n                return { subscribed: ctx.subscribed, result };\n            } : undefined,\n        });\n        await subscribed;\n        return () => result;\n    }\n    first(ctx) {\n        const state = { found: false };\n        return new Promise((resolve, reject) => {\n            const subscribed = this.makeProducer(\n            // onData\n            (data) => this.extractor(data, (item) => {\n                Object.assign(state, { found: true, result: item });\n                return false;\n            }), \n            // onEnd\n            (eof) => {\n                if (eof) {\n                    if (this.isFinite) {\n                        resolve((state.found ? state.result : undefined));\n                    }\n                    else if (state.found) {\n                        resolve(state.result);\n                    }\n                    else {\n                        reject(new Error('Unexpected end of stream'));\n                    }\n                }\n                else {\n                    reject(new Error('Subscription closed'));\n                }\n            });\n            if (ctx != null) {\n                ctx.subscribed = subscribed;\n            }\n        });\n    }\n    on(handler, ctx) {\n        const subscribed = this.makeProducer((event) => this.extractor(event, async (item) => {\n            await handler(item);\n            return true;\n        }), (_eof) => {\n        });\n        if (ctx != null) {\n            ctx.subscribed = subscribed;\n        }\n    }\n    merge(other) {\n        return new StreamImpl((onData, onEnd) => {\n            const state = {\n                stopped: false,\n                counter: 0,\n            };\n            const checkEnd = (eof) => {\n                if (state.stopped) {\n                    return;\n                }\n                if (++state.counter == 2 || !eof) {\n                    state.stopped = true;\n                    onEnd(eof);\n                }\n            };\n            return Promise.all([\n                this.makeProducer(onData, checkEnd),\n                other.makeProducer(onData, checkEnd),\n            ]).then(() => {\n            });\n        }, () => {\n            this.stopProducer();\n            other.stopProducer();\n        }, this.extractor, (this.isFinite && other.isFinite));\n    }\n    enumerate() {\n        const state = {\n            index: 0,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            return handler({\n                index: state.index++,\n                item,\n            });\n        }), this.isFinite);\n    }\n    tap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            await f(item);\n            return handler(item);\n        }), this.isFinite);\n    }\n    filter(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (await f(item)) {\n                return handler(item);\n            }\n            else {\n                return true;\n            }\n        }), this.isFinite);\n    }\n    filterMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const newItem = await f(item);\n            if (newItem !== undefined) {\n                return handler(newItem);\n            }\n            else {\n                return true;\n            }\n        }), this.isFinite);\n    }\n    map(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const newItem = await f(item);\n            return handler(newItem);\n        }), this.isFinite);\n    }\n    flatMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const items = await f(item);\n            for (const newItem of items) {\n                if (!(await handler(newItem))) {\n                    return false;\n                }\n            }\n            return true;\n        }), this.isFinite);\n    }\n    skip(n) {\n        const state = {\n            index: 0,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, (item) => {\n            if (state.index >= n) {\n                return handler(item);\n            }\n            else {\n                ++state.index;\n                return true;\n            }\n        }), this.isFinite);\n    }\n    skipWhile(f) {\n        const state = {\n            shouldSkip: true,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (!state.shouldSkip || !(await f(item))) {\n                state.shouldSkip = false;\n                return handler(item);\n            }\n            else {\n                return true;\n            }\n        }), this.isFinite);\n    }\n    take(n) {\n        const state = {\n            index: 0,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, (item) => {\n            if (state.index < n) {\n                ++state.index;\n                return handler(item);\n            }\n            else {\n                return false;\n            }\n        }), true);\n    }\n    takeWhile(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (await f(item)) {\n                return handler(item);\n            }\n            else {\n                return false;\n            }\n        }), true);\n    }\n    takeWhileMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const newItem = await f(item);\n            if (newItem !== undefined) {\n                return handler(newItem);\n            }\n            else {\n                return false;\n            }\n        }), true);\n    }\n    onlyFinite(f) {\n        if (this.isFinite) {\n            return f;\n        }\n        else {\n            return undefined;\n        }\n    }\n}\nclass UnorderedTransactionsScanner {\n    constructor(provider, params) {\n        this.provider = provider;\n        this.params = params;\n        this.queue = new PromiseQueue();\n        this.isRunning = false;\n    }\n    start() {\n        if (this.isRunning || this.promise != null) {\n            return;\n        }\n        this.isRunning = true;\n        this.promise = (async () => {\n            const params = this.params;\n            const state = {\n                complete: false,\n            };\n            while (this.isRunning && !state.complete) {\n                try {\n                    const { transactions, continuation } = await this.provider.getTransactions({\n                        address: this.params.address,\n                        continuation: this.continuation,\n                    });\n                    state.complete = !state.complete && transactions.length == null;\n                    if (!this.isRunning || state.complete) {\n                        break;\n                    }\n                    const filteredTransactions = transactions.filter((item) => ((params.fromLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, params.fromLt) > 0) &&\n                        (params.fromUtime == null || item.createdAt > params.fromUtime)));\n                    if (filteredTransactions.length == 0) {\n                        state.complete = true;\n                        break;\n                    }\n                    const info = {\n                        maxLt: filteredTransactions[0].id.lt,\n                        minLt: filteredTransactions[filteredTransactions.length - 1].id.lt,\n                        batchType: 'old',\n                    };\n                    this.queue.enqueue(async () => {\n                        const isRunning = this.params.onData({\n                            address: this.params.address,\n                            transactions: filteredTransactions,\n                            info,\n                        });\n                        if (!isRunning) {\n                            state.complete = true;\n                            this.isRunning = false;\n                        }\n                    });\n                    if (continuation != null) {\n                        this.continuation = continuation;\n                    }\n                    else {\n                        state.complete = true;\n                        break;\n                    }\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            }\n            this.queue.enqueue(async () => this.params.onEnd(state.complete));\n            this.isRunning = false;\n            this.continuation = undefined;\n        })();\n    }\n    async stop() {\n        this.isRunning = false;\n        this.queue.clear();\n        if (this.promise != null) {\n            await this.promise;\n        }\n        else {\n            this.params.onEnd(false);\n        }\n    }\n}\nclass TraceTransactionsScanner {\n    constructor(provider, params) {\n        this.provider = provider;\n        this.params = params;\n        this.queue = new PromiseQueue();\n        this.isRunning = false;\n        this.semaphore = new utils_1.Semaphore(10);\n    }\n    start() {\n        if (this.isRunning || this.promise != null) {\n            return;\n        }\n        const provider = this.provider;\n        this.isRunning = true;\n        this.promise = (async () => {\n            const state = {\n                complete: false,\n            };\n            const makePendingTransaction = (messageHash) => {\n                const state = { stopped: false };\n                const promise = (async () => {\n                    let timeout = 500;\n                    while (true) {\n                        const release = await this.semaphore.acquire();\n                        if (state.stopped) {\n                            release();\n                            return;\n                        }\n                        const result = await provider.rawApi.findTransaction({\n                            inMessageHash: messageHash,\n                        }).catch(() => ({ transaction: undefined })).finally(() => release());\n                        if (state.stopped) {\n                            return;\n                        }\n                        if (result.transaction != null) {\n                            const transaction = (0, models_1.parseTransaction)(result.transaction);\n                            transaction.account = transaction.inMessage.dst;\n                            return transaction;\n                        }\n                        let resolve;\n                        const promise = new Promise((resolvePromise, rejectPromise) => {\n                            resolve = () => resolvePromise();\n                            state.reject = () => rejectPromise();\n                        });\n                        state.timeout = setTimeout(resolve, timeout);\n                        await promise;\n                        if (state.stopped) {\n                            return;\n                        }\n                        state.reject = undefined;\n                        timeout = Math.min(timeout * 2, 3000);\n                    }\n                })();\n                const reject = () => {\n                    var _a;\n                    state.stopped = true;\n                    (_a = state.reject) === null || _a === void 0 ? void 0 : _a.call(state);\n                    if (state.timeout != null) {\n                        clearTimeout(state.timeout);\n                    }\n                };\n                return { promise, reject };\n            };\n            const transactionsQueue = [this.params.origin];\n            try {\n                outer: while (this.isRunning) {\n                    const transaction = transactionsQueue.shift();\n                    if (transaction == null) {\n                        state.complete = true;\n                        break;\n                    }\n                    // Spawn promises\n                    const pendingTransactions = transaction\n                        .outMessages\n                        .filter((message) => message.dst != null)\n                        .map((message) => {\n                        const messageHash = message.hash;\n                        return makePendingTransaction(messageHash);\n                    });\n                    this.pendingTransactions = pendingTransactions;\n                    for (const { promise } of pendingTransactions) {\n                        const childTransaction = await promise;\n                        if (!this.isRunning || state.complete || childTransaction == null) {\n                            break outer;\n                        }\n                        this.queue.enqueue(async () => {\n                            const isRunning = this.params.onData(childTransaction);\n                            if (!isRunning) {\n                                state.complete = true;\n                                this.isRunning = false;\n                                this.rejectPendingTransactions();\n                            }\n                        });\n                        transactionsQueue.push(childTransaction);\n                    }\n                    this.pendingTransactions = undefined;\n                }\n            }\n            catch (e) {\n                console.error(e);\n                /* do nothing */\n            }\n            finally {\n                this.queue.enqueue(async () => this.params.onEnd(state.complete));\n                this.isRunning = false;\n                this.rejectPendingTransactions();\n            }\n        })();\n    }\n    async stop() {\n        this.isRunning = false;\n        this.queue.clear();\n        this.rejectPendingTransactions();\n        if (this.promise != null) {\n            await this.promise;\n        }\n        else {\n            this.params.onEnd(false);\n        }\n    }\n    rejectPendingTransactions() {\n        if (this.pendingTransactions != null) {\n            for (const pendingTransaction of this.pendingTransactions) {\n                pendingTransaction.reject();\n            }\n            this.pendingTransactions = undefined;\n        }\n        this.semaphore.releaseAll();\n    }\n}\nclass PromiseQueue {\n    constructor() {\n        this.queue = [];\n        this.workingOnPromise = false;\n    }\n    enqueue(promise) {\n        this.queue.push(promise);\n        this._dequeue().catch(() => {\n        });\n    }\n    clear() {\n        this.queue.length = 0;\n    }\n    async _dequeue() {\n        if (this.workingOnPromise) {\n            return;\n        }\n        const item = this.queue.shift();\n        if (!item) {\n            return;\n        }\n        this.workingOnPromise = true;\n        item()\n            .then(() => {\n            this.workingOnPromise = false;\n            this._dequeue();\n        })\n            .catch(() => {\n            this.workingOnPromise = false;\n            this._dequeue();\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLWlucGFnZS1wcm92aWRlci9kaXN0L3N0cmVhbS5qcz80NWUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdWJzY3JpYmVyID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgbW9kZWxzXzEgPSByZXF1aXJlKFwiLi9tb2RlbHNcIik7XG4vKipcbiAqIEBjYXRlZ29yeSBTdHJlYW1cbiAqL1xuY2xhc3MgU3Vic2NyaWJlciB7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2Nhbm5lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSBhc3luYyAoKSA9PiB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyZWFtIG9mIG5ldyB0cmFuc2FjdGlvbnNcbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvbnMoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkU3Vic2NyaXB0aW9uKCd0cmFuc2FjdGlvbnNGb3VuZCcsIGFkZHJlc3MsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZpbml0ZSBzdHJlYW0gb2YgY2hpbGQgdHJhbnNhY3Rpb25zXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gcm9vdCB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIHRyYWNlKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGlkID0gKDAsIHV0aWxzXzEuZ2V0VW5pcXVlSWQpKCk7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCgob25EYXRhLCBvbkVuZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2Nhbm5lciA9IG5ldyBUcmFjZVRyYW5zYWN0aW9uc1NjYW5uZXIodGhpcy5wcm92aWRlciwge1xuICAgICAgICAgICAgICAgIG9yaWdpbjogdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgb25EYXRhLFxuICAgICAgICAgICAgICAgIG9uRW5kOiAoZW9mKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgb25FbmQoZW9mKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNjYW5uZXJzLnNldChpZCwgc2Nhbm5lcik7XG4gICAgICAgICAgICBzY2FubmVyLnN0YXJ0KCk7XG4gICAgICAgICAgICAvLyBTdWJzY3JpcHRpb24gaXMgbm90IHJlcXVpcmVkXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH0sIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjYW5uZXIgPSB0aGlzLnNjYW5uZXJzLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoc2Nhbm5lciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FubmVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHNjYW5uZXIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpZGVudGl0eSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJlYW0gb2Ygb2xkIHRyYW5zYWN0aW9uc1xuICAgICAqL1xuICAgIG9sZFRyYW5zYWN0aW9ucyhhZGRyZXNzLCBmaWx0ZXIpIHtcbiAgICAgICAgY29uc3QgaWQgPSAoMCwgdXRpbHNfMS5nZXRVbmlxdWVJZCkoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKChvbkRhdGEsIG9uRW5kKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2FubmVyID0gbmV3IFVub3JkZXJlZFRyYW5zYWN0aW9uc1NjYW5uZXIodGhpcy5wcm92aWRlciwge1xuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgb25EYXRhLFxuICAgICAgICAgICAgICAgIG9uRW5kOiAoZW9mKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgb25FbmQoZW9mKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC4uLmZpbHRlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zY2FubmVycy5zZXQoaWQsIHNjYW5uZXIpO1xuICAgICAgICAgICAgc2Nhbm5lci5zdGFydCgpO1xuICAgICAgICAgICAgLy8gU3Vic2NyaXB0aW9uIGlzIG5vdCByZXF1aXJlZFxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2FubmVyID0gdGhpcy5zY2FubmVycy5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKHNjYW5uZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzY2FubmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaWRlbnRpdHksIHRydWUpO1xuICAgIH1cbiAgICBzdGF0ZXMoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkU3Vic2NyaXB0aW9uKCdjb250cmFjdFN0YXRlQ2hhbmdlZCcsIGFkZHJlc3MsIGZhbHNlKTtcbiAgICB9XG4gICAgYXN5bmMgX3Vuc3Vic2NyaWJlKCkge1xuICAgICAgICBjb25zdCB0YXNrcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5zdWJzY3JpcHRpb25zLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtldmVudCwgZXZlbnREYXRhXSBvZiBPYmplY3QuZW50cmllcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtW2V2ZW50XTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnREYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaChldmVudERhdGEuc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihpdGVtID0+IGl0ZW0udW5zdWJzY3JpYmUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmNsZWFyKCk7XG4gICAgICAgIGZvciAoY29uc3Qgc2Nhbm5lciBvZiB0aGlzLnNjYW5uZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB0YXNrcy5wdXNoKHNjYW5uZXIuc3RvcCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjYW5uZXJzLmNsZWFyKCk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRhc2tzKTtcbiAgICB9XG4gICAgX2FkZFN1YnNjcmlwdGlvbihldmVudCwgYWRkcmVzcywgaXNGaW5pdGUpIHtcbiAgICAgICAgY29uc3QgcmF3QWRkcmVzcyA9IGFkZHJlc3MudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3Qgc3RvcFByb2R1Y2VyID0gKGlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zLmdldChyYXdBZGRyZXNzKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBzdWJzY3JpcHRpb25zIGZvciB0aGUgYWRkcmVzc1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IHN1YnNjcmlwdGlvbnNbZXZlbnRdO1xuICAgICAgICAgICAgaWYgKGV2ZW50RGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IGV2ZW50RGF0YS5oYW5kbGVycy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGV2ZW50IGhhbmRsZXIgd2l0aCB0aGUgaWRcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREYXRhLmhhbmRsZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcXVldWUsIG9uRW5kLCBzdGF0ZSB9ID0gaGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLmVucXVldWUoYXN5bmMgKCkgPT4gb25FbmQoc3RhdGUuZW9mKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGV2ZW50IGRhdGEgc3Vic2NyaXB0aW9uIGlmIHRoZXJlIGFyZSBub25lIG9mIHRoZW1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnREYXRhLmhhbmRsZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gZXZlbnREYXRhLnN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN1YnNjcmlwdGlvbnNbZXZlbnRdO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChzdWJzY3JpcHRpb24pID0+IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGNvbnNvbGUuZGVidWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBhZGRyZXNzIHN1YnNjcmlwdGlvbnMgb2JqZWN0IGlmIGl0IGlzIGVtcHR5XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9ucy5jb250cmFjdFN0YXRlQ2hhbmdlZCA9PSBudWxsICYmIHN1YnNjcmlwdGlvbnMudHJhbnNhY3Rpb25zRm91bmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kZWxldGUocmF3QWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGlkID0gKDAsIHV0aWxzXzEuZ2V0VW5pcXVlSWQpKCk7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCgob25EYXRhLCBvbkVuZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQocmF3QWRkcmVzcyk7XG4gICAgICAgICAgICBsZXQgZXZlbnREYXRhID0gc3Vic2NyaXB0aW9ucyA9PT0gbnVsbCB8fCBzdWJzY3JpcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdWJzY3JpcHRpb25zW2V2ZW50XTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0geyBlb2Y6IGZhbHNlLCBmaW5pc2hlZDogZmFsc2UgfTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBoYW5kbGVyIG9iamVjdFxuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHtcbiAgICAgICAgICAgICAgICBvbkRhdGEsXG4gICAgICAgICAgICAgICAgb25FbmQsXG4gICAgICAgICAgICAgICAgcXVldWU6IG5ldyBQcm9taXNlUXVldWUoKSxcbiAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXZlbnREYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgaGFuZGxlciBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgaGFuZGxlciBncm91cFxuICAgICAgICAgICAgICAgIGV2ZW50RGF0YS5oYW5kbGVycy5zZXQoaWQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENyZWF0ZSBoYW5kbGVycyBncm91cFxuICAgICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBoYW5kbGVycy5zZXQoaWQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5wcm92aWRlci5zdWJzY3JpYmUoZXZlbnQsIHsgYWRkcmVzcyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChzdWJzY3JpcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgb25EYXRhLCBxdWV1ZSwgc3RhdGUgfSBvZiBoYW5kbGVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBjbG9zZWQgc3RyZWFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmVvZiB8fCBzdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYXdhaXQgb25EYXRhKGRhdGEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5lb2YgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wUHJvZHVjZXIoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLm9uKCd1bnN1YnNjcmliZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaWQgb2YgaGFuZGxlcnMua2V5cygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wUHJvZHVjZXIoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGhhbmRsZXJzLmtleXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9wUHJvZHVjZXIoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBZGQgZXZlbnQgZGF0YSB0byBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgICBldmVudERhdGEgPSB7IHN1YnNjcmlwdGlvbiwgaGFuZGxlcnMgfTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuc2V0KHJhd0FkZHJlc3MsIHsgW2V2ZW50XTogZXZlbnREYXRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uc1tldmVudF0gPSBldmVudERhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXYWl0IHVudGlsIHN1YnNjcmliZWRcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb24udGhlbigoKSA9PiB7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgKCkgPT4gc3RvcFByb2R1Y2VyKGlkKSwgaWRlbnRpdHksIGlzRmluaXRlKTtcbiAgICB9XG59XG5leHBvcnRzLlN1YnNjcmliZXIgPSBTdWJzY3JpYmVyO1xuYXN5bmMgZnVuY3Rpb24gaWRlbnRpdHkoaXRlbSwgaGFuZGxlcikge1xuICAgIHJldHVybiBoYW5kbGVyKGl0ZW0pO1xufVxuY2xhc3MgU3RyZWFtSW1wbCB7XG4gICAgY29uc3RydWN0b3IobWFrZVByb2R1Y2VyLCBzdG9wUHJvZHVjZXIsIGV4dHJhY3RvciwgaXNGaW5pdGUpIHtcbiAgICAgICAgdGhpcy5tYWtlUHJvZHVjZXIgPSBtYWtlUHJvZHVjZXI7XG4gICAgICAgIHRoaXMuc3RvcFByb2R1Y2VyID0gc3RvcFByb2R1Y2VyO1xuICAgICAgICB0aGlzLmV4dHJhY3RvciA9IGV4dHJhY3RvcjtcbiAgICAgICAgdGhpcy5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9sZHMgZXZlcnkgZWxlbWVudCBpbnRvIGFuIGFjY3VtdWxhdG9yIGJ5IGFwcGx5aW5nIGFuIG9wZXJhdGlvbiwgcmV0dXJuaW5nIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9sZCA9IHRoaXMub25seUZpbml0ZSgoaW5pdCwgZiwgY3R4KSA9PiB7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSBpbml0O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVkID0gdGhpcy5tYWtlUHJvZHVjZXIoXG4gICAgICAgICAgICAgICAgLy8gb25EYXRhXG4gICAgICAgICAgICAgICAgKGRhdGEpID0+IHRoaXMuZXh0cmFjdG9yKGRhdGEsIGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gYXdhaXQgZihzdGF0ZSwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICAvLyBvbkVuZFxuICAgICAgICAgICAgICAgIChlb2YpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVvZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdTdWJzY3JpcHRpb24gY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdWJzY3JpYmVkID0gc3Vic2NyaWJlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXYWl0cyB1bnRpbCB0aGUgZW5kIG9mIHRoZSBzdHJlYW1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0aGlzLm9ubHlGaW5pdGUoKGN0eCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVkID0gdGhpcy5tYWtlUHJvZHVjZXIoXG4gICAgICAgICAgICAgICAgLy8gb25EYXRhXG4gICAgICAgICAgICAgICAgKGRhdGEpID0+IHRoaXMuZXh0cmFjdG9yKGRhdGEsIChfaXRlbSkgPT4gdHJ1ZSksIFxuICAgICAgICAgICAgICAgIC8vIG9uRW5kXG4gICAgICAgICAgICAgICAgKGVvZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdTdWJzY3JpcHRpb24gY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdWJzY3JpYmVkID0gc3Vic2NyaWJlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGF5ZWQoZikge1xuICAgICAgICBjb25zdCB7IHN1YnNjcmliZWQsIHJlc3VsdCB9ID0gZih7XG4gICAgICAgICAgICBmaXJzdDogKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdHggPSB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmZpcnN0KGN0eCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3Vic2NyaWJlZDogY3R4LnN1YnNjcmliZWQsIHJlc3VsdCB9O1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvbjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdHggPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKGhhbmRsZXIsIGN0eCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3Vic2NyaWJlZDogY3R4LnN1YnNjcmliZWQsIHJlc3VsdDogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9sZDogdGhpcy5mb2xkICE9IG51bGwgPyAoaW5pdCwgZikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZm9sZChpbml0LCBmLCBjdHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN1YnNjcmliZWQ6IGN0eC5zdWJzY3JpYmVkLCByZXN1bHQgfTtcbiAgICAgICAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBmaW5pc2hlZDogdGhpcy5maW5pc2hlZCAhPSBudWxsID8gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZmluaXNoZWQoY3R4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdWJzY3JpYmVkOiBjdHguc3Vic2NyaWJlZCwgcmVzdWx0IH07XG4gICAgICAgICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgc3Vic2NyaWJlZDtcbiAgICAgICAgcmV0dXJuICgpID0+IHJlc3VsdDtcbiAgICB9XG4gICAgZmlyc3QoY3R4KSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0geyBmb3VuZDogZmFsc2UgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZWQgPSB0aGlzLm1ha2VQcm9kdWNlcihcbiAgICAgICAgICAgIC8vIG9uRGF0YVxuICAgICAgICAgICAgKGRhdGEpID0+IHRoaXMuZXh0cmFjdG9yKGRhdGEsIChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdGF0ZSwgeyBmb3VuZDogdHJ1ZSwgcmVzdWx0OiBpdGVtIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgIC8vIG9uRW5kXG4gICAgICAgICAgICAoZW9mKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVvZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0Zpbml0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgoc3RhdGUuZm91bmQgPyBzdGF0ZS5yZXN1bHQgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZS5mb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdGF0ZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2Ygc3RyZWFtJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdTdWJzY3JpcHRpb24gY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN1YnNjcmliZWQgPSBzdWJzY3JpYmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb24oaGFuZGxlciwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZWQgPSB0aGlzLm1ha2VQcm9kdWNlcigoZXZlbnQpID0+IHRoaXMuZXh0cmFjdG9yKGV2ZW50LCBhc3luYyAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlcihpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KSwgKF9lb2YpID0+IHtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgY3R4LnN1YnNjcmliZWQgPSBzdWJzY3JpYmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCgob25EYXRhLCBvbkVuZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgc3RvcHBlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY291bnRlcjogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjaGVja0VuZCA9IChlb2YpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgrK3N0YXRlLmNvdW50ZXIgPT0gMiB8fCAhZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvbkVuZChlb2YpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMubWFrZVByb2R1Y2VyKG9uRGF0YSwgY2hlY2tFbmQpLFxuICAgICAgICAgICAgICAgIG90aGVyLm1ha2VQcm9kdWNlcihvbkRhdGEsIGNoZWNrRW5kKSxcbiAgICAgICAgICAgIF0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFByb2R1Y2VyKCk7XG4gICAgICAgICAgICBvdGhlci5zdG9wUHJvZHVjZXIoKTtcbiAgICAgICAgfSwgdGhpcy5leHRyYWN0b3IsICh0aGlzLmlzRmluaXRlICYmIG90aGVyLmlzRmluaXRlKSk7XG4gICAgfVxuICAgIGVudW1lcmF0ZSgpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKHRoaXMubWFrZVByb2R1Y2VyLCB0aGlzLnN0b3BQcm9kdWNlciwgKGV2ZW50LCBoYW5kbGVyKSA9PiB0aGlzLmV4dHJhY3RvcihldmVudCwgYXN5bmMgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyKHtcbiAgICAgICAgICAgICAgICBpbmRleDogc3RhdGUuaW5kZXgrKyxcbiAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLCB0aGlzLmlzRmluaXRlKTtcbiAgICB9XG4gICAgdGFwKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKHRoaXMubWFrZVByb2R1Y2VyLCB0aGlzLnN0b3BQcm9kdWNlciwgKGV2ZW50LCBoYW5kbGVyKSA9PiB0aGlzLmV4dHJhY3RvcihldmVudCwgYXN5bmMgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGF3YWl0IGYoaXRlbSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlcihpdGVtKTtcbiAgICAgICAgfSksIHRoaXMuaXNGaW5pdGUpO1xuICAgIH1cbiAgICBmaWx0ZXIoZikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwodGhpcy5tYWtlUHJvZHVjZXIsIHRoaXMuc3RvcFByb2R1Y2VyLCAoZXZlbnQsIGhhbmRsZXIpID0+IHRoaXMuZXh0cmFjdG9yKGV2ZW50LCBhc3luYyAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGF3YWl0IGYoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcihpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgdGhpcy5pc0Zpbml0ZSk7XG4gICAgfVxuICAgIGZpbHRlck1hcChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCh0aGlzLm1ha2VQcm9kdWNlciwgdGhpcy5zdG9wUHJvZHVjZXIsIChldmVudCwgaGFuZGxlcikgPT4gdGhpcy5leHRyYWN0b3IoZXZlbnQsIGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtID0gYXdhaXQgZihpdGVtKTtcbiAgICAgICAgICAgIGlmIChuZXdJdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcihuZXdJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgdGhpcy5pc0Zpbml0ZSk7XG4gICAgfVxuICAgIG1hcChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCh0aGlzLm1ha2VQcm9kdWNlciwgdGhpcy5zdG9wUHJvZHVjZXIsIChldmVudCwgaGFuZGxlcikgPT4gdGhpcy5leHRyYWN0b3IoZXZlbnQsIGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtID0gYXdhaXQgZihpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyKG5ld0l0ZW0pO1xuICAgICAgICB9KSwgdGhpcy5pc0Zpbml0ZSk7XG4gICAgfVxuICAgIGZsYXRNYXAoZikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwodGhpcy5tYWtlUHJvZHVjZXIsIHRoaXMuc3RvcFByb2R1Y2VyLCAoZXZlbnQsIGhhbmRsZXIpID0+IHRoaXMuZXh0cmFjdG9yKGV2ZW50LCBhc3luYyAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBhd2FpdCBmKGl0ZW0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBuZXdJdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoYXdhaXQgaGFuZGxlcihuZXdJdGVtKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KSwgdGhpcy5pc0Zpbml0ZSk7XG4gICAgfVxuICAgIHNraXAobikge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwodGhpcy5tYWtlUHJvZHVjZXIsIHRoaXMuc3RvcFByb2R1Y2VyLCAoZXZlbnQsIGhhbmRsZXIpID0+IHRoaXMuZXh0cmFjdG9yKGV2ZW50LCAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmluZGV4ID49IG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcihpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICsrc3RhdGUuaW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCB0aGlzLmlzRmluaXRlKTtcbiAgICB9XG4gICAgc2tpcFdoaWxlKGYpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICBzaG91bGRTa2lwOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwodGhpcy5tYWtlUHJvZHVjZXIsIHRoaXMuc3RvcFByb2R1Y2VyLCAoZXZlbnQsIGhhbmRsZXIpID0+IHRoaXMuZXh0cmFjdG9yKGV2ZW50LCBhc3luYyAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5zaG91bGRTa2lwIHx8ICEoYXdhaXQgZihpdGVtKSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zaG91bGRTa2lwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHRoaXMuaXNGaW5pdGUpO1xuICAgIH1cbiAgICB0YWtlKG4pIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKHRoaXMubWFrZVByb2R1Y2VyLCB0aGlzLnN0b3BQcm9kdWNlciwgKGV2ZW50LCBoYW5kbGVyKSA9PiB0aGlzLmV4dHJhY3RvcihldmVudCwgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pbmRleCA8IG4pIHtcbiAgICAgICAgICAgICAgICArK3N0YXRlLmluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRha2VXaGlsZShmKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCh0aGlzLm1ha2VQcm9kdWNlciwgdGhpcy5zdG9wUHJvZHVjZXIsIChldmVudCwgaGFuZGxlcikgPT4gdGhpcy5leHRyYWN0b3IoZXZlbnQsIGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXdhaXQgZihpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRha2VXaGlsZU1hcChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCh0aGlzLm1ha2VQcm9kdWNlciwgdGhpcy5zdG9wUHJvZHVjZXIsIChldmVudCwgaGFuZGxlcikgPT4gdGhpcy5leHRyYWN0b3IoZXZlbnQsIGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtID0gYXdhaXQgZihpdGVtKTtcbiAgICAgICAgICAgIGlmIChuZXdJdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcihuZXdJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHRydWUpO1xuICAgIH1cbiAgICBvbmx5RmluaXRlKGYpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFVub3JkZXJlZFRyYW5zYWN0aW9uc1NjYW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQcm9taXNlUXVldWUoKTtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUnVubmluZyB8fCB0aGlzLnByb21pc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzUnVubmluZyAmJiAhc3RhdGUuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9ucywgY29udGludWF0aW9uIH0gPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLnBhcmFtcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWF0aW9uOiB0aGlzLmNvbnRpbnVhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlID0gIXN0YXRlLmNvbXBsZXRlICYmIHRyYW5zYWN0aW9ucy5sZW5ndGggPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZyB8fCBzdGF0ZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRUcmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMuZmlsdGVyKChpdGVtKSA9PiAoKHBhcmFtcy5mcm9tTHQgPT0gbnVsbCB8fCB1dGlsc18xLkxUX0NPTExBVE9SLmNvbXBhcmUoaXRlbS5pZC5sdCwgcGFyYW1zLmZyb21MdCkgPiAwKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHBhcmFtcy5mcm9tVXRpbWUgPT0gbnVsbCB8fCBpdGVtLmNyZWF0ZWRBdCA+IHBhcmFtcy5mcm9tVXRpbWUpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJlZFRyYW5zYWN0aW9ucy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEx0OiBmaWx0ZXJlZFRyYW5zYWN0aW9uc1swXS5pZC5sdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkx0OiBmaWx0ZXJlZFRyYW5zYWN0aW9uc1tmaWx0ZXJlZFRyYW5zYWN0aW9ucy5sZW5ndGggLSAxXS5pZC5sdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoVHlwZTogJ29sZCcsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1J1bm5pbmcgPSB0aGlzLnBhcmFtcy5vbkRhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMucGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBmaWx0ZXJlZFRyYW5zYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUnVubmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRpbnVhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVhdGlvbiA9IGNvbnRpbnVhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHRoaXMucGFyYW1zLm9uRW5kKHN0YXRlLmNvbXBsZXRlKSk7XG4gICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jb250aW51YXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGFzeW5jIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucXVldWUuY2xlYXIoKTtcbiAgICAgICAgaWYgKHRoaXMucHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy5vbkVuZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBUcmFjZVRyYW5zYWN0aW9uc1NjYW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQcm9taXNlUXVldWUoKTtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZW1hcGhvcmUgPSBuZXcgdXRpbHNfMS5TZW1hcGhvcmUoMTApO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nIHx8IHRoaXMucHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyO1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbWFrZVBlbmRpbmdUcmFuc2FjdGlvbiA9IChtZXNzYWdlSGFzaCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0geyBzdG9wcGVkOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGltZW91dCA9IDUwMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGVhc2UgPSBhd2FpdCB0aGlzLnNlbWFwaG9yZS5hY3F1aXJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5yYXdBcGkuZmluZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbk1lc3NhZ2VIYXNoOiBtZXNzYWdlSGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKCgpID0+ICh7IHRyYW5zYWN0aW9uOiB1bmRlZmluZWQgfSkpLmZpbmFsbHkoKCkgPT4gcmVsZWFzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC50cmFuc2FjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSAoMCwgbW9kZWxzXzEucGFyc2VUcmFuc2FjdGlvbikocmVzdWx0LnRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5hY2NvdW50ID0gdHJhbnNhY3Rpb24uaW5NZXNzYWdlLmRzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gKCkgPT4gcmVzb2x2ZVByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5yZWplY3QgPSAoKSA9PiByZWplY3RQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUucmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IE1hdGgubWluKHRpbWVvdXQgKiAyLCAzMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVqZWN0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdGF0ZS5yZWplY3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBwcm9taXNlLCByZWplY3QgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbnNRdWV1ZSA9IFt0aGlzLnBhcmFtcy5vcmlnaW5dO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvdXRlcjogd2hpbGUgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25zUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNwYXduIHByb21pc2VzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdUcmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLm91dE1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChtZXNzYWdlKSA9PiBtZXNzYWdlLmRzdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZUhhc2ggPSBtZXNzYWdlLmhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZVBlbmRpbmdUcmFuc2FjdGlvbihtZXNzYWdlSGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUcmFuc2FjdGlvbnMgPSBwZW5kaW5nVHJhbnNhY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcHJvbWlzZSB9IG9mIHBlbmRpbmdUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkVHJhbnNhY3Rpb24gPSBhd2FpdCBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZyB8fCBzdGF0ZS5jb21wbGV0ZSB8fCBjaGlsZFRyYW5zYWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNSdW5uaW5nID0gdGhpcy5wYXJhbXMub25EYXRhKGNoaWxkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3RQZW5kaW5nVHJhbnNhY3Rpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnNRdWV1ZS5wdXNoKGNoaWxkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1RyYW5zYWN0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgLyogZG8gbm90aGluZyAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHRoaXMucGFyYW1zLm9uRW5kKHN0YXRlLmNvbXBsZXRlKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdFBlbmRpbmdUcmFuc2FjdGlvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5xdWV1ZS5jbGVhcigpO1xuICAgICAgICB0aGlzLnJlamVjdFBlbmRpbmdUcmFuc2FjdGlvbnMoKTtcbiAgICAgICAgaWYgKHRoaXMucHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy5vbkVuZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVqZWN0UGVuZGluZ1RyYW5zYWN0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1RyYW5zYWN0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBlbmRpbmdUcmFuc2FjdGlvbiBvZiB0aGlzLnBlbmRpbmdUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nVHJhbnNhY3Rpb24ucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdUcmFuc2FjdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW1hcGhvcmUucmVsZWFzZUFsbCgpO1xuICAgIH1cbn1cbmNsYXNzIFByb21pc2VRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy53b3JraW5nT25Qcm9taXNlID0gZmFsc2U7XG4gICAgfVxuICAgIGVucXVldWUocHJvbWlzZSkge1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2gocHJvbWlzZSk7XG4gICAgICAgIHRoaXMuX2RlcXVldWUoKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5xdWV1ZS5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBhc3luYyBfZGVxdWV1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2luZ09uUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud29ya2luZ09uUHJvbWlzZSA9IHRydWU7XG4gICAgICAgIGl0ZW0oKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53b3JraW5nT25Qcm9taXNlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9kZXF1ZXVlKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53b3JraW5nT25Qcm9taXNlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9kZXF1ZXVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///25\n")},786:(__unused_webpack_module,exports)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getUniqueId = exports.mergeTransactions = exports.LT_COLLATOR = exports.Semaphore = exports.DelayedTransactions = exports.MessageExpiredException = exports.AddressLiteral = exports.Address = void 0;\n/**\n * @category Utils\n */\nclass Address {\n    constructor(address) {\n        this.equals = (other) => this._equals(other);\n        this._address = address;\n    }\n    toString() {\n        return this._address;\n    }\n    toJSON() {\n        return this._address;\n    }\n    _equals(other) {\n        if (other instanceof Address) {\n            return this._address === other._address;\n        }\n        else {\n            return this._address === other;\n        }\n    }\n}\nexports.Address = Address;\n/**\n * @category Utils\n */\nclass AddressLiteral extends Address {\n    constructor(address) {\n        super(address);\n    }\n}\nexports.AddressLiteral = AddressLiteral;\n/**\n * @category Utils\n */\nclass MessageExpiredException extends Error {\n    constructor(address, hash) {\n        super('Message expired');\n        this.address = address;\n        this.hash = hash;\n    }\n}\nexports.MessageExpiredException = MessageExpiredException;\nclass DelayedTransactions {\n    constructor() {\n        this.transactions = new Map();\n    }\n    async waitTransaction(address, hash) {\n        var _a;\n        let transaction = (_a = this.transactions.get(hash)) === null || _a === void 0 ? void 0 : _a.promise;\n        if (transaction == null) {\n            let resolve;\n            let reject;\n            transaction = new Promise((promiseResolve, promiseReject) => {\n                resolve = (tx) => promiseResolve(tx);\n                reject = () => promiseReject();\n            });\n            this.transactions.set(hash, {\n                promise: transaction,\n                resolve: resolve,\n                reject: reject,\n            });\n        }\n        const tx = await transaction;\n        if (tx == null) {\n            throw new MessageExpiredException(address, hash);\n        }\n        return tx;\n    }\n    fillTransaction(hash, transaction) {\n        const pendingTransaction = this.transactions.get(hash);\n        if (pendingTransaction != null) {\n            pendingTransaction.resolve(transaction);\n        }\n        else {\n            this.transactions.set(hash, {\n                promise: Promise.resolve(transaction),\n                resolve: () => {\n                },\n                reject: () => {\n                },\n            });\n        }\n    }\n}\nexports.DelayedTransactions = DelayedTransactions;\n/**\n * @category Utils\n */\nclass Semaphore {\n    constructor(count) {\n        this.tasks = [];\n        this.sched = () => {\n            var _a;\n            if (this.count > 0 && this.tasks.length > 0) {\n                this.count--;\n                (_a = this.tasks.shift()) === null || _a === void 0 ? void 0 : _a();\n            }\n        };\n        this.count = count;\n    }\n    acquire() {\n        return new Promise((res, _rej) => {\n            this.tasks.push(() => {\n                let released = false;\n                res(() => {\n                    if (!released) {\n                        released = true;\n                        this.count++;\n                        this.sched();\n                    }\n                });\n            });\n            nextTick(this.sched);\n        });\n    }\n    releaseAll() {\n        var _a;\n        while (this.tasks.length > 0) {\n            (_a = this.tasks.shift()) === null || _a === void 0 ? void 0 : _a();\n        }\n    }\n}\nexports.Semaphore = Semaphore;\nfunction byObserver(Observer) {\n    const node = document.createTextNode('');\n    let queue, currentQueue, bit = 0, i = 0;\n    new Observer(function () {\n        let callback;\n        if (!queue) {\n            if (!currentQueue)\n                return;\n            queue = currentQueue;\n        }\n        else if (currentQueue) {\n            queue = currentQueue.slice(i).concat(queue);\n        }\n        currentQueue = queue;\n        queue = null;\n        i = 0;\n        if (typeof currentQueue === 'function') {\n            callback = currentQueue;\n            currentQueue = null;\n            callback();\n            return;\n        }\n        node.data = (bit = ++bit % 2);\n        while (i < currentQueue.length) {\n            callback = currentQueue[i];\n            i++;\n            if (i === currentQueue.length)\n                currentQueue = null;\n            callback();\n        }\n    }).observe(node, { characterData: true });\n    return function (fn) {\n        if (queue) {\n            if (typeof queue === 'function')\n                queue = [queue, fn];\n            else\n                queue.push(fn);\n            return;\n        }\n        queue = fn;\n        node.data = (bit = ++bit % 2);\n    };\n}\nconst nextTick = (function () {\n    // queueMicrotask\n    if (typeof queueMicrotask === 'function') {\n        return queueMicrotask;\n    }\n    // MutationObserver\n    if ((typeof document === 'object') && document) {\n        if (typeof MutationObserver === 'function')\n            return byObserver(MutationObserver);\n        if (typeof window.WebKitMutationObserver === 'function')\n            return byObserver(window.WebKitMutationObserver);\n    }\n    /* @ts-ignore */\n    if (typeof setImmediate === 'function') {\n        /* @ts-ignore */\n        return setImmediate;\n    }\n    if ((typeof setTimeout === 'function') || (typeof setTimeout === 'object')) {\n        return function (cb) {\n            setTimeout(cb, 0);\n        };\n    }\n    throw new Error('No `nextTick` implementation found');\n}());\n/**\n * @category Utils\n */\nexports.LT_COLLATOR = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });\n/**\n * Modifies knownTransactions array, merging it with new transactions.\n * All arrays are assumed to be sorted by descending logical time.\n *\n * > Note! This method does not remove duplicates.\n *\n * @param knownTransactions\n * @param newTransactions\n * @param info\n *\n * @category Utils\n */\nfunction mergeTransactions(knownTransactions, newTransactions, info) {\n    if (info.batchType === 'old') {\n        knownTransactions.push(...newTransactions);\n        return knownTransactions;\n    }\n    if (knownTransactions.length === 0) {\n        knownTransactions.push(...newTransactions);\n        return knownTransactions;\n    }\n    // Example:\n    // known lts: [N, N-1, N-2, N-3, (!) N-10,...]\n    // new lts: [N-4, N-5]\n    // batch info: { minLt: N-5, maxLt: N-4, batchType: 'new' }\n    // 1. Skip indices until known transaction lt is greater than the biggest in the batch\n    let i = 0;\n    while (i < knownTransactions.length &&\n        exports.LT_COLLATOR.compare(knownTransactions[i].id.lt, info.maxLt) >= 0) {\n        ++i;\n    }\n    // 2. Insert new transactions\n    knownTransactions.splice(i, 0, ...newTransactions);\n    return knownTransactions;\n}\nexports.mergeTransactions = mergeTransactions;\nconst MAX = 4294967295;\nlet idCounter = Math.floor(Math.random() * MAX);\nfunction getUniqueId() {\n    idCounter = (idCounter + 1) % MAX;\n    return idCounter;\n}\nexports.getUniqueId = getUniqueId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXIvZGlzdC91dGlscy5qcz80M2IyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRVbmlxdWVJZCA9IGV4cG9ydHMubWVyZ2VUcmFuc2FjdGlvbnMgPSBleHBvcnRzLkxUX0NPTExBVE9SID0gZXhwb3J0cy5TZW1hcGhvcmUgPSBleHBvcnRzLkRlbGF5ZWRUcmFuc2FjdGlvbnMgPSBleHBvcnRzLk1lc3NhZ2VFeHBpcmVkRXhjZXB0aW9uID0gZXhwb3J0cy5BZGRyZXNzTGl0ZXJhbCA9IGV4cG9ydHMuQWRkcmVzcyA9IHZvaWQgMDtcbi8qKlxuICogQGNhdGVnb3J5IFV0aWxzXG4gKi9cbmNsYXNzIEFkZHJlc3Mge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MpIHtcbiAgICAgICAgdGhpcy5lcXVhbHMgPSAob3RoZXIpID0+IHRoaXMuX2VxdWFscyhvdGhlcik7XG4gICAgICAgIHRoaXMuX2FkZHJlc3MgPSBhZGRyZXNzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3M7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3M7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQWRkcmVzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3MgPT09IG90aGVyLl9hZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3MgPT09IG90aGVyO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzID0gQWRkcmVzcztcbi8qKlxuICogQGNhdGVnb3J5IFV0aWxzXG4gKi9cbmNsYXNzIEFkZHJlc3NMaXRlcmFsIGV4dGVuZHMgQWRkcmVzcyB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcykge1xuICAgICAgICBzdXBlcihhZGRyZXNzKTtcbiAgICB9XG59XG5leHBvcnRzLkFkZHJlc3NMaXRlcmFsID0gQWRkcmVzc0xpdGVyYWw7XG4vKipcbiAqIEBjYXRlZ29yeSBVdGlsc1xuICovXG5jbGFzcyBNZXNzYWdlRXhwaXJlZEV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBoYXNoKSB7XG4gICAgICAgIHN1cGVyKCdNZXNzYWdlIGV4cGlyZWQnKTtcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5oYXNoID0gaGFzaDtcbiAgICB9XG59XG5leHBvcnRzLk1lc3NhZ2VFeHBpcmVkRXhjZXB0aW9uID0gTWVzc2FnZUV4cGlyZWRFeGNlcHRpb247XG5jbGFzcyBEZWxheWVkVHJhbnNhY3Rpb25zIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRUcmFuc2FjdGlvbihhZGRyZXNzLCBoYXNoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHRyYW5zYWN0aW9uID0gKF9hID0gdGhpcy50cmFuc2FjdGlvbnMuZ2V0KGhhc2gpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvbWlzZTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlO1xuICAgICAgICAgICAgbGV0IHJlamVjdDtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gbmV3IFByb21pc2UoKHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9ICh0eCkgPT4gcHJvbWlzZVJlc29sdmUodHgpO1xuICAgICAgICAgICAgICAgIHJlamVjdCA9ICgpID0+IHByb21pc2VSZWplY3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMuc2V0KGhhc2gsIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlOiB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0cmFuc2FjdGlvbjtcbiAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZXNzYWdlRXhwaXJlZEV4Y2VwdGlvbihhZGRyZXNzLCBoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIGZpbGxUcmFuc2FjdGlvbihoYXNoLCB0cmFuc2FjdGlvbikge1xuICAgICAgICBjb25zdCBwZW5kaW5nVHJhbnNhY3Rpb24gPSB0aGlzLnRyYW5zYWN0aW9ucy5nZXQoaGFzaCk7XG4gICAgICAgIGlmIChwZW5kaW5nVHJhbnNhY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgcGVuZGluZ1RyYW5zYWN0aW9uLnJlc29sdmUodHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMuc2V0KGhhc2gsIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlOiBQcm9taXNlLnJlc29sdmUodHJhbnNhY3Rpb24pLFxuICAgICAgICAgICAgICAgIHJlc29sdmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlamVjdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRGVsYXllZFRyYW5zYWN0aW9ucyA9IERlbGF5ZWRUcmFuc2FjdGlvbnM7XG4vKipcbiAqIEBjYXRlZ29yeSBVdGlsc1xuICovXG5jbGFzcyBTZW1hcGhvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNvdW50KSB7XG4gICAgICAgIHRoaXMudGFza3MgPSBbXTtcbiAgICAgICAgdGhpcy5zY2hlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50ID4gMCAmJiB0aGlzLnRhc2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50LS07XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy50YXNrcy5zaGlmdCgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgIH1cbiAgICBhY3F1aXJlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgX3JlaikgPT4ge1xuICAgICAgICAgICAgdGhpcy50YXNrcy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVsZWFzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXMoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbGVhc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjaGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV4dFRpY2sodGhpcy5zY2hlZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWxlYXNlQWxsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHdoaWxlICh0aGlzLnRhc2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMudGFza3Muc2hpZnQoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNlbWFwaG9yZSA9IFNlbWFwaG9yZTtcbmZ1bmN0aW9uIGJ5T2JzZXJ2ZXIoT2JzZXJ2ZXIpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIGxldCBxdWV1ZSwgY3VycmVudFF1ZXVlLCBiaXQgPSAwLCBpID0gMDtcbiAgICBuZXcgT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgY2FsbGJhY2s7XG4gICAgICAgIGlmICghcXVldWUpIHtcbiAgICAgICAgICAgIGlmICghY3VycmVudFF1ZXVlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuc2xpY2UoaSkuY29uY2F0KHF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBudWxsO1xuICAgICAgICBpID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50UXVldWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY3VycmVudFF1ZXVlO1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5kYXRhID0gKGJpdCA9ICsrYml0ICUgMik7XG4gICAgICAgIHdoaWxlIChpIDwgY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjdXJyZW50UXVldWVbaV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAoaSA9PT0gY3VycmVudFF1ZXVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH0pLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKHF1ZXVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXVlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHF1ZXVlID0gW3F1ZXVlLCBmbl07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcXVldWUgPSBmbjtcbiAgICAgICAgbm9kZS5kYXRhID0gKGJpdCA9ICsrYml0ICUgMik7XG4gICAgfTtcbn1cbmNvbnN0IG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBxdWV1ZU1pY3JvdGFza1xuICAgIGlmICh0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXVlTWljcm90YXNrO1xuICAgIH1cbiAgICAvLyBNdXRhdGlvbk9ic2VydmVyXG4gICAgaWYgKCh0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnKSAmJiBkb2N1bWVudCkge1xuICAgICAgICBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm4gYnlPYnNlcnZlcihNdXRhdGlvbk9ic2VydmVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiBieU9ic2VydmVyKHdpbmRvdy5XZWJLaXRNdXRhdGlvbk9ic2VydmVyKTtcbiAgICB9XG4gICAgLyogQHRzLWlnbm9yZSAqL1xuICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZTtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykgfHwgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gYG5leHRUaWNrYCBpbXBsZW1lbnRhdGlvbiBmb3VuZCcpO1xufSgpKTtcbi8qKlxuICogQGNhdGVnb3J5IFV0aWxzXG4gKi9cbmV4cG9ydHMuTFRfQ09MTEFUT1IgPSBuZXcgSW50bC5Db2xsYXRvcih1bmRlZmluZWQsIHsgbnVtZXJpYzogdHJ1ZSwgc2Vuc2l0aXZpdHk6ICdiYXNlJyB9KTtcbi8qKlxuICogTW9kaWZpZXMga25vd25UcmFuc2FjdGlvbnMgYXJyYXksIG1lcmdpbmcgaXQgd2l0aCBuZXcgdHJhbnNhY3Rpb25zLlxuICogQWxsIGFycmF5cyBhcmUgYXNzdW1lZCB0byBiZSBzb3J0ZWQgYnkgZGVzY2VuZGluZyBsb2dpY2FsIHRpbWUuXG4gKlxuICogPiBOb3RlISBUaGlzIG1ldGhvZCBkb2VzIG5vdCByZW1vdmUgZHVwbGljYXRlcy5cbiAqXG4gKiBAcGFyYW0ga25vd25UcmFuc2FjdGlvbnNcbiAqIEBwYXJhbSBuZXdUcmFuc2FjdGlvbnNcbiAqIEBwYXJhbSBpbmZvXG4gKlxuICogQGNhdGVnb3J5IFV0aWxzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlVHJhbnNhY3Rpb25zKGtub3duVHJhbnNhY3Rpb25zLCBuZXdUcmFuc2FjdGlvbnMsIGluZm8pIHtcbiAgICBpZiAoaW5mby5iYXRjaFR5cGUgPT09ICdvbGQnKSB7XG4gICAgICAgIGtub3duVHJhbnNhY3Rpb25zLnB1c2goLi4ubmV3VHJhbnNhY3Rpb25zKTtcbiAgICAgICAgcmV0dXJuIGtub3duVHJhbnNhY3Rpb25zO1xuICAgIH1cbiAgICBpZiAoa25vd25UcmFuc2FjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGtub3duVHJhbnNhY3Rpb25zLnB1c2goLi4ubmV3VHJhbnNhY3Rpb25zKTtcbiAgICAgICAgcmV0dXJuIGtub3duVHJhbnNhY3Rpb25zO1xuICAgIH1cbiAgICAvLyBFeGFtcGxlOlxuICAgIC8vIGtub3duIGx0czogW04sIE4tMSwgTi0yLCBOLTMsICghKSBOLTEwLC4uLl1cbiAgICAvLyBuZXcgbHRzOiBbTi00LCBOLTVdXG4gICAgLy8gYmF0Y2ggaW5mbzogeyBtaW5MdDogTi01LCBtYXhMdDogTi00LCBiYXRjaFR5cGU6ICduZXcnIH1cbiAgICAvLyAxLiBTa2lwIGluZGljZXMgdW50aWwga25vd24gdHJhbnNhY3Rpb24gbHQgaXMgZ3JlYXRlciB0aGFuIHRoZSBiaWdnZXN0IGluIHRoZSBiYXRjaFxuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGtub3duVHJhbnNhY3Rpb25zLmxlbmd0aCAmJlxuICAgICAgICBleHBvcnRzLkxUX0NPTExBVE9SLmNvbXBhcmUoa25vd25UcmFuc2FjdGlvbnNbaV0uaWQubHQsIGluZm8ubWF4THQpID49IDApIHtcbiAgICAgICAgKytpO1xuICAgIH1cbiAgICAvLyAyLiBJbnNlcnQgbmV3IHRyYW5zYWN0aW9uc1xuICAgIGtub3duVHJhbnNhY3Rpb25zLnNwbGljZShpLCAwLCAuLi5uZXdUcmFuc2FjdGlvbnMpO1xuICAgIHJldHVybiBrbm93blRyYW5zYWN0aW9ucztcbn1cbmV4cG9ydHMubWVyZ2VUcmFuc2FjdGlvbnMgPSBtZXJnZVRyYW5zYWN0aW9ucztcbmNvbnN0IE1BWCA9IDQyOTQ5NjcyOTU7XG5sZXQgaWRDb3VudGVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTUFYKTtcbmZ1bmN0aW9uIGdldFVuaXF1ZUlkKCkge1xuICAgIGlkQ291bnRlciA9IChpZENvdW50ZXIgKyAxKSAlIE1BWDtcbiAgICByZXR1cm4gaWRDb3VudGVyO1xufVxuZXhwb3J0cy5nZXRVbmlxdWVJZCA9IGdldFVuaXF1ZUlkO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///786\n")},758:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.MsigAccount = exports.GenericAccount = void 0;\nconst everscale_inpage_provider_1 = __webpack_require__(511);\n/**\n * @category AccountsStorage\n */\nclass GenericAccount {\n    constructor(args) {\n        this.address = args.address instanceof everscale_inpage_provider_1.Address ? args.address : new everscale_inpage_provider_1.Address(args.address);\n        this.abi = typeof args.abi === \'string\' ? args.abi : JSON.stringify(args.abi);\n        this.prepareMessageImpl = args.prepareMessage;\n        this.publicKey = args.publicKey;\n    }\n    async fetchPublicKey(ctx) {\n        if (this.publicKey != null) {\n            return this.publicKey;\n        }\n        this.publicKey = await ctx.fetchPublicKey(this.address);\n        return this.publicKey;\n    }\n    async prepareMessage(args, ctx) {\n        const publicKey = await this.fetchPublicKey(ctx);\n        const signer = await ctx.getSigner(publicKey);\n        const { method, params, stateInit } = await this.prepareMessageImpl(args, ctx);\n        return await ctx.createExternalMessage({\n            address: this.address,\n            signer,\n            timeout: args.timeout,\n            abi: this.abi,\n            method,\n            params,\n            stateInit,\n        });\n    }\n}\nexports.GenericAccount = GenericAccount;\n/**\n * @category AccountsStorage\n */\nclass MsigAccount extends GenericAccount {\n    constructor(args) {\n        super({\n            address: args.address,\n            publicKey: args.publicKey,\n            abi: MSIG_ABI,\n            prepareMessage: async (args, ctx) => {\n                const payload = args.payload\n                    ? ctx.encodeInternalInput(args.payload)\n                    : \'\';\n                return {\n                    method: \'sendTransaction\',\n                    params: {\n                        dest: args.recipient,\n                        value: args.amount,\n                        bounce: args.bounce,\n                        flags: 3,\n                        payload,\n                    },\n                };\n            },\n        });\n    }\n}\nexports.MsigAccount = MsigAccount;\nconst MSIG_ABI = `{\n  "ABI version": 2,\n  "header": ["pubkey", "time", "expire"],\n  "functions": [{\n    "name": "sendTransaction",\n    "inputs": [\n      {"name":"dest","type":"address"},\n      {"name":"value","type":"uint128"},\n      {"name":"bounce","type":"bool"},\n      {"name":"flags","type":"uint8"},\n      {"name":"payload","type":"cell"}\n    ],\n    "outputs": []\n  }],\n  "events": []\n}`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzU4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvQWNjb3VudHNTdG9yYWdlL0dlbmVyaWMuanM/YzJiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXNpZ0FjY291bnQgPSBleHBvcnRzLkdlbmVyaWNBY2NvdW50ID0gdm9pZCAwO1xuY29uc3QgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xID0gcmVxdWlyZShcImV2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXJcIik7XG4vKipcbiAqIEBjYXRlZ29yeSBBY2NvdW50c1N0b3JhZ2VcbiAqL1xuY2xhc3MgR2VuZXJpY0FjY291bnQge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYXJncy5hZGRyZXNzIGluc3RhbmNlb2YgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3MgPyBhcmdzLmFkZHJlc3MgOiBuZXcgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3MoYXJncy5hZGRyZXNzKTtcbiAgICAgICAgdGhpcy5hYmkgPSB0eXBlb2YgYXJncy5hYmkgPT09ICdzdHJpbmcnID8gYXJncy5hYmkgOiBKU09OLnN0cmluZ2lmeShhcmdzLmFiaSk7XG4gICAgICAgIHRoaXMucHJlcGFyZU1lc3NhZ2VJbXBsID0gYXJncy5wcmVwYXJlTWVzc2FnZTtcbiAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBhcmdzLnB1YmxpY0tleTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hQdWJsaWNLZXkoY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLnB1YmxpY0tleSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNLZXk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBhd2FpdCBjdHguZmV0Y2hQdWJsaWNLZXkodGhpcy5hZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljS2V5O1xuICAgIH1cbiAgICBhc3luYyBwcmVwYXJlTWVzc2FnZShhcmdzLCBjdHgpIHtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgdGhpcy5mZXRjaFB1YmxpY0tleShjdHgpO1xuICAgICAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBjdHguZ2V0U2lnbmVyKHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IHsgbWV0aG9kLCBwYXJhbXMsIHN0YXRlSW5pdCB9ID0gYXdhaXQgdGhpcy5wcmVwYXJlTWVzc2FnZUltcGwoYXJncywgY3R4KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGN0eC5jcmVhdGVFeHRlcm5hbE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgICAgc2lnbmVyLFxuICAgICAgICAgICAgdGltZW91dDogYXJncy50aW1lb3V0LFxuICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIHN0YXRlSW5pdCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5HZW5lcmljQWNjb3VudCA9IEdlbmVyaWNBY2NvdW50O1xuLyoqXG4gKiBAY2F0ZWdvcnkgQWNjb3VudHNTdG9yYWdlXG4gKi9cbmNsYXNzIE1zaWdBY2NvdW50IGV4dGVuZHMgR2VuZXJpY0FjY291bnQge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgYWRkcmVzczogYXJncy5hZGRyZXNzLFxuICAgICAgICAgICAgcHVibGljS2V5OiBhcmdzLnB1YmxpY0tleSxcbiAgICAgICAgICAgIGFiaTogTVNJR19BQkksXG4gICAgICAgICAgICBwcmVwYXJlTWVzc2FnZTogYXN5bmMgKGFyZ3MsIGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhcmdzLnBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgPyBjdHguZW5jb2RlSW50ZXJuYWxJbnB1dChhcmdzLnBheWxvYWQpXG4gICAgICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnc2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0OiBhcmdzLnJlY2lwaWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhcmdzLmFtb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5jZTogYXJncy5ib3VuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnczogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTXNpZ0FjY291bnQgPSBNc2lnQWNjb3VudDtcbmNvbnN0IE1TSUdfQUJJID0gYHtcbiAgXCJBQkkgdmVyc2lvblwiOiAyLFxuICBcImhlYWRlclwiOiBbXCJwdWJrZXlcIiwgXCJ0aW1lXCIsIFwiZXhwaXJlXCJdLFxuICBcImZ1bmN0aW9uc1wiOiBbe1xuICAgIFwibmFtZVwiOiBcInNlbmRUcmFuc2FjdGlvblwiLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcIm5hbWVcIjpcImRlc3RcIixcInR5cGVcIjpcImFkZHJlc3NcIn0sXG4gICAgICB7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOlwidWludDEyOFwifSxcbiAgICAgIHtcIm5hbWVcIjpcImJvdW5jZVwiLFwidHlwZVwiOlwiYm9vbFwifSxcbiAgICAgIHtcIm5hbWVcIjpcImZsYWdzXCIsXCJ0eXBlXCI6XCJ1aW50OFwifSxcbiAgICAgIHtcIm5hbWVcIjpcInBheWxvYWRcIixcInR5cGVcIjpcImNlbGxcIn1cbiAgICBdLFxuICAgIFwib3V0cHV0c1wiOiBbXVxuICB9XSxcbiAgXCJldmVudHNcIjogW11cbn1gO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///758\n')},766:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.GiverAccount = void 0;\nconst everscale_inpage_provider_1 = __webpack_require__(511);\n/**\n * Any account which supports Giver ABI (GiverV2, GiverV3):\n *\n * ```\n * {\n *   "ABI version": 2,\n *   "header": ["pubkey", "time", "expire"],\n *   "functions": [{\n *     "name": "sendTransaction",\n *     "inputs": [\n *       {"name":"dest","type":"address"},\n *       {"name":"value","type":"uint128"},\n *       {"name":"bounce","type":"bool"},\n *     ],\n *     "outputs": []\n *   }],\n *   "events": []\n * }\n * ```\n *\n * @category AccountsStorage\n */\nclass GiverAccount {\n    constructor(args) {\n        this.address = args.address instanceof everscale_inpage_provider_1.Address ? args.address : new everscale_inpage_provider_1.Address(args.address);\n        this.publicKey = args.publicKey;\n    }\n    static fromVersion(version) {\n        let address;\n        switch (version) {\n            case 2:\n                address = \'0:ece57bcc6c530283becbbd8a3b24d3c5987cdddc3c8b7b33be6e4a6312490415\';\n                break;\n            case 3:\n                address = \'0:78fbd6980c10cf41401b32e9b51810415e7578b52403af80dae68ddf99714498\';\n                break;\n            default:\n                throw new Error(\'Unknown version\');\n        }\n        return new GiverAccount({\n            address,\n            publicKey: GiverAccount.GIVER_KEY_PAIR.publicKey,\n        });\n    }\n    async fetchPublicKey(_ctx) {\n        return this.publicKey;\n    }\n    async prepareMessage(args, ctx) {\n        if (args.payload != null) {\n            console.warn(\'Giver contract does not support payload\');\n        }\n        const signer = await ctx.getSigner(this.publicKey);\n        return await ctx.createExternalMessage({\n            address: this.address,\n            signer,\n            timeout: args.timeout,\n            abi: GIVER_ABI,\n            method: \'sendTransaction\',\n            params: {\n                dest: args.recipient,\n                value: args.amount,\n                bounce: args.bounce,\n            },\n        });\n    }\n}\nexports.GiverAccount = GiverAccount;\nGiverAccount.GIVER_KEY_PAIR = {\n    secretKey: \'172af540e43a524763dd53b26a066d472a97c4de37d5498170564510608250c3\',\n    publicKey: \'2ada2e65ab8eeab09490e3521415f45b6e42df9c760a639bcf53957550b25a16\',\n};\nconst GIVER_ABI = `{\n  "ABI version": 2,\n  "header": ["time", "expire"],\n  "functions": [{\n    "name": "sendTransaction",\n    "inputs": [\n      {"name":"dest","type":"address"},\n      {"name":"value","type":"uint128"},\n      {"name":"bounce","type":"bool"}\n    ],\n    "outputs": []\n  }],\n  "events": []\n}`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzY2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvQWNjb3VudHNTdG9yYWdlL0dpdmVyLmpzP2FjM2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdpdmVyQWNjb3VudCA9IHZvaWQgMDtcbmNvbnN0IGV2ZXJzY2FsZV9pbnBhZ2VfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCJldmVyc2NhbGUtaW5wYWdlLXByb3ZpZGVyXCIpO1xuLyoqXG4gKiBBbnkgYWNjb3VudCB3aGljaCBzdXBwb3J0cyBHaXZlciBBQkkgKEdpdmVyVjIsIEdpdmVyVjMpOlxuICpcbiAqIGBgYFxuICoge1xuICogICBcIkFCSSB2ZXJzaW9uXCI6IDIsXG4gKiAgIFwiaGVhZGVyXCI6IFtcInB1YmtleVwiLCBcInRpbWVcIiwgXCJleHBpcmVcIl0sXG4gKiAgIFwiZnVuY3Rpb25zXCI6IFt7XG4gKiAgICAgXCJuYW1lXCI6IFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gKiAgICAgXCJpbnB1dHNcIjogW1xuICogICAgICAge1wibmFtZVwiOlwiZGVzdFwiLFwidHlwZVwiOlwiYWRkcmVzc1wifSxcbiAqICAgICAgIHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6XCJ1aW50MTI4XCJ9LFxuICogICAgICAge1wibmFtZVwiOlwiYm91bmNlXCIsXCJ0eXBlXCI6XCJib29sXCJ9LFxuICogICAgIF0sXG4gKiAgICAgXCJvdXRwdXRzXCI6IFtdXG4gKiAgIH1dLFxuICogICBcImV2ZW50c1wiOiBbXVxuICogfVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IEFjY291bnRzU3RvcmFnZVxuICovXG5jbGFzcyBHaXZlckFjY291bnQge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYXJncy5hZGRyZXNzIGluc3RhbmNlb2YgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3MgPyBhcmdzLmFkZHJlc3MgOiBuZXcgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3MoYXJncy5hZGRyZXNzKTtcbiAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBhcmdzLnB1YmxpY0tleTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21WZXJzaW9uKHZlcnNpb24pIHtcbiAgICAgICAgbGV0IGFkZHJlc3M7XG4gICAgICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGFkZHJlc3MgPSAnMDplY2U1N2JjYzZjNTMwMjgzYmVjYmJkOGEzYjI0ZDNjNTk4N2NkZGRjM2M4YjdiMzNiZTZlNGE2MzEyNDkwNDE1JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gJzA6NzhmYmQ2OTgwYzEwY2Y0MTQwMWIzMmU5YjUxODEwNDE1ZTc1NzhiNTI0MDNhZjgwZGFlNjhkZGY5OTcxNDQ5OCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB2ZXJzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBHaXZlckFjY291bnQoe1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIHB1YmxpY0tleTogR2l2ZXJBY2NvdW50LkdJVkVSX0tFWV9QQUlSLnB1YmxpY0tleSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoUHVibGljS2V5KF9jdHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljS2V5O1xuICAgIH1cbiAgICBhc3luYyBwcmVwYXJlTWVzc2FnZShhcmdzLCBjdHgpIHtcbiAgICAgICAgaWYgKGFyZ3MucGF5bG9hZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0dpdmVyIGNvbnRyYWN0IGRvZXMgbm90IHN1cHBvcnQgcGF5bG9hZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IGN0eC5nZXRTaWduZXIodGhpcy5wdWJsaWNLZXkpO1xuICAgICAgICByZXR1cm4gYXdhaXQgY3R4LmNyZWF0ZUV4dGVybmFsTWVzc2FnZSh7XG4gICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgICBzaWduZXIsXG4gICAgICAgICAgICB0aW1lb3V0OiBhcmdzLnRpbWVvdXQsXG4gICAgICAgICAgICBhYmk6IEdJVkVSX0FCSSxcbiAgICAgICAgICAgIG1ldGhvZDogJ3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBkZXN0OiBhcmdzLnJlY2lwaWVudCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXJncy5hbW91bnQsXG4gICAgICAgICAgICAgICAgYm91bmNlOiBhcmdzLmJvdW5jZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuR2l2ZXJBY2NvdW50ID0gR2l2ZXJBY2NvdW50O1xuR2l2ZXJBY2NvdW50LkdJVkVSX0tFWV9QQUlSID0ge1xuICAgIHNlY3JldEtleTogJzE3MmFmNTQwZTQzYTUyNDc2M2RkNTNiMjZhMDY2ZDQ3MmE5N2M0ZGUzN2Q1NDk4MTcwNTY0NTEwNjA4MjUwYzMnLFxuICAgIHB1YmxpY0tleTogJzJhZGEyZTY1YWI4ZWVhYjA5NDkwZTM1MjE0MTVmNDViNmU0MmRmOWM3NjBhNjM5YmNmNTM5NTc1NTBiMjVhMTYnLFxufTtcbmNvbnN0IEdJVkVSX0FCSSA9IGB7XG4gIFwiQUJJIHZlcnNpb25cIjogMixcbiAgXCJoZWFkZXJcIjogW1widGltZVwiLCBcImV4cGlyZVwiXSxcbiAgXCJmdW5jdGlvbnNcIjogW3tcbiAgICBcIm5hbWVcIjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XCJuYW1lXCI6XCJkZXN0XCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9LFxuICAgICAge1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjpcInVpbnQxMjhcIn0sXG4gICAgICB7XCJuYW1lXCI6XCJib3VuY2VcIixcInR5cGVcIjpcImJvb2xcIn1cbiAgICBdLFxuICAgIFwib3V0cHV0c1wiOiBbXVxuICB9XSxcbiAgXCJldmVudHNcIjogW11cbn1gO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///766\n')},128:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HighloadWalletV2 = void 0;\nconst everscale_inpage_provider_1 = __webpack_require__(511);\nconst bignumber_js_1 = __importDefault(__webpack_require__(431));\nconst core_1 = __importDefault(__webpack_require__(521));\nconst { ensureNekotonLoaded, nekoton } = core_1.default;\n/**\n * @category AccountsStorage\n */\nclass HighloadWalletV2 {\n    constructor(address) {\n        this.address = address instanceof everscale_inpage_provider_1.Address ? address : new everscale_inpage_provider_1.Address(address);\n    }\n    static async computeAddress(args) {\n        // TODO: Somehow propagate init params\n        await ensureNekotonLoaded();\n        const publicKey = args.publicKey instanceof bignumber_js_1.default\n            ? args.publicKey\n            : new bignumber_js_1.default(`0x${args.publicKey}`);\n        const tvc = makeStateInit(publicKey);\n        const hash = nekoton.getBocHash(tvc);\n        return new everscale_inpage_provider_1.Address(`${args.workchain != null ? args.workchain : 0}:${hash}`);\n    }\n    static async fromPubkey(args) {\n        const publicKey = new bignumber_js_1.default(`0x${args.publicKey}`);\n        const address = await HighloadWalletV2.computeAddress({ publicKey, workchain: args.workchain });\n        const result = new HighloadWalletV2(address);\n        result.publicKey = publicKey;\n        return result;\n    }\n    async fetchPublicKey(ctx) {\n        let publicKey = this.publicKey;\n        if (publicKey == null) {\n            publicKey = this.publicKey = await ctx.fetchPublicKey(this.address)\n                .then(publicKey => new bignumber_js_1.default(`0x${publicKey}`));\n        }\n        return publicKey.toString(16).padStart(64, '0');\n    }\n    async prepareMessage(args, ctx) {\n        const { publicKey, stateInit } = await this.fetchState(ctx);\n        const signer = await ctx.getSigner(publicKey);\n        const expireAt = ctx.nowSec + args.timeout;\n        const attachedPayload = args.payload\n            ? ctx.encodeInternalInput(args.payload)\n            : undefined;\n        const internalMessage = ctx.encodeInternalMessage({\n            dst: args.recipient,\n            bounce: args.bounce,\n            stateInit: args.stateInit,\n            body: attachedPayload,\n            amount: args.amount,\n        });\n        const params = {\n            messages: [[0, {\n                        flags: 3,\n                        message: internalMessage,\n                    }]],\n        };\n        const messages = ctx.packIntoCell({ structure: MESSAGES_STRUCTURE, data: params });\n        const messagesHash = ctx.getBocHash(messages);\n        params.walletId = WALLET_ID;\n        params.expireAt = expireAt;\n        params.messagesHash = `0x${messagesHash.slice(-8)}`;\n        const unsignedPayload = ctx.packIntoCell({ structure: UNSIGNED_TRANSFER_STRUCTURE, data: params });\n        const hash = ctx.getBocHash(unsignedPayload);\n        const signature = await signer.sign(hash);\n        const { signatureParts } = ctx.extendSignature(signature);\n        params.signatureHigh = signatureParts.high;\n        params.signatureLow = signatureParts.low;\n        const signedPayload = ctx.packIntoCell({ structure: SIGNED_TRANSFER_STRUCTURE, data: params });\n        return ctx.createRawExternalMessage({\n            address: this.address.toString(),\n            body: signedPayload,\n            stateInit,\n            expireAt,\n        });\n    }\n    async fetchState(ctx) {\n        let stateInit = undefined;\n        let publicKey;\n        const state = await ctx.getFullContractState(this.address);\n        if (state == null || !state.isDeployed) {\n            if (this.publicKey == null) {\n                throw new Error('Contract not deployed and public key was not specified');\n            }\n            stateInit = makeStateInit(this.publicKey);\n            publicKey = this.publicKey;\n        }\n        else if (this.publicKey == null) {\n            const data = ctx.extractContractData(state.boc);\n            if (data == null) {\n                throw new Error('Failed to extract contract data');\n            }\n            publicKey = parseInitData(ctx, data).publicKey;\n        }\n        else {\n            publicKey = this.publicKey;\n        }\n        if (this.publicKey == null) {\n            this.publicKey = publicKey;\n        }\n        return {\n            publicKey: publicKey.toString(16).padStart(64, '0'),\n            stateInit,\n        };\n    }\n}\nexports.HighloadWalletV2 = HighloadWalletV2;\nconst parseInitData = (ctx, boc) => {\n    const parsed = ctx.unpackFromCell({ structure: DATA_STRUCTURE, boc, allowPartial: true });\n    if (typeof parsed !== 'object' || typeof parsed['publicKey'] !== 'string') {\n        throw new Error('Invalid contract data');\n    }\n    return {\n        publicKey: new bignumber_js_1.default(parsed.publicKey),\n    };\n};\nconst makeStateInit = (publicKey) => {\n    const data = nekoton.packIntoCell(DATA_STRUCTURE, {\n        walletId: WALLET_ID,\n        lastCleaned: 0,\n        publicKey: publicKey.toFixed(0),\n        queries: false,\n    });\n    return nekoton.mergeTvc(HIGHLOAD_WALLET_V2_CODE, data);\n};\nconst MESSAGES_STRUCTURE = [\n    {\n        name: 'messages',\n        type: 'map(uint16,tuple)',\n        components: [\n            { name: 'flags', type: 'uint8' },\n            { name: 'message', type: 'cell' },\n        ],\n    },\n];\nconst UNSIGNED_TRANSFER_STRUCTURE = [\n    { name: 'walletId', type: 'uint32' },\n    { name: 'expireAt', type: 'uint32' },\n    { name: 'messagesHash', type: 'uint32' },\n    ...MESSAGES_STRUCTURE,\n];\nconst SIGNED_TRANSFER_STRUCTURE = [\n    { name: 'signatureHigh', type: 'uint256' },\n    { name: 'signatureLow', type: 'uint256' },\n    ...UNSIGNED_TRANSFER_STRUCTURE,\n];\nconst DATA_STRUCTURE = [\n    { name: 'walletId', type: 'uint32' },\n    { name: 'lastCleaned', type: 'uint64' },\n    { name: 'publicKey', type: 'uint256' },\n    { name: 'queries', type: 'bool' },\n];\nconst HIGHLOAD_WALLET_V2_CODE = 'te6ccgEBCQEA5QABFP8A9KQT9LzyyAsBAgEgBAIB6vKDCNcYINMf0z/4I6ofUyC58mPtRNDTH9M/0//0BNFTYIBA9A5voTHyYFFzuvKiB/kBVBCH+RDyowL0BNH4AH+OFiGAEPR4b6UgmALTB9QwAfsAkTLiAbPmW4MlochANIBA9EOK5jHIEssfE8s/y//0AMntVAMANCCAQPSWb6UyURCUMFMDud4gkzM2AZIyMOKzAgFICAUCASAHBgBBvl+XaiaGmPmOmf6f+Y+gJoqRBAIHoHN9CYyS2/yV3R8UABe9nOdqJoaa+Y64X/wABNAw';\nconst WALLET_ID = 0;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvQWNjb3VudHNTdG9yYWdlL0hpZ2hsb2FkV2FsbGV0VjIuanM/ZDBhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGlnaGxvYWRXYWxsZXRWMiA9IHZvaWQgMDtcbmNvbnN0IGV2ZXJzY2FsZV9pbnBhZ2VfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCJldmVyc2NhbGUtaW5wYWdlLXByb3ZpZGVyXCIpO1xuY29uc3QgYmlnbnVtYmVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJpZ251bWJlci5qc1wiKSk7XG5jb25zdCBjb3JlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2NvcmVcIikpO1xuY29uc3QgeyBlbnN1cmVOZWtvdG9uTG9hZGVkLCBuZWtvdG9uIH0gPSBjb3JlXzEuZGVmYXVsdDtcbi8qKlxuICogQGNhdGVnb3J5IEFjY291bnRzU3RvcmFnZVxuICovXG5jbGFzcyBIaWdobG9hZFdhbGxldFYyIHtcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzKSB7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3MgaW5zdGFuY2VvZiBldmVyc2NhbGVfaW5wYWdlX3Byb3ZpZGVyXzEuQWRkcmVzcyA/IGFkZHJlc3MgOiBuZXcgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3MoYWRkcmVzcyk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjb21wdXRlQWRkcmVzcyhhcmdzKSB7XG4gICAgICAgIC8vIFRPRE86IFNvbWVob3cgcHJvcGFnYXRlIGluaXQgcGFyYW1zXG4gICAgICAgIGF3YWl0IGVuc3VyZU5la290b25Mb2FkZWQoKTtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gYXJncy5wdWJsaWNLZXkgaW5zdGFuY2VvZiBiaWdudW1iZXJfanNfMS5kZWZhdWx0XG4gICAgICAgICAgICA/IGFyZ3MucHVibGljS2V5XG4gICAgICAgICAgICA6IG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KGAweCR7YXJncy5wdWJsaWNLZXl9YCk7XG4gICAgICAgIGNvbnN0IHR2YyA9IG1ha2VTdGF0ZUluaXQocHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgaGFzaCA9IG5la290b24uZ2V0Qm9jSGFzaCh0dmMpO1xuICAgICAgICByZXR1cm4gbmV3IGV2ZXJzY2FsZV9pbnBhZ2VfcHJvdmlkZXJfMS5BZGRyZXNzKGAke2FyZ3Mud29ya2NoYWluICE9IG51bGwgPyBhcmdzLndvcmtjaGFpbiA6IDB9OiR7aGFzaH1gKTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGZyb21QdWJrZXkoYXJncykge1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdChgMHgke2FyZ3MucHVibGljS2V5fWApO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgSGlnaGxvYWRXYWxsZXRWMi5jb21wdXRlQWRkcmVzcyh7IHB1YmxpY0tleSwgd29ya2NoYWluOiBhcmdzLndvcmtjaGFpbiB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEhpZ2hsb2FkV2FsbGV0VjIoYWRkcmVzcyk7XG4gICAgICAgIHJlc3VsdC5wdWJsaWNLZXkgPSBwdWJsaWNLZXk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoUHVibGljS2V5KGN0eCkge1xuICAgICAgICBsZXQgcHVibGljS2V5ID0gdGhpcy5wdWJsaWNLZXk7XG4gICAgICAgIGlmIChwdWJsaWNLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcHVibGljS2V5ID0gdGhpcy5wdWJsaWNLZXkgPSBhd2FpdCBjdHguZmV0Y2hQdWJsaWNLZXkodGhpcy5hZGRyZXNzKVxuICAgICAgICAgICAgICAgIC50aGVuKHB1YmxpY0tleSA9PiBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdChgMHgke3B1YmxpY0tleX1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB1YmxpY0tleS50b1N0cmluZygxNikucGFkU3RhcnQoNjQsICcwJyk7XG4gICAgfVxuICAgIGFzeW5jIHByZXBhcmVNZXNzYWdlKGFyZ3MsIGN0eCkge1xuICAgICAgICBjb25zdCB7IHB1YmxpY0tleSwgc3RhdGVJbml0IH0gPSBhd2FpdCB0aGlzLmZldGNoU3RhdGUoY3R4KTtcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgY3R4LmdldFNpZ25lcihwdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBleHBpcmVBdCA9IGN0eC5ub3dTZWMgKyBhcmdzLnRpbWVvdXQ7XG4gICAgICAgIGNvbnN0IGF0dGFjaGVkUGF5bG9hZCA9IGFyZ3MucGF5bG9hZFxuICAgICAgICAgICAgPyBjdHguZW5jb2RlSW50ZXJuYWxJbnB1dChhcmdzLnBheWxvYWQpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxNZXNzYWdlID0gY3R4LmVuY29kZUludGVybmFsTWVzc2FnZSh7XG4gICAgICAgICAgICBkc3Q6IGFyZ3MucmVjaXBpZW50LFxuICAgICAgICAgICAgYm91bmNlOiBhcmdzLmJvdW5jZSxcbiAgICAgICAgICAgIHN0YXRlSW5pdDogYXJncy5zdGF0ZUluaXQsXG4gICAgICAgICAgICBib2R5OiBhdHRhY2hlZFBheWxvYWQsXG4gICAgICAgICAgICBhbW91bnQ6IGFyZ3MuYW1vdW50LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgbWVzc2FnZXM6IFtbMCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBpbnRlcm5hbE1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBjdHgucGFja0ludG9DZWxsKHsgc3RydWN0dXJlOiBNRVNTQUdFU19TVFJVQ1RVUkUsIGRhdGE6IHBhcmFtcyB9KTtcbiAgICAgICAgY29uc3QgbWVzc2FnZXNIYXNoID0gY3R4LmdldEJvY0hhc2gobWVzc2FnZXMpO1xuICAgICAgICBwYXJhbXMud2FsbGV0SWQgPSBXQUxMRVRfSUQ7XG4gICAgICAgIHBhcmFtcy5leHBpcmVBdCA9IGV4cGlyZUF0O1xuICAgICAgICBwYXJhbXMubWVzc2FnZXNIYXNoID0gYDB4JHttZXNzYWdlc0hhc2guc2xpY2UoLTgpfWA7XG4gICAgICAgIGNvbnN0IHVuc2lnbmVkUGF5bG9hZCA9IGN0eC5wYWNrSW50b0NlbGwoeyBzdHJ1Y3R1cmU6IFVOU0lHTkVEX1RSQU5TRkVSX1NUUlVDVFVSRSwgZGF0YTogcGFyYW1zIH0pO1xuICAgICAgICBjb25zdCBoYXNoID0gY3R4LmdldEJvY0hhc2godW5zaWduZWRQYXlsb2FkKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnbmVyLnNpZ24oaGFzaCk7XG4gICAgICAgIGNvbnN0IHsgc2lnbmF0dXJlUGFydHMgfSA9IGN0eC5leHRlbmRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgcGFyYW1zLnNpZ25hdHVyZUhpZ2ggPSBzaWduYXR1cmVQYXJ0cy5oaWdoO1xuICAgICAgICBwYXJhbXMuc2lnbmF0dXJlTG93ID0gc2lnbmF0dXJlUGFydHMubG93O1xuICAgICAgICBjb25zdCBzaWduZWRQYXlsb2FkID0gY3R4LnBhY2tJbnRvQ2VsbCh7IHN0cnVjdHVyZTogU0lHTkVEX1RSQU5TRkVSX1NUUlVDVFVSRSwgZGF0YTogcGFyYW1zIH0pO1xuICAgICAgICByZXR1cm4gY3R4LmNyZWF0ZVJhd0V4dGVybmFsTWVzc2FnZSh7XG4gICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGJvZHk6IHNpZ25lZFBheWxvYWQsXG4gICAgICAgICAgICBzdGF0ZUluaXQsXG4gICAgICAgICAgICBleHBpcmVBdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoU3RhdGUoY3R4KSB7XG4gICAgICAgIGxldCBzdGF0ZUluaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBwdWJsaWNLZXk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgY3R4LmdldEZ1bGxDb250cmFjdFN0YXRlKHRoaXMuYWRkcmVzcyk7XG4gICAgICAgIGlmIChzdGF0ZSA9PSBudWxsIHx8ICFzdGF0ZS5pc0RlcGxveWVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wdWJsaWNLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udHJhY3Qgbm90IGRlcGxveWVkIGFuZCBwdWJsaWMga2V5IHdhcyBub3Qgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZUluaXQgPSBtYWtlU3RhdGVJbml0KHRoaXMucHVibGljS2V5KTtcbiAgICAgICAgICAgIHB1YmxpY0tleSA9IHRoaXMucHVibGljS2V5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHVibGljS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjdHguZXh0cmFjdENvbnRyYWN0RGF0YShzdGF0ZS5ib2MpO1xuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGV4dHJhY3QgY29udHJhY3QgZGF0YScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHVibGljS2V5ID0gcGFyc2VJbml0RGF0YShjdHgsIGRhdGEpLnB1YmxpY0tleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHB1YmxpY0tleSA9IHRoaXMucHVibGljS2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnB1YmxpY0tleSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnB1YmxpY0tleSA9IHB1YmxpY0tleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHVibGljS2V5OiBwdWJsaWNLZXkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDY0LCAnMCcpLFxuICAgICAgICAgICAgc3RhdGVJbml0LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuSGlnaGxvYWRXYWxsZXRWMiA9IEhpZ2hsb2FkV2FsbGV0VjI7XG5jb25zdCBwYXJzZUluaXREYXRhID0gKGN0eCwgYm9jKSA9PiB7XG4gICAgY29uc3QgcGFyc2VkID0gY3R4LnVucGFja0Zyb21DZWxsKHsgc3RydWN0dXJlOiBEQVRBX1NUUlVDVFVSRSwgYm9jLCBhbGxvd1BhcnRpYWw6IHRydWUgfSk7XG4gICAgaWYgKHR5cGVvZiBwYXJzZWQgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJzZWRbJ3B1YmxpY0tleSddICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29udHJhY3QgZGF0YScpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwdWJsaWNLZXk6IG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KHBhcnNlZC5wdWJsaWNLZXkpLFxuICAgIH07XG59O1xuY29uc3QgbWFrZVN0YXRlSW5pdCA9IChwdWJsaWNLZXkpID0+IHtcbiAgICBjb25zdCBkYXRhID0gbmVrb3Rvbi5wYWNrSW50b0NlbGwoREFUQV9TVFJVQ1RVUkUsIHtcbiAgICAgICAgd2FsbGV0SWQ6IFdBTExFVF9JRCxcbiAgICAgICAgbGFzdENsZWFuZWQ6IDAsXG4gICAgICAgIHB1YmxpY0tleTogcHVibGljS2V5LnRvRml4ZWQoMCksXG4gICAgICAgIHF1ZXJpZXM6IGZhbHNlLFxuICAgIH0pO1xuICAgIHJldHVybiBuZWtvdG9uLm1lcmdlVHZjKEhJR0hMT0FEX1dBTExFVF9WMl9DT0RFLCBkYXRhKTtcbn07XG5jb25zdCBNRVNTQUdFU19TVFJVQ1RVUkUgPSBbXG4gICAge1xuICAgICAgICBuYW1lOiAnbWVzc2FnZXMnLFxuICAgICAgICB0eXBlOiAnbWFwKHVpbnQxNix0dXBsZSknLFxuICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICB7IG5hbWU6ICdmbGFncycsIHR5cGU6ICd1aW50OCcgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21lc3NhZ2UnLCB0eXBlOiAnY2VsbCcgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuXTtcbmNvbnN0IFVOU0lHTkVEX1RSQU5TRkVSX1NUUlVDVFVSRSA9IFtcbiAgICB7IG5hbWU6ICd3YWxsZXRJZCcsIHR5cGU6ICd1aW50MzInIH0sXG4gICAgeyBuYW1lOiAnZXhwaXJlQXQnLCB0eXBlOiAndWludDMyJyB9LFxuICAgIHsgbmFtZTogJ21lc3NhZ2VzSGFzaCcsIHR5cGU6ICd1aW50MzInIH0sXG4gICAgLi4uTUVTU0FHRVNfU1RSVUNUVVJFLFxuXTtcbmNvbnN0IFNJR05FRF9UUkFOU0ZFUl9TVFJVQ1RVUkUgPSBbXG4gICAgeyBuYW1lOiAnc2lnbmF0dXJlSGlnaCcsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgIHsgbmFtZTogJ3NpZ25hdHVyZUxvdycsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgIC4uLlVOU0lHTkVEX1RSQU5TRkVSX1NUUlVDVFVSRSxcbl07XG5jb25zdCBEQVRBX1NUUlVDVFVSRSA9IFtcbiAgICB7IG5hbWU6ICd3YWxsZXRJZCcsIHR5cGU6ICd1aW50MzInIH0sXG4gICAgeyBuYW1lOiAnbGFzdENsZWFuZWQnLCB0eXBlOiAndWludDY0JyB9LFxuICAgIHsgbmFtZTogJ3B1YmxpY0tleScsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgIHsgbmFtZTogJ3F1ZXJpZXMnLCB0eXBlOiAnYm9vbCcgfSxcbl07XG5jb25zdCBISUdITE9BRF9XQUxMRVRfVjJfQ09ERSA9ICd0ZTZjY2dFQkNRRUE1UUFCRlA4QTlLUVQ5THp5eUFzQkFnRWdCQUlCNnZLRENOY1lJTk1mMHovNEk2b2ZVeUM1OG1QdFJORFRIOU0vMC8vMEJORlRZSUJBOUE1dm9USHlZRkZ6dXZLaUIva0JWQkNIK1JEeW93TDBCTkg0QUgrT0ZpR0FFUFI0YjZVZ21BTFRCOVF3QWZzQWtUTGlBYlBtVzRNbG9jaEFOSUJBOUVPSzVqSElFc3NmRThzL3kvLzBBTW50VkFNQU5DQ0FRUFNXYjZVeVVSQ1VNRk1EdWQ0Z2t6TTJBWkl5TU9LekFnRklDQVVDQVNBSEJnQkJ2bCtYYWlhR21QbU9tZjZmK1krZ0pvcVJCQUlIb0hOOUNZeVMyL3lWM1I4VUFCZTluT2RxSm9hYStZNjRYL3dBQk5Bdyc7XG5jb25zdCBXQUxMRVRfSUQgPSAwO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///128\n")},61:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletV3Account = void 0;\nconst everscale_inpage_provider_1 = __webpack_require__(511);\nconst bignumber_js_1 = __importDefault(__webpack_require__(431));\nconst core_1 = __importDefault(__webpack_require__(521));\nconst { ensureNekotonLoaded, nekoton } = core_1.default;\n/**\n * @category AccountsStorage\n */\nclass WalletV3Account {\n    constructor(address) {\n        this.address = address;\n    }\n    static async computeAddress(args) {\n        // TODO: Somehow propagate init params\n        await ensureNekotonLoaded();\n        const publicKey = args.publicKey instanceof bignumber_js_1.default\n            ? args.publicKey\n            : new bignumber_js_1.default(`0x${args.publicKey}`);\n        const tvc = makeStateInit(publicKey);\n        const hash = nekoton.getBocHash(tvc);\n        return new everscale_inpage_provider_1.Address(`${args.workchain != null ? args.workchain : 0}:${hash}`);\n    }\n    static async fromPubkey(args) {\n        const publicKey = new bignumber_js_1.default(`0x${args.publicKey}`);\n        const address = await WalletV3Account.computeAddress({ publicKey, workchain: args.workchain });\n        const result = new WalletV3Account(address);\n        result.publicKey = publicKey;\n        return result;\n    }\n    async fetchPublicKey(ctx) {\n        let publicKey = this.publicKey;\n        if (publicKey == null) {\n            publicKey = this.publicKey = await ctx.fetchPublicKey(this.address)\n                .then(publicKey => new bignumber_js_1.default(`0x${publicKey}`));\n        }\n        return publicKey.toString(16).padStart(64, '0');\n    }\n    async prepareMessage(args, ctx) {\n        const { seqno, publicKey, stateInit } = await this.fetchState(ctx);\n        const signer = await ctx.getSigner(publicKey);\n        const expireAt = ctx.nowSec + args.timeout;\n        const attachedPayload = args.payload\n            ? ctx.encodeInternalInput(args.payload)\n            : undefined;\n        const internalMessage = ctx.encodeInternalMessage({\n            dst: args.recipient,\n            bounce: args.bounce,\n            stateInit: args.stateInit,\n            body: attachedPayload,\n            amount: args.amount,\n        });\n        const params = {\n            walletId: WALLET_ID,\n            expireAt,\n            seqno,\n            flags: 3,\n            message: internalMessage,\n        };\n        const unsignedPayload = ctx.packIntoCell({ structure: UNSIGNED_TRANSFER_STRUCTURE, data: params });\n        const hash = ctx.getBocHash(unsignedPayload);\n        const signature = await signer.sign(hash);\n        const { signatureParts } = ctx.extendSignature(signature);\n        params.signatureHigh = signatureParts.high;\n        params.signatureLow = signatureParts.low;\n        const signedPayload = ctx.packIntoCell({\n            structure: SIGNED_TRANSFER_STRUCTURE,\n            data: params,\n        });\n        return ctx.createRawExternalMessage({\n            address: this.address,\n            body: signedPayload,\n            stateInit,\n            expireAt,\n        });\n    }\n    async fetchState(ctx) {\n        let stateInit = undefined;\n        let result;\n        const state = await ctx.getFullContractState(this.address);\n        if (state == null || !state.isDeployed) {\n            if (this.publicKey == null) {\n                throw new Error('Contract not deployed and public key was not specified');\n            }\n            stateInit = makeStateInit(this.publicKey);\n            result = { seqno: 0, publicKey: this.publicKey };\n        }\n        else {\n            const data = ctx.extractContractData(state.boc);\n            if (data == null) {\n                throw new Error('Failed to extract contract data');\n            }\n            result = parseInitData(ctx, data);\n        }\n        if (this.publicKey == null) {\n            this.publicKey = result.publicKey;\n        }\n        else if (!this.publicKey.eq(result.publicKey)) {\n            throw new Error('Public key mismatch');\n        }\n        return {\n            seqno: result.seqno,\n            publicKey: result.publicKey.toString(16).padStart(64, '0'),\n            stateInit,\n        };\n    }\n}\nexports.WalletV3Account = WalletV3Account;\nconst parseInitData = (ctx, boc) => {\n    const parsed = ctx.unpackFromCell({\n        structure: DATA_STRUCTURE,\n        boc,\n        allowPartial: false,\n    });\n    if (typeof parsed !== 'object' || typeof parsed['seqno'] !== 'string' || typeof parsed['publicKey'] !== 'string') {\n        throw new Error('Invalid contract data ');\n    }\n    return {\n        seqno: parseInt(parsed.seqno),\n        publicKey: new bignumber_js_1.default(parsed.publicKey),\n    };\n};\nconst makeStateInit = (publicKey) => {\n    const data = nekoton.packIntoCell(DATA_STRUCTURE, {\n        seqno: 0,\n        walletId: WALLET_ID,\n        publicKey: publicKey.toFixed(0),\n    });\n    return nekoton.mergeTvc(WALLET_V3_CODE, data);\n};\nconst UNSIGNED_TRANSFER_STRUCTURE = [\n    { name: 'walletId', type: 'uint32' },\n    { name: 'expireAt', type: 'uint32' },\n    { name: 'seqno', type: 'uint32' },\n    { name: 'flags', type: 'uint8' },\n    { name: 'message', type: 'cell' },\n];\nconst SIGNED_TRANSFER_STRUCTURE = [\n    { name: 'signatureHigh', type: 'uint256' },\n    { name: 'signatureLow', type: 'uint256' },\n    ...UNSIGNED_TRANSFER_STRUCTURE,\n];\nconst DATA_STRUCTURE = [\n    { name: 'seqno', type: 'uint32' },\n    { name: 'walletId', type: 'uint32' },\n    { name: 'publicKey', type: 'uint256' },\n];\nconst WALLET_V3_CODE = 'te6ccgEBAQEAcQAA3v8AIN0gggFMl7ohggEznLqxn3Gw7UTQ0x/THzHXC//jBOCk8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVA==';\nconst WALLET_ID = 0x4BA92D8A;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9BY2NvdW50c1N0b3JhZ2UvV2FsbGV0VjMuanM/NTdmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2FsbGV0VjNBY2NvdW50ID0gdm9pZCAwO1xuY29uc3QgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xID0gcmVxdWlyZShcImV2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXJcIik7XG5jb25zdCBiaWdudW1iZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmlnbnVtYmVyLmpzXCIpKTtcbmNvbnN0IGNvcmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vY29yZVwiKSk7XG5jb25zdCB7IGVuc3VyZU5la290b25Mb2FkZWQsIG5la290b24gfSA9IGNvcmVfMS5kZWZhdWx0O1xuLyoqXG4gKiBAY2F0ZWdvcnkgQWNjb3VudHNTdG9yYWdlXG4gKi9cbmNsYXNzIFdhbGxldFYzQWNjb3VudCB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcykge1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY29tcHV0ZUFkZHJlc3MoYXJncykge1xuICAgICAgICAvLyBUT0RPOiBTb21laG93IHByb3BhZ2F0ZSBpbml0IHBhcmFtc1xuICAgICAgICBhd2FpdCBlbnN1cmVOZWtvdG9uTG9hZGVkKCk7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGFyZ3MucHVibGljS2V5IGluc3RhbmNlb2YgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdFxuICAgICAgICAgICAgPyBhcmdzLnB1YmxpY0tleVxuICAgICAgICAgICAgOiBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdChgMHgke2FyZ3MucHVibGljS2V5fWApO1xuICAgICAgICBjb25zdCB0dmMgPSBtYWtlU3RhdGVJbml0KHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBuZWtvdG9uLmdldEJvY0hhc2godHZjKTtcbiAgICAgICAgcmV0dXJuIG5ldyBldmVyc2NhbGVfaW5wYWdlX3Byb3ZpZGVyXzEuQWRkcmVzcyhgJHthcmdzLndvcmtjaGFpbiAhPSBudWxsID8gYXJncy53b3JrY2hhaW4gOiAwfToke2hhc2h9YCk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBmcm9tUHVia2V5KGFyZ3MpIHtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQoYDB4JHthcmdzLnB1YmxpY0tleX1gKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IFdhbGxldFYzQWNjb3VudC5jb21wdXRlQWRkcmVzcyh7IHB1YmxpY0tleSwgd29ya2NoYWluOiBhcmdzLndvcmtjaGFpbiB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFdhbGxldFYzQWNjb3VudChhZGRyZXNzKTtcbiAgICAgICAgcmVzdWx0LnB1YmxpY0tleSA9IHB1YmxpY0tleTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hQdWJsaWNLZXkoY3R4KSB7XG4gICAgICAgIGxldCBwdWJsaWNLZXkgPSB0aGlzLnB1YmxpY0tleTtcbiAgICAgICAgaWYgKHB1YmxpY0tleSA9PSBudWxsKSB7XG4gICAgICAgICAgICBwdWJsaWNLZXkgPSB0aGlzLnB1YmxpY0tleSA9IGF3YWl0IGN0eC5mZXRjaFB1YmxpY0tleSh0aGlzLmFkZHJlc3MpXG4gICAgICAgICAgICAgICAgLnRoZW4ocHVibGljS2V5ID0+IG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KGAweCR7cHVibGljS2V5fWApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVibGljS2V5LnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgJzAnKTtcbiAgICB9XG4gICAgYXN5bmMgcHJlcGFyZU1lc3NhZ2UoYXJncywgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgc2Vxbm8sIHB1YmxpY0tleSwgc3RhdGVJbml0IH0gPSBhd2FpdCB0aGlzLmZldGNoU3RhdGUoY3R4KTtcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgY3R4LmdldFNpZ25lcihwdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBleHBpcmVBdCA9IGN0eC5ub3dTZWMgKyBhcmdzLnRpbWVvdXQ7XG4gICAgICAgIGNvbnN0IGF0dGFjaGVkUGF5bG9hZCA9IGFyZ3MucGF5bG9hZFxuICAgICAgICAgICAgPyBjdHguZW5jb2RlSW50ZXJuYWxJbnB1dChhcmdzLnBheWxvYWQpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxNZXNzYWdlID0gY3R4LmVuY29kZUludGVybmFsTWVzc2FnZSh7XG4gICAgICAgICAgICBkc3Q6IGFyZ3MucmVjaXBpZW50LFxuICAgICAgICAgICAgYm91bmNlOiBhcmdzLmJvdW5jZSxcbiAgICAgICAgICAgIHN0YXRlSW5pdDogYXJncy5zdGF0ZUluaXQsXG4gICAgICAgICAgICBib2R5OiBhdHRhY2hlZFBheWxvYWQsXG4gICAgICAgICAgICBhbW91bnQ6IGFyZ3MuYW1vdW50LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgd2FsbGV0SWQ6IFdBTExFVF9JRCxcbiAgICAgICAgICAgIGV4cGlyZUF0LFxuICAgICAgICAgICAgc2Vxbm8sXG4gICAgICAgICAgICBmbGFnczogMyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGludGVybmFsTWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdW5zaWduZWRQYXlsb2FkID0gY3R4LnBhY2tJbnRvQ2VsbCh7IHN0cnVjdHVyZTogVU5TSUdORURfVFJBTlNGRVJfU1RSVUNUVVJFLCBkYXRhOiBwYXJhbXMgfSk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBjdHguZ2V0Qm9jSGFzaCh1bnNpZ25lZFBheWxvYWQpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzaWduZXIuc2lnbihoYXNoKTtcbiAgICAgICAgY29uc3QgeyBzaWduYXR1cmVQYXJ0cyB9ID0gY3R4LmV4dGVuZFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICBwYXJhbXMuc2lnbmF0dXJlSGlnaCA9IHNpZ25hdHVyZVBhcnRzLmhpZ2g7XG4gICAgICAgIHBhcmFtcy5zaWduYXR1cmVMb3cgPSBzaWduYXR1cmVQYXJ0cy5sb3c7XG4gICAgICAgIGNvbnN0IHNpZ25lZFBheWxvYWQgPSBjdHgucGFja0ludG9DZWxsKHtcbiAgICAgICAgICAgIHN0cnVjdHVyZTogU0lHTkVEX1RSQU5TRkVSX1NUUlVDVFVSRSxcbiAgICAgICAgICAgIGRhdGE6IHBhcmFtcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjdHguY3JlYXRlUmF3RXh0ZXJuYWxNZXNzYWdlKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgIGJvZHk6IHNpZ25lZFBheWxvYWQsXG4gICAgICAgICAgICBzdGF0ZUluaXQsXG4gICAgICAgICAgICBleHBpcmVBdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoU3RhdGUoY3R4KSB7XG4gICAgICAgIGxldCBzdGF0ZUluaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgY3R4LmdldEZ1bGxDb250cmFjdFN0YXRlKHRoaXMuYWRkcmVzcyk7XG4gICAgICAgIGlmIChzdGF0ZSA9PSBudWxsIHx8ICFzdGF0ZS5pc0RlcGxveWVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wdWJsaWNLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udHJhY3Qgbm90IGRlcGxveWVkIGFuZCBwdWJsaWMga2V5IHdhcyBub3Qgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZUluaXQgPSBtYWtlU3RhdGVJbml0KHRoaXMucHVibGljS2V5KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHsgc2Vxbm86IDAsIHB1YmxpY0tleTogdGhpcy5wdWJsaWNLZXkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjdHguZXh0cmFjdENvbnRyYWN0RGF0YShzdGF0ZS5ib2MpO1xuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGV4dHJhY3QgY29udHJhY3QgZGF0YScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VJbml0RGF0YShjdHgsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnB1YmxpY0tleSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnB1YmxpY0tleSA9IHJlc3VsdC5wdWJsaWNLZXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMucHVibGljS2V5LmVxKHJlc3VsdC5wdWJsaWNLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1B1YmxpYyBrZXkgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2Vxbm86IHJlc3VsdC5zZXFubyxcbiAgICAgICAgICAgIHB1YmxpY0tleTogcmVzdWx0LnB1YmxpY0tleS50b1N0cmluZygxNikucGFkU3RhcnQoNjQsICcwJyksXG4gICAgICAgICAgICBzdGF0ZUluaXQsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5XYWxsZXRWM0FjY291bnQgPSBXYWxsZXRWM0FjY291bnQ7XG5jb25zdCBwYXJzZUluaXREYXRhID0gKGN0eCwgYm9jKSA9PiB7XG4gICAgY29uc3QgcGFyc2VkID0gY3R4LnVucGFja0Zyb21DZWxsKHtcbiAgICAgICAgc3RydWN0dXJlOiBEQVRBX1NUUlVDVFVSRSxcbiAgICAgICAgYm9jLFxuICAgICAgICBhbGxvd1BhcnRpYWw6IGZhbHNlLFxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgcGFyc2VkICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFyc2VkWydzZXFubyddICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgcGFyc2VkWydwdWJsaWNLZXknXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbnRyYWN0IGRhdGEgJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNlcW5vOiBwYXJzZUludChwYXJzZWQuc2Vxbm8pLFxuICAgICAgICBwdWJsaWNLZXk6IG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KHBhcnNlZC5wdWJsaWNLZXkpLFxuICAgIH07XG59O1xuY29uc3QgbWFrZVN0YXRlSW5pdCA9IChwdWJsaWNLZXkpID0+IHtcbiAgICBjb25zdCBkYXRhID0gbmVrb3Rvbi5wYWNrSW50b0NlbGwoREFUQV9TVFJVQ1RVUkUsIHtcbiAgICAgICAgc2Vxbm86IDAsXG4gICAgICAgIHdhbGxldElkOiBXQUxMRVRfSUQsXG4gICAgICAgIHB1YmxpY0tleTogcHVibGljS2V5LnRvRml4ZWQoMCksXG4gICAgfSk7XG4gICAgcmV0dXJuIG5la290b24ubWVyZ2VUdmMoV0FMTEVUX1YzX0NPREUsIGRhdGEpO1xufTtcbmNvbnN0IFVOU0lHTkVEX1RSQU5TRkVSX1NUUlVDVFVSRSA9IFtcbiAgICB7IG5hbWU6ICd3YWxsZXRJZCcsIHR5cGU6ICd1aW50MzInIH0sXG4gICAgeyBuYW1lOiAnZXhwaXJlQXQnLCB0eXBlOiAndWludDMyJyB9LFxuICAgIHsgbmFtZTogJ3NlcW5vJywgdHlwZTogJ3VpbnQzMicgfSxcbiAgICB7IG5hbWU6ICdmbGFncycsIHR5cGU6ICd1aW50OCcgfSxcbiAgICB7IG5hbWU6ICdtZXNzYWdlJywgdHlwZTogJ2NlbGwnIH0sXG5dO1xuY29uc3QgU0lHTkVEX1RSQU5TRkVSX1NUUlVDVFVSRSA9IFtcbiAgICB7IG5hbWU6ICdzaWduYXR1cmVIaWdoJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgeyBuYW1lOiAnc2lnbmF0dXJlTG93JywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgLi4uVU5TSUdORURfVFJBTlNGRVJfU1RSVUNUVVJFLFxuXTtcbmNvbnN0IERBVEFfU1RSVUNUVVJFID0gW1xuICAgIHsgbmFtZTogJ3NlcW5vJywgdHlwZTogJ3VpbnQzMicgfSxcbiAgICB7IG5hbWU6ICd3YWxsZXRJZCcsIHR5cGU6ICd1aW50MzInIH0sXG4gICAgeyBuYW1lOiAncHVibGljS2V5JywgdHlwZTogJ3VpbnQyNTYnIH0sXG5dO1xuY29uc3QgV0FMTEVUX1YzX0NPREUgPSAndGU2Y2NnRUJBUUVBY1FBQTN2OEFJTjBnZ2dGTWw3b2hnZ0V6bkxxeG4zR3c3VVRRMHgvVEh6SFhDLy9qQk9DazhtQ0RDTmNZSU5NZjB4L1RIL2dqRTd2eVkrMUUwTk1mMHgvVC85RlJNcnJ5b1ZGRXV2S2lCUGtCVkJCVitSRHlvL2dBa3lEWFNwYlRCOVFDK3dEbzBRR2t5TXNmeXgvTC84bnRWQT09JztcbmNvbnN0IFdBTExFVF9JRCA9IDB4NEJBOTJEOEE7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///61\n")},487:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.SimpleAccountsStorage = exports.AccountsStorageContext = exports.HighloadWalletV2 = exports.WalletV3Account = exports.MsigAccount = exports.GenericAccount = exports.GiverAccount = void 0;\nconst everscale_inpage_provider_1 = __webpack_require__(511);\nvar Giver_1 = __webpack_require__(766);\nObject.defineProperty(exports, "GiverAccount", ({ enumerable: true, get: function () { return Giver_1.GiverAccount; } }));\nvar Generic_1 = __webpack_require__(758);\nObject.defineProperty(exports, "GenericAccount", ({ enumerable: true, get: function () { return Generic_1.GenericAccount; } }));\nObject.defineProperty(exports, "MsigAccount", ({ enumerable: true, get: function () { return Generic_1.MsigAccount; } }));\nvar WalletV3_1 = __webpack_require__(61);\nObject.defineProperty(exports, "WalletV3Account", ({ enumerable: true, get: function () { return WalletV3_1.WalletV3Account; } }));\nvar HighloadWalletV2_1 = __webpack_require__(128);\nObject.defineProperty(exports, "HighloadWalletV2", ({ enumerable: true, get: function () { return HighloadWalletV2_1.HighloadWalletV2; } }));\n/**\n * @category AccountsStorage\n */\nclass AccountsStorageContext {\n    constructor(clock, connectionController, nekoton, keystore) {\n        this.clock = clock;\n        this.connectionController = connectionController;\n        this.nekoton = nekoton;\n        this.keystore = keystore;\n    }\n    async getSigner(publicKey) {\n        if (this.keystore == null) {\n            throw new Error(\'Keystore not found\');\n        }\n        const signer = await this.keystore.getSigner(publicKey);\n        if (signer == null) {\n            throw new Error(\'Signer not found\');\n        }\n        return signer;\n    }\n    get nowMs() {\n        return this.clock.nowMs;\n    }\n    get nowSec() {\n        return ~~(this.clock.nowMs / 1000);\n    }\n    async fetchPublicKey(address) {\n        const state = await this.getFullContractState(address);\n        if (state == null || !state.isDeployed) {\n            throw new Error(\'Contract not deployed\');\n        }\n        return this.nekoton.extractPublicKey(state.boc);\n    }\n    async getFullContractState(address) {\n        return this.connectionController.use(async ({ data: { transport } }) => transport.getFullContractState(address.toString()));\n    }\n    extractContractData(boc) {\n        return this.nekoton.extractContractData(boc);\n    }\n    packIntoCell(args) {\n        return this.nekoton.packIntoCell(args.structure, args.data, args.abiVersion);\n    }\n    unpackFromCell(args) {\n        return this.nekoton.unpackFromCell(args.structure, args.boc, args.allowPartial, args.abiVersion);\n    }\n    getBocHash(boc) {\n        return this.nekoton.getBocHash(boc);\n    }\n    extendSignature(signature) {\n        return this.nekoton.extendSignature(signature);\n    }\n    encodeInternalInput(args) {\n        return this.nekoton.encodeInternalInput(args.abi, args.method, args.params);\n    }\n    encodeInternalMessage(args) {\n        return this.nekoton.encodeInternalMessage(args.src, args.dst, args.bounce, args.stateInit, args.body, args.amount);\n    }\n    async createExternalMessage(args) {\n        const unsignedMessage = this.nekoton.createExternalMessage(this.clock, args.address.toString(), args.abi, args.method, args.stateInit, args.params, args.signer.publicKey, args.timeout);\n        try {\n            const signature = await args.signer.sign(unsignedMessage.hash);\n            return unsignedMessage.sign(signature);\n        }\n        finally {\n            unsignedMessage.free();\n        }\n    }\n    createRawExternalMessage(args) {\n        return this.nekoton.createRawExternalMessage(args.address.toString(), args.stateInit, args.body, args.expireAt);\n    }\n}\nexports.AccountsStorageContext = AccountsStorageContext;\n/**\n * @category AccountsStorage\n */\nclass SimpleAccountsStorage {\n    /**\n     * Creates new simple accounts storage.\n     *\n     * If no `defaultAccount` provided, uses first provided entry\n     *\n     * @param args\n     */\n    constructor(args = {}) {\n        this.accounts = new Map();\n        if (args.entries != null) {\n            for (const account of args.entries) {\n                if (this._defaultAccount == null) {\n                    this._defaultAccount = account.address;\n                }\n                this.accounts.set(account.address.toString(), account);\n            }\n        }\n        if (args.defaultAccount != null) {\n            let defaultAccount;\n            if (args.defaultAccount instanceof everscale_inpage_provider_1.Address) {\n                defaultAccount = args.defaultAccount;\n            }\n            else {\n                defaultAccount = new everscale_inpage_provider_1.Address(args.defaultAccount);\n            }\n            if (!this.accounts.has(defaultAccount.toString())) {\n                throw new Error(\'Provided default account not found in storage\');\n            }\n            this._defaultAccount = defaultAccount;\n        }\n    }\n    get defaultAccount() {\n        return this._defaultAccount;\n    }\n    set defaultAccount(value) {\n        const address = value === null || value === void 0 ? void 0 : value.toString();\n        if (address != null && !this.accounts.has(address)) {\n            throw new Error(\'Account not found in storage\');\n        }\n        this._defaultAccount = (value == null || value instanceof everscale_inpage_provider_1.Address) ? value : new everscale_inpage_provider_1.Address(value);\n    }\n    async getAccount(address) {\n        return this.accounts.get(address.toString());\n    }\n    addAccount(account) {\n        const address = account.address;\n        this.accounts.set(address.toString(), account);\n        return address;\n    }\n    hasAccount(address) {\n        return this.accounts.has(address.toString());\n    }\n    removeAccount(address) {\n        this.accounts.delete(address.toString());\n    }\n}\nexports.SimpleAccountsStorage = SimpleAccountsStorage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvQWNjb3VudHNTdG9yYWdlL2luZGV4LmpzPzYyOGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpbXBsZUFjY291bnRzU3RvcmFnZSA9IGV4cG9ydHMuQWNjb3VudHNTdG9yYWdlQ29udGV4dCA9IGV4cG9ydHMuSGlnaGxvYWRXYWxsZXRWMiA9IGV4cG9ydHMuV2FsbGV0VjNBY2NvdW50ID0gZXhwb3J0cy5Nc2lnQWNjb3VudCA9IGV4cG9ydHMuR2VuZXJpY0FjY291bnQgPSBleHBvcnRzLkdpdmVyQWNjb3VudCA9IHZvaWQgMDtcbmNvbnN0IGV2ZXJzY2FsZV9pbnBhZ2VfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCJldmVyc2NhbGUtaW5wYWdlLXByb3ZpZGVyXCIpO1xudmFyIEdpdmVyXzEgPSByZXF1aXJlKFwiLi9HaXZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdpdmVyQWNjb3VudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gR2l2ZXJfMS5HaXZlckFjY291bnQ7IH0gfSk7XG52YXIgR2VuZXJpY18xID0gcmVxdWlyZShcIi4vR2VuZXJpY1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdlbmVyaWNBY2NvdW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBHZW5lcmljXzEuR2VuZXJpY0FjY291bnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNc2lnQWNjb3VudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gR2VuZXJpY18xLk1zaWdBY2NvdW50OyB9IH0pO1xudmFyIFdhbGxldFYzXzEgPSByZXF1aXJlKFwiLi9XYWxsZXRWM1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldhbGxldFYzQWNjb3VudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gV2FsbGV0VjNfMS5XYWxsZXRWM0FjY291bnQ7IH0gfSk7XG52YXIgSGlnaGxvYWRXYWxsZXRWMl8xID0gcmVxdWlyZShcIi4vSGlnaGxvYWRXYWxsZXRWMlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkhpZ2hsb2FkV2FsbGV0VjJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEhpZ2hsb2FkV2FsbGV0VjJfMS5IaWdobG9hZFdhbGxldFYyOyB9IH0pO1xuLyoqXG4gKiBAY2F0ZWdvcnkgQWNjb3VudHNTdG9yYWdlXG4gKi9cbmNsYXNzIEFjY291bnRzU3RvcmFnZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGNsb2NrLCBjb25uZWN0aW9uQ29udHJvbGxlciwgbmVrb3Rvbiwga2V5c3RvcmUpIHtcbiAgICAgICAgdGhpcy5jbG9jayA9IGNsb2NrO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Db250cm9sbGVyID0gY29ubmVjdGlvbkNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMubmVrb3RvbiA9IG5la290b247XG4gICAgICAgIHRoaXMua2V5c3RvcmUgPSBrZXlzdG9yZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2lnbmVyKHB1YmxpY0tleSkge1xuICAgICAgICBpZiAodGhpcy5rZXlzdG9yZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleXN0b3JlIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHRoaXMua2V5c3RvcmUuZ2V0U2lnbmVyKHB1YmxpY0tleSk7XG4gICAgICAgIGlmIChzaWduZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaWduZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ25lcjtcbiAgICB9XG4gICAgZ2V0IG5vd01zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9jay5ub3dNcztcbiAgICB9XG4gICAgZ2V0IG5vd1NlYygpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMuY2xvY2subm93TXMgLyAxMDAwKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hQdWJsaWNLZXkoYWRkcmVzcykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGF3YWl0IHRoaXMuZ2V0RnVsbENvbnRyYWN0U3RhdGUoYWRkcmVzcyk7XG4gICAgICAgIGlmIChzdGF0ZSA9PSBudWxsIHx8ICFzdGF0ZS5pc0RlcGxveWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyYWN0IG5vdCBkZXBsb3llZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5la290b24uZXh0cmFjdFB1YmxpY0tleShzdGF0ZS5ib2MpO1xuICAgIH1cbiAgICBhc3luYyBnZXRGdWxsQ29udHJhY3RTdGF0ZShhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Db250cm9sbGVyLnVzZShhc3luYyAoeyBkYXRhOiB7IHRyYW5zcG9ydCB9IH0pID0+IHRyYW5zcG9ydC5nZXRGdWxsQ29udHJhY3RTdGF0ZShhZGRyZXNzLnRvU3RyaW5nKCkpKTtcbiAgICB9XG4gICAgZXh0cmFjdENvbnRyYWN0RGF0YShib2MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVrb3Rvbi5leHRyYWN0Q29udHJhY3REYXRhKGJvYyk7XG4gICAgfVxuICAgIHBhY2tJbnRvQ2VsbChhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5la290b24ucGFja0ludG9DZWxsKGFyZ3Muc3RydWN0dXJlLCBhcmdzLmRhdGEsIGFyZ3MuYWJpVmVyc2lvbik7XG4gICAgfVxuICAgIHVucGFja0Zyb21DZWxsKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVrb3Rvbi51bnBhY2tGcm9tQ2VsbChhcmdzLnN0cnVjdHVyZSwgYXJncy5ib2MsIGFyZ3MuYWxsb3dQYXJ0aWFsLCBhcmdzLmFiaVZlcnNpb24pO1xuICAgIH1cbiAgICBnZXRCb2NIYXNoKGJvYykge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWtvdG9uLmdldEJvY0hhc2goYm9jKTtcbiAgICB9XG4gICAgZXh0ZW5kU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWtvdG9uLmV4dGVuZFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIH1cbiAgICBlbmNvZGVJbnRlcm5hbElucHV0KGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVrb3Rvbi5lbmNvZGVJbnRlcm5hbElucHV0KGFyZ3MuYWJpLCBhcmdzLm1ldGhvZCwgYXJncy5wYXJhbXMpO1xuICAgIH1cbiAgICBlbmNvZGVJbnRlcm5hbE1lc3NhZ2UoYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWtvdG9uLmVuY29kZUludGVybmFsTWVzc2FnZShhcmdzLnNyYywgYXJncy5kc3QsIGFyZ3MuYm91bmNlLCBhcmdzLnN0YXRlSW5pdCwgYXJncy5ib2R5LCBhcmdzLmFtb3VudCk7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUV4dGVybmFsTWVzc2FnZShhcmdzKSB7XG4gICAgICAgIGNvbnN0IHVuc2lnbmVkTWVzc2FnZSA9IHRoaXMubmVrb3Rvbi5jcmVhdGVFeHRlcm5hbE1lc3NhZ2UodGhpcy5jbG9jaywgYXJncy5hZGRyZXNzLnRvU3RyaW5nKCksIGFyZ3MuYWJpLCBhcmdzLm1ldGhvZCwgYXJncy5zdGF0ZUluaXQsIGFyZ3MucGFyYW1zLCBhcmdzLnNpZ25lci5wdWJsaWNLZXksIGFyZ3MudGltZW91dCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBhcmdzLnNpZ25lci5zaWduKHVuc2lnbmVkTWVzc2FnZS5oYXNoKTtcbiAgICAgICAgICAgIHJldHVybiB1bnNpZ25lZE1lc3NhZ2Uuc2lnbihzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdW5zaWduZWRNZXNzYWdlLmZyZWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVSYXdFeHRlcm5hbE1lc3NhZ2UoYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWtvdG9uLmNyZWF0ZVJhd0V4dGVybmFsTWVzc2FnZShhcmdzLmFkZHJlc3MudG9TdHJpbmcoKSwgYXJncy5zdGF0ZUluaXQsIGFyZ3MuYm9keSwgYXJncy5leHBpcmVBdCk7XG4gICAgfVxufVxuZXhwb3J0cy5BY2NvdW50c1N0b3JhZ2VDb250ZXh0ID0gQWNjb3VudHNTdG9yYWdlQ29udGV4dDtcbi8qKlxuICogQGNhdGVnb3J5IEFjY291bnRzU3RvcmFnZVxuICovXG5jbGFzcyBTaW1wbGVBY2NvdW50c1N0b3JhZ2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IHNpbXBsZSBhY2NvdW50cyBzdG9yYWdlLlxuICAgICAqXG4gICAgICogSWYgbm8gYGRlZmF1bHRBY2NvdW50YCBwcm92aWRlZCwgdXNlcyBmaXJzdCBwcm92aWRlZCBlbnRyeVxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhcmdzID0ge30pIHtcbiAgICAgICAgdGhpcy5hY2NvdW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKGFyZ3MuZW50cmllcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFjY291bnQgb2YgYXJncy5lbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RlZmF1bHRBY2NvdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdEFjY291bnQgPSBhY2NvdW50LmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYWNjb3VudHMuc2V0KGFjY291bnQuYWRkcmVzcy50b1N0cmluZygpLCBhY2NvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy5kZWZhdWx0QWNjb3VudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgZGVmYXVsdEFjY291bnQ7XG4gICAgICAgICAgICBpZiAoYXJncy5kZWZhdWx0QWNjb3VudCBpbnN0YW5jZW9mIGV2ZXJzY2FsZV9pbnBhZ2VfcHJvdmlkZXJfMS5BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEFjY291bnQgPSBhcmdzLmRlZmF1bHRBY2NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEFjY291bnQgPSBuZXcgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3MoYXJncy5kZWZhdWx0QWNjb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWNjb3VudHMuaGFzKGRlZmF1bHRBY2NvdW50LnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBkZWZhdWx0IGFjY291bnQgbm90IGZvdW5kIGluIHN0b3JhZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRBY2NvdW50ID0gZGVmYXVsdEFjY291bnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRlZmF1bHRBY2NvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdEFjY291bnQ7XG4gICAgfVxuICAgIHNldCBkZWZhdWx0QWNjb3VudCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChhZGRyZXNzICE9IG51bGwgJiYgIXRoaXMuYWNjb3VudHMuaGFzKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgbm90IGZvdW5kIGluIHN0b3JhZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZWZhdWx0QWNjb3VudCA9ICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlIGluc3RhbmNlb2YgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3MpID8gdmFsdWUgOiBuZXcgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3ModmFsdWUpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBY2NvdW50KGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjb3VudHMuZ2V0KGFkZHJlc3MudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGFkZEFjY291bnQoYWNjb3VudCkge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYWNjb3VudC5hZGRyZXNzO1xuICAgICAgICB0aGlzLmFjY291bnRzLnNldChhZGRyZXNzLnRvU3RyaW5nKCksIGFjY291bnQpO1xuICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICB9XG4gICAgaGFzQWNjb3VudChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY291bnRzLmhhcyhhZGRyZXNzLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICByZW1vdmVBY2NvdW50KGFkZHJlc3MpIHtcbiAgICAgICAgdGhpcy5hY2NvdW50cy5kZWxldGUoYWRkcmVzcy50b1N0cmluZygpKTtcbiAgICB9XG59XG5leHBvcnRzLlNpbXBsZUFjY291bnRzU3RvcmFnZSA9IFNpbXBsZUFjY291bnRzU3RvcmFnZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///487\n')},315:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GqlSocket = void 0;\nconst core_1 = __importDefault(__webpack_require__(521));\nconst { nekoton, fetch, fetchAgent, debugLog } = core_1.default;\nclass GqlSocket {\n    async connect(clock, params) {\n        class GqlSender {\n            constructor(params) {\n                this.nextLatencyDetectionTime = 0;\n                this.params = params;\n                this.latencyDetectionInterval = params.latencyDetectionInterval || 60000;\n                this.endpoints = params.endpoints.map(GqlSocket.expandAddress);\n                if (this.endpoints.length == 1) {\n                    this.currentEndpoint = this.endpoints[0];\n                    this.nextLatencyDetectionTime = Number.MAX_VALUE;\n                }\n            }\n            isLocal() {\n                return this.params.local;\n            }\n            send(data, handler, _longQuery) {\n                ;\n                (async () => {\n                    const now = Date.now();\n                    try {\n                        let endpoint;\n                        if (this.currentEndpoint != null && now < this.nextLatencyDetectionTime) {\n                            // Default route\n                            endpoint = this.currentEndpoint;\n                        }\n                        else if (this.resolutionPromise != null) {\n                            // Already resolving\n                            endpoint = await this.resolutionPromise;\n                            delete this.resolutionPromise;\n                        }\n                        else {\n                            delete this.currentEndpoint;\n                            // Start resolving (current endpoint is null, or it is time to refresh)\n                            this.resolutionPromise = this._selectQueryingEndpoint().then((endpoint) => {\n                                this.currentEndpoint = endpoint;\n                                this.nextLatencyDetectionTime = Date.now() + this.latencyDetectionInterval;\n                                return endpoint;\n                            });\n                            endpoint = await this.resolutionPromise;\n                            delete this.resolutionPromise;\n                        }\n                        const response = await fetch(endpoint.url, {\n                            method: 'post',\n                            headers: DEFAULT_HEADERS,\n                            body: data,\n                            agent: endpoint.agent,\n                        }).then((response) => response.text());\n                        handler.onReceive(response);\n                    }\n                    catch (e) {\n                        handler.onError(e);\n                    }\n                })();\n            }\n            async _selectQueryingEndpoint() {\n                const maxLatency = this.params.maxLatency || 60000;\n                const endpointCount = this.endpoints.length;\n                for (let retryCount = 0; retryCount < 5; ++retryCount) {\n                    let handlers;\n                    const promise = new Promise((resolve, reject) => {\n                        handlers = {\n                            resolve: (endpoint) => resolve(endpoint),\n                            reject: () => reject(undefined),\n                        };\n                    });\n                    let checkedEndpoints = 0;\n                    let lastLatency;\n                    for (const endpoint of this.endpoints) {\n                        GqlSocket.checkLatency(endpoint).then((latency) => {\n                            ++checkedEndpoints;\n                            if (latency !== undefined && latency <= maxLatency) {\n                                return handlers.resolve(endpoint);\n                            }\n                            if (lastLatency === undefined ||\n                                lastLatency.latency === undefined ||\n                                (latency !== undefined && latency < lastLatency.latency)) {\n                                lastLatency = { endpoint, latency };\n                            }\n                            if (checkedEndpoints >= endpointCount) {\n                                if ((lastLatency === null || lastLatency === void 0 ? void 0 : lastLatency.latency) !== undefined) {\n                                    handlers.resolve(lastLatency.endpoint);\n                                }\n                                else {\n                                    handlers.reject();\n                                }\n                            }\n                        });\n                    }\n                    try {\n                        return await promise;\n                    }\n                    catch (e) {\n                        let resolveDelay;\n                        const delayPromise = new Promise((resolve) => {\n                            resolveDelay = () => resolve();\n                        });\n                        setTimeout(() => resolveDelay(), Math.min(100 * retryCount, 5000));\n                        await delayPromise;\n                    }\n                }\n                throw new Error('Not available endpoint found');\n            }\n        }\n        return new nekoton.GqlConnection(clock, new GqlSender(params));\n    }\n    static async checkLatency(endpoint) {\n        const response = await fetch(`${endpoint.url}?query=%7Binfo%7Bversion%20time%20latency%7D%7D`, {\n            method: 'get',\n            agent: endpoint.agent,\n        })\n            .then((response) => response.json())\n            .catch((e) => {\n            debugLog(e);\n            return undefined;\n        });\n        if (typeof response !== 'object' || response == null) {\n            return;\n        }\n        const data = response['data'];\n        if (typeof data !== 'object' || data == null) {\n            return;\n        }\n        const info = data['info'];\n        if (typeof info !== 'object' || info == null) {\n            return;\n        }\n        const latency = info['latency'];\n        if (typeof latency !== 'number') {\n            return;\n        }\n        return latency;\n    }\n}\nexports.GqlSocket = GqlSocket;\nGqlSocket.expandAddress = (baseUrl) => {\n    const lastBackslashIndex = baseUrl.lastIndexOf('/');\n    baseUrl = lastBackslashIndex < 0 ? baseUrl : baseUrl.substring(0, lastBackslashIndex);\n    let url;\n    if (baseUrl.startsWith('http://') || baseUrl.startsWith('https://')) {\n        url = `${baseUrl}/graphql`;\n    }\n    else if (['localhost', '127.0.0.1'].indexOf(baseUrl) >= 0) {\n        url = `http://${baseUrl}/graphql`;\n    }\n    else {\n        url = `https://${baseUrl}/graphql`;\n    }\n    return {\n        url,\n        agent: fetchAgent(url),\n    };\n};\nconst DEFAULT_HEADERS = {\n    'Content-Type': 'application/json',\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvQ29ubmVjdGlvbkNvbnRyb2xsZXIvZ3FsLmpzPzE2MDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdxbFNvY2tldCA9IHZvaWQgMDtcbmNvbnN0IGNvcmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vY29yZVwiKSk7XG5jb25zdCB7IG5la290b24sIGZldGNoLCBmZXRjaEFnZW50LCBkZWJ1Z0xvZyB9ID0gY29yZV8xLmRlZmF1bHQ7XG5jbGFzcyBHcWxTb2NrZXQge1xuICAgIGFzeW5jIGNvbm5lY3QoY2xvY2ssIHBhcmFtcykge1xuICAgICAgICBjbGFzcyBHcWxTZW5kZXIge1xuICAgICAgICAgICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TGF0ZW5jeURldGVjdGlvblRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZW5jeURldGVjdGlvbkludGVydmFsID0gcGFyYW1zLmxhdGVuY3lEZXRlY3Rpb25JbnRlcnZhbCB8fCA2MDAwMDtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50cyA9IHBhcmFtcy5lbmRwb2ludHMubWFwKEdxbFNvY2tldC5leHBhbmRBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRwb2ludHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RW5kcG9pbnQgPSB0aGlzLmVuZHBvaW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0TGF0ZW5jeURldGVjdGlvblRpbWUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzTG9jYWwoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmxvY2FsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VuZChkYXRhLCBoYW5kbGVyLCBfbG9uZ1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RW5kcG9pbnQgIT0gbnVsbCAmJiBub3cgPCB0aGlzLm5leHRMYXRlbmN5RGV0ZWN0aW9uVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgcm91dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludCA9IHRoaXMuY3VycmVudEVuZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5yZXNvbHV0aW9uUHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSByZXNvbHZpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludCA9IGF3YWl0IHRoaXMucmVzb2x1dGlvblByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVzb2x1dGlvblByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jdXJyZW50RW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgcmVzb2x2aW5nIChjdXJyZW50IGVuZHBvaW50IGlzIG51bGwsIG9yIGl0IGlzIHRpbWUgdG8gcmVmcmVzaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdXRpb25Qcm9taXNlID0gdGhpcy5fc2VsZWN0UXVlcnlpbmdFbmRwb2ludCgpLnRoZW4oKGVuZHBvaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEVuZHBvaW50ID0gZW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dExhdGVuY3lEZXRlY3Rpb25UaW1lID0gRGF0ZS5ub3coKSArIHRoaXMubGF0ZW5jeURldGVjdGlvbkludGVydmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQgPSBhd2FpdCB0aGlzLnJlc29sdXRpb25Qcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlc29sdXRpb25Qcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChlbmRwb2ludC51cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdwb3N0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBERUZBVUxUX0hFQURFUlMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2VudDogZW5kcG9pbnQuYWdlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UudGV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIub25SZWNlaXZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5vbkVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzeW5jIF9zZWxlY3RRdWVyeWluZ0VuZHBvaW50KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heExhdGVuY3kgPSB0aGlzLnBhcmFtcy5tYXhMYXRlbmN5IHx8IDYwMDAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50Q291bnQgPSB0aGlzLmVuZHBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcmV0cnlDb3VudCA9IDA7IHJldHJ5Q291bnQgPCA1OyArK3JldHJ5Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhhbmRsZXJzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZTogKGVuZHBvaW50KSA9PiByZXNvbHZlKGVuZHBvaW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Q6ICgpID0+IHJlamVjdCh1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGVja2VkRW5kcG9pbnRzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RMYXRlbmN5O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVuZHBvaW50IG9mIHRoaXMuZW5kcG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBHcWxTb2NrZXQuY2hlY2tMYXRlbmN5KGVuZHBvaW50KS50aGVuKChsYXRlbmN5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytjaGVja2VkRW5kcG9pbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXRlbmN5ICE9PSB1bmRlZmluZWQgJiYgbGF0ZW5jeSA8PSBtYXhMYXRlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVycy5yZXNvbHZlKGVuZHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RMYXRlbmN5ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdExhdGVuY3kubGF0ZW5jeSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsYXRlbmN5ICE9PSB1bmRlZmluZWQgJiYgbGF0ZW5jeSA8IGxhc3RMYXRlbmN5LmxhdGVuY3kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RMYXRlbmN5ID0geyBlbmRwb2ludCwgbGF0ZW5jeSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZEVuZHBvaW50cyA+PSBlbmRwb2ludENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobGFzdExhdGVuY3kgPT09IG51bGwgfHwgbGFzdExhdGVuY3kgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RMYXRlbmN5LmxhdGVuY3kpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnJlc29sdmUobGFzdExhdGVuY3kuZW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXNvbHZlRGVsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxheVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVEZWxheSA9ICgpID0+IHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlRGVsYXkoKSwgTWF0aC5taW4oMTAwICogcmV0cnlDb3VudCwgNTAwMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGVsYXlQcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGF2YWlsYWJsZSBlbmRwb2ludCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgbmVrb3Rvbi5HcWxDb25uZWN0aW9uKGNsb2NrLCBuZXcgR3FsU2VuZGVyKHBhcmFtcykpO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY2hlY2tMYXRlbmN5KGVuZHBvaW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7ZW5kcG9pbnQudXJsfT9xdWVyeT0lN0JpbmZvJTdCdmVyc2lvbiUyMHRpbWUlMjBsYXRlbmN5JTdEJTdEYCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnZ2V0JyxcbiAgICAgICAgICAgIGFnZW50OiBlbmRwb2ludC5hZ2VudCxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBkZWJ1Z0xvZyhlKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlICE9PSAnb2JqZWN0JyB8fCByZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHwgZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5mbyA9IGRhdGFbJ2luZm8nXTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmZvICE9PSAnb2JqZWN0JyB8fCBpbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXRlbmN5ID0gaW5mb1snbGF0ZW5jeSddO1xuICAgICAgICBpZiAodHlwZW9mIGxhdGVuY3kgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhdGVuY3k7XG4gICAgfVxufVxuZXhwb3J0cy5HcWxTb2NrZXQgPSBHcWxTb2NrZXQ7XG5HcWxTb2NrZXQuZXhwYW5kQWRkcmVzcyA9IChiYXNlVXJsKSA9PiB7XG4gICAgY29uc3QgbGFzdEJhY2tzbGFzaEluZGV4ID0gYmFzZVVybC5sYXN0SW5kZXhPZignLycpO1xuICAgIGJhc2VVcmwgPSBsYXN0QmFja3NsYXNoSW5kZXggPCAwID8gYmFzZVVybCA6IGJhc2VVcmwuc3Vic3RyaW5nKDAsIGxhc3RCYWNrc2xhc2hJbmRleCk7XG4gICAgbGV0IHVybDtcbiAgICBpZiAoYmFzZVVybC5zdGFydHNXaXRoKCdodHRwOi8vJykgfHwgYmFzZVVybC5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgICAgIHVybCA9IGAke2Jhc2VVcmx9L2dyYXBocWxgO1xuICAgIH1cbiAgICBlbHNlIGlmIChbJ2xvY2FsaG9zdCcsICcxMjcuMC4wLjEnXS5pbmRleE9mKGJhc2VVcmwpID49IDApIHtcbiAgICAgICAgdXJsID0gYGh0dHA6Ly8ke2Jhc2VVcmx9L2dyYXBocWxgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXJsID0gYGh0dHBzOi8vJHtiYXNlVXJsfS9ncmFwaHFsYDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXJsLFxuICAgICAgICBhZ2VudDogZmV0Y2hBZ2VudCh1cmwpLFxuICAgIH07XG59O1xuY29uc3QgREVGQVVMVF9IRUFERVJTID0ge1xuICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///315\n")},863:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectionController = exports.createConnectionController = exports.ConnectionError = exports.checkConnection = exports.NETWORK_PRESETS = exports.DEFAULT_NETWORK_GROUP = void 0;\nconst await_semaphore_1 = __webpack_require__(68);\nconst core_1 = __importDefault(__webpack_require__(521));\nconst gql_1 = __webpack_require__(315);\nconst jrpc_1 = __webpack_require__(106);\nconst { nekoton, debugLog } = core_1.default;\nexports.DEFAULT_NETWORK_GROUP = 'mainnet';\n/**\n * @category Client\n */\nexports.NETWORK_PRESETS = {\n    mainnet: {\n        id: 1,\n        group: 'mainnet',\n        type: 'graphql',\n        data: {\n            endpoints: [\n                'eri01.main.everos.dev',\n                'gra01.main.everos.dev',\n                'gra02.main.everos.dev',\n                'lim01.main.everos.dev',\n                'rbx01.main.everos.dev',\n            ],\n            local: false,\n        },\n    },\n    mainnetJrpc: {\n        id: 1,\n        group: 'mainnet',\n        type: 'jrpc',\n        data: {\n            endpoint: 'https://jrpc.everwallet.net/rpc',\n        },\n    },\n    testnet: {\n        id: 2,\n        group: 'testnet',\n        type: 'graphql',\n        data: {\n            endpoints: ['eri01.net.everos.dev', 'rbx01.net.everos.dev', 'gra01.net.everos.dev'],\n            local: false,\n        },\n    },\n    fld: {\n        id: 10,\n        group: 'fld',\n        type: 'graphql',\n        data: {\n            endpoints: ['gql.custler.net'],\n            local: false,\n        },\n    },\n    local: {\n        id: 31337,\n        group: 'localnet',\n        type: 'graphql',\n        data: {\n            endpoints: ['127.0.0.1'],\n            local: true,\n        },\n    },\n};\nfunction loadPreset(params) {\n    if (typeof params === 'string') {\n        const targetPreset = exports.NETWORK_PRESETS[params];\n        if (targetPreset == null) {\n            throw new Error(`Target preset id not found: ${params}`);\n        }\n        return targetPreset;\n    }\n    else {\n        return params;\n    }\n}\n/**\n * Tries to connect with the specified params. Throws an exception in case of error\n *\n * @category Client\n * @throws ConnectionError\n */\nasync function checkConnection(params) {\n    const preset = loadPreset(params);\n    const clock = new nekoton.ClockWithOffset();\n    try {\n        const controller = new ConnectionController(clock);\n        await controller['_connect'](preset);\n        if (controller['_initializedTransport'] != null) {\n            cleanupInitializedTransport(controller['_initializedTransport']);\n        }\n    }\n    catch (e) {\n        throw new ConnectionError(preset, e.toString());\n    }\n    finally {\n        clock.free();\n    }\n}\nexports.checkConnection = checkConnection;\n/**\n * @category Client\n */\nclass ConnectionError extends Error {\n    constructor(params, message) {\n        super(message);\n        this.params = params;\n    }\n}\nexports.ConnectionError = ConnectionError;\nasync function createConnectionController(clock, params, retry = false) {\n    const preset = loadPreset(params);\n    // Try connect\n    while (true) {\n        try {\n            const controller = new ConnectionController(clock);\n            await controller.startSwitchingNetwork(preset).then((handle) => handle.switch());\n            debugLog(`Successfully connected to ${preset.group}`);\n            return controller;\n        }\n        catch (e) {\n            if (retry) {\n                console.error('Connection failed:', e);\n                await new Promise((resolve) => {\n                    setTimeout(() => resolve(), 5000);\n                });\n                debugLog('Restarting connection process');\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n}\nexports.createConnectionController = createConnectionController;\nclass ConnectionController {\n    constructor(clock) {\n        this._networkMutex = new await_semaphore_1.Mutex();\n        this._acquiredTransportCounter = 0;\n        this._clock = clock;\n    }\n    async acquire() {\n        requireInitializedTransport(this._initializedTransport);\n        await this._acquireTransport();\n        return {\n            transport: this._initializedTransport,\n            release: () => this._releaseTransport(),\n        };\n    }\n    async use(f) {\n        requireInitializedTransport(this._initializedTransport);\n        await this._acquireTransport();\n        return f(this._initializedTransport)\n            .finally(() => {\n            this._releaseTransport();\n        });\n    }\n    async startSwitchingNetwork(params) {\n        var _a;\n        class NetworkSwitchHandle {\n            constructor(controller, release, params) {\n                this._controller = controller;\n                this._release = release;\n                this._params = params;\n            }\n            async switch() {\n                await this._controller\n                    ._connect(this._params)\n                    .finally(() => this._release());\n            }\n        }\n        (_a = this._cancelTestTransport) === null || _a === void 0 ? void 0 : _a.call(this);\n        const release = await this._networkMutex.acquire();\n        return new NetworkSwitchHandle(this, release, params);\n    }\n    get initializedTransport() {\n        return this._initializedTransport;\n    }\n    async _connect(params) {\n        if (this._initializedTransport != null) {\n            cleanupInitializedTransport(this._initializedTransport);\n        }\n        this._initializedTransport = undefined;\n        let TestConnectionResult;\n        (function (TestConnectionResult) {\n            TestConnectionResult[TestConnectionResult[\"DONE\"] = 0] = \"DONE\";\n            TestConnectionResult[TestConnectionResult[\"CANCELLED\"] = 1] = \"CANCELLED\";\n        })(TestConnectionResult || (TestConnectionResult = {}));\n        const testTransport = async ({ data: { transport } }, local) => {\n            return new Promise((resolve, reject) => {\n                this._cancelTestTransport = () => resolve(TestConnectionResult.CANCELLED);\n                if (local) {\n                    transport\n                        .getAccountsByCodeHash('4e92716de61d456e58f16e4e867e3e93a7548321eace86301b51c8b80ca6239b', 1)\n                        .then(() => resolve(TestConnectionResult.DONE))\n                        .catch((e) => reject(e));\n                }\n                else {\n                    // Try to get any account state\n                    transport\n                        .getFullContractState('-1:0000000000000000000000000000000000000000000000000000000000000000')\n                        .then(() => resolve(TestConnectionResult.DONE))\n                        .catch((e) => reject(e));\n                }\n                setTimeout(() => reject(new Error('Connection timeout')), 10000);\n            }).finally(() => this._cancelTestTransport = undefined);\n        };\n        try {\n            const { local, transportData } = await (params.type === 'graphql'\n                ? async () => {\n                    const socket = new gql_1.GqlSocket();\n                    const connection = await socket.connect(this._clock, params.data);\n                    const transport = nekoton.Transport.fromGqlConnection(connection);\n                    const transportData = {\n                        id: params.id,\n                        group: params.group,\n                        type: 'graphql',\n                        data: {\n                            socket,\n                            connection,\n                            transport,\n                        },\n                    };\n                    return {\n                        local: params.data.local,\n                        transportData,\n                    };\n                }\n                : async () => {\n                    const socket = new jrpc_1.JrpcSocket();\n                    const connection = await socket.connect(this._clock, params.data);\n                    const transport = nekoton.Transport.fromJrpcConnection(connection);\n                    const transportData = {\n                        id: params.id,\n                        group: params.group,\n                        type: 'jrpc',\n                        data: {\n                            socket,\n                            connection,\n                            transport,\n                        },\n                    };\n                    return {\n                        local: false,\n                        transportData,\n                    };\n                })();\n            try {\n                if (await testTransport(transportData, local) == TestConnectionResult.CANCELLED) {\n                    cleanupInitializedTransport(transportData);\n                    return;\n                }\n            }\n            catch (e) {\n                // Free transport data in case of error\n                cleanupInitializedTransport(transportData);\n                throw e;\n            }\n            this._initializedTransport = transportData;\n        }\n        catch (e) {\n            throw new Error(`Failed to create connection: ${e.toString()}`);\n        }\n    }\n    async _acquireTransport() {\n        debugLog('_acquireTransport');\n        if (this._acquiredTransportCounter > 0) {\n            debugLog('_acquireTransport -> increase');\n            this._acquiredTransportCounter += 1;\n        }\n        else {\n            this._acquiredTransportCounter = 1;\n            if (this._release != null) {\n                console.warn('mutex is already acquired');\n            }\n            else {\n                debugLog('_acquireTransport -> await');\n                this._release = await this._networkMutex.acquire();\n                debugLog('_acquireTransport -> create');\n            }\n        }\n    }\n    _releaseTransport() {\n        var _a;\n        debugLog('_releaseTransport');\n        this._acquiredTransportCounter -= 1;\n        if (this._acquiredTransportCounter <= 0) {\n            debugLog('_releaseTransport -> release');\n            (_a = this._release) === null || _a === void 0 ? void 0 : _a.call(this);\n            this._release = undefined;\n        }\n    }\n}\nexports.ConnectionController = ConnectionController;\nfunction cleanupInitializedTransport(transport) {\n    transport.data.transport.free();\n    transport.data.connection.free();\n}\nfunction requireInitializedTransport(transport) {\n    if (transport == null) {\n        throw new Error('Connection is not initialized');\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODYzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvQ29ubmVjdGlvbkNvbnRyb2xsZXIvaW5kZXguanM/YjIxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29ubmVjdGlvbkNvbnRyb2xsZXIgPSBleHBvcnRzLmNyZWF0ZUNvbm5lY3Rpb25Db250cm9sbGVyID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBleHBvcnRzLmNoZWNrQ29ubmVjdGlvbiA9IGV4cG9ydHMuTkVUV09SS19QUkVTRVRTID0gZXhwb3J0cy5ERUZBVUxUX05FVFdPUktfR1JPVVAgPSB2b2lkIDA7XG5jb25zdCBhd2FpdF9zZW1hcGhvcmVfMSA9IHJlcXVpcmUoXCJAYnJveHVzL2F3YWl0LXNlbWFwaG9yZVwiKTtcbmNvbnN0IGNvcmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vY29yZVwiKSk7XG5jb25zdCBncWxfMSA9IHJlcXVpcmUoXCIuL2dxbFwiKTtcbmNvbnN0IGpycGNfMSA9IHJlcXVpcmUoXCIuL2pycGNcIik7XG5jb25zdCB7IG5la290b24sIGRlYnVnTG9nIH0gPSBjb3JlXzEuZGVmYXVsdDtcbmV4cG9ydHMuREVGQVVMVF9ORVRXT1JLX0dST1VQID0gJ21haW5uZXQnO1xuLyoqXG4gKiBAY2F0ZWdvcnkgQ2xpZW50XG4gKi9cbmV4cG9ydHMuTkVUV09SS19QUkVTRVRTID0ge1xuICAgIG1haW5uZXQ6IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIGdyb3VwOiAnbWFpbm5ldCcsXG4gICAgICAgIHR5cGU6ICdncmFwaHFsJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZW5kcG9pbnRzOiBbXG4gICAgICAgICAgICAgICAgJ2VyaTAxLm1haW4uZXZlcm9zLmRldicsXG4gICAgICAgICAgICAgICAgJ2dyYTAxLm1haW4uZXZlcm9zLmRldicsXG4gICAgICAgICAgICAgICAgJ2dyYTAyLm1haW4uZXZlcm9zLmRldicsXG4gICAgICAgICAgICAgICAgJ2xpbTAxLm1haW4uZXZlcm9zLmRldicsXG4gICAgICAgICAgICAgICAgJ3JieDAxLm1haW4uZXZlcm9zLmRldicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgbWFpbm5ldEpycGM6IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIGdyb3VwOiAnbWFpbm5ldCcsXG4gICAgICAgIHR5cGU6ICdqcnBjJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZW5kcG9pbnQ6ICdodHRwczovL2pycGMuZXZlcndhbGxldC5uZXQvcnBjJyxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHRlc3RuZXQ6IHtcbiAgICAgICAgaWQ6IDIsXG4gICAgICAgIGdyb3VwOiAndGVzdG5ldCcsXG4gICAgICAgIHR5cGU6ICdncmFwaHFsJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZW5kcG9pbnRzOiBbJ2VyaTAxLm5ldC5ldmVyb3MuZGV2JywgJ3JieDAxLm5ldC5ldmVyb3MuZGV2JywgJ2dyYTAxLm5ldC5ldmVyb3MuZGV2J10sXG4gICAgICAgICAgICBsb2NhbDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBmbGQ6IHtcbiAgICAgICAgaWQ6IDEwLFxuICAgICAgICBncm91cDogJ2ZsZCcsXG4gICAgICAgIHR5cGU6ICdncmFwaHFsJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZW5kcG9pbnRzOiBbJ2dxbC5jdXN0bGVyLm5ldCddLFxuICAgICAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgbG9jYWw6IHtcbiAgICAgICAgaWQ6IDMxMzM3LFxuICAgICAgICBncm91cDogJ2xvY2FsbmV0JyxcbiAgICAgICAgdHlwZTogJ2dyYXBocWwnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBlbmRwb2ludHM6IFsnMTI3LjAuMC4xJ10sXG4gICAgICAgICAgICBsb2NhbDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGxvYWRQcmVzZXQocGFyYW1zKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFByZXNldCA9IGV4cG9ydHMuTkVUV09SS19QUkVTRVRTW3BhcmFtc107XG4gICAgICAgIGlmICh0YXJnZXRQcmVzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYXJnZXQgcHJlc2V0IGlkIG5vdCBmb3VuZDogJHtwYXJhbXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldFByZXNldDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxufVxuLyoqXG4gKiBUcmllcyB0byBjb25uZWN0IHdpdGggdGhlIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBhbiBleGNlcHRpb24gaW4gY2FzZSBvZiBlcnJvclxuICpcbiAqIEBjYXRlZ29yeSBDbGllbnRcbiAqIEB0aHJvd3MgQ29ubmVjdGlvbkVycm9yXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrQ29ubmVjdGlvbihwYXJhbXMpIHtcbiAgICBjb25zdCBwcmVzZXQgPSBsb2FkUHJlc2V0KHBhcmFtcyk7XG4gICAgY29uc3QgY2xvY2sgPSBuZXcgbmVrb3Rvbi5DbG9ja1dpdGhPZmZzZXQoKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IENvbm5lY3Rpb25Db250cm9sbGVyKGNsb2NrKTtcbiAgICAgICAgYXdhaXQgY29udHJvbGxlclsnX2Nvbm5lY3QnXShwcmVzZXQpO1xuICAgICAgICBpZiAoY29udHJvbGxlclsnX2luaXRpYWxpemVkVHJhbnNwb3J0J10gIT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYW51cEluaXRpYWxpemVkVHJhbnNwb3J0KGNvbnRyb2xsZXJbJ19pbml0aWFsaXplZFRyYW5zcG9ydCddKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKHByZXNldCwgZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGNsb2NrLmZyZWUoKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrQ29ubmVjdGlvbiA9IGNoZWNrQ29ubmVjdGlvbjtcbi8qKlxuICogQGNhdGVnb3J5IENsaWVudFxuICovXG5jbGFzcyBDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB9XG59XG5leHBvcnRzLkNvbm5lY3Rpb25FcnJvciA9IENvbm5lY3Rpb25FcnJvcjtcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb25Db250cm9sbGVyKGNsb2NrLCBwYXJhbXMsIHJldHJ5ID0gZmFsc2UpIHtcbiAgICBjb25zdCBwcmVzZXQgPSBsb2FkUHJlc2V0KHBhcmFtcyk7XG4gICAgLy8gVHJ5IGNvbm5lY3RcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBDb25uZWN0aW9uQ29udHJvbGxlcihjbG9jayk7XG4gICAgICAgICAgICBhd2FpdCBjb250cm9sbGVyLnN0YXJ0U3dpdGNoaW5nTmV0d29yayhwcmVzZXQpLnRoZW4oKGhhbmRsZSkgPT4gaGFuZGxlLnN3aXRjaCgpKTtcbiAgICAgICAgICAgIGRlYnVnTG9nKGBTdWNjZXNzZnVsbHkgY29ubmVjdGVkIHRvICR7cHJlc2V0Lmdyb3VwfWApO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChyZXRyeSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nvbm5lY3Rpb24gZmFpbGVkOicsIGUpO1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSgpLCA1MDAwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWJ1Z0xvZygnUmVzdGFydGluZyBjb25uZWN0aW9uIHByb2Nlc3MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUNvbm5lY3Rpb25Db250cm9sbGVyID0gY3JlYXRlQ29ubmVjdGlvbkNvbnRyb2xsZXI7XG5jbGFzcyBDb25uZWN0aW9uQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoY2xvY2spIHtcbiAgICAgICAgdGhpcy5fbmV0d29ya011dGV4ID0gbmV3IGF3YWl0X3NlbWFwaG9yZV8xLk11dGV4KCk7XG4gICAgICAgIHRoaXMuX2FjcXVpcmVkVHJhbnNwb3J0Q291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX2Nsb2NrID0gY2xvY2s7XG4gICAgfVxuICAgIGFzeW5jIGFjcXVpcmUoKSB7XG4gICAgICAgIHJlcXVpcmVJbml0aWFsaXplZFRyYW5zcG9ydCh0aGlzLl9pbml0aWFsaXplZFRyYW5zcG9ydCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2FjcXVpcmVUcmFuc3BvcnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydDogdGhpcy5faW5pdGlhbGl6ZWRUcmFuc3BvcnQsXG4gICAgICAgICAgICByZWxlYXNlOiAoKSA9PiB0aGlzLl9yZWxlYXNlVHJhbnNwb3J0KCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHVzZShmKSB7XG4gICAgICAgIHJlcXVpcmVJbml0aWFsaXplZFRyYW5zcG9ydCh0aGlzLl9pbml0aWFsaXplZFRyYW5zcG9ydCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2FjcXVpcmVUcmFuc3BvcnQoKTtcbiAgICAgICAgcmV0dXJuIGYodGhpcy5faW5pdGlhbGl6ZWRUcmFuc3BvcnQpXG4gICAgICAgICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZWxlYXNlVHJhbnNwb3J0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzdGFydFN3aXRjaGluZ05ldHdvcmsocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY2xhc3MgTmV0d29ya1N3aXRjaEhhbmRsZSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcihjb250cm9sbGVyLCByZWxlYXNlLCBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWxlYXNlID0gcmVsZWFzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3luYyBzd2l0Y2goKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fY29udHJvbGxlclxuICAgICAgICAgICAgICAgICAgICAuX2Nvbm5lY3QodGhpcy5fcGFyYW1zKVxuICAgICAgICAgICAgICAgICAgICAuZmluYWxseSgoKSA9PiB0aGlzLl9yZWxlYXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuX2NhbmNlbFRlc3RUcmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgICAgICBjb25zdCByZWxlYXNlID0gYXdhaXQgdGhpcy5fbmV0d29ya011dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXR3b3JrU3dpdGNoSGFuZGxlKHRoaXMsIHJlbGVhc2UsIHBhcmFtcyk7XG4gICAgfVxuICAgIGdldCBpbml0aWFsaXplZFRyYW5zcG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXRpYWxpemVkVHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBfY29ubmVjdChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkVHJhbnNwb3J0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFudXBJbml0aWFsaXplZFRyYW5zcG9ydCh0aGlzLl9pbml0aWFsaXplZFRyYW5zcG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWRUcmFuc3BvcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBUZXN0Q29ubmVjdGlvblJlc3VsdDtcbiAgICAgICAgKGZ1bmN0aW9uIChUZXN0Q29ubmVjdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgVGVzdENvbm5lY3Rpb25SZXN1bHRbVGVzdENvbm5lY3Rpb25SZXN1bHRbXCJET05FXCJdID0gMF0gPSBcIkRPTkVcIjtcbiAgICAgICAgICAgIFRlc3RDb25uZWN0aW9uUmVzdWx0W1Rlc3RDb25uZWN0aW9uUmVzdWx0W1wiQ0FOQ0VMTEVEXCJdID0gMV0gPSBcIkNBTkNFTExFRFwiO1xuICAgICAgICB9KShUZXN0Q29ubmVjdGlvblJlc3VsdCB8fCAoVGVzdENvbm5lY3Rpb25SZXN1bHQgPSB7fSkpO1xuICAgICAgICBjb25zdCB0ZXN0VHJhbnNwb3J0ID0gYXN5bmMgKHsgZGF0YTogeyB0cmFuc3BvcnQgfSB9LCBsb2NhbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWxUZXN0VHJhbnNwb3J0ID0gKCkgPT4gcmVzb2x2ZShUZXN0Q29ubmVjdGlvblJlc3VsdC5DQU5DRUxMRUQpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRBY2NvdW50c0J5Q29kZUhhc2goJzRlOTI3MTZkZTYxZDQ1NmU1OGYxNmU0ZTg2N2UzZTkzYTc1NDgzMjFlYWNlODYzMDFiNTFjOGI4MGNhNjIzOWInLCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gcmVzb2x2ZShUZXN0Q29ubmVjdGlvblJlc3VsdC5ET05FKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4gcmVqZWN0KGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBnZXQgYW55IGFjY291bnQgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RnVsbENvbnRyYWN0U3RhdGUoJy0xOjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gcmVzb2x2ZShUZXN0Q29ubmVjdGlvblJlc3VsdC5ET05FKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4gcmVqZWN0KGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKCdDb25uZWN0aW9uIHRpbWVvdXQnKSksIDEwMDAwKTtcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoKCkgPT4gdGhpcy5fY2FuY2VsVGVzdFRyYW5zcG9ydCA9IHVuZGVmaW5lZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGxvY2FsLCB0cmFuc3BvcnREYXRhIH0gPSBhd2FpdCAocGFyYW1zLnR5cGUgPT09ICdncmFwaHFsJ1xuICAgICAgICAgICAgICAgID8gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb2NrZXQgPSBuZXcgZ3FsXzEuR3FsU29ja2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBzb2NrZXQuY29ubmVjdCh0aGlzLl9jbG9jaywgcGFyYW1zLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZWtvdG9uLlRyYW5zcG9ydC5mcm9tR3FsQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cDogcGFyYW1zLmdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2dyYXBocWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbDogcGFyYW1zLmRhdGEubG9jYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnREYXRhLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gbmV3IGpycGNfMS5KcnBjU29ja2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBzb2NrZXQuY29ubmVjdCh0aGlzLl9jbG9jaywgcGFyYW1zLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZWtvdG9uLlRyYW5zcG9ydC5mcm9tSnJwY0Nvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zcG9ydERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcGFyYW1zLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IHBhcmFtcy5ncm91cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdqcnBjJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoYXdhaXQgdGVzdFRyYW5zcG9ydCh0cmFuc3BvcnREYXRhLCBsb2NhbCkgPT0gVGVzdENvbm5lY3Rpb25SZXN1bHQuQ0FOQ0VMTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXBJbml0aWFsaXplZFRyYW5zcG9ydCh0cmFuc3BvcnREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gRnJlZSB0cmFuc3BvcnQgZGF0YSBpbiBjYXNlIG9mIGVycm9yXG4gICAgICAgICAgICAgICAgY2xlYW51cEluaXRpYWxpemVkVHJhbnNwb3J0KHRyYW5zcG9ydERhdGEpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZFRyYW5zcG9ydCA9IHRyYW5zcG9ydERhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBjb25uZWN0aW9uOiAke2UudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfYWNxdWlyZVRyYW5zcG9ydCgpIHtcbiAgICAgICAgZGVidWdMb2coJ19hY3F1aXJlVHJhbnNwb3J0Jyk7XG4gICAgICAgIGlmICh0aGlzLl9hY3F1aXJlZFRyYW5zcG9ydENvdW50ZXIgPiAwKSB7XG4gICAgICAgICAgICBkZWJ1Z0xvZygnX2FjcXVpcmVUcmFuc3BvcnQgLT4gaW5jcmVhc2UnKTtcbiAgICAgICAgICAgIHRoaXMuX2FjcXVpcmVkVHJhbnNwb3J0Q291bnRlciArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWNxdWlyZWRUcmFuc3BvcnRDb3VudGVyID0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWxlYXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ211dGV4IGlzIGFscmVhZHkgYWNxdWlyZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYnVnTG9nKCdfYWNxdWlyZVRyYW5zcG9ydCAtPiBhd2FpdCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbGVhc2UgPSBhd2FpdCB0aGlzLl9uZXR3b3JrTXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgICAgIGRlYnVnTG9nKCdfYWNxdWlyZVRyYW5zcG9ydCAtPiBjcmVhdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVsZWFzZVRyYW5zcG9ydCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBkZWJ1Z0xvZygnX3JlbGVhc2VUcmFuc3BvcnQnKTtcbiAgICAgICAgdGhpcy5fYWNxdWlyZWRUcmFuc3BvcnRDb3VudGVyIC09IDE7XG4gICAgICAgIGlmICh0aGlzLl9hY3F1aXJlZFRyYW5zcG9ydENvdW50ZXIgPD0gMCkge1xuICAgICAgICAgICAgZGVidWdMb2coJ19yZWxlYXNlVHJhbnNwb3J0IC0+IHJlbGVhc2UnKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuX3JlbGVhc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcmVsZWFzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29ubmVjdGlvbkNvbnRyb2xsZXIgPSBDb25uZWN0aW9uQ29udHJvbGxlcjtcbmZ1bmN0aW9uIGNsZWFudXBJbml0aWFsaXplZFRyYW5zcG9ydCh0cmFuc3BvcnQpIHtcbiAgICB0cmFuc3BvcnQuZGF0YS50cmFuc3BvcnQuZnJlZSgpO1xuICAgIHRyYW5zcG9ydC5kYXRhLmNvbm5lY3Rpb24uZnJlZSgpO1xufVxuZnVuY3Rpb24gcmVxdWlyZUluaXRpYWxpemVkVHJhbnNwb3J0KHRyYW5zcG9ydCkge1xuICAgIGlmICh0cmFuc3BvcnQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gaXMgbm90IGluaXRpYWxpemVkJyk7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///863\n")},106:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JrpcSocket = void 0;\nconst core_1 = __importDefault(__webpack_require__(521));\nconst { nekoton, fetch, fetchAgent } = core_1.default;\nclass JrpcSocket {\n    async connect(clock, params) {\n        class JrpcSender {\n            constructor(params) {\n                this.endpoint = params.endpoint;\n                this.endpointAgent = fetchAgent(this.endpoint);\n                this.alternativeEndpoint = params.alternativeEndpoint != null\n                    ? params.alternativeEndpoint\n                    : params.endpoint;\n                this.alternativeEndpointAgent = fetchAgent(this.alternativeEndpoint);\n            }\n            send(data, handler, requiresDb) {\n                ;\n                (async () => {\n                    try {\n                        const url = requiresDb ? this.endpoint : this.alternativeEndpoint;\n                        const agent = requiresDb ? this.endpointAgent : this.alternativeEndpointAgent;\n                        const response = await fetch(url, {\n                            method: 'post',\n                            headers: DEFAULT_HEADERS,\n                            body: data,\n                            agent,\n                        }).then((response) => response.text());\n                        handler.onReceive(response);\n                    }\n                    catch (e) {\n                        handler.onError(e);\n                    }\n                })();\n            }\n        }\n        return new nekoton.JrpcConnection(clock, new JrpcSender(params));\n    }\n}\nexports.JrpcSocket = JrpcSocket;\nconst DEFAULT_HEADERS = {\n    'Content-Type': 'application/json',\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvQ29ubmVjdGlvbkNvbnRyb2xsZXIvanJwYy5qcz9iNDY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5KcnBjU29ja2V0ID0gdm9pZCAwO1xuY29uc3QgY29yZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9jb3JlXCIpKTtcbmNvbnN0IHsgbmVrb3RvbiwgZmV0Y2gsIGZldGNoQWdlbnQgfSA9IGNvcmVfMS5kZWZhdWx0O1xuY2xhc3MgSnJwY1NvY2tldCB7XG4gICAgYXN5bmMgY29ubmVjdChjbG9jaywgcGFyYW1zKSB7XG4gICAgICAgIGNsYXNzIEpycGNTZW5kZXIge1xuICAgICAgICAgICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRwb2ludCA9IHBhcmFtcy5lbmRwb2ludDtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50QWdlbnQgPSBmZXRjaEFnZW50KHRoaXMuZW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRpdmVFbmRwb2ludCA9IHBhcmFtcy5hbHRlcm5hdGl2ZUVuZHBvaW50ICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJhbXMuYWx0ZXJuYXRpdmVFbmRwb2ludFxuICAgICAgICAgICAgICAgICAgICA6IHBhcmFtcy5lbmRwb2ludDtcbiAgICAgICAgICAgICAgICB0aGlzLmFsdGVybmF0aXZlRW5kcG9pbnRBZ2VudCA9IGZldGNoQWdlbnQodGhpcy5hbHRlcm5hdGl2ZUVuZHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbmQoZGF0YSwgaGFuZGxlciwgcmVxdWlyZXNEYikge1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gcmVxdWlyZXNEYiA/IHRoaXMuZW5kcG9pbnQgOiB0aGlzLmFsdGVybmF0aXZlRW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZ2VudCA9IHJlcXVpcmVzRGIgPyB0aGlzLmVuZHBvaW50QWdlbnQgOiB0aGlzLmFsdGVybmF0aXZlRW5kcG9pbnRBZ2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAncG9zdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogREVGQVVMVF9IRUFERVJTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UudGV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIub25SZWNlaXZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5vbkVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IG5la290b24uSnJwY0Nvbm5lY3Rpb24oY2xvY2ssIG5ldyBKcnBjU2VuZGVyKHBhcmFtcykpO1xuICAgIH1cbn1cbmV4cG9ydHMuSnJwY1NvY2tldCA9IEpycGNTb2NrZXQ7XG5jb25zdCBERUZBVUxUX0hFQURFUlMgPSB7XG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///106\n")},536:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SubscriptionController = void 0;\nconst await_semaphore_1 = __webpack_require__(68);\nconst utils_1 = __webpack_require__(344);\nconst subscription_1 = __webpack_require__(334);\nconst DEFAULT_POLLING_INTERVAL = 10000; // 10s\nclass SubscriptionController {\n    constructor(connectionController, notify) {\n        this._subscriptions = new Map();\n        this._subscriptionsMutex = new await_semaphore_1.Mutex();\n        this._sendMessageRequests = new Map();\n        this._subscriptionStates = new Map();\n        this._connectionController = connectionController;\n        this._notify = notify;\n    }\n    async sendMessageLocally(address, signedMessage) {\n        const subscriptionId = (0, utils_1.getUniqueId)();\n        try {\n            await this.subscribeToContract(address, { state: true }, subscriptionId);\n            const subscription = this._subscriptions.get(address);\n            if (subscription == null) {\n                throw new Error('Failed to subscribe to contract');\n            }\n            return await subscription.use((contract) => contract.sendMessageLocally(signedMessage));\n        }\n        finally {\n            this.unsubscribeFromContract(address, subscriptionId).catch(console.error);\n        }\n    }\n    sendMessage(address, signedMessage) {\n        let messageRequests = this._sendMessageRequests.get(address);\n        if (messageRequests == null) {\n            messageRequests = new Map();\n            this._sendMessageRequests.set(address, messageRequests);\n        }\n        const subscriptionId = (0, utils_1.getUniqueId)();\n        return new Promise((resolve, reject) => {\n            const id = signedMessage.hash;\n            messageRequests.set(id, { resolve, reject });\n            this.subscribeToContract(address, { state: true }, subscriptionId)\n                .then(async () => {\n                const subscription = this._subscriptions.get(address);\n                if (subscription == null) {\n                    throw new Error('Failed to subscribe to contract');\n                }\n                await subscription.prepareReliablePolling();\n                await subscription\n                    .use(async (contract) => {\n                    await contract.sendMessage(signedMessage);\n                    subscription.skipRefreshTimer();\n                });\n            })\n                .catch((e) => this._rejectMessageRequest(address, id, e))\n                .finally(() => {\n                this.unsubscribeFromContract(address, subscriptionId).catch(console.error);\n            });\n        });\n    }\n    async subscribeToContract(address, params, internalId) {\n        return this._subscriptionsMutex.use(async () => {\n            let mergeInputParams = (currentParams) => {\n                const newParams = { ...currentParams };\n                Object.keys(newParams).map((param) => {\n                    if (param !== 'state' && param !== 'transactions') {\n                        throw new Error(`Unknown subscription topic: ${param}`);\n                    }\n                    const value = params[param];\n                    if (typeof value === 'boolean') {\n                        newParams[param] = value;\n                    }\n                    else if (value == null) {\n                        return;\n                    }\n                    else {\n                        throw new Error(`Unknown subscription topic value ${param}: ${value}`);\n                    }\n                });\n                return newParams;\n            };\n            const subscriptionState = this._subscriptionStates.get(address) || makeDefaultSubscriptionState();\n            let changedParams;\n            if (internalId == null) {\n                // Client subscription without id\n                // Changed params are `SubscriptionState.client`\n                changedParams = mergeInputParams(subscriptionState.client);\n            }\n            else {\n                // Internal subscription with id\n                // Changed params are `SubscriptionState.internal[internalId]`\n                let exisingParams = subscriptionState.internal.get(internalId);\n                if (exisingParams != null) {\n                    // Updating existing internal params\n                    changedParams = mergeInputParams(exisingParams);\n                    // Remove entry if it is empty\n                    if (isEmptySubscription(changedParams)) {\n                        subscriptionState.internal.delete(internalId);\n                    }\n                }\n                else {\n                    // Merge input params with empty struct\n                    changedParams = mergeInputParams({ state: false, transactions: false });\n                }\n            }\n            // Merge changed params with the rest of internal params\n            let computedParams = { ...changedParams };\n            for (const params of subscriptionState.internal.values()) {\n                computedParams.state || (computedParams.state = params.state);\n                computedParams.transactions || (computedParams.transactions = params.transactions);\n            }\n            // Remove subscription if all params are empty\n            if (isEmptySubscription(computedParams)) {\n                this._subscriptionStates.delete(address);\n                await this._tryUnsubscribe(address);\n                return { ...computedParams };\n            }\n            // Create subscription if it doesn't exist\n            let existingSubscription = this._subscriptions.get(address);\n            const isNewSubscription = existingSubscription == null;\n            if (existingSubscription == null) {\n                existingSubscription = await this._createSubscription(address);\n            }\n            // Update subscription state\n            if (internalId == null) {\n                // Update client params\n                subscriptionState.client = changedParams;\n            }\n            else {\n                // Set new internal params\n                subscriptionState.internal.set(internalId, changedParams);\n            }\n            this._subscriptionStates.set(address, subscriptionState);\n            // Start subscription\n            if (isNewSubscription) {\n                await existingSubscription.start();\n            }\n            // Returns only changed params\n            return { ...changedParams };\n        });\n    }\n    async unsubscribeFromContract(address, internalId) {\n        await this.subscribeToContract(address, {\n            state: false,\n            transactions: false,\n        }, internalId);\n    }\n    async unsubscribeFromAllContracts(internalId) {\n        for (const address of this._subscriptions.keys()) {\n            await this.unsubscribeFromContract(address, internalId);\n        }\n    }\n    get subscriptionStates() {\n        const result = {};\n        for (const [key, value] of this._subscriptionStates.entries()) {\n            result[key] = { ...value.client };\n        }\n        return result;\n    }\n    async _createSubscription(address) {\n        class ContractHandler {\n            constructor(address, controller) {\n                this._enabled = false;\n                this._address = address;\n                this._controller = controller;\n            }\n            enabledNotifications() {\n                this._enabled = true;\n            }\n            onMessageExpired(pendingTransaction) {\n                if (this._enabled) {\n                    this._controller\n                        ._resolveMessageRequest(this._address, pendingTransaction.messageHash, undefined)\n                        .catch(console.error);\n                }\n            }\n            onMessageSent(pendingTransaction, transaction) {\n                if (this._enabled) {\n                    this._controller\n                        ._resolveMessageRequest(this._address, pendingTransaction.messageHash, transaction)\n                        .catch(console.error);\n                }\n            }\n            onStateChanged(newState) {\n                if (this._enabled) {\n                    this._controller._notifyStateChanged(this._address, newState);\n                }\n            }\n            onTransactionsFound(transactions, info) {\n                if (this._enabled) {\n                    this._controller._notifyTransactionsFound(this._address, transactions, info);\n                }\n            }\n        }\n        const handler = new ContractHandler(address, this);\n        const subscription = await subscription_1.ContractSubscription.subscribe(this._connectionController, address, handler);\n        subscription.setPollingInterval(DEFAULT_POLLING_INTERVAL);\n        handler.enabledNotifications();\n        this._subscriptions.set(address, subscription);\n        return subscription;\n    }\n    async _tryUnsubscribe(address) {\n        const subscriptionState = this._subscriptionStates.get(address);\n        const sendMessageRequests = this._sendMessageRequests.get(address);\n        if (subscriptionState == null && ((sendMessageRequests === null || sendMessageRequests === void 0 ? void 0 : sendMessageRequests.size) || 0) == 0) {\n            const subscription = this._subscriptions.get(address);\n            this._subscriptions.delete(address);\n            await (subscription === null || subscription === void 0 ? void 0 : subscription.stop());\n        }\n    }\n    async _rejectMessageRequest(address, id, error) {\n        this._deleteMessageRequestAndGetCallback(address, id).reject(error);\n        await this._subscriptionsMutex.use(async () => this._tryUnsubscribe(address));\n    }\n    async _resolveMessageRequest(address, id, transaction) {\n        this._deleteMessageRequestAndGetCallback(address, id).resolve(transaction);\n        await this._subscriptionsMutex.use(async () => this._tryUnsubscribe(address));\n    }\n    _notifyStateChanged(address, state) {\n        const subscriptionState = this._subscriptionStates.get(address);\n        if (subscriptionState === null || subscriptionState === void 0 ? void 0 : subscriptionState.client.state) {\n            this._notify('contractStateChanged', {\n                address,\n                state,\n            });\n        }\n    }\n    _notifyTransactionsFound(address, transactions, info) {\n        const subscriptionState = this._subscriptionStates.get(address);\n        if (subscriptionState === null || subscriptionState === void 0 ? void 0 : subscriptionState.client.transactions) {\n            this._notify('transactionsFound', {\n                address,\n                transactions,\n                info,\n            });\n        }\n    }\n    _deleteMessageRequestAndGetCallback(address, id) {\n        var _a;\n        const callbacks = (_a = this._sendMessageRequests.get(address)) === null || _a === void 0 ? void 0 : _a.get(id);\n        if (!callbacks) {\n            throw new Error(`SendMessage request with id '${id}' not found`);\n        }\n        this._deleteMessageRequest(address, id);\n        return callbacks;\n    }\n    _deleteMessageRequest(address, id) {\n        const accountMessageRequests = this._sendMessageRequests.get(address);\n        if (!accountMessageRequests) {\n            return;\n        }\n        accountMessageRequests.delete(id);\n        if (accountMessageRequests.size == 0) {\n            this._sendMessageRequests.delete(address);\n        }\n    }\n}\nexports.SubscriptionController = SubscriptionController;\nconst makeDefaultSubscriptionState = () => ({\n    internal: new Map(),\n    client: {\n        state: false,\n        transactions: false,\n    },\n});\nconst isEmptySubscription = (params) => !params.state && !params.transactions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvU3Vic2NyaXB0aW9uQ29udHJvbGxlci9pbmRleC5qcz8zMjU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdWJzY3JpcHRpb25Db250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgYXdhaXRfc2VtYXBob3JlXzEgPSByZXF1aXJlKFwiQGJyb3h1cy9hd2FpdC1zZW1hcGhvcmVcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3Qgc3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKFwiLi9zdWJzY3JpcHRpb25cIik7XG5jb25zdCBERUZBVUxUX1BPTExJTkdfSU5URVJWQUwgPSAxMDAwMDsgLy8gMTBzXG5jbGFzcyBTdWJzY3JpcHRpb25Db250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uQ29udHJvbGxlciwgbm90aWZ5KSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNNdXRleCA9IG5ldyBhd2FpdF9zZW1hcGhvcmVfMS5NdXRleCgpO1xuICAgICAgICB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Db250cm9sbGVyID0gY29ubmVjdGlvbkNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuX25vdGlmeSA9IG5vdGlmeTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZE1lc3NhZ2VMb2NhbGx5KGFkZHJlc3MsIHNpZ25lZE1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uSWQgPSAoMCwgdXRpbHNfMS5nZXRVbmlxdWVJZCkoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3Vic2NyaWJlVG9Db250cmFjdChhZGRyZXNzLCB7IHN0YXRlOiB0cnVlIH0sIHN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnMuZ2V0KGFkZHJlc3MpO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc3Vic2NyaWJlIHRvIGNvbnRyYWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgc3Vic2NyaXB0aW9uLnVzZSgoY29udHJhY3QpID0+IGNvbnRyYWN0LnNlbmRNZXNzYWdlTG9jYWxseShzaWduZWRNZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbUNvbnRyYWN0KGFkZHJlc3MsIHN1YnNjcmlwdGlvbklkKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kTWVzc2FnZShhZGRyZXNzLCBzaWduZWRNZXNzYWdlKSB7XG4gICAgICAgIGxldCBtZXNzYWdlUmVxdWVzdHMgPSB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzLmdldChhZGRyZXNzKTtcbiAgICAgICAgaWYgKG1lc3NhZ2VSZXF1ZXN0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlUmVxdWVzdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzLnNldChhZGRyZXNzLCBtZXNzYWdlUmVxdWVzdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbklkID0gKDAsIHV0aWxzXzEuZ2V0VW5pcXVlSWQpKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHNpZ25lZE1lc3NhZ2UuaGFzaDtcbiAgICAgICAgICAgIG1lc3NhZ2VSZXF1ZXN0cy5zZXQoaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NvbnRyYWN0KGFkZHJlc3MsIHsgc3RhdGU6IHRydWUgfSwgc3Vic2NyaXB0aW9uSWQpXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnMuZ2V0KGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzdWJzY3JpYmUgdG8gY29udHJhY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgc3Vic2NyaXB0aW9uLnByZXBhcmVSZWxpYWJsZVBvbGxpbmcoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgLnVzZShhc3luYyAoY29udHJhY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY29udHJhY3Quc2VuZE1lc3NhZ2Uoc2lnbmVkTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5za2lwUmVmcmVzaFRpbWVyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4gdGhpcy5fcmVqZWN0TWVzc2FnZVJlcXVlc3QoYWRkcmVzcywgaWQsIGUpKVxuICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbUNvbnRyYWN0KGFkZHJlc3MsIHN1YnNjcmlwdGlvbklkKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc3Vic2NyaWJlVG9Db250cmFjdChhZGRyZXNzLCBwYXJhbXMsIGludGVybmFsSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbnNNdXRleC51c2UoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IG1lcmdlSW5wdXRQYXJhbXMgPSAoY3VycmVudFBhcmFtcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHsgLi4uY3VycmVudFBhcmFtcyB9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG5ld1BhcmFtcykubWFwKChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0gIT09ICdzdGF0ZScgJiYgcGFyYW0gIT09ICd0cmFuc2FjdGlvbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3Vic2NyaXB0aW9uIHRvcGljOiAke3BhcmFtfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zW3BhcmFtXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJhbXNbcGFyYW1dID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN1YnNjcmlwdGlvbiB0b3BpYyB2YWx1ZSAke3BhcmFtfTogJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdQYXJhbXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU3RhdGUgPSB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZXMuZ2V0KGFkZHJlc3MpIHx8IG1ha2VEZWZhdWx0U3Vic2NyaXB0aW9uU3RhdGUoKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkUGFyYW1zO1xuICAgICAgICAgICAgaWYgKGludGVybmFsSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIENsaWVudCBzdWJzY3JpcHRpb24gd2l0aG91dCBpZFxuICAgICAgICAgICAgICAgIC8vIENoYW5nZWQgcGFyYW1zIGFyZSBgU3Vic2NyaXB0aW9uU3RhdGUuY2xpZW50YFxuICAgICAgICAgICAgICAgIGNoYW5nZWRQYXJhbXMgPSBtZXJnZUlucHV0UGFyYW1zKHN1YnNjcmlwdGlvblN0YXRlLmNsaWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbnRlcm5hbCBzdWJzY3JpcHRpb24gd2l0aCBpZFxuICAgICAgICAgICAgICAgIC8vIENoYW5nZWQgcGFyYW1zIGFyZSBgU3Vic2NyaXB0aW9uU3RhdGUuaW50ZXJuYWxbaW50ZXJuYWxJZF1gXG4gICAgICAgICAgICAgICAgbGV0IGV4aXNpbmdQYXJhbXMgPSBzdWJzY3JpcHRpb25TdGF0ZS5pbnRlcm5hbC5nZXQoaW50ZXJuYWxJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXNpbmdQYXJhbXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGluZyBleGlzdGluZyBpbnRlcm5hbCBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZFBhcmFtcyA9IG1lcmdlSW5wdXRQYXJhbXMoZXhpc2luZ1BhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBlbnRyeSBpZiBpdCBpcyBlbXB0eVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eVN1YnNjcmlwdGlvbihjaGFuZ2VkUGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uU3RhdGUuaW50ZXJuYWwuZGVsZXRlKGludGVybmFsSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBNZXJnZSBpbnB1dCBwYXJhbXMgd2l0aCBlbXB0eSBzdHJ1Y3RcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZFBhcmFtcyA9IG1lcmdlSW5wdXRQYXJhbXMoeyBzdGF0ZTogZmFsc2UsIHRyYW5zYWN0aW9uczogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWVyZ2UgY2hhbmdlZCBwYXJhbXMgd2l0aCB0aGUgcmVzdCBvZiBpbnRlcm5hbCBwYXJhbXNcbiAgICAgICAgICAgIGxldCBjb21wdXRlZFBhcmFtcyA9IHsgLi4uY2hhbmdlZFBhcmFtcyB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJhbXMgb2Ygc3Vic2NyaXB0aW9uU3RhdGUuaW50ZXJuYWwudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlZFBhcmFtcy5zdGF0ZSB8fCAoY29tcHV0ZWRQYXJhbXMuc3RhdGUgPSBwYXJhbXMuc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkUGFyYW1zLnRyYW5zYWN0aW9ucyB8fCAoY29tcHV0ZWRQYXJhbXMudHJhbnNhY3Rpb25zID0gcGFyYW1zLnRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaXB0aW9uIGlmIGFsbCBwYXJhbXMgYXJlIGVtcHR5XG4gICAgICAgICAgICBpZiAoaXNFbXB0eVN1YnNjcmlwdGlvbihjb21wdXRlZFBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZXMuZGVsZXRlKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3RyeVVuc3Vic2NyaWJlKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLmNvbXB1dGVkUGFyYW1zIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgc3Vic2NyaXB0aW9uIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgIGxldCBleGlzdGluZ1N1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnMuZ2V0KGFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgaXNOZXdTdWJzY3JpcHRpb24gPSBleGlzdGluZ1N1YnNjcmlwdGlvbiA9PSBudWxsO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nU3Vic2NyaXB0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1N1YnNjcmlwdGlvbiA9IGF3YWl0IHRoaXMuX2NyZWF0ZVN1YnNjcmlwdGlvbihhZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzdWJzY3JpcHRpb24gc3RhdGVcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbElkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY2xpZW50IHBhcmFtc1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvblN0YXRlLmNsaWVudCA9IGNoYW5nZWRQYXJhbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgbmV3IGludGVybmFsIHBhcmFtc1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvblN0YXRlLmludGVybmFsLnNldChpbnRlcm5hbElkLCBjaGFuZ2VkUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlcy5zZXQoYWRkcmVzcywgc3Vic2NyaXB0aW9uU3RhdGUpO1xuICAgICAgICAgICAgLy8gU3RhcnQgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICBpZiAoaXNOZXdTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBleGlzdGluZ1N1YnNjcmlwdGlvbi5zdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0dXJucyBvbmx5IGNoYW5nZWQgcGFyYW1zXG4gICAgICAgICAgICByZXR1cm4geyAuLi5jaGFuZ2VkUGFyYW1zIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB1bnN1YnNjcmliZUZyb21Db250cmFjdChhZGRyZXNzLCBpbnRlcm5hbElkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3Vic2NyaWJlVG9Db250cmFjdChhZGRyZXNzLCB7XG4gICAgICAgICAgICBzdGF0ZTogZmFsc2UsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbnM6IGZhbHNlLFxuICAgICAgICB9LCBpbnRlcm5hbElkKTtcbiAgICB9XG4gICAgYXN5bmMgdW5zdWJzY3JpYmVGcm9tQWxsQ29udHJhY3RzKGludGVybmFsSWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIHRoaXMuX3N1YnNjcmlwdGlvbnMua2V5cygpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnVuc3Vic2NyaWJlRnJvbUNvbnRyYWN0KGFkZHJlc3MsIGludGVybmFsSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzdWJzY3JpcHRpb25TdGF0ZXMoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHsgLi4udmFsdWUuY2xpZW50IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgX2NyZWF0ZVN1YnNjcmlwdGlvbihhZGRyZXNzKSB7XG4gICAgICAgIGNsYXNzIENvbnRyYWN0SGFuZGxlciB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5hYmxlZE5vdGlmaWNhdGlvbnMoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbk1lc3NhZ2VFeHBpcmVkKHBlbmRpbmdUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5fcmVzb2x2ZU1lc3NhZ2VSZXF1ZXN0KHRoaXMuX2FkZHJlc3MsIHBlbmRpbmdUcmFuc2FjdGlvbi5tZXNzYWdlSGFzaCwgdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uTWVzc2FnZVNlbnQocGVuZGluZ1RyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5fcmVzb2x2ZU1lc3NhZ2VSZXF1ZXN0KHRoaXMuX2FkZHJlc3MsIHBlbmRpbmdUcmFuc2FjdGlvbi5tZXNzYWdlSGFzaCwgdHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25TdGF0ZUNoYW5nZWQobmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250cm9sbGVyLl9ub3RpZnlTdGF0ZUNoYW5nZWQodGhpcy5fYWRkcmVzcywgbmV3U3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uVHJhbnNhY3Rpb25zRm91bmQodHJhbnNhY3Rpb25zLCBpbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udHJvbGxlci5fbm90aWZ5VHJhbnNhY3Rpb25zRm91bmQodGhpcy5fYWRkcmVzcywgdHJhbnNhY3Rpb25zLCBpbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlciA9IG5ldyBDb250cmFjdEhhbmRsZXIoYWRkcmVzcywgdGhpcyk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IHN1YnNjcmlwdGlvbl8xLkNvbnRyYWN0U3Vic2NyaXB0aW9uLnN1YnNjcmliZSh0aGlzLl9jb25uZWN0aW9uQ29udHJvbGxlciwgYWRkcmVzcywgaGFuZGxlcik7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5zZXRQb2xsaW5nSW50ZXJ2YWwoREVGQVVMVF9QT0xMSU5HX0lOVEVSVkFMKTtcbiAgICAgICAgaGFuZGxlci5lbmFibGVkTm90aWZpY2F0aW9ucygpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnNldChhZGRyZXNzLCBzdWJzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH1cbiAgICBhc3luYyBfdHJ5VW5zdWJzY3JpYmUoYWRkcmVzcykge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25TdGF0ZSA9IHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlcy5nZXQoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IHNlbmRNZXNzYWdlUmVxdWVzdHMgPSB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzLmdldChhZGRyZXNzKTtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvblN0YXRlID09IG51bGwgJiYgKChzZW5kTWVzc2FnZVJlcXVlc3RzID09PSBudWxsIHx8IHNlbmRNZXNzYWdlUmVxdWVzdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbmRNZXNzYWdlUmVxdWVzdHMuc2l6ZSkgfHwgMCkgPT0gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5fc3Vic2NyaXB0aW9ucy5nZXQoYWRkcmVzcyk7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmRlbGV0ZShhZGRyZXNzKTtcbiAgICAgICAgICAgIGF3YWl0IChzdWJzY3JpcHRpb24gPT09IG51bGwgfHwgc3Vic2NyaXB0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdWJzY3JpcHRpb24uc3RvcCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfcmVqZWN0TWVzc2FnZVJlcXVlc3QoYWRkcmVzcywgaWQsIGVycm9yKSB7XG4gICAgICAgIHRoaXMuX2RlbGV0ZU1lc3NhZ2VSZXF1ZXN0QW5kR2V0Q2FsbGJhY2soYWRkcmVzcywgaWQpLnJlamVjdChlcnJvcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3N1YnNjcmlwdGlvbnNNdXRleC51c2UoYXN5bmMgKCkgPT4gdGhpcy5fdHJ5VW5zdWJzY3JpYmUoYWRkcmVzcykpO1xuICAgIH1cbiAgICBhc3luYyBfcmVzb2x2ZU1lc3NhZ2VSZXF1ZXN0KGFkZHJlc3MsIGlkLCB0cmFuc2FjdGlvbikge1xuICAgICAgICB0aGlzLl9kZWxldGVNZXNzYWdlUmVxdWVzdEFuZEdldENhbGxiYWNrKGFkZHJlc3MsIGlkKS5yZXNvbHZlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3Vic2NyaXB0aW9uc011dGV4LnVzZShhc3luYyAoKSA9PiB0aGlzLl90cnlVbnN1YnNjcmliZShhZGRyZXNzKSk7XG4gICAgfVxuICAgIF9ub3RpZnlTdGF0ZUNoYW5nZWQoYWRkcmVzcywgc3RhdGUpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU3RhdGUgPSB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZXMuZ2V0KGFkZHJlc3MpO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uU3RhdGUgPT09IG51bGwgfHwgc3Vic2NyaXB0aW9uU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1YnNjcmlwdGlvblN0YXRlLmNsaWVudC5zdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fbm90aWZ5KCdjb250cmFjdFN0YXRlQ2hhbmdlZCcsIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX25vdGlmeVRyYW5zYWN0aW9uc0ZvdW5kKGFkZHJlc3MsIHRyYW5zYWN0aW9ucywgaW5mbykge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25TdGF0ZSA9IHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlcy5nZXQoYWRkcmVzcyk7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25TdGF0ZSA9PT0gbnVsbCB8fCBzdWJzY3JpcHRpb25TdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Vic2NyaXB0aW9uU3RhdGUuY2xpZW50LnRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fbm90aWZ5KCd0cmFuc2FjdGlvbnNGb3VuZCcsIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgICAgICAgICAgICBpbmZvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2RlbGV0ZU1lc3NhZ2VSZXF1ZXN0QW5kR2V0Q2FsbGJhY2soYWRkcmVzcywgaWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAoX2EgPSB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzLmdldChhZGRyZXNzKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChpZCk7XG4gICAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlbmRNZXNzYWdlIHJlcXVlc3Qgd2l0aCBpZCAnJHtpZH0nIG5vdCBmb3VuZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlbGV0ZU1lc3NhZ2VSZXF1ZXN0KGFkZHJlc3MsIGlkKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrcztcbiAgICB9XG4gICAgX2RlbGV0ZU1lc3NhZ2VSZXF1ZXN0KGFkZHJlc3MsIGlkKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnRNZXNzYWdlUmVxdWVzdHMgPSB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzLmdldChhZGRyZXNzKTtcbiAgICAgICAgaWYgKCFhY2NvdW50TWVzc2FnZVJlcXVlc3RzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWNjb3VudE1lc3NhZ2VSZXF1ZXN0cy5kZWxldGUoaWQpO1xuICAgICAgICBpZiAoYWNjb3VudE1lc3NhZ2VSZXF1ZXN0cy5zaXplID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRNZXNzYWdlUmVxdWVzdHMuZGVsZXRlKGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TdWJzY3JpcHRpb25Db250cm9sbGVyID0gU3Vic2NyaXB0aW9uQ29udHJvbGxlcjtcbmNvbnN0IG1ha2VEZWZhdWx0U3Vic2NyaXB0aW9uU3RhdGUgPSAoKSA9PiAoe1xuICAgIGludGVybmFsOiBuZXcgTWFwKCksXG4gICAgY2xpZW50OiB7XG4gICAgICAgIHN0YXRlOiBmYWxzZSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBmYWxzZSxcbiAgICB9LFxufSk7XG5jb25zdCBpc0VtcHR5U3Vic2NyaXB0aW9uID0gKHBhcmFtcykgPT4gIXBhcmFtcy5zdGF0ZSAmJiAhcGFyYW1zLnRyYW5zYWN0aW9ucztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///536\n")},334:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContractSubscription = void 0;\nconst await_semaphore_1 = __webpack_require__(68);\nconst core_1 = __importDefault(__webpack_require__(521));\nconst { nekoton, debugLog } = core_1.default;\nclass ContractSubscription {\n    constructor(connection, release, address, contract) {\n        this._contractMutex = new await_semaphore_1.Mutex();\n        this._pollingInterval = BACKGROUND_POLLING_INTERVAL;\n        this._isRunning = false;\n        this._connection = connection;\n        this._address = address;\n        this._contract = contract;\n        this._releaseTransport = release;\n        this._currentPollingMethod = contract.pollingMethod;\n    }\n    static async subscribe(connectionController, address, handler) {\n        const { transport: { data: { connection, transport } }, release, } = await connectionController.acquire();\n        try {\n            const contract = await transport.subscribeToGenericContract(address, handler);\n            if (contract == null) {\n                throw new Error(`Failed to subscribe to contract: ${address}`);\n            }\n            return new ContractSubscription(connection, release, address, contract);\n        }\n        catch (e) {\n            release();\n            throw e;\n        }\n    }\n    setPollingInterval(interval) {\n        this._pollingInterval = interval;\n    }\n    async start() {\n        if (this._releaseTransport == null) {\n            throw new Error('Contract subscription must not be started after being closed');\n        }\n        if (this._loopPromise) {\n            debugLog('ContractSubscription -> awaiting loop promise');\n            await this._loopPromise;\n        }\n        debugLog('ContractSubscription -> loop started');\n        this._loopPromise = (async () => {\n            const isSimple = !(this._connection instanceof nekoton.GqlConnection);\n            this._isRunning = true;\n            let previousPollingMethod = this._currentPollingMethod;\n            while (this._isRunning) {\n                const pollingMethodChanged = previousPollingMethod != this._currentPollingMethod;\n                previousPollingMethod = this._currentPollingMethod;\n                if (isSimple || this._currentPollingMethod == 'manual') {\n                    this._currentBlockId = undefined;\n                    debugLog('ContractSubscription -> manual -> waiting begins');\n                    const pollingInterval = this._currentPollingMethod == 'manual'\n                        ? this._pollingInterval\n                        : INTENSIVE_POLLING_INTERVAL;\n                    await new Promise((resolve) => {\n                        const timerHandle = setTimeout(() => {\n                            this._refreshTimer = undefined;\n                            resolve();\n                        }, pollingInterval);\n                        this._refreshTimer = [timerHandle, resolve];\n                    });\n                    debugLog('ContractSubscription -> manual -> waiting ends');\n                    if (!this._isRunning) {\n                        break;\n                    }\n                    debugLog('ContractSubscription -> manual -> refreshing begins');\n                    try {\n                        this._currentPollingMethod = await this._contractMutex.use(async () => {\n                            await this._contract.refresh();\n                            return this._contract.pollingMethod;\n                        });\n                    }\n                    catch (e) {\n                        console.error(`Error during account refresh (${this._address})`, e);\n                    }\n                    debugLog('ContractSubscription -> manual -> refreshing ends');\n                }\n                else {\n                    // SAFETY: connection is always GqlConnection here due to `isSimple`\n                    const connection = this._connection;\n                    debugLog('ContractSubscription -> reliable start');\n                    if (pollingMethodChanged && this._suggestedBlockId != null) {\n                        this._currentBlockId = this._suggestedBlockId;\n                    }\n                    this._suggestedBlockId = undefined;\n                    let nextBlockId;\n                    if (this._currentBlockId == null) {\n                        console.warn('Starting reliable connection with unknown block');\n                        try {\n                            const latestBlock = await connection.getLatestBlock(this._address);\n                            this._currentBlockId = latestBlock.id;\n                            nextBlockId = this._currentBlockId;\n                        }\n                        catch (e) {\n                            console.error(`Failed to get latest block for ${this._address}`, e);\n                            continue;\n                        }\n                    }\n                    else {\n                        try {\n                            nextBlockId = await connection.waitForNextBlock(this._currentBlockId, this._address, NEXT_BLOCK_TIMEOUT);\n                        }\n                        catch (e) {\n                            console.error(`Failed to wait for next block for ${this._address}`);\n                            continue; // retry\n                        }\n                    }\n                    try {\n                        this._currentPollingMethod = await this._contractMutex.use(async () => {\n                            await this._contract.handleBlock(nextBlockId);\n                            return this._contract.pollingMethod;\n                        });\n                        this._currentBlockId = nextBlockId;\n                    }\n                    catch (e) {\n                        console.error(`Failed to handle block for ${this._address}`, e);\n                    }\n                }\n            }\n            debugLog('ContractSubscription -> loop finished');\n        })();\n    }\n    skipRefreshTimer() {\n        var _a, _b;\n        clearTimeout((_a = this._refreshTimer) === null || _a === void 0 ? void 0 : _a[0]);\n        (_b = this._refreshTimer) === null || _b === void 0 ? void 0 : _b[1]();\n        this._refreshTimer = undefined;\n    }\n    async pause() {\n        if (!this._isRunning) {\n            return;\n        }\n        this._isRunning = false;\n        this.skipRefreshTimer();\n        await this._loopPromise;\n        this._loopPromise = undefined;\n        this._currentPollingMethod = await this._contractMutex.use(async () => {\n            return this._contract.pollingMethod;\n        });\n        this._currentBlockId = undefined;\n        this._suggestedBlockId = undefined;\n    }\n    async stop() {\n        var _a;\n        await this.pause();\n        this._contract.free();\n        (_a = this._releaseTransport) === null || _a === void 0 ? void 0 : _a.call(this);\n        this._releaseTransport = undefined;\n    }\n    async prepareReliablePolling() {\n        try {\n            if (this._connection instanceof nekoton.GqlConnection) {\n                this._suggestedBlockId = (await this._connection.getLatestBlock(this._address)).id;\n            }\n        }\n        catch (e) {\n            throw new Error(`Failed to prepare reliable polling: ${e.toString()}`);\n        }\n    }\n    async use(f) {\n        const release = await this._contractMutex.acquire();\n        return f(this._contract)\n            .then((res) => {\n            release();\n            return res;\n        })\n            .catch((err) => {\n            release();\n            throw err;\n        });\n    }\n}\nexports.ContractSubscription = ContractSubscription;\nconst NEXT_BLOCK_TIMEOUT = 60; // 60s\nconst INTENSIVE_POLLING_INTERVAL = 2000; // 2s\nconst BACKGROUND_POLLING_INTERVAL = 60000;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvU3Vic2NyaXB0aW9uQ29udHJvbGxlci9zdWJzY3JpcHRpb24uanM/ZDc5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udHJhY3RTdWJzY3JpcHRpb24gPSB2b2lkIDA7XG5jb25zdCBhd2FpdF9zZW1hcGhvcmVfMSA9IHJlcXVpcmUoXCJAYnJveHVzL2F3YWl0LXNlbWFwaG9yZVwiKTtcbmNvbnN0IGNvcmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vY29yZVwiKSk7XG5jb25zdCB7IG5la290b24sIGRlYnVnTG9nIH0gPSBjb3JlXzEuZGVmYXVsdDtcbmNsYXNzIENvbnRyYWN0U3Vic2NyaXB0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCByZWxlYXNlLCBhZGRyZXNzLCBjb250cmFjdCkge1xuICAgICAgICB0aGlzLl9jb250cmFjdE11dGV4ID0gbmV3IGF3YWl0X3NlbWFwaG9yZV8xLk11dGV4KCk7XG4gICAgICAgIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCA9IEJBQ0tHUk9VTkRfUE9MTElOR19JTlRFUlZBTDtcbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICB0aGlzLl9hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5fY29udHJhY3QgPSBjb250cmFjdDtcbiAgICAgICAgdGhpcy5fcmVsZWFzZVRyYW5zcG9ydCA9IHJlbGVhc2U7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRQb2xsaW5nTWV0aG9kID0gY29udHJhY3QucG9sbGluZ01ldGhvZDtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIHN1YnNjcmliZShjb25uZWN0aW9uQ29udHJvbGxlciwgYWRkcmVzcywgaGFuZGxlcikge1xuICAgICAgICBjb25zdCB7IHRyYW5zcG9ydDogeyBkYXRhOiB7IGNvbm5lY3Rpb24sIHRyYW5zcG9ydCB9IH0sIHJlbGVhc2UsIH0gPSBhd2FpdCBjb25uZWN0aW9uQ29udHJvbGxlci5hY3F1aXJlKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IHRyYW5zcG9ydC5zdWJzY3JpYmVUb0dlbmVyaWNDb250cmFjdChhZGRyZXNzLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIGlmIChjb250cmFjdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3Vic2NyaWJlIHRvIGNvbnRyYWN0OiAke2FkZHJlc3N9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0U3Vic2NyaXB0aW9uKGNvbm5lY3Rpb24sIHJlbGVhc2UsIGFkZHJlc3MsIGNvbnRyYWN0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQb2xsaW5nSW50ZXJ2YWwoaW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5fcG9sbGluZ0ludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5fcmVsZWFzZVRyYW5zcG9ydCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyYWN0IHN1YnNjcmlwdGlvbiBtdXN0IG5vdCBiZSBzdGFydGVkIGFmdGVyIGJlaW5nIGNsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9sb29wUHJvbWlzZSkge1xuICAgICAgICAgICAgZGVidWdMb2coJ0NvbnRyYWN0U3Vic2NyaXB0aW9uIC0+IGF3YWl0aW5nIGxvb3AgcHJvbWlzZScpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbG9vcFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWdMb2coJ0NvbnRyYWN0U3Vic2NyaXB0aW9uIC0+IGxvb3Agc3RhcnRlZCcpO1xuICAgICAgICB0aGlzLl9sb29wUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1NpbXBsZSA9ICEodGhpcy5fY29ubmVjdGlvbiBpbnN0YW5jZW9mIG5la290b24uR3FsQ29ubmVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzUG9sbGluZ01ldGhvZCA9IHRoaXMuX2N1cnJlbnRQb2xsaW5nTWV0aG9kO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvbGxpbmdNZXRob2RDaGFuZ2VkID0gcHJldmlvdXNQb2xsaW5nTWV0aG9kICE9IHRoaXMuX2N1cnJlbnRQb2xsaW5nTWV0aG9kO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9sbGluZ01ldGhvZCA9IHRoaXMuX2N1cnJlbnRQb2xsaW5nTWV0aG9kO1xuICAgICAgICAgICAgICAgIGlmIChpc1NpbXBsZSB8fCB0aGlzLl9jdXJyZW50UG9sbGluZ01ldGhvZCA9PSAnbWFudWFsJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50QmxvY2tJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdMb2coJ0NvbnRyYWN0U3Vic2NyaXB0aW9uIC0+IG1hbnVhbCAtPiB3YWl0aW5nIGJlZ2lucycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2xsaW5nSW50ZXJ2YWwgPSB0aGlzLl9jdXJyZW50UG9sbGluZ01ldGhvZCA9PSAnbWFudWFsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9wb2xsaW5nSW50ZXJ2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogSU5URU5TSVZFX1BPTExJTkdfSU5URVJWQUw7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lckhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBwb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVmcmVzaFRpbWVyID0gW3RpbWVySGFuZGxlLCByZXNvbHZlXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nKCdDb250cmFjdFN1YnNjcmlwdGlvbiAtPiBtYW51YWwgLT4gd2FpdGluZyBlbmRzJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZygnQ29udHJhY3RTdWJzY3JpcHRpb24gLT4gbWFudWFsIC0+IHJlZnJlc2hpbmcgYmVnaW5zJyk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50UG9sbGluZ01ldGhvZCA9IGF3YWl0IHRoaXMuX2NvbnRyYWN0TXV0ZXgudXNlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9jb250cmFjdC5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyYWN0LnBvbGxpbmdNZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZHVyaW5nIGFjY291bnQgcmVmcmVzaCAoJHt0aGlzLl9hZGRyZXNzfSlgLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZygnQ29udHJhY3RTdWJzY3JpcHRpb24gLT4gbWFudWFsIC0+IHJlZnJlc2hpbmcgZW5kcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBjb25uZWN0aW9uIGlzIGFsd2F5cyBHcWxDb25uZWN0aW9uIGhlcmUgZHVlIHRvIGBpc1NpbXBsZWBcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nKCdDb250cmFjdFN1YnNjcmlwdGlvbiAtPiByZWxpYWJsZSBzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9sbGluZ01ldGhvZENoYW5nZWQgJiYgdGhpcy5fc3VnZ2VzdGVkQmxvY2tJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50QmxvY2tJZCA9IHRoaXMuX3N1Z2dlc3RlZEJsb2NrSWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3VnZ2VzdGVkQmxvY2tJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRCbG9ja0lkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEJsb2NrSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdTdGFydGluZyByZWxpYWJsZSBjb25uZWN0aW9uIHdpdGggdW5rbm93biBibG9jaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXRlc3RCbG9jayA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2sodGhpcy5fYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEJsb2NrSWQgPSBsYXRlc3RCbG9jay5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0QmxvY2tJZCA9IHRoaXMuX2N1cnJlbnRCbG9ja0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZ2V0IGxhdGVzdCBibG9jayBmb3IgJHt0aGlzLl9hZGRyZXNzfWAsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0QmxvY2tJZCA9IGF3YWl0IGNvbm5lY3Rpb24ud2FpdEZvck5leHRCbG9jayh0aGlzLl9jdXJyZW50QmxvY2tJZCwgdGhpcy5fYWRkcmVzcywgTkVYVF9CTE9DS19USU1FT1VUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHdhaXQgZm9yIG5leHQgYmxvY2sgZm9yICR7dGhpcy5fYWRkcmVzc31gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFBvbGxpbmdNZXRob2QgPSBhd2FpdCB0aGlzLl9jb250cmFjdE11dGV4LnVzZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fY29udHJhY3QuaGFuZGxlQmxvY2sobmV4dEJsb2NrSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250cmFjdC5wb2xsaW5nTWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50QmxvY2tJZCA9IG5leHRCbG9ja0lkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gaGFuZGxlIGJsb2NrIGZvciAke3RoaXMuX2FkZHJlc3N9YCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1Z0xvZygnQ29udHJhY3RTdWJzY3JpcHRpb24gLT4gbG9vcCBmaW5pc2hlZCcpO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBza2lwUmVmcmVzaFRpbWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjbGVhclRpbWVvdXQoKF9hID0gdGhpcy5fcmVmcmVzaFRpbWVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pO1xuICAgICAgICAoX2IgPSB0aGlzLl9yZWZyZXNoVGltZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsxXSgpO1xuICAgICAgICB0aGlzLl9yZWZyZXNoVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFzeW5jIHBhdXNlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzUnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNraXBSZWZyZXNoVGltZXIoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fbG9vcFByb21pc2U7XG4gICAgICAgIHRoaXMuX2xvb3BQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jdXJyZW50UG9sbGluZ01ldGhvZCA9IGF3YWl0IHRoaXMuX2NvbnRyYWN0TXV0ZXgudXNlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250cmFjdC5wb2xsaW5nTWV0aG9kO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY3VycmVudEJsb2NrSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3N1Z2dlc3RlZEJsb2NrSWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFzeW5jIHN0b3AoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYXdhaXQgdGhpcy5wYXVzZSgpO1xuICAgICAgICB0aGlzLl9jb250cmFjdC5mcmVlKCk7XG4gICAgICAgIChfYSA9IHRoaXMuX3JlbGVhc2VUcmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZWxlYXNlVHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyBwcmVwYXJlUmVsaWFibGVQb2xsaW5nKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb24gaW5zdGFuY2VvZiBuZWtvdG9uLkdxbENvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWdnZXN0ZWRCbG9ja0lkID0gKGF3YWl0IHRoaXMuX2Nvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2sodGhpcy5fYWRkcmVzcykpLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwcmVwYXJlIHJlbGlhYmxlIHBvbGxpbmc6ICR7ZS50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHVzZShmKSB7XG4gICAgICAgIGNvbnN0IHJlbGVhc2UgPSBhd2FpdCB0aGlzLl9jb250cmFjdE11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgcmV0dXJuIGYodGhpcy5fY29udHJhY3QpXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db250cmFjdFN1YnNjcmlwdGlvbiA9IENvbnRyYWN0U3Vic2NyaXB0aW9uO1xuY29uc3QgTkVYVF9CTE9DS19USU1FT1VUID0gNjA7IC8vIDYwc1xuY29uc3QgSU5URU5TSVZFX1BPTExJTkdfSU5URVJWQUwgPSAyMDAwOyAvLyAyc1xuY29uc3QgQkFDS0dST1VORF9QT0xMSU5HX0lOVEVSVkFMID0gNjAwMDA7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///334\n")},241:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Clock = void 0;\n/**\n * Wrapper around clocks which are used in `EverscaleStandaloneClient` instances\n *\n * @category Client\n */\nclass Clock {\n    constructor(offset) {\n        this.impls = [];\n        this.currentOffset = 0;\n        if (offset != null) {\n            this.currentOffset = offset;\n        }\n    }\n    /**\n     * Clock offset in milliseconds\n     */\n    get offset() {\n        return this.currentOffset;\n    }\n    /**\n     * Set clock offset in milliseconds\n     */\n    set offset(value) {\n        this.currentOffset = value;\n        for (const impl of this.impls) {\n            impl.updateOffset(this.currentOffset);\n        }\n    }\n    /**\n     * Returns current time in milliseconds\n     */\n    get time() {\n        return new Date().getTime() + this.offset;\n    }\n    /**\n     * Detaches all affected providers\n     *\n     * NOTE: affected providers offset remains the same\n     */\n    detach() {\n        this.impls = [];\n    }\n}\nexports.Clock = Clock;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvY2xvY2suanM/MzZhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xvY2sgPSB2b2lkIDA7XG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIGNsb2NrcyB3aGljaCBhcmUgdXNlZCBpbiBgRXZlcnNjYWxlU3RhbmRhbG9uZUNsaWVudGAgaW5zdGFuY2VzXG4gKlxuICogQGNhdGVnb3J5IENsaWVudFxuICovXG5jbGFzcyBDbG9jayB7XG4gICAgY29uc3RydWN0b3Iob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuaW1wbHMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKG9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvY2sgb2Zmc2V0IGluIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIGdldCBvZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBjbG9jayBvZmZzZXQgaW4gbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgc2V0IG9mZnNldCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRPZmZzZXQgPSB2YWx1ZTtcbiAgICAgICAgZm9yIChjb25zdCBpbXBsIG9mIHRoaXMuaW1wbHMpIHtcbiAgICAgICAgICAgIGltcGwudXBkYXRlT2Zmc2V0KHRoaXMuY3VycmVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJyZW50IHRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgZ2V0IHRpbWUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHRoaXMub2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRhY2hlcyBhbGwgYWZmZWN0ZWQgcHJvdmlkZXJzXG4gICAgICpcbiAgICAgKiBOT1RFOiBhZmZlY3RlZCBwcm92aWRlcnMgb2Zmc2V0IHJlbWFpbnMgdGhlIHNhbWVcbiAgICAgKi9cbiAgICBkZXRhY2goKSB7XG4gICAgICAgIHRoaXMuaW1wbHMgPSBbXTtcbiAgICB9XG59XG5leHBvcnRzLkNsb2NrID0gQ2xvY2s7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///241\n')},637:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EverscaleStandaloneClient = exports.SUPPORTED_PERMISSIONS = exports.VERSION = exports.DEFAULT_CLIENT_PROPERTIES = exports.Clock = exports.SimpleKeystore = exports.checkConnection = exports.ConnectionError = exports.NETWORK_PRESETS = void 0;\nconst fast_safe_stringify_1 = __importDefault(__webpack_require__(445));\nconst core_1 = __importDefault(__webpack_require__(521));\nconst utils_1 = __webpack_require__(344);\nconst ConnectionController_1 = __webpack_require__(863);\nconst SubscriptionController_1 = __webpack_require__(536);\nconst AccountsStorage_1 = __webpack_require__(487);\nvar ConnectionController_2 = __webpack_require__(863);\nObject.defineProperty(exports, \"NETWORK_PRESETS\", ({ enumerable: true, get: function () { return ConnectionController_2.NETWORK_PRESETS; } }));\nvar ConnectionController_3 = __webpack_require__(863);\nObject.defineProperty(exports, \"ConnectionError\", ({ enumerable: true, get: function () { return ConnectionController_3.ConnectionError; } }));\nObject.defineProperty(exports, \"checkConnection\", ({ enumerable: true, get: function () { return ConnectionController_3.checkConnection; } }));\n__exportStar(__webpack_require__(487), exports);\nvar keystore_1 = __webpack_require__(837);\nObject.defineProperty(exports, \"SimpleKeystore\", ({ enumerable: true, get: function () { return keystore_1.SimpleKeystore; } }));\nvar clock_1 = __webpack_require__(241);\nObject.defineProperty(exports, \"Clock\", ({ enumerable: true, get: function () { return clock_1.Clock; } }));\nconst { ensureNekotonLoaded, nekoton } = core_1.default;\nfunction validateMessageProperties(message) {\n    const m = message || {};\n    return {\n        retryCount: m.retryCount != null ? Math.max(1, ~~m.retryCount) : 5,\n        timeout: m.timeout != null ? Math.max(1, ~~m.timeout) : 60,\n        timeoutGrowFactor: m.timeoutGrowFactor || 1.2,\n        retryTransfers: true,\n    };\n}\n/**\n * @category Client\n */\nexports.DEFAULT_CLIENT_PROPERTIES = {\n    connection: ConnectionController_1.DEFAULT_NETWORK_GROUP,\n};\n/**\n * @category Client\n */\nexports.VERSION = '0.2.25';\n/**\n * @category Client\n */\nexports.SUPPORTED_PERMISSIONS = ['basic', 'accountInteraction'];\n/**\n * @category Client\n */\nclass EverscaleStandaloneClient extends utils_1.SafeEventEmitter {\n    constructor(ctx) {\n        super();\n        this._handlers = {\n            requestPermissions,\n            changeAccount,\n            disconnect,\n            subscribe,\n            unsubscribe,\n            unsubscribeAll,\n            getProviderState,\n            getFullContractState,\n            getAccountsByCodeHash,\n            getTransactions,\n            getTransaction,\n            findTransaction,\n            runLocal,\n            getExpectedAddress,\n            getBocHash,\n            packIntoCell,\n            unpackFromCell,\n            extractPublicKey,\n            codeToTvc,\n            mergeTvc,\n            splitTvc,\n            setCodeSalt,\n            getCodeSalt,\n            encodeInternalInput,\n            decodeInput,\n            decodeOutput,\n            decodeEvent,\n            decodeTransaction,\n            decodeTransactionEvents,\n            verifySignature,\n            sendUnsignedExternalMessage,\n            // addAsset, // not supported\n            signData,\n            signDataRaw,\n            // encryptData, // not supported\n            // decryptData, // not supported\n            // estimateFees, // not supported\n            sendMessage,\n            sendMessageDelayed,\n            sendExternalMessage,\n            sendExternalMessageDelayed,\n        };\n        this._context = ctx;\n    }\n    static async create(params) {\n        await ensureNekotonLoaded(params.initInput);\n        // NOTE: capture client inside notify using wrapper object\n        const notificationContext = {};\n        const notify = (method, params) => {\n            var _a;\n            (_a = notificationContext.client) === null || _a === void 0 ? void 0 : _a.emit(method, params);\n        };\n        const clock = new core_1.default.nekoton.ClockWithOffset();\n        if (params.clock != null) {\n            params.clock['impls'].push(clock);\n            clock.updateOffset(params.clock.offset);\n        }\n        try {\n            const connectionController = await (0, ConnectionController_1.createConnectionController)(clock, params.connection);\n            const subscriptionController = new SubscriptionController_1.SubscriptionController(connectionController, notify);\n            const client = new EverscaleStandaloneClient({\n                permissions: {},\n                connectionController,\n                subscriptionController,\n                properties: {\n                    message: validateMessageProperties(params.message),\n                },\n                keystore: params.keystore,\n                accountsStorage: params.accountsStorage,\n                clock,\n                notify,\n            });\n            // NOTE: WeakRef is not working here, so hope it will be garbage collected\n            notificationContext.client = client;\n            return client;\n        }\n        catch (e) {\n            if (params.clock != null) {\n                params.clock['impls'].pop();\n            }\n            clock.free();\n            throw e;\n        }\n    }\n    request(req) {\n        const handler = this._handlers[req.method];\n        if (handler == null) {\n            throw invalidRequest(req, `Method '${req.method}' is not supported by standalone provider`);\n        }\n        return handler(this._context, req);\n    }\n    addListener(eventName, listener) {\n        return super.addListener(eventName, listener);\n    }\n    removeListener(eventName, listener) {\n        return super.removeListener(eventName, listener);\n    }\n    on(eventName, listener) {\n        return super.on(eventName, listener);\n    }\n    once(eventName, listener) {\n        return super.once(eventName, listener);\n    }\n    prependListener(eventName, listener) {\n        return super.prependListener(eventName, listener);\n    }\n    prependOnceListener(eventName, listener) {\n        return super.prependOnceListener(eventName, listener);\n    }\n}\nexports.EverscaleStandaloneClient = EverscaleStandaloneClient;\nconst requestPermissions = async (ctx, req) => {\n    requireParams(req);\n    const { permissions } = req.params;\n    requireArray(req, req.params, 'permissions');\n    const newPermissions = { ...ctx.permissions };\n    for (const permission of permissions) {\n        if (permission === 'basic' || permission === 'tonClient') {\n            newPermissions.basic = true;\n        }\n        else if (permission === 'accountInteraction') {\n            if (newPermissions.accountInteraction != null) {\n                continue;\n            }\n            newPermissions.accountInteraction = await makeAccountInteractionPermission(req, ctx);\n        }\n        else {\n            throw invalidRequest(req, `Permission '${permission}' is not supported by standalone provider`);\n        }\n    }\n    ctx.permissions = newPermissions;\n    // NOTE: be sure to return object copy to prevent adding new permissions\n    const permissionsCopy = JSON.parse(JSON.stringify(newPermissions));\n    ctx.notify('permissionsChanged', {\n        permissions: permissionsCopy,\n    });\n    return permissionsCopy;\n};\nconst changeAccount = async (ctx, req) => {\n    requireAccountsStorage(req, ctx);\n    const newPermissions = { ...ctx.permissions };\n    newPermissions.accountInteraction = await makeAccountInteractionPermission(req, ctx);\n    ctx.permissions = newPermissions;\n    // NOTE: be sure to return object copy to prevent adding new permissions\n    const permissionsCopy = JSON.parse(JSON.stringify(newPermissions));\n    ctx.notify('permissionsChanged', {\n        permissions: permissionsCopy,\n    });\n    return permissionsCopy;\n};\nconst disconnect = async (ctx, _req) => {\n    ctx.permissions = {};\n    await ctx.subscriptionController.unsubscribeFromAllContracts();\n    ctx.notify('permissionsChanged', { permissions: {} });\n    return undefined;\n};\nconst subscribe = async (ctx, req) => {\n    requireParams(req);\n    const { address, subscriptions } = req.params;\n    requireString(req, req.params, 'address');\n    requireOptionalObject(req, req.params, 'subscriptions');\n    let repackedAddress;\n    try {\n        repackedAddress = nekoton.repackAddress(address);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    try {\n        return await ctx.subscriptionController.subscribeToContract(repackedAddress, subscriptions);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst unsubscribe = async (ctx, req) => {\n    requireParams(req);\n    const { address } = req.params;\n    requireString(req, req.params, 'address');\n    let repackedAddress;\n    try {\n        repackedAddress = nekoton.repackAddress(address);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    await ctx.subscriptionController.unsubscribeFromContract(repackedAddress);\n    return undefined;\n};\nconst unsubscribeAll = async (ctx, _req) => {\n    await ctx.subscriptionController.unsubscribeFromAllContracts();\n    return undefined;\n};\nconst getProviderState = async (ctx, req) => {\n    const transport = ctx.connectionController.initializedTransport;\n    if (transport == null) {\n        throw invalidRequest(req, 'Connection controller was not initialized');\n    }\n    const version = exports.VERSION;\n    return {\n        version,\n        numericVersion: (0, utils_1.convertVersionToInt32)(version),\n        networkId: transport.id,\n        selectedConnection: transport.group,\n        supportedPermissions: [...exports.SUPPORTED_PERMISSIONS],\n        permissions: JSON.parse(JSON.stringify(ctx.permissions)),\n        subscriptions: ctx.subscriptionController.subscriptionStates,\n    };\n};\nconst getFullContractState = async (ctx, req) => {\n    requireParams(req);\n    const { address } = req.params;\n    requireString(req, req.params, 'address');\n    const { connectionController } = ctx;\n    try {\n        return connectionController.use(async ({ data: { transport } }) => ({\n            state: await transport.getFullContractState(address),\n        }));\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getAccountsByCodeHash = async (ctx, req) => {\n    requireParams(req);\n    const { codeHash, limit, continuation } = req.params;\n    requireString(req, req.params, 'codeHash');\n    requireOptionalNumber(req, req.params, 'limit');\n    requireOptionalString(req, req.params, 'continuation');\n    const { connectionController } = ctx;\n    try {\n        return connectionController.use(({ data: { transport } }) => transport.getAccountsByCodeHash(codeHash, limit || 50, continuation));\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getTransactions = async (ctx, req) => {\n    requireParams(req);\n    const { address, continuation, limit } = req.params;\n    requireString(req, req.params, 'address');\n    requireOptional(req, req.params, 'continuation', requireTransactionId);\n    requireOptionalNumber(req, req.params, 'limit');\n    const { connectionController } = ctx;\n    try {\n        return connectionController.use(({ data: { transport } }) => transport.getTransactions(address, continuation === null || continuation === void 0 ? void 0 : continuation.lt, limit || 50));\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getTransaction = async (ctx, req) => {\n    requireParams(req);\n    const { hash } = req.params;\n    requireString(req, req.params, 'hash');\n    const { connectionController } = ctx;\n    try {\n        return {\n            transaction: await connectionController.use(({ data: { transport } }) => transport.getTransaction(hash)),\n        };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst findTransaction = async (ctx, req) => {\n    requireParams(req);\n    const { inMessageHash } = req.params;\n    requireOptional(req, req.params, 'inMessageHash', requireString);\n    const { connectionController } = ctx;\n    // TODO: add more filters\n    if (inMessageHash == null) {\n        return {\n            transaction: undefined,\n        };\n    }\n    try {\n        return {\n            transaction: await connectionController.use(({ data: { transport } }) => transport.getDstTransaction(inMessageHash)),\n        };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst runLocal = async (ctx, req) => {\n    requireParams(req);\n    const { address, cachedState, responsible, functionCall } = req.params;\n    requireString(req, req.params, 'address');\n    requireOptional(req, req.params, 'cachedState', requireContractState);\n    requireOptionalBoolean(req, req.params, 'responsible');\n    requireFunctionCall(req, req.params, 'functionCall');\n    const { clock, connectionController } = ctx;\n    let contractState = cachedState;\n    if (contractState == null) {\n        contractState = await connectionController.use(async ({ data: { transport } }) => transport.getFullContractState(address));\n    }\n    if (contractState == null) {\n        throw invalidRequest(req, 'Account not found');\n    }\n    if (!contractState.isDeployed || contractState.lastTransactionId == null) {\n        throw invalidRequest(req, 'Account is not deployed');\n    }\n    try {\n        const { output, code } = nekoton.runLocal(clock, contractState.boc, functionCall.abi, functionCall.method, functionCall.params, responsible || false);\n        return { output, code };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getExpectedAddress = async (_ctx, req) => {\n    requireParams(req);\n    const { tvc, abi, workchain, publicKey, initParams } = req.params;\n    requireString(req, req.params, 'tvc');\n    requireString(req, req.params, 'abi');\n    requireOptionalNumber(req, req.params, 'workchain');\n    requireOptionalString(req, req.params, 'publicKey');\n    try {\n        return nekoton.getExpectedAddress(tvc, abi, workchain || 0, publicKey, initParams);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getBocHash = async (_ctx, req) => {\n    requireParams(req);\n    const { boc } = req.params;\n    requireString(req, req.params, 'boc');\n    try {\n        return { hash: nekoton.getBocHash(boc) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst packIntoCell = async (_ctx, req) => {\n    requireParams(req);\n    const { structure, data, abiVersion } = req.params;\n    requireArray(req, req.params, 'structure');\n    requireOptional(req, req.params, 'abiVersion', requireString);\n    try {\n        return { boc: nekoton.packIntoCell(structure, data, abiVersion) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst unpackFromCell = async (_ctx, req) => {\n    requireParams(req);\n    const { structure, boc, allowPartial, abiVersion } = req.params;\n    requireArray(req, req.params, 'structure');\n    requireString(req, req.params, 'boc');\n    requireBoolean(req, req.params, 'allowPartial');\n    requireOptional(req, req.params, 'abiVersion', requireString);\n    try {\n        return { data: nekoton.unpackFromCell(structure, boc, allowPartial, abiVersion) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst extractPublicKey = async (_ctx, req) => {\n    requireParams(req);\n    const { boc } = req.params;\n    requireString(req, req.params, 'boc');\n    try {\n        return { publicKey: nekoton.extractPublicKey(boc) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst codeToTvc = async (_ctx, req) => {\n    requireParams(req);\n    const { code } = req.params;\n    requireString(req, req.params, 'code');\n    try {\n        return { tvc: nekoton.codeToTvc(code) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst mergeTvc = async (_ctx, req) => {\n    requireParams(req);\n    const { code, data } = req.params;\n    requireString(req, req.params, 'code');\n    requireString(req, req.params, 'data');\n    try {\n        return { tvc: nekoton.mergeTvc(code, data) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst splitTvc = async (_ctx, req) => {\n    requireParams(req);\n    const { tvc } = req.params;\n    requireString(req, req.params, 'tvc');\n    try {\n        return nekoton.splitTvc(tvc);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst setCodeSalt = async (_ctx, req) => {\n    requireParams(req);\n    const { code, salt } = req.params;\n    requireString(req, req.params, 'code');\n    requireString(req, req.params, 'salt');\n    try {\n        return { code: nekoton.setCodeSalt(code, salt) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getCodeSalt = async (_ctx, req) => {\n    requireParams(req);\n    const { code } = req.params;\n    requireString(req, req.params, 'code');\n    try {\n        return { salt: nekoton.getCodeSalt(code) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst encodeInternalInput = async (_ctx, req) => {\n    requireParams(req);\n    requireFunctionCall(req, req, 'params');\n    const { abi, method, params } = req.params;\n    try {\n        return { boc: nekoton.encodeInternalInput(abi, method, params) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeInput = async (_ctx, req) => {\n    requireParams(req);\n    const { body, abi, method, internal } = req.params;\n    requireString(req, req.params, 'body');\n    requireString(req, req.params, 'abi');\n    requireMethodOrArray(req, req.params, 'method');\n    requireBoolean(req, req.params, 'internal');\n    try {\n        return nekoton.decodeInput(body, abi, method, internal) || null;\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeOutput = async (_ctx, req) => {\n    requireParams(req);\n    const { body, abi, method } = req.params;\n    requireString(req, req.params, 'body');\n    requireString(req, req.params, 'abi');\n    requireMethodOrArray(req, req.params, 'method');\n    try {\n        return nekoton.decodeOutput(body, abi, method) || null;\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeEvent = async (_ctx, req) => {\n    requireParams(req);\n    const { body, abi, event } = req.params;\n    requireString(req, req.params, 'body');\n    requireString(req, req.params, 'abi');\n    requireMethodOrArray(req, req.params, 'event');\n    try {\n        return nekoton.decodeEvent(body, abi, event) || null;\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeTransaction = async (_ctx, req) => {\n    requireParams(req);\n    const { transaction, abi, method } = req.params;\n    requireString(req, req.params, 'abi');\n    requireMethodOrArray(req, req.params, 'method');\n    try {\n        return nekoton.decodeTransaction(transaction, abi, method) || null;\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeTransactionEvents = async (_ctx, req) => {\n    requireParams(req);\n    const { transaction, abi } = req.params;\n    requireString(req, req.params, 'abi');\n    try {\n        return { events: nekoton.decodeTransactionEvents(transaction, abi) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst verifySignature = async (_ctx, req) => {\n    requireParams(req);\n    const { publicKey, dataHash, signature } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'dataHash');\n    requireString(req, req.params, 'signature');\n    try {\n        return { isValid: nekoton.verifySignature(publicKey, dataHash, signature) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst sendUnsignedExternalMessage = async (ctx, req) => {\n    requireParams(req);\n    const { recipient, stateInit, payload, local } = req.params;\n    requireString(req, req.params, 'recipient');\n    requireOptionalString(req, req.params, 'stateInit');\n    requireOptionalRawFunctionCall(req, req.params, 'payload');\n    requireOptionalBoolean(req, req.params, 'local');\n    let repackedRecipient;\n    try {\n        repackedRecipient = nekoton.repackAddress(recipient);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    const { clock, subscriptionController, properties } = ctx;\n    const makeSignedMessage = (timeout) => {\n        try {\n            if (typeof payload === 'string' || payload == null) {\n                const expireAt = ~~(clock.nowMs / 1000) + timeout;\n                return nekoton.createRawExternalMessage(repackedRecipient, stateInit, payload, expireAt);\n            }\n            else {\n                return nekoton.createExternalMessageWithoutSignature(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, timeout);\n            }\n        }\n        catch (e) {\n            throw invalidRequest(req, e.toString());\n        }\n    };\n    const handleTransaction = (transaction) => {\n        let output;\n        try {\n            if (typeof payload === 'object' && typeof payload != null) {\n                const decoded = nekoton.decodeTransaction(transaction, payload.abi, payload.method);\n                output = decoded === null || decoded === void 0 ? void 0 : decoded.output;\n            }\n        }\n        catch (_) { /* do nothing */\n        }\n        return { transaction, output };\n    };\n    // Force local execution\n    if (local === true) {\n        const signedMessage = makeSignedMessage(60);\n        const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage);\n        return handleTransaction(transaction);\n    }\n    // Send and wait with several retries\n    let timeout = properties.message.timeout;\n    for (let retry = 0; retry < properties.message.retryCount; ++retry) {\n        const signedMessage = makeSignedMessage(timeout);\n        const transaction = await subscriptionController.sendMessage(repackedRecipient, signedMessage);\n        if (transaction == null) {\n            timeout *= properties.message.timeoutGrowFactor;\n            continue;\n        }\n        return handleTransaction(transaction);\n    }\n    // Execute locally\n    const errorMessage = 'Message expired';\n    const signedMessage = makeSignedMessage(60);\n    const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage)\n        .catch((e) => {\n        throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);\n    });\n    const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';\n    throw invalidRequest(req, `${errorMessage}${additionalText}`);\n};\nconst signData = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireParams(req);\n    const { publicKey, data } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'data');\n    const { keystore } = ctx;\n    const signer = await keystore.getSigner(publicKey);\n    if (signer == null) {\n        throw invalidRequest(req, 'Signer not found for public key');\n    }\n    try {\n        const dataHash = nekoton.getDataHash(data);\n        return {\n            dataHash,\n            ...(await signer.sign(dataHash).then(nekoton.extendSignature)),\n        };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst signDataRaw = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireParams(req);\n    const { publicKey, data } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'data');\n    const { keystore } = ctx;\n    const signer = await keystore.getSigner(publicKey);\n    if (signer == null) {\n        throw invalidRequest(req, 'Signer not found for public key');\n    }\n    try {\n        return await signer.sign(data).then(nekoton.extendSignature);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst sendMessage = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireAccountsStorage(req, ctx);\n    requireParams(req);\n    const { sender, recipient, amount, bounce, payload } = req.params;\n    requireString(req, req.params, 'sender');\n    requireString(req, req.params, 'recipient');\n    requireString(req, req.params, 'amount');\n    requireBoolean(req, req.params, 'bounce');\n    requireOptional(req, req.params, 'payload', requireFunctionCall);\n    const { clock, properties, subscriptionController, connectionController, keystore, accountsStorage } = ctx;\n    let repackedSender;\n    let repackedRecipient;\n    let account;\n    try {\n        repackedSender = nekoton.repackAddress(sender);\n        repackedRecipient = nekoton.repackAddress(recipient);\n        account = await accountsStorage.getAccount(repackedSender).then((account) => {\n            if (account != null) {\n                return account;\n            }\n            else {\n                throw new Error('Sender not found');\n            }\n        });\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    const makeSignedMessage = async (timeout) => {\n        try {\n            return account.prepareMessage({\n                recipient: repackedRecipient,\n                amount,\n                bounce,\n                payload,\n                stateInit: undefined,\n                timeout,\n            }, new AccountsStorage_1.AccountsStorageContext(clock, connectionController, nekoton, keystore));\n        }\n        catch (e) {\n            throw invalidRequest(req, e.toString());\n        }\n    };\n    // Send and wait with several retries\n    let timeout = properties.message.timeout;\n    // Set `retryCount` if not explicitly disabled\n    const retryCount = properties.message.retryTransfers !== false ? properties.message.retryCount : 1;\n    for (let retry = 0; retry < retryCount; ++retry) {\n        const signedMessage = await makeSignedMessage(timeout);\n        const transaction = await subscriptionController.sendMessage(repackedSender, signedMessage);\n        if (transaction == null) {\n            timeout *= properties.message.timeoutGrowFactor;\n            continue;\n        }\n        return { transaction };\n    }\n    // Execute locally\n    const errorMessage = 'Message expired';\n    const signedMessage = await makeSignedMessage(60);\n    const transaction = await subscriptionController.sendMessageLocally(repackedSender, signedMessage)\n        .catch((e) => {\n        throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);\n    });\n    const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';\n    throw invalidRequest(req, `${errorMessage}${additionalText}`);\n};\nconst sendMessageDelayed = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireAccountsStorage(req, ctx);\n    requireParams(req);\n    const { sender, recipient, amount, bounce, payload } = req.params;\n    requireString(req, req.params, 'sender');\n    requireString(req, req.params, 'recipient');\n    requireString(req, req.params, 'amount');\n    requireBoolean(req, req.params, 'bounce');\n    requireOptional(req, req.params, 'payload', requireFunctionCall);\n    const { clock, subscriptionController, connectionController, keystore, accountsStorage, notify } = ctx;\n    let repackedSender;\n    let repackedRecipient;\n    try {\n        repackedSender = nekoton.repackAddress(sender);\n        repackedRecipient = nekoton.repackAddress(recipient);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    let signedMessage;\n    try {\n        const account = await accountsStorage.getAccount(repackedSender);\n        if (account == null) {\n            throw new Error('Sender not found');\n        }\n        signedMessage = await account.prepareMessage({\n            recipient: repackedRecipient,\n            amount,\n            bounce,\n            payload,\n            stateInit: undefined,\n            timeout: 60, // TEMP\n        }, new AccountsStorage_1.AccountsStorageContext(clock, connectionController, nekoton, keystore));\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    subscriptionController.sendMessage(repackedSender, signedMessage)\n        .then(transaction => {\n        notify('messageStatusUpdated', {\n            address: repackedSender,\n            hash: signedMessage.hash,\n            transaction,\n        });\n    })\n        .catch(console.error);\n    return {\n        message: {\n            account: repackedSender,\n            hash: signedMessage.hash,\n            expireAt: signedMessage.expireAt,\n        },\n    };\n};\nconst sendExternalMessage = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireParams(req);\n    const { publicKey, recipient, stateInit, payload, local } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'recipient');\n    requireOptionalString(req, req.params, 'stateInit');\n    requireFunctionCall(req, req.params, 'payload');\n    requireOptionalBoolean(req, req.params, 'local');\n    let repackedRecipient;\n    try {\n        repackedRecipient = nekoton.repackAddress(recipient);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    const { clock, subscriptionController, keystore, properties } = ctx;\n    const signer = await keystore.getSigner(publicKey);\n    if (signer == null) {\n        throw invalidRequest(req, 'Signer not found for public key');\n    }\n    const makeSignedMessage = async (timeout) => {\n        let unsignedMessage;\n        try {\n            unsignedMessage = nekoton.createExternalMessage(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, publicKey, timeout);\n        }\n        catch (e) {\n            throw invalidRequest(req, e.toString());\n        }\n        try {\n            const signature = await signer.sign(unsignedMessage.hash);\n            return unsignedMessage.sign(signature);\n        }\n        catch (e) {\n            throw invalidRequest(req, e.toString());\n        }\n        finally {\n            unsignedMessage.free();\n        }\n    };\n    const handleTransaction = (transaction) => {\n        let output;\n        try {\n            const decoded = nekoton.decodeTransaction(transaction, payload.abi, payload.method);\n            output = decoded === null || decoded === void 0 ? void 0 : decoded.output;\n        }\n        catch (_) { /* do nothing */\n        }\n        return { transaction, output };\n    };\n    // Force local execution\n    if (local === true) {\n        const signedMessage = await makeSignedMessage(60);\n        const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage);\n        return handleTransaction(transaction);\n    }\n    // Send and wait with several retries\n    let timeout = properties.message.timeout;\n    for (let retry = 0; retry < properties.message.retryCount; ++retry) {\n        const signedMessage = await makeSignedMessage(timeout);\n        const transaction = await subscriptionController.sendMessage(repackedRecipient, signedMessage);\n        if (transaction == null) {\n            timeout *= properties.message.timeoutGrowFactor;\n            continue;\n        }\n        return handleTransaction(transaction);\n    }\n    // Execute locally\n    const errorMessage = 'Message expired';\n    const signedMessage = await makeSignedMessage(60);\n    const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage)\n        .catch((e) => {\n        throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);\n    });\n    const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';\n    throw invalidRequest(req, `${errorMessage}${additionalText}`);\n};\nconst sendExternalMessageDelayed = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireParams(req);\n    const { publicKey, recipient, stateInit, payload } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'recipient');\n    requireOptionalString(req, req.params, 'stateInit');\n    requireFunctionCall(req, req.params, 'payload');\n    let repackedRecipient;\n    try {\n        repackedRecipient = nekoton.repackAddress(recipient);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    const { clock, subscriptionController, keystore, properties, notify } = ctx;\n    const signer = await keystore.getSigner(publicKey);\n    if (signer == null) {\n        throw invalidRequest(req, 'Signer not found for public key');\n    }\n    let unsignedMessage;\n    try {\n        unsignedMessage = nekoton.createExternalMessage(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, publicKey, properties.message.timeout);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    let signedMessage;\n    try {\n        const signature = await signer.sign(unsignedMessage.hash);\n        signedMessage = unsignedMessage.sign(signature);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    finally {\n        unsignedMessage.free();\n    }\n    subscriptionController.sendMessage(repackedRecipient, signedMessage)\n        .then(transaction => {\n        notify('messageStatusUpdated', {\n            address: repackedRecipient,\n            hash: signedMessage.hash,\n            transaction,\n        });\n    })\n        .catch(console.error);\n    return {\n        message: {\n            account: repackedRecipient,\n            hash: signedMessage.hash,\n            expireAt: signedMessage.expireAt,\n        },\n    };\n};\nfunction requireKeystore(req, context) {\n    if (context.keystore == null) {\n        throw invalidRequest(req, 'Keystore not found');\n    }\n}\nfunction requireAccountsStorage(req, context) {\n    if (context.accountsStorage == null) {\n        throw invalidRequest(req, 'AccountsStorage not found');\n    }\n}\nfunction requireParams(req) {\n    if (req.params == null || typeof req.params !== 'object') {\n        throw invalidRequest(req, 'required params object');\n    }\n}\nfunction requireObject(req, object, key) {\n    const property = object[key];\n    if (typeof property !== 'object') {\n        throw invalidRequest(req, `'${String(key)}' must be an object`);\n    }\n}\nfunction requireOptionalObject(req, object, key) {\n    const property = object[key];\n    if (property != null && typeof property !== 'object') {\n        throw invalidRequest(req, `'${String(key)}' must be an object if specified`);\n    }\n}\nfunction requireBoolean(req, object, key) {\n    const property = object[key];\n    if (typeof property !== 'boolean') {\n        throw invalidRequest(req, `'${String(key)}' must be a boolean`);\n    }\n}\nfunction requireOptionalBoolean(req, object, key) {\n    const property = object[key];\n    if (property != null && typeof property !== 'boolean') {\n        throw invalidRequest(req, `'${String(key)}' must be a boolean if specified`);\n    }\n}\nfunction requireString(req, object, key) {\n    const property = object[key];\n    if (typeof property !== 'string' || property.length === 0) {\n        throw invalidRequest(req, `'${String(key)}' must be non-empty string`);\n    }\n}\nfunction requireOptionalString(req, object, key) {\n    const property = object[key];\n    if (property != null && (typeof property !== 'string' || property.length === 0)) {\n        throw invalidRequest(req, `'${String(key)}' must be a non-empty string if provided`);\n    }\n}\nfunction requireOptionalNumber(req, object, key) {\n    const property = object[key];\n    if (property != null && typeof property !== 'number') {\n        throw invalidRequest(req, `'${String(key)}' must be a number if provider`);\n    }\n}\nfunction requireArray(req, object, key) {\n    const property = object[key];\n    if (!Array.isArray(property)) {\n        throw invalidRequest(req, `'${String(key)}' must be an array`);\n    }\n}\nfunction requireOptional(req, object, key, predicate) {\n    const property = object[key];\n    if (property != null) {\n        predicate(req, object, key);\n    }\n}\nfunction requireTransactionId(req, object, key) {\n    requireObject(req, object, key);\n    const property = object[key];\n    requireString(req, property, 'lt');\n    requireString(req, property, 'hash');\n}\nfunction requireLastTransactionId(req, object, key) {\n    requireObject(req, object, key);\n    const property = object[key];\n    requireBoolean(req, property, 'isExact');\n    requireString(req, property, 'lt');\n    requireOptionalString(req, property, 'hash');\n}\nfunction requireContractState(req, object, key) {\n    requireObject(req, object, key);\n    const property = object[key];\n    requireString(req, property, 'balance');\n    requireOptional(req, property, 'lastTransactionId', requireLastTransactionId);\n    requireBoolean(req, property, 'isDeployed');\n}\nfunction requireFunctionCall(req, object, key) {\n    requireObject(req, object, key);\n    const property = object[key];\n    requireString(req, property, 'abi');\n    requireString(req, property, 'method');\n    requireObject(req, property, 'params');\n}\nfunction requireOptionalRawFunctionCall(req, object, key) {\n    const property = object[key];\n    if (typeof property === 'string' || property == null) {\n        return;\n    }\n    else if (typeof property === 'object') {\n        requireString(req, property, 'abi');\n        requireString(req, property, 'method');\n        requireObject(req, property, 'params');\n    }\n    else {\n        throw invalidRequest(req, `'${String(key)}' must be a function all or optional string`);\n    }\n}\nfunction requireMethodOrArray(req, object, key) {\n    const property = object[key];\n    if (property != null && typeof property !== 'string' && !Array.isArray(property)) {\n        throw invalidRequest(req, `'${String(key)}' must be a method name or an array of possible names`);\n    }\n}\nasync function makeAccountInteractionPermission(req, ctx) {\n    requireAccountsStorage(req, ctx);\n    const defaultAccount = ctx.accountsStorage.defaultAccount;\n    if (defaultAccount == null) {\n        throw invalidRequest(req, 'Default account not set in accounts storage');\n    }\n    const account = await ctx.accountsStorage.getAccount(defaultAccount);\n    if (account == null) {\n        throw invalidRequest(req, 'Default account not found');\n    }\n    const publicKey = await account.fetchPublicKey(new AccountsStorage_1.AccountsStorageContext(ctx.clock, ctx.connectionController, nekoton));\n    return {\n        address: account.address.toString(),\n        publicKey,\n        contractType: 'unknown',\n    };\n}\nconst invalidRequest = (req, message, data) => new NekotonRpcError(2, `${req.method}: ${message}`, data);\nclass NekotonRpcError extends Error {\n    constructor(code, message, data) {\n        if (!Number.isInteger(code)) {\n            throw new Error('\"code\" must be an integer');\n        }\n        if (!message || typeof message !== 'string') {\n            throw new Error('\"message\" must be a nonempty string');\n        }\n        super(message);\n        this.code = code;\n        this.data = data;\n    }\n    serialize() {\n        const serialized = {\n            code: this.code,\n            message: this.message,\n        };\n        if (this.data !== undefined) {\n            serialized.data = this.data;\n        }\n        if (this.stack) {\n            serialized.stack = this.stack;\n        }\n        return serialized;\n    }\n    toString() {\n        return (0, fast_safe_stringify_1.default)(this.serialize(), stringifyReplacer, 2);\n    }\n}\nconst stringifyReplacer = (_, value) => {\n    if (value === '[Circular]') {\n        return undefined;\n    }\n    return value;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjM3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvaW5kZXguanM/ZTEwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FdmVyc2NhbGVTdGFuZGFsb25lQ2xpZW50ID0gZXhwb3J0cy5TVVBQT1JURURfUEVSTUlTU0lPTlMgPSBleHBvcnRzLlZFUlNJT04gPSBleHBvcnRzLkRFRkFVTFRfQ0xJRU5UX1BST1BFUlRJRVMgPSBleHBvcnRzLkNsb2NrID0gZXhwb3J0cy5TaW1wbGVLZXlzdG9yZSA9IGV4cG9ydHMuY2hlY2tDb25uZWN0aW9uID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBleHBvcnRzLk5FVFdPUktfUFJFU0VUUyA9IHZvaWQgMDtcbmNvbnN0IGZhc3Rfc2FmZV9zdHJpbmdpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZmFzdC1zYWZlLXN0cmluZ2lmeVwiKSk7XG5jb25zdCBjb3JlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2NvcmVcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgQ29ubmVjdGlvbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL0Nvbm5lY3Rpb25Db250cm9sbGVyXCIpO1xuY29uc3QgU3Vic2NyaXB0aW9uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4vU3Vic2NyaXB0aW9uQ29udHJvbGxlclwiKTtcbmNvbnN0IEFjY291bnRzU3RvcmFnZV8xID0gcmVxdWlyZShcIi4vQWNjb3VudHNTdG9yYWdlXCIpO1xudmFyIENvbm5lY3Rpb25Db250cm9sbGVyXzIgPSByZXF1aXJlKFwiLi9Db25uZWN0aW9uQ29udHJvbGxlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5FVFdPUktfUFJFU0VUU1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ29ubmVjdGlvbkNvbnRyb2xsZXJfMi5ORVRXT1JLX1BSRVNFVFM7IH0gfSk7XG52YXIgQ29ubmVjdGlvbkNvbnRyb2xsZXJfMyA9IHJlcXVpcmUoXCIuL0Nvbm5lY3Rpb25Db250cm9sbGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvbkVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDb25uZWN0aW9uQ29udHJvbGxlcl8zLkNvbm5lY3Rpb25FcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNoZWNrQ29ubmVjdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ29ubmVjdGlvbkNvbnRyb2xsZXJfMy5jaGVja0Nvbm5lY3Rpb247IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQWNjb3VudHNTdG9yYWdlXCIpLCBleHBvcnRzKTtcbnZhciBrZXlzdG9yZV8xID0gcmVxdWlyZShcIi4va2V5c3RvcmVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaW1wbGVLZXlzdG9yZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ga2V5c3RvcmVfMS5TaW1wbGVLZXlzdG9yZTsgfSB9KTtcbnZhciBjbG9ja18xID0gcmVxdWlyZShcIi4vY2xvY2tcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbG9ja1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xvY2tfMS5DbG9jazsgfSB9KTtcbmNvbnN0IHsgZW5zdXJlTmVrb3RvbkxvYWRlZCwgbmVrb3RvbiB9ID0gY29yZV8xLmRlZmF1bHQ7XG5mdW5jdGlvbiB2YWxpZGF0ZU1lc3NhZ2VQcm9wZXJ0aWVzKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBtID0gbWVzc2FnZSB8fCB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXRyeUNvdW50OiBtLnJldHJ5Q291bnQgIT0gbnVsbCA/IE1hdGgubWF4KDEsIH5+bS5yZXRyeUNvdW50KSA6IDUsXG4gICAgICAgIHRpbWVvdXQ6IG0udGltZW91dCAhPSBudWxsID8gTWF0aC5tYXgoMSwgfn5tLnRpbWVvdXQpIDogNjAsXG4gICAgICAgIHRpbWVvdXRHcm93RmFjdG9yOiBtLnRpbWVvdXRHcm93RmFjdG9yIHx8IDEuMixcbiAgICAgICAgcmV0cnlUcmFuc2ZlcnM6IHRydWUsXG4gICAgfTtcbn1cbi8qKlxuICogQGNhdGVnb3J5IENsaWVudFxuICovXG5leHBvcnRzLkRFRkFVTFRfQ0xJRU5UX1BST1BFUlRJRVMgPSB7XG4gICAgY29ubmVjdGlvbjogQ29ubmVjdGlvbkNvbnRyb2xsZXJfMS5ERUZBVUxUX05FVFdPUktfR1JPVVAsXG59O1xuLyoqXG4gKiBAY2F0ZWdvcnkgQ2xpZW50XG4gKi9cbmV4cG9ydHMuVkVSU0lPTiA9ICcwLjIuMjUnO1xuLyoqXG4gKiBAY2F0ZWdvcnkgQ2xpZW50XG4gKi9cbmV4cG9ydHMuU1VQUE9SVEVEX1BFUk1JU1NJT05TID0gWydiYXNpYycsICdhY2NvdW50SW50ZXJhY3Rpb24nXTtcbi8qKlxuICogQGNhdGVnb3J5IENsaWVudFxuICovXG5jbGFzcyBFdmVyc2NhbGVTdGFuZGFsb25lQ2xpZW50IGV4dGVuZHMgdXRpbHNfMS5TYWZlRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7XG4gICAgICAgICAgICByZXF1ZXN0UGVybWlzc2lvbnMsXG4gICAgICAgICAgICBjaGFuZ2VBY2NvdW50LFxuICAgICAgICAgICAgZGlzY29ubmVjdCxcbiAgICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlLFxuICAgICAgICAgICAgdW5zdWJzY3JpYmVBbGwsXG4gICAgICAgICAgICBnZXRQcm92aWRlclN0YXRlLFxuICAgICAgICAgICAgZ2V0RnVsbENvbnRyYWN0U3RhdGUsXG4gICAgICAgICAgICBnZXRBY2NvdW50c0J5Q29kZUhhc2gsXG4gICAgICAgICAgICBnZXRUcmFuc2FjdGlvbnMsXG4gICAgICAgICAgICBnZXRUcmFuc2FjdGlvbixcbiAgICAgICAgICAgIGZpbmRUcmFuc2FjdGlvbixcbiAgICAgICAgICAgIHJ1bkxvY2FsLFxuICAgICAgICAgICAgZ2V0RXhwZWN0ZWRBZGRyZXNzLFxuICAgICAgICAgICAgZ2V0Qm9jSGFzaCxcbiAgICAgICAgICAgIHBhY2tJbnRvQ2VsbCxcbiAgICAgICAgICAgIHVucGFja0Zyb21DZWxsLFxuICAgICAgICAgICAgZXh0cmFjdFB1YmxpY0tleSxcbiAgICAgICAgICAgIGNvZGVUb1R2YyxcbiAgICAgICAgICAgIG1lcmdlVHZjLFxuICAgICAgICAgICAgc3BsaXRUdmMsXG4gICAgICAgICAgICBzZXRDb2RlU2FsdCxcbiAgICAgICAgICAgIGdldENvZGVTYWx0LFxuICAgICAgICAgICAgZW5jb2RlSW50ZXJuYWxJbnB1dCxcbiAgICAgICAgICAgIGRlY29kZUlucHV0LFxuICAgICAgICAgICAgZGVjb2RlT3V0cHV0LFxuICAgICAgICAgICAgZGVjb2RlRXZlbnQsXG4gICAgICAgICAgICBkZWNvZGVUcmFuc2FjdGlvbixcbiAgICAgICAgICAgIGRlY29kZVRyYW5zYWN0aW9uRXZlbnRzLFxuICAgICAgICAgICAgdmVyaWZ5U2lnbmF0dXJlLFxuICAgICAgICAgICAgc2VuZFVuc2lnbmVkRXh0ZXJuYWxNZXNzYWdlLFxuICAgICAgICAgICAgLy8gYWRkQXNzZXQsIC8vIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIHNpZ25EYXRhLFxuICAgICAgICAgICAgc2lnbkRhdGFSYXcsXG4gICAgICAgICAgICAvLyBlbmNyeXB0RGF0YSwgLy8gbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgLy8gZGVjcnlwdERhdGEsIC8vIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIC8vIGVzdGltYXRlRmVlcywgLy8gbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgc2VuZE1lc3NhZ2UsXG4gICAgICAgICAgICBzZW5kTWVzc2FnZURlbGF5ZWQsXG4gICAgICAgICAgICBzZW5kRXh0ZXJuYWxNZXNzYWdlLFxuICAgICAgICAgICAgc2VuZEV4dGVybmFsTWVzc2FnZURlbGF5ZWQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjdHg7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIGF3YWl0IGVuc3VyZU5la290b25Mb2FkZWQocGFyYW1zLmluaXRJbnB1dCk7XG4gICAgICAgIC8vIE5PVEU6IGNhcHR1cmUgY2xpZW50IGluc2lkZSBub3RpZnkgdXNpbmcgd3JhcHBlciBvYmplY3RcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uQ29udGV4dCA9IHt9O1xuICAgICAgICBjb25zdCBub3RpZnkgPSAobWV0aG9kLCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IG5vdGlmaWNhdGlvbkNvbnRleHQuY2xpZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW1pdChtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsb2NrID0gbmV3IGNvcmVfMS5kZWZhdWx0Lm5la290b24uQ2xvY2tXaXRoT2Zmc2V0KCk7XG4gICAgICAgIGlmIChwYXJhbXMuY2xvY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyYW1zLmNsb2NrWydpbXBscyddLnB1c2goY2xvY2spO1xuICAgICAgICAgICAgY2xvY2sudXBkYXRlT2Zmc2V0KHBhcmFtcy5jbG9jay5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uQ29udHJvbGxlciA9IGF3YWl0ICgwLCBDb25uZWN0aW9uQ29udHJvbGxlcl8xLmNyZWF0ZUNvbm5lY3Rpb25Db250cm9sbGVyKShjbG9jaywgcGFyYW1zLmNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uQ29udHJvbGxlciA9IG5ldyBTdWJzY3JpcHRpb25Db250cm9sbGVyXzEuU3Vic2NyaXB0aW9uQ29udHJvbGxlcihjb25uZWN0aW9uQ29udHJvbGxlciwgbm90aWZ5KTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBFdmVyc2NhbGVTdGFuZGFsb25lQ2xpZW50KHtcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczoge30sXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbkNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZhbGlkYXRlTWVzc2FnZVByb3BlcnRpZXMocGFyYW1zLm1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAga2V5c3RvcmU6IHBhcmFtcy5rZXlzdG9yZSxcbiAgICAgICAgICAgICAgICBhY2NvdW50c1N0b3JhZ2U6IHBhcmFtcy5hY2NvdW50c1N0b3JhZ2UsXG4gICAgICAgICAgICAgICAgY2xvY2ssXG4gICAgICAgICAgICAgICAgbm90aWZ5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBOT1RFOiBXZWFrUmVmIGlzIG5vdCB3b3JraW5nIGhlcmUsIHNvIGhvcGUgaXQgd2lsbCBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICAgICAgICAgICAgbm90aWZpY2F0aW9uQ29udGV4dC5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmNsb2NrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuY2xvY2tbJ2ltcGxzJ10ucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbG9jay5mcmVlKCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3QocmVxKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9oYW5kbGVyc1tyZXEubWV0aG9kXTtcbiAgICAgICAgaWYgKGhhbmRsZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgTWV0aG9kICcke3JlcS5tZXRob2R9JyBpcyBub3Qgc3VwcG9ydGVkIGJ5IHN0YW5kYWxvbmUgcHJvdmlkZXJgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlcih0aGlzLl9jb250ZXh0LCByZXEpO1xuICAgIH1cbiAgICBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLm9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHByZXBlbmRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHByZXBlbmRPbmNlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIucHJlcGVuZE9uY2VMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG59XG5leHBvcnRzLkV2ZXJzY2FsZVN0YW5kYWxvbmVDbGllbnQgPSBFdmVyc2NhbGVTdGFuZGFsb25lQ2xpZW50O1xuY29uc3QgcmVxdWVzdFBlcm1pc3Npb25zID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgcGVybWlzc2lvbnMgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZUFycmF5KHJlcSwgcmVxLnBhcmFtcywgJ3Blcm1pc3Npb25zJyk7XG4gICAgY29uc3QgbmV3UGVybWlzc2lvbnMgPSB7IC4uLmN0eC5wZXJtaXNzaW9ucyB9O1xuICAgIGZvciAoY29uc3QgcGVybWlzc2lvbiBvZiBwZXJtaXNzaW9ucykge1xuICAgICAgICBpZiAocGVybWlzc2lvbiA9PT0gJ2Jhc2ljJyB8fCBwZXJtaXNzaW9uID09PSAndG9uQ2xpZW50Jykge1xuICAgICAgICAgICAgbmV3UGVybWlzc2lvbnMuYmFzaWMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBlcm1pc3Npb24gPT09ICdhY2NvdW50SW50ZXJhY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAobmV3UGVybWlzc2lvbnMuYWNjb3VudEludGVyYWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1Blcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbiA9IGF3YWl0IG1ha2VBY2NvdW50SW50ZXJhY3Rpb25QZXJtaXNzaW9uKHJlcSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYFBlcm1pc3Npb24gJyR7cGVybWlzc2lvbn0nIGlzIG5vdCBzdXBwb3J0ZWQgYnkgc3RhbmRhbG9uZSBwcm92aWRlcmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGN0eC5wZXJtaXNzaW9ucyA9IG5ld1Blcm1pc3Npb25zO1xuICAgIC8vIE5PVEU6IGJlIHN1cmUgdG8gcmV0dXJuIG9iamVjdCBjb3B5IHRvIHByZXZlbnQgYWRkaW5nIG5ldyBwZXJtaXNzaW9uc1xuICAgIGNvbnN0IHBlcm1pc3Npb25zQ29weSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobmV3UGVybWlzc2lvbnMpKTtcbiAgICBjdHgubm90aWZ5KCdwZXJtaXNzaW9uc0NoYW5nZWQnLCB7XG4gICAgICAgIHBlcm1pc3Npb25zOiBwZXJtaXNzaW9uc0NvcHksXG4gICAgfSk7XG4gICAgcmV0dXJuIHBlcm1pc3Npb25zQ29weTtcbn07XG5jb25zdCBjaGFuZ2VBY2NvdW50ID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZUFjY291bnRzU3RvcmFnZShyZXEsIGN0eCk7XG4gICAgY29uc3QgbmV3UGVybWlzc2lvbnMgPSB7IC4uLmN0eC5wZXJtaXNzaW9ucyB9O1xuICAgIG5ld1Blcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbiA9IGF3YWl0IG1ha2VBY2NvdW50SW50ZXJhY3Rpb25QZXJtaXNzaW9uKHJlcSwgY3R4KTtcbiAgICBjdHgucGVybWlzc2lvbnMgPSBuZXdQZXJtaXNzaW9ucztcbiAgICAvLyBOT1RFOiBiZSBzdXJlIHRvIHJldHVybiBvYmplY3QgY29weSB0byBwcmV2ZW50IGFkZGluZyBuZXcgcGVybWlzc2lvbnNcbiAgICBjb25zdCBwZXJtaXNzaW9uc0NvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG5ld1Blcm1pc3Npb25zKSk7XG4gICAgY3R4Lm5vdGlmeSgncGVybWlzc2lvbnNDaGFuZ2VkJywge1xuICAgICAgICBwZXJtaXNzaW9uczogcGVybWlzc2lvbnNDb3B5LFxuICAgIH0pO1xuICAgIHJldHVybiBwZXJtaXNzaW9uc0NvcHk7XG59O1xuY29uc3QgZGlzY29ubmVjdCA9IGFzeW5jIChjdHgsIF9yZXEpID0+IHtcbiAgICBjdHgucGVybWlzc2lvbnMgPSB7fTtcbiAgICBhd2FpdCBjdHguc3Vic2NyaXB0aW9uQ29udHJvbGxlci51bnN1YnNjcmliZUZyb21BbGxDb250cmFjdHMoKTtcbiAgICBjdHgubm90aWZ5KCdwZXJtaXNzaW9uc0NoYW5nZWQnLCB7IHBlcm1pc3Npb25zOiB7fSB9KTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmNvbnN0IHN1YnNjcmliZSA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IGFkZHJlc3MsIHN1YnNjcmlwdGlvbnMgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdhZGRyZXNzJyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsT2JqZWN0KHJlcSwgcmVxLnBhcmFtcywgJ3N1YnNjcmlwdGlvbnMnKTtcbiAgICBsZXQgcmVwYWNrZWRBZGRyZXNzO1xuICAgIHRyeSB7XG4gICAgICAgIHJlcGFja2VkQWRkcmVzcyA9IG5la290b24ucmVwYWNrQWRkcmVzcyhhZGRyZXNzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgY3R4LnN1YnNjcmlwdGlvbkNvbnRyb2xsZXIuc3Vic2NyaWJlVG9Db250cmFjdChyZXBhY2tlZEFkZHJlc3MsIHN1YnNjcmlwdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IHVuc3Vic2NyaWJlID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgYWRkcmVzcyB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2FkZHJlc3MnKTtcbiAgICBsZXQgcmVwYWNrZWRBZGRyZXNzO1xuICAgIHRyeSB7XG4gICAgICAgIHJlcGFja2VkQWRkcmVzcyA9IG5la290b24ucmVwYWNrQWRkcmVzcyhhZGRyZXNzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBhd2FpdCBjdHguc3Vic2NyaXB0aW9uQ29udHJvbGxlci51bnN1YnNjcmliZUZyb21Db250cmFjdChyZXBhY2tlZEFkZHJlc3MpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuY29uc3QgdW5zdWJzY3JpYmVBbGwgPSBhc3luYyAoY3R4LCBfcmVxKSA9PiB7XG4gICAgYXdhaXQgY3R4LnN1YnNjcmlwdGlvbkNvbnRyb2xsZXIudW5zdWJzY3JpYmVGcm9tQWxsQ29udHJhY3RzKCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5jb25zdCBnZXRQcm92aWRlclN0YXRlID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgY29uc3QgdHJhbnNwb3J0ID0gY3R4LmNvbm5lY3Rpb25Db250cm9sbGVyLmluaXRpYWxpemVkVHJhbnNwb3J0O1xuICAgIGlmICh0cmFuc3BvcnQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsICdDb25uZWN0aW9uIGNvbnRyb2xsZXIgd2FzIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH1cbiAgICBjb25zdCB2ZXJzaW9uID0gZXhwb3J0cy5WRVJTSU9OO1xuICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIG51bWVyaWNWZXJzaW9uOiAoMCwgdXRpbHNfMS5jb252ZXJ0VmVyc2lvblRvSW50MzIpKHZlcnNpb24pLFxuICAgICAgICBuZXR3b3JrSWQ6IHRyYW5zcG9ydC5pZCxcbiAgICAgICAgc2VsZWN0ZWRDb25uZWN0aW9uOiB0cmFuc3BvcnQuZ3JvdXAsXG4gICAgICAgIHN1cHBvcnRlZFBlcm1pc3Npb25zOiBbLi4uZXhwb3J0cy5TVVBQT1JURURfUEVSTUlTU0lPTlNdLFxuICAgICAgICBwZXJtaXNzaW9uczogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjdHgucGVybWlzc2lvbnMpKSxcbiAgICAgICAgc3Vic2NyaXB0aW9uczogY3R4LnN1YnNjcmlwdGlvbkNvbnRyb2xsZXIuc3Vic2NyaXB0aW9uU3RhdGVzLFxuICAgIH07XG59O1xuY29uc3QgZ2V0RnVsbENvbnRyYWN0U3RhdGUgPSBhc3luYyAoY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBhZGRyZXNzIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYWRkcmVzcycpO1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbkNvbnRyb2xsZXIgfSA9IGN0eDtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbkNvbnRyb2xsZXIudXNlKGFzeW5jICh7IGRhdGE6IHsgdHJhbnNwb3J0IH0gfSkgPT4gKHtcbiAgICAgICAgICAgIHN0YXRlOiBhd2FpdCB0cmFuc3BvcnQuZ2V0RnVsbENvbnRyYWN0U3RhdGUoYWRkcmVzcyksXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBnZXRBY2NvdW50c0J5Q29kZUhhc2ggPSBhc3luYyAoY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBjb2RlSGFzaCwgbGltaXQsIGNvbnRpbnVhdGlvbiB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2NvZGVIYXNoJyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsTnVtYmVyKHJlcSwgcmVxLnBhcmFtcywgJ2xpbWl0Jyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2NvbnRpbnVhdGlvbicpO1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbkNvbnRyb2xsZXIgfSA9IGN0eDtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbkNvbnRyb2xsZXIudXNlKCh7IGRhdGE6IHsgdHJhbnNwb3J0IH0gfSkgPT4gdHJhbnNwb3J0LmdldEFjY291bnRzQnlDb2RlSGFzaChjb2RlSGFzaCwgbGltaXQgfHwgNTAsIGNvbnRpbnVhdGlvbikpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGdldFRyYW5zYWN0aW9ucyA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGNvbnRpbnVhdGlvbiwgbGltaXQgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdhZGRyZXNzJyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsKHJlcSwgcmVxLnBhcmFtcywgJ2NvbnRpbnVhdGlvbicsIHJlcXVpcmVUcmFuc2FjdGlvbklkKTtcbiAgICByZXF1aXJlT3B0aW9uYWxOdW1iZXIocmVxLCByZXEucGFyYW1zLCAnbGltaXQnKTtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25Db250cm9sbGVyIH0gPSBjdHg7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25Db250cm9sbGVyLnVzZSgoeyBkYXRhOiB7IHRyYW5zcG9ydCB9IH0pID0+IHRyYW5zcG9ydC5nZXRUcmFuc2FjdGlvbnMoYWRkcmVzcywgY29udGludWF0aW9uID09PSBudWxsIHx8IGNvbnRpbnVhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGludWF0aW9uLmx0LCBsaW1pdCB8fCA1MCkpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGdldFRyYW5zYWN0aW9uID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgaGFzaCB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2hhc2gnKTtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25Db250cm9sbGVyIH0gPSBjdHg7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBhd2FpdCBjb25uZWN0aW9uQ29udHJvbGxlci51c2UoKHsgZGF0YTogeyB0cmFuc3BvcnQgfSB9KSA9PiB0cmFuc3BvcnQuZ2V0VHJhbnNhY3Rpb24oaGFzaCkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGZpbmRUcmFuc2FjdGlvbiA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IGluTWVzc2FnZUhhc2ggfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZU9wdGlvbmFsKHJlcSwgcmVxLnBhcmFtcywgJ2luTWVzc2FnZUhhc2gnLCByZXF1aXJlU3RyaW5nKTtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25Db250cm9sbGVyIH0gPSBjdHg7XG4gICAgLy8gVE9ETzogYWRkIG1vcmUgZmlsdGVyc1xuICAgIGlmIChpbk1lc3NhZ2VIYXNoID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogYXdhaXQgY29ubmVjdGlvbkNvbnRyb2xsZXIudXNlKCh7IGRhdGE6IHsgdHJhbnNwb3J0IH0gfSkgPT4gdHJhbnNwb3J0LmdldERzdFRyYW5zYWN0aW9uKGluTWVzc2FnZUhhc2gpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBydW5Mb2NhbCA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGNhY2hlZFN0YXRlLCByZXNwb25zaWJsZSwgZnVuY3Rpb25DYWxsIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYWRkcmVzcycpO1xuICAgIHJlcXVpcmVPcHRpb25hbChyZXEsIHJlcS5wYXJhbXMsICdjYWNoZWRTdGF0ZScsIHJlcXVpcmVDb250cmFjdFN0YXRlKTtcbiAgICByZXF1aXJlT3B0aW9uYWxCb29sZWFuKHJlcSwgcmVxLnBhcmFtcywgJ3Jlc3BvbnNpYmxlJyk7XG4gICAgcmVxdWlyZUZ1bmN0aW9uQ2FsbChyZXEsIHJlcS5wYXJhbXMsICdmdW5jdGlvbkNhbGwnKTtcbiAgICBjb25zdCB7IGNsb2NrLCBjb25uZWN0aW9uQ29udHJvbGxlciB9ID0gY3R4O1xuICAgIGxldCBjb250cmFjdFN0YXRlID0gY2FjaGVkU3RhdGU7XG4gICAgaWYgKGNvbnRyYWN0U3RhdGUgPT0gbnVsbCkge1xuICAgICAgICBjb250cmFjdFN0YXRlID0gYXdhaXQgY29ubmVjdGlvbkNvbnRyb2xsZXIudXNlKGFzeW5jICh7IGRhdGE6IHsgdHJhbnNwb3J0IH0gfSkgPT4gdHJhbnNwb3J0LmdldEZ1bGxDb250cmFjdFN0YXRlKGFkZHJlc3MpKTtcbiAgICB9XG4gICAgaWYgKGNvbnRyYWN0U3RhdGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsICdBY2NvdW50IG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbnRyYWN0U3RhdGUuaXNEZXBsb3llZCB8fCBjb250cmFjdFN0YXRlLmxhc3RUcmFuc2FjdGlvbklkID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCAnQWNjb3VudCBpcyBub3QgZGVwbG95ZWQnKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBvdXRwdXQsIGNvZGUgfSA9IG5la290b24ucnVuTG9jYWwoY2xvY2ssIGNvbnRyYWN0U3RhdGUuYm9jLCBmdW5jdGlvbkNhbGwuYWJpLCBmdW5jdGlvbkNhbGwubWV0aG9kLCBmdW5jdGlvbkNhbGwucGFyYW1zLCByZXNwb25zaWJsZSB8fCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB7IG91dHB1dCwgY29kZSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGdldEV4cGVjdGVkQWRkcmVzcyA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyB0dmMsIGFiaSwgd29ya2NoYWluLCBwdWJsaWNLZXksIGluaXRQYXJhbXMgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICd0dmMnKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2FiaScpO1xuICAgIHJlcXVpcmVPcHRpb25hbE51bWJlcihyZXEsIHJlcS5wYXJhbXMsICd3b3JrY2hhaW4nKTtcbiAgICByZXF1aXJlT3B0aW9uYWxTdHJpbmcocmVxLCByZXEucGFyYW1zLCAncHVibGljS2V5Jyk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5la290b24uZ2V0RXhwZWN0ZWRBZGRyZXNzKHR2YywgYWJpLCB3b3JrY2hhaW4gfHwgMCwgcHVibGljS2V5LCBpbml0UGFyYW1zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBnZXRCb2NIYXNoID0gYXN5bmMgKF9jdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IGJvYyB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2JvYycpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IGhhc2g6IG5la290b24uZ2V0Qm9jSGFzaChib2MpIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3QgcGFja0ludG9DZWxsID0gYXN5bmMgKF9jdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IHN0cnVjdHVyZSwgZGF0YSwgYWJpVmVyc2lvbiB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlQXJyYXkocmVxLCByZXEucGFyYW1zLCAnc3RydWN0dXJlJyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsKHJlcSwgcmVxLnBhcmFtcywgJ2FiaVZlcnNpb24nLCByZXF1aXJlU3RyaW5nKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyBib2M6IG5la290b24ucGFja0ludG9DZWxsKHN0cnVjdHVyZSwgZGF0YSwgYWJpVmVyc2lvbikgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCB1bnBhY2tGcm9tQ2VsbCA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBzdHJ1Y3R1cmUsIGJvYywgYWxsb3dQYXJ0aWFsLCBhYmlWZXJzaW9uIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVBcnJheShyZXEsIHJlcS5wYXJhbXMsICdzdHJ1Y3R1cmUnKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2JvYycpO1xuICAgIHJlcXVpcmVCb29sZWFuKHJlcSwgcmVxLnBhcmFtcywgJ2FsbG93UGFydGlhbCcpO1xuICAgIHJlcXVpcmVPcHRpb25hbChyZXEsIHJlcS5wYXJhbXMsICdhYmlWZXJzaW9uJywgcmVxdWlyZVN0cmluZyk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbmVrb3Rvbi51bnBhY2tGcm9tQ2VsbChzdHJ1Y3R1cmUsIGJvYywgYWxsb3dQYXJ0aWFsLCBhYmlWZXJzaW9uKSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGV4dHJhY3RQdWJsaWNLZXkgPSBhc3luYyAoX2N0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgYm9jIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYm9jJyk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgcHVibGljS2V5OiBuZWtvdG9uLmV4dHJhY3RQdWJsaWNLZXkoYm9jKSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGNvZGVUb1R2YyA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBjb2RlIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnY29kZScpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IHR2YzogbmVrb3Rvbi5jb2RlVG9UdmMoY29kZSkgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBtZXJnZVR2YyA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBjb2RlLCBkYXRhIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnY29kZScpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnZGF0YScpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IHR2YzogbmVrb3Rvbi5tZXJnZVR2Yyhjb2RlLCBkYXRhKSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IHNwbGl0VHZjID0gYXN5bmMgKF9jdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IHR2YyB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3R2YycpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZWtvdG9uLnNwbGl0VHZjKHR2Yyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3Qgc2V0Q29kZVNhbHQgPSBhc3luYyAoX2N0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgY29kZSwgc2FsdCB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2NvZGUnKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3NhbHQnKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyBjb2RlOiBuZWtvdG9uLnNldENvZGVTYWx0KGNvZGUsIHNhbHQpIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3QgZ2V0Q29kZVNhbHQgPSBhc3luYyAoX2N0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgY29kZSB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2NvZGUnKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyBzYWx0OiBuZWtvdG9uLmdldENvZGVTYWx0KGNvZGUpIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3QgZW5jb2RlSW50ZXJuYWxJbnB1dCA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgcmVxdWlyZUZ1bmN0aW9uQ2FsbChyZXEsIHJlcSwgJ3BhcmFtcycpO1xuICAgIGNvbnN0IHsgYWJpLCBtZXRob2QsIHBhcmFtcyB9ID0gcmVxLnBhcmFtcztcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyBib2M6IG5la290b24uZW5jb2RlSW50ZXJuYWxJbnB1dChhYmksIG1ldGhvZCwgcGFyYW1zKSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGRlY29kZUlucHV0ID0gYXN5bmMgKF9jdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IGJvZHksIGFiaSwgbWV0aG9kLCBpbnRlcm5hbCB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2JvZHknKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2FiaScpO1xuICAgIHJlcXVpcmVNZXRob2RPckFycmF5KHJlcSwgcmVxLnBhcmFtcywgJ21ldGhvZCcpO1xuICAgIHJlcXVpcmVCb29sZWFuKHJlcSwgcmVxLnBhcmFtcywgJ2ludGVybmFsJyk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5la290b24uZGVjb2RlSW5wdXQoYm9keSwgYWJpLCBtZXRob2QsIGludGVybmFsKSB8fCBudWxsO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGRlY29kZU91dHB1dCA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBib2R5LCBhYmksIG1ldGhvZCB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2JvZHknKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2FiaScpO1xuICAgIHJlcXVpcmVNZXRob2RPckFycmF5KHJlcSwgcmVxLnBhcmFtcywgJ21ldGhvZCcpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZWtvdG9uLmRlY29kZU91dHB1dChib2R5LCBhYmksIG1ldGhvZCkgfHwgbnVsbDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBkZWNvZGVFdmVudCA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBib2R5LCBhYmksIGV2ZW50IH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYm9keScpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYWJpJyk7XG4gICAgcmVxdWlyZU1ldGhvZE9yQXJyYXkocmVxLCByZXEucGFyYW1zLCAnZXZlbnQnKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmVrb3Rvbi5kZWNvZGVFdmVudChib2R5LCBhYmksIGV2ZW50KSB8fCBudWxsO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGRlY29kZVRyYW5zYWN0aW9uID0gYXN5bmMgKF9jdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9uLCBhYmksIG1ldGhvZCB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2FiaScpO1xuICAgIHJlcXVpcmVNZXRob2RPckFycmF5KHJlcSwgcmVxLnBhcmFtcywgJ21ldGhvZCcpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZWtvdG9uLmRlY29kZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBhYmksIG1ldGhvZCkgfHwgbnVsbDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBkZWNvZGVUcmFuc2FjdGlvbkV2ZW50cyA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbiwgYWJpIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYWJpJyk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgZXZlbnRzOiBuZWtvdG9uLmRlY29kZVRyYW5zYWN0aW9uRXZlbnRzKHRyYW5zYWN0aW9uLCBhYmkpIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3QgdmVyaWZ5U2lnbmF0dXJlID0gYXN5bmMgKF9jdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IHB1YmxpY0tleSwgZGF0YUhhc2gsIHNpZ25hdHVyZSB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3B1YmxpY0tleScpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnZGF0YUhhc2gnKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3NpZ25hdHVyZScpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IG5la290b24udmVyaWZ5U2lnbmF0dXJlKHB1YmxpY0tleSwgZGF0YUhhc2gsIHNpZ25hdHVyZSkgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBzZW5kVW5zaWduZWRFeHRlcm5hbE1lc3NhZ2UgPSBhc3luYyAoY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyByZWNpcGllbnQsIHN0YXRlSW5pdCwgcGF5bG9hZCwgbG9jYWwgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdyZWNpcGllbnQnKTtcbiAgICByZXF1aXJlT3B0aW9uYWxTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnc3RhdGVJbml0Jyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsUmF3RnVuY3Rpb25DYWxsKHJlcSwgcmVxLnBhcmFtcywgJ3BheWxvYWQnKTtcbiAgICByZXF1aXJlT3B0aW9uYWxCb29sZWFuKHJlcSwgcmVxLnBhcmFtcywgJ2xvY2FsJyk7XG4gICAgbGV0IHJlcGFja2VkUmVjaXBpZW50O1xuICAgIHRyeSB7XG4gICAgICAgIHJlcGFja2VkUmVjaXBpZW50ID0gbmVrb3Rvbi5yZXBhY2tBZGRyZXNzKHJlY2lwaWVudCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgY29uc3QgeyBjbG9jaywgc3Vic2NyaXB0aW9uQ29udHJvbGxlciwgcHJvcGVydGllcyB9ID0gY3R4O1xuICAgIGNvbnN0IG1ha2VTaWduZWRNZXNzYWdlID0gKHRpbWVvdXQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycgfHwgcGF5bG9hZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwaXJlQXQgPSB+fihjbG9jay5ub3dNcyAvIDEwMDApICsgdGltZW91dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmVrb3Rvbi5jcmVhdGVSYXdFeHRlcm5hbE1lc3NhZ2UocmVwYWNrZWRSZWNpcGllbnQsIHN0YXRlSW5pdCwgcGF5bG9hZCwgZXhwaXJlQXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5la290b24uY3JlYXRlRXh0ZXJuYWxNZXNzYWdlV2l0aG91dFNpZ25hdHVyZShjbG9jaywgcmVwYWNrZWRSZWNpcGllbnQsIHBheWxvYWQuYWJpLCBwYXlsb2FkLm1ldGhvZCwgc3RhdGVJbml0LCBwYXlsb2FkLnBhcmFtcywgdGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlVHJhbnNhY3Rpb24gPSAodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgICAgbGV0IG91dHB1dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBheWxvYWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY29kZWQgPSBuZWtvdG9uLmRlY29kZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBwYXlsb2FkLmFiaSwgcGF5bG9hZC5tZXRob2QpO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IGRlY29kZWQgPT09IG51bGwgfHwgZGVjb2RlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVjb2RlZC5vdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHsgLyogZG8gbm90aGluZyAqL1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRyYW5zYWN0aW9uLCBvdXRwdXQgfTtcbiAgICB9O1xuICAgIC8vIEZvcmNlIGxvY2FsIGV4ZWN1dGlvblxuICAgIGlmIChsb2NhbCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBzaWduZWRNZXNzYWdlID0gbWFrZVNpZ25lZE1lc3NhZ2UoNjApO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHN1YnNjcmlwdGlvbkNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VMb2NhbGx5KHJlcGFja2VkUmVjaXBpZW50LCBzaWduZWRNZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgLy8gU2VuZCBhbmQgd2FpdCB3aXRoIHNldmVyYWwgcmV0cmllc1xuICAgIGxldCB0aW1lb3V0ID0gcHJvcGVydGllcy5tZXNzYWdlLnRpbWVvdXQ7XG4gICAgZm9yIChsZXQgcmV0cnkgPSAwOyByZXRyeSA8IHByb3BlcnRpZXMubWVzc2FnZS5yZXRyeUNvdW50OyArK3JldHJ5KSB7XG4gICAgICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2UgPSBtYWtlU2lnbmVkTWVzc2FnZSh0aW1lb3V0KTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCBzdWJzY3JpcHRpb25Db250cm9sbGVyLnNlbmRNZXNzYWdlKHJlcGFja2VkUmVjaXBpZW50LCBzaWduZWRNZXNzYWdlKTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgKj0gcHJvcGVydGllcy5tZXNzYWdlLnRpbWVvdXRHcm93RmFjdG9yO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgLy8gRXhlY3V0ZSBsb2NhbGx5XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ01lc3NhZ2UgZXhwaXJlZCc7XG4gICAgY29uc3Qgc2lnbmVkTWVzc2FnZSA9IG1ha2VTaWduZWRNZXNzYWdlKDYwKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHN1YnNjcmlwdGlvbkNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VMb2NhbGx5KHJlcGFja2VkUmVjaXBpZW50LCBzaWduZWRNZXNzYWdlKVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgJHtlcnJvck1lc3NhZ2V9LiAke2UudG9TdHJpbmcoKX1gKTtcbiAgICB9KTtcbiAgICBjb25zdCBhZGRpdGlvbmFsVGV4dCA9IHRyYW5zYWN0aW9uLmV4aXRDb2RlICE9IG51bGwgPyBgLiBQb3NzaWJsZSBleGl0IGNvZGU6ICR7dHJhbnNhY3Rpb24uZXhpdENvZGV9YCA6ICcnO1xuICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYCR7ZXJyb3JNZXNzYWdlfSR7YWRkaXRpb25hbFRleHR9YCk7XG59O1xuY29uc3Qgc2lnbkRhdGEgPSBhc3luYyAoY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlS2V5c3RvcmUocmVxLCBjdHgpO1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IHB1YmxpY0tleSwgZGF0YSB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3B1YmxpY0tleScpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnZGF0YScpO1xuICAgIGNvbnN0IHsga2V5c3RvcmUgfSA9IGN0eDtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBrZXlzdG9yZS5nZXRTaWduZXIocHVibGljS2V5KTtcbiAgICBpZiAoc2lnbmVyID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCAnU2lnbmVyIG5vdCBmb3VuZCBmb3IgcHVibGljIGtleScpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhSGFzaCA9IG5la290b24uZ2V0RGF0YUhhc2goZGF0YSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhSGFzaCxcbiAgICAgICAgICAgIC4uLihhd2FpdCBzaWduZXIuc2lnbihkYXRhSGFzaCkudGhlbihuZWtvdG9uLmV4dGVuZFNpZ25hdHVyZSkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IHNpZ25EYXRhUmF3ID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZUtleXN0b3JlKHJlcSwgY3R4KTtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBwdWJsaWNLZXksIGRhdGEgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdwdWJsaWNLZXknKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2RhdGEnKTtcbiAgICBjb25zdCB7IGtleXN0b3JlIH0gPSBjdHg7XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQga2V5c3RvcmUuZ2V0U2lnbmVyKHB1YmxpY0tleSk7XG4gICAgaWYgKHNpZ25lciA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgJ1NpZ25lciBub3QgZm91bmQgZm9yIHB1YmxpYyBrZXknKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNpZ25lci5zaWduKGRhdGEpLnRoZW4obmVrb3Rvbi5leHRlbmRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IHNlbmRNZXNzYWdlID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZUtleXN0b3JlKHJlcSwgY3R4KTtcbiAgICByZXF1aXJlQWNjb3VudHNTdG9yYWdlKHJlcSwgY3R4KTtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBzZW5kZXIsIHJlY2lwaWVudCwgYW1vdW50LCBib3VuY2UsIHBheWxvYWQgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdzZW5kZXInKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3JlY2lwaWVudCcpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYW1vdW50Jyk7XG4gICAgcmVxdWlyZUJvb2xlYW4ocmVxLCByZXEucGFyYW1zLCAnYm91bmNlJyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsKHJlcSwgcmVxLnBhcmFtcywgJ3BheWxvYWQnLCByZXF1aXJlRnVuY3Rpb25DYWxsKTtcbiAgICBjb25zdCB7IGNsb2NrLCBwcm9wZXJ0aWVzLCBzdWJzY3JpcHRpb25Db250cm9sbGVyLCBjb25uZWN0aW9uQ29udHJvbGxlciwga2V5c3RvcmUsIGFjY291bnRzU3RvcmFnZSB9ID0gY3R4O1xuICAgIGxldCByZXBhY2tlZFNlbmRlcjtcbiAgICBsZXQgcmVwYWNrZWRSZWNpcGllbnQ7XG4gICAgbGV0IGFjY291bnQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVwYWNrZWRTZW5kZXIgPSBuZWtvdG9uLnJlcGFja0FkZHJlc3Moc2VuZGVyKTtcbiAgICAgICAgcmVwYWNrZWRSZWNpcGllbnQgPSBuZWtvdG9uLnJlcGFja0FkZHJlc3MocmVjaXBpZW50KTtcbiAgICAgICAgYWNjb3VudCA9IGF3YWl0IGFjY291bnRzU3RvcmFnZS5nZXRBY2NvdW50KHJlcGFja2VkU2VuZGVyKS50aGVuKChhY2NvdW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoYWNjb3VudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgY29uc3QgbWFrZVNpZ25lZE1lc3NhZ2UgPSBhc3luYyAodGltZW91dCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY291bnQucHJlcGFyZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHJlY2lwaWVudDogcmVwYWNrZWRSZWNpcGllbnQsXG4gICAgICAgICAgICAgICAgYW1vdW50LFxuICAgICAgICAgICAgICAgIGJvdW5jZSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgIHN0YXRlSW5pdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICB9LCBuZXcgQWNjb3VudHNTdG9yYWdlXzEuQWNjb3VudHNTdG9yYWdlQ29udGV4dChjbG9jaywgY29ubmVjdGlvbkNvbnRyb2xsZXIsIG5la290b24sIGtleXN0b3JlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gU2VuZCBhbmQgd2FpdCB3aXRoIHNldmVyYWwgcmV0cmllc1xuICAgIGxldCB0aW1lb3V0ID0gcHJvcGVydGllcy5tZXNzYWdlLnRpbWVvdXQ7XG4gICAgLy8gU2V0IGByZXRyeUNvdW50YCBpZiBub3QgZXhwbGljaXRseSBkaXNhYmxlZFxuICAgIGNvbnN0IHJldHJ5Q291bnQgPSBwcm9wZXJ0aWVzLm1lc3NhZ2UucmV0cnlUcmFuc2ZlcnMgIT09IGZhbHNlID8gcHJvcGVydGllcy5tZXNzYWdlLnJldHJ5Q291bnQgOiAxO1xuICAgIGZvciAobGV0IHJldHJ5ID0gMDsgcmV0cnkgPCByZXRyeUNvdW50OyArK3JldHJ5KSB7XG4gICAgICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2UgPSBhd2FpdCBtYWtlU2lnbmVkTWVzc2FnZSh0aW1lb3V0KTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCBzdWJzY3JpcHRpb25Db250cm9sbGVyLnNlbmRNZXNzYWdlKHJlcGFja2VkU2VuZGVyLCBzaWduZWRNZXNzYWdlKTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgKj0gcHJvcGVydGllcy5tZXNzYWdlLnRpbWVvdXRHcm93RmFjdG9yO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHJhbnNhY3Rpb24gfTtcbiAgICB9XG4gICAgLy8gRXhlY3V0ZSBsb2NhbGx5XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ01lc3NhZ2UgZXhwaXJlZCc7XG4gICAgY29uc3Qgc2lnbmVkTWVzc2FnZSA9IGF3YWl0IG1ha2VTaWduZWRNZXNzYWdlKDYwKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHN1YnNjcmlwdGlvbkNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VMb2NhbGx5KHJlcGFja2VkU2VuZGVyLCBzaWduZWRNZXNzYWdlKVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgJHtlcnJvck1lc3NhZ2V9LiAke2UudG9TdHJpbmcoKX1gKTtcbiAgICB9KTtcbiAgICBjb25zdCBhZGRpdGlvbmFsVGV4dCA9IHRyYW5zYWN0aW9uLmV4aXRDb2RlICE9IG51bGwgPyBgLiBQb3NzaWJsZSBleGl0IGNvZGU6ICR7dHJhbnNhY3Rpb24uZXhpdENvZGV9YCA6ICcnO1xuICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYCR7ZXJyb3JNZXNzYWdlfSR7YWRkaXRpb25hbFRleHR9YCk7XG59O1xuY29uc3Qgc2VuZE1lc3NhZ2VEZWxheWVkID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZUtleXN0b3JlKHJlcSwgY3R4KTtcbiAgICByZXF1aXJlQWNjb3VudHNTdG9yYWdlKHJlcSwgY3R4KTtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBzZW5kZXIsIHJlY2lwaWVudCwgYW1vdW50LCBib3VuY2UsIHBheWxvYWQgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdzZW5kZXInKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3JlY2lwaWVudCcpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYW1vdW50Jyk7XG4gICAgcmVxdWlyZUJvb2xlYW4ocmVxLCByZXEucGFyYW1zLCAnYm91bmNlJyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsKHJlcSwgcmVxLnBhcmFtcywgJ3BheWxvYWQnLCByZXF1aXJlRnVuY3Rpb25DYWxsKTtcbiAgICBjb25zdCB7IGNsb2NrLCBzdWJzY3JpcHRpb25Db250cm9sbGVyLCBjb25uZWN0aW9uQ29udHJvbGxlciwga2V5c3RvcmUsIGFjY291bnRzU3RvcmFnZSwgbm90aWZ5IH0gPSBjdHg7XG4gICAgbGV0IHJlcGFja2VkU2VuZGVyO1xuICAgIGxldCByZXBhY2tlZFJlY2lwaWVudDtcbiAgICB0cnkge1xuICAgICAgICByZXBhY2tlZFNlbmRlciA9IG5la290b24ucmVwYWNrQWRkcmVzcyhzZW5kZXIpO1xuICAgICAgICByZXBhY2tlZFJlY2lwaWVudCA9IG5la290b24ucmVwYWNrQWRkcmVzcyhyZWNpcGllbnQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGxldCBzaWduZWRNZXNzYWdlO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCBhY2NvdW50c1N0b3JhZ2UuZ2V0QWNjb3VudChyZXBhY2tlZFNlbmRlcik7XG4gICAgICAgIGlmIChhY2NvdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25lZE1lc3NhZ2UgPSBhd2FpdCBhY2NvdW50LnByZXBhcmVNZXNzYWdlKHtcbiAgICAgICAgICAgIHJlY2lwaWVudDogcmVwYWNrZWRSZWNpcGllbnQsXG4gICAgICAgICAgICBhbW91bnQsXG4gICAgICAgICAgICBib3VuY2UsXG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgc3RhdGVJbml0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aW1lb3V0OiA2MCwgLy8gVEVNUFxuICAgICAgICB9LCBuZXcgQWNjb3VudHNTdG9yYWdlXzEuQWNjb3VudHNTdG9yYWdlQ29udGV4dChjbG9jaywgY29ubmVjdGlvbkNvbnRyb2xsZXIsIG5la290b24sIGtleXN0b3JlKSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgc3Vic2NyaXB0aW9uQ29udHJvbGxlci5zZW5kTWVzc2FnZShyZXBhY2tlZFNlbmRlciwgc2lnbmVkTWVzc2FnZSlcbiAgICAgICAgLnRoZW4odHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBub3RpZnkoJ21lc3NhZ2VTdGF0dXNVcGRhdGVkJywge1xuICAgICAgICAgICAgYWRkcmVzczogcmVwYWNrZWRTZW5kZXIsXG4gICAgICAgICAgICBoYXNoOiBzaWduZWRNZXNzYWdlLmhhc2gsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgIGFjY291bnQ6IHJlcGFja2VkU2VuZGVyLFxuICAgICAgICAgICAgaGFzaDogc2lnbmVkTWVzc2FnZS5oYXNoLFxuICAgICAgICAgICAgZXhwaXJlQXQ6IHNpZ25lZE1lc3NhZ2UuZXhwaXJlQXQsXG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5jb25zdCBzZW5kRXh0ZXJuYWxNZXNzYWdlID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZUtleXN0b3JlKHJlcSwgY3R4KTtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBwdWJsaWNLZXksIHJlY2lwaWVudCwgc3RhdGVJbml0LCBwYXlsb2FkLCBsb2NhbCB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3B1YmxpY0tleScpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAncmVjaXBpZW50Jyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3N0YXRlSW5pdCcpO1xuICAgIHJlcXVpcmVGdW5jdGlvbkNhbGwocmVxLCByZXEucGFyYW1zLCAncGF5bG9hZCcpO1xuICAgIHJlcXVpcmVPcHRpb25hbEJvb2xlYW4ocmVxLCByZXEucGFyYW1zLCAnbG9jYWwnKTtcbiAgICBsZXQgcmVwYWNrZWRSZWNpcGllbnQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVwYWNrZWRSZWNpcGllbnQgPSBuZWtvdG9uLnJlcGFja0FkZHJlc3MocmVjaXBpZW50KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBjb25zdCB7IGNsb2NrLCBzdWJzY3JpcHRpb25Db250cm9sbGVyLCBrZXlzdG9yZSwgcHJvcGVydGllcyB9ID0gY3R4O1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IGtleXN0b3JlLmdldFNpZ25lcihwdWJsaWNLZXkpO1xuICAgIGlmIChzaWduZXIgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsICdTaWduZXIgbm90IGZvdW5kIGZvciBwdWJsaWMga2V5Jyk7XG4gICAgfVxuICAgIGNvbnN0IG1ha2VTaWduZWRNZXNzYWdlID0gYXN5bmMgKHRpbWVvdXQpID0+IHtcbiAgICAgICAgbGV0IHVuc2lnbmVkTWVzc2FnZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVuc2lnbmVkTWVzc2FnZSA9IG5la290b24uY3JlYXRlRXh0ZXJuYWxNZXNzYWdlKGNsb2NrLCByZXBhY2tlZFJlY2lwaWVudCwgcGF5bG9hZC5hYmksIHBheWxvYWQubWV0aG9kLCBzdGF0ZUluaXQsIHBheWxvYWQucGFyYW1zLCBwdWJsaWNLZXksIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25lci5zaWduKHVuc2lnbmVkTWVzc2FnZS5oYXNoKTtcbiAgICAgICAgICAgIHJldHVybiB1bnNpZ25lZE1lc3NhZ2Uuc2lnbihzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB1bnNpZ25lZE1lc3NhZ2UuZnJlZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVUcmFuc2FjdGlvbiA9ICh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlZCA9IG5la290b24uZGVjb2RlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHBheWxvYWQuYWJpLCBwYXlsb2FkLm1ldGhvZCk7XG4gICAgICAgICAgICBvdXRwdXQgPSBkZWNvZGVkID09PSBudWxsIHx8IGRlY29kZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlY29kZWQub3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7IC8qIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0cmFuc2FjdGlvbiwgb3V0cHV0IH07XG4gICAgfTtcbiAgICAvLyBGb3JjZSBsb2NhbCBleGVjdXRpb25cbiAgICBpZiAobG9jYWwgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3Qgc2lnbmVkTWVzc2FnZSA9IGF3YWl0IG1ha2VTaWduZWRNZXNzYWdlKDYwKTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCBzdWJzY3JpcHRpb25Db250cm9sbGVyLnNlbmRNZXNzYWdlTG9jYWxseShyZXBhY2tlZFJlY2lwaWVudCwgc2lnbmVkTWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIC8vIFNlbmQgYW5kIHdhaXQgd2l0aCBzZXZlcmFsIHJldHJpZXNcbiAgICBsZXQgdGltZW91dCA9IHByb3BlcnRpZXMubWVzc2FnZS50aW1lb3V0O1xuICAgIGZvciAobGV0IHJldHJ5ID0gMDsgcmV0cnkgPCBwcm9wZXJ0aWVzLm1lc3NhZ2UucmV0cnlDb3VudDsgKytyZXRyeSkge1xuICAgICAgICBjb25zdCBzaWduZWRNZXNzYWdlID0gYXdhaXQgbWFrZVNpZ25lZE1lc3NhZ2UodGltZW91dCk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgc3Vic2NyaXB0aW9uQ29udHJvbGxlci5zZW5kTWVzc2FnZShyZXBhY2tlZFJlY2lwaWVudCwgc2lnbmVkTWVzc2FnZSk7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aW1lb3V0ICo9IHByb3BlcnRpZXMubWVzc2FnZS50aW1lb3V0R3Jvd0ZhY3RvcjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIC8vIEV4ZWN1dGUgbG9jYWxseVxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICdNZXNzYWdlIGV4cGlyZWQnO1xuICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2UgPSBhd2FpdCBtYWtlU2lnbmVkTWVzc2FnZSg2MCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCBzdWJzY3JpcHRpb25Db250cm9sbGVyLnNlbmRNZXNzYWdlTG9jYWxseShyZXBhY2tlZFJlY2lwaWVudCwgc2lnbmVkTWVzc2FnZSlcbiAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYCR7ZXJyb3JNZXNzYWdlfS4gJHtlLnRvU3RyaW5nKCl9YCk7XG4gICAgfSk7XG4gICAgY29uc3QgYWRkaXRpb25hbFRleHQgPSB0cmFuc2FjdGlvbi5leGl0Q29kZSAhPSBudWxsID8gYC4gUG9zc2libGUgZXhpdCBjb2RlOiAke3RyYW5zYWN0aW9uLmV4aXRDb2RlfWAgOiAnJztcbiAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGAke2Vycm9yTWVzc2FnZX0ke2FkZGl0aW9uYWxUZXh0fWApO1xufTtcbmNvbnN0IHNlbmRFeHRlcm5hbE1lc3NhZ2VEZWxheWVkID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZUtleXN0b3JlKHJlcSwgY3R4KTtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBwdWJsaWNLZXksIHJlY2lwaWVudCwgc3RhdGVJbml0LCBwYXlsb2FkIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAncHVibGljS2V5Jyk7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdyZWNpcGllbnQnKTtcbiAgICByZXF1aXJlT3B0aW9uYWxTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnc3RhdGVJbml0Jyk7XG4gICAgcmVxdWlyZUZ1bmN0aW9uQ2FsbChyZXEsIHJlcS5wYXJhbXMsICdwYXlsb2FkJyk7XG4gICAgbGV0IHJlcGFja2VkUmVjaXBpZW50O1xuICAgIHRyeSB7XG4gICAgICAgIHJlcGFja2VkUmVjaXBpZW50ID0gbmVrb3Rvbi5yZXBhY2tBZGRyZXNzKHJlY2lwaWVudCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgY29uc3QgeyBjbG9jaywgc3Vic2NyaXB0aW9uQ29udHJvbGxlciwga2V5c3RvcmUsIHByb3BlcnRpZXMsIG5vdGlmeSB9ID0gY3R4O1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IGtleXN0b3JlLmdldFNpZ25lcihwdWJsaWNLZXkpO1xuICAgIGlmIChzaWduZXIgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsICdTaWduZXIgbm90IGZvdW5kIGZvciBwdWJsaWMga2V5Jyk7XG4gICAgfVxuICAgIGxldCB1bnNpZ25lZE1lc3NhZ2U7XG4gICAgdHJ5IHtcbiAgICAgICAgdW5zaWduZWRNZXNzYWdlID0gbmVrb3Rvbi5jcmVhdGVFeHRlcm5hbE1lc3NhZ2UoY2xvY2ssIHJlcGFja2VkUmVjaXBpZW50LCBwYXlsb2FkLmFiaSwgcGF5bG9hZC5tZXRob2QsIHN0YXRlSW5pdCwgcGF5bG9hZC5wYXJhbXMsIHB1YmxpY0tleSwgcHJvcGVydGllcy5tZXNzYWdlLnRpbWVvdXQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGxldCBzaWduZWRNZXNzYWdlO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25lci5zaWduKHVuc2lnbmVkTWVzc2FnZS5oYXNoKTtcbiAgICAgICAgc2lnbmVkTWVzc2FnZSA9IHVuc2lnbmVkTWVzc2FnZS5zaWduKHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHVuc2lnbmVkTWVzc2FnZS5mcmVlKCk7XG4gICAgfVxuICAgIHN1YnNjcmlwdGlvbkNvbnRyb2xsZXIuc2VuZE1lc3NhZ2UocmVwYWNrZWRSZWNpcGllbnQsIHNpZ25lZE1lc3NhZ2UpXG4gICAgICAgIC50aGVuKHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgbm90aWZ5KCdtZXNzYWdlU3RhdHVzVXBkYXRlZCcsIHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHJlcGFja2VkUmVjaXBpZW50LFxuICAgICAgICAgICAgaGFzaDogc2lnbmVkTWVzc2FnZS5oYXNoLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgICAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICBhY2NvdW50OiByZXBhY2tlZFJlY2lwaWVudCxcbiAgICAgICAgICAgIGhhc2g6IHNpZ25lZE1lc3NhZ2UuaGFzaCxcbiAgICAgICAgICAgIGV4cGlyZUF0OiBzaWduZWRNZXNzYWdlLmV4cGlyZUF0LFxuICAgICAgICB9LFxuICAgIH07XG59O1xuZnVuY3Rpb24gcmVxdWlyZUtleXN0b3JlKHJlcSwgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LmtleXN0b3JlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCAnS2V5c3RvcmUgbm90IGZvdW5kJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZUFjY291bnRzU3RvcmFnZShyZXEsIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5hY2NvdW50c1N0b3JhZ2UgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsICdBY2NvdW50c1N0b3JhZ2Ugbm90IGZvdW5kJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZVBhcmFtcyhyZXEpIHtcbiAgICBpZiAocmVxLnBhcmFtcyA9PSBudWxsIHx8IHR5cGVvZiByZXEucGFyYW1zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsICdyZXF1aXJlZCBwYXJhbXMgb2JqZWN0Jyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZU9iamVjdChyZXEsIG9iamVjdCwga2V5KSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBvYmplY3Rba2V5XTtcbiAgICBpZiAodHlwZW9mIHByb3BlcnR5ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGAnJHtTdHJpbmcoa2V5KX0nIG11c3QgYmUgYW4gb2JqZWN0YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZU9wdGlvbmFsT2JqZWN0KHJlcSwgb2JqZWN0LCBrZXkpIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IG9iamVjdFtrZXldO1xuICAgIGlmIChwcm9wZXJ0eSAhPSBudWxsICYmIHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgJyR7U3RyaW5nKGtleSl9JyBtdXN0IGJlIGFuIG9iamVjdCBpZiBzcGVjaWZpZWRgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1aXJlQm9vbGVhbihyZXEsIG9iamVjdCwga2V5KSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBvYmplY3Rba2V5XTtcbiAgICBpZiAodHlwZW9mIHByb3BlcnR5ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgJyR7U3RyaW5nKGtleSl9JyBtdXN0IGJlIGEgYm9vbGVhbmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcXVpcmVPcHRpb25hbEJvb2xlYW4ocmVxLCBvYmplY3QsIGtleSkge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgaWYgKHByb3BlcnR5ICE9IG51bGwgJiYgdHlwZW9mIHByb3BlcnR5ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgJyR7U3RyaW5nKGtleSl9JyBtdXN0IGJlIGEgYm9vbGVhbiBpZiBzcGVjaWZpZWRgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1aXJlU3RyaW5nKHJlcSwgb2JqZWN0LCBrZXkpIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IG9iamVjdFtrZXldO1xuICAgIGlmICh0eXBlb2YgcHJvcGVydHkgIT09ICdzdHJpbmcnIHx8IHByb3BlcnR5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGAnJHtTdHJpbmcoa2V5KX0nIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ2ApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcXVpcmVPcHRpb25hbFN0cmluZyhyZXEsIG9iamVjdCwga2V5KSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBvYmplY3Rba2V5XTtcbiAgICBpZiAocHJvcGVydHkgIT0gbnVsbCAmJiAodHlwZW9mIHByb3BlcnR5ICE9PSAnc3RyaW5nJyB8fCBwcm9wZXJ0eS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYCcke1N0cmluZyhrZXkpfScgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgaWYgcHJvdmlkZWRgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1aXJlT3B0aW9uYWxOdW1iZXIocmVxLCBvYmplY3QsIGtleSkge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgaWYgKHByb3BlcnR5ICE9IG51bGwgJiYgdHlwZW9mIHByb3BlcnR5ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGAnJHtTdHJpbmcoa2V5KX0nIG11c3QgYmUgYSBudW1iZXIgaWYgcHJvdmlkZXJgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1aXJlQXJyYXkocmVxLCBvYmplY3QsIGtleSkge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BlcnR5KSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGAnJHtTdHJpbmcoa2V5KX0nIG11c3QgYmUgYW4gYXJyYXlgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1aXJlT3B0aW9uYWwocmVxLCBvYmplY3QsIGtleSwgcHJlZGljYXRlKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBvYmplY3Rba2V5XTtcbiAgICBpZiAocHJvcGVydHkgIT0gbnVsbCkge1xuICAgICAgICBwcmVkaWNhdGUocmVxLCBvYmplY3QsIGtleSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZVRyYW5zYWN0aW9uSWQocmVxLCBvYmplY3QsIGtleSkge1xuICAgIHJlcXVpcmVPYmplY3QocmVxLCBvYmplY3QsIGtleSk7XG4gICAgY29uc3QgcHJvcGVydHkgPSBvYmplY3Rba2V5XTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcHJvcGVydHksICdsdCcpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCBwcm9wZXJ0eSwgJ2hhc2gnKTtcbn1cbmZ1bmN0aW9uIHJlcXVpcmVMYXN0VHJhbnNhY3Rpb25JZChyZXEsIG9iamVjdCwga2V5KSB7XG4gICAgcmVxdWlyZU9iamVjdChyZXEsIG9iamVjdCwga2V5KTtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IG9iamVjdFtrZXldO1xuICAgIHJlcXVpcmVCb29sZWFuKHJlcSwgcHJvcGVydHksICdpc0V4YWN0Jyk7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHByb3BlcnR5LCAnbHQnKTtcbiAgICByZXF1aXJlT3B0aW9uYWxTdHJpbmcocmVxLCBwcm9wZXJ0eSwgJ2hhc2gnKTtcbn1cbmZ1bmN0aW9uIHJlcXVpcmVDb250cmFjdFN0YXRlKHJlcSwgb2JqZWN0LCBrZXkpIHtcbiAgICByZXF1aXJlT2JqZWN0KHJlcSwgb2JqZWN0LCBrZXkpO1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHByb3BlcnR5LCAnYmFsYW5jZScpO1xuICAgIHJlcXVpcmVPcHRpb25hbChyZXEsIHByb3BlcnR5LCAnbGFzdFRyYW5zYWN0aW9uSWQnLCByZXF1aXJlTGFzdFRyYW5zYWN0aW9uSWQpO1xuICAgIHJlcXVpcmVCb29sZWFuKHJlcSwgcHJvcGVydHksICdpc0RlcGxveWVkJyk7XG59XG5mdW5jdGlvbiByZXF1aXJlRnVuY3Rpb25DYWxsKHJlcSwgb2JqZWN0LCBrZXkpIHtcbiAgICByZXF1aXJlT2JqZWN0KHJlcSwgb2JqZWN0LCBrZXkpO1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHByb3BlcnR5LCAnYWJpJyk7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHByb3BlcnR5LCAnbWV0aG9kJyk7XG4gICAgcmVxdWlyZU9iamVjdChyZXEsIHByb3BlcnR5LCAncGFyYW1zJyk7XG59XG5mdW5jdGlvbiByZXF1aXJlT3B0aW9uYWxSYXdGdW5jdGlvbkNhbGwocmVxLCBvYmplY3QsIGtleSkge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycgfHwgcHJvcGVydHkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmVxdWlyZVN0cmluZyhyZXEsIHByb3BlcnR5LCAnYWJpJyk7XG4gICAgICAgIHJlcXVpcmVTdHJpbmcocmVxLCBwcm9wZXJ0eSwgJ21ldGhvZCcpO1xuICAgICAgICByZXF1aXJlT2JqZWN0KHJlcSwgcHJvcGVydHksICdwYXJhbXMnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYCcke1N0cmluZyhrZXkpfScgbXVzdCBiZSBhIGZ1bmN0aW9uIGFsbCBvciBvcHRpb25hbCBzdHJpbmdgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1aXJlTWV0aG9kT3JBcnJheShyZXEsIG9iamVjdCwga2V5KSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBvYmplY3Rba2V5XTtcbiAgICBpZiAocHJvcGVydHkgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcGVydHkgIT09ICdzdHJpbmcnICYmICFBcnJheS5pc0FycmF5KHByb3BlcnR5KSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGAnJHtTdHJpbmcoa2V5KX0nIG11c3QgYmUgYSBtZXRob2QgbmFtZSBvciBhbiBhcnJheSBvZiBwb3NzaWJsZSBuYW1lc2ApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIG1ha2VBY2NvdW50SW50ZXJhY3Rpb25QZXJtaXNzaW9uKHJlcSwgY3R4KSB7XG4gICAgcmVxdWlyZUFjY291bnRzU3RvcmFnZShyZXEsIGN0eCk7XG4gICAgY29uc3QgZGVmYXVsdEFjY291bnQgPSBjdHguYWNjb3VudHNTdG9yYWdlLmRlZmF1bHRBY2NvdW50O1xuICAgIGlmIChkZWZhdWx0QWNjb3VudCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgJ0RlZmF1bHQgYWNjb3VudCBub3Qgc2V0IGluIGFjY291bnRzIHN0b3JhZ2UnKTtcbiAgICB9XG4gICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IGN0eC5hY2NvdW50c1N0b3JhZ2UuZ2V0QWNjb3VudChkZWZhdWx0QWNjb3VudCk7XG4gICAgaWYgKGFjY291bnQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsICdEZWZhdWx0IGFjY291bnQgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IGFjY291bnQuZmV0Y2hQdWJsaWNLZXkobmV3IEFjY291bnRzU3RvcmFnZV8xLkFjY291bnRzU3RvcmFnZUNvbnRleHQoY3R4LmNsb2NrLCBjdHguY29ubmVjdGlvbkNvbnRyb2xsZXIsIG5la290b24pKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBhY2NvdW50LmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgcHVibGljS2V5LFxuICAgICAgICBjb250cmFjdFR5cGU6ICd1bmtub3duJyxcbiAgICB9O1xufVxuY29uc3QgaW52YWxpZFJlcXVlc3QgPSAocmVxLCBtZXNzYWdlLCBkYXRhKSA9PiBuZXcgTmVrb3RvblJwY0Vycm9yKDIsIGAke3JlcS5tZXRob2R9OiAke21lc3NhZ2V9YCwgZGF0YSk7XG5jbGFzcyBOZWtvdG9uUnBjRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9uZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgICAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhY2spIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQuc3RhY2sgPSB0aGlzLnN0YWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICgwLCBmYXN0X3NhZmVfc3RyaW5naWZ5XzEuZGVmYXVsdCkodGhpcy5zZXJpYWxpemUoKSwgc3RyaW5naWZ5UmVwbGFjZXIsIDIpO1xuICAgIH1cbn1cbmNvbnN0IHN0cmluZ2lmeVJlcGxhY2VyID0gKF8sIHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSAnW0NpcmN1bGFyXScpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///637\n")},837:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.SimpleKeystore = void 0;\nconst core_1 = __importDefault(__webpack_require__(521));\nconst { nekoton } = core_1.default;\n/**\n * @category Keystore\n */\nclass SimpleKeystore {\n    constructor(entries = {}) {\n        this.signers = new Map();\n        this.signersByPublicKey = new Map();\n        for (const [id, signer] of Object.entries(entries)) {\n            this.addKeyPair(id, signer);\n        }\n    }\n    static generateKeyPair() {\n        return nekoton.ed25519_generateKeyPair();\n    }\n    addKeyPair(idOrKeypair, rest) {\n        let id;\n        let keyPair;\n        if (typeof idOrKeypair == \'string\') {\n            id = idOrKeypair;\n            keyPair = rest;\n        }\n        else {\n            id = idOrKeypair.publicKey;\n            keyPair = idOrKeypair;\n        }\n        const signer = new SimpleSigner(keyPair);\n        this.signers.set(id, signer);\n        this.signersByPublicKey.set(keyPair.publicKey, signer);\n    }\n    removeKeyPair(id) {\n        const signer = this.signers.get(id);\n        if (signer != null) {\n            this.signers.delete(id);\n            this.signersByPublicKey.delete(signer.publicKey);\n        }\n    }\n    /**\n     * Generate and add a new key\n     *\n     * @returns keyId of the new signer\n     */\n    async withNewKey(f, options = {}) {\n        const newKey = SimpleKeystore.generateKeyPair();\n        const keyId = options.keyId != null ? options.keyId : newKey.publicKey;\n        const keepOnError = options.keepOnError || false;\n        this.addKeyPair(keyId, newKey);\n        return f(keyId)\n            .then(retain => {\n            if (retain === false) {\n                this.removeKeyPair(keyId);\n            }\n            return keyId;\n        })\n            .catch((e) => {\n            if (!keepOnError) {\n                this.removeKeyPair(keyId);\n            }\n            throw e;\n        });\n    }\n    async getSigner(id) {\n        return this.signers.get(id) || this.signersByPublicKey.get(id);\n    }\n}\nexports.SimpleKeystore = SimpleKeystore;\nclass SimpleSigner {\n    constructor(keyPair) {\n        this.keyPair = keyPair;\n        this.publicKey = this.keyPair.publicKey;\n    }\n    async sign(rawData) {\n        return nekoton.ed25519_sign(this.keyPair.secretKey, rawData);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODM3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQva2V5c3RvcmUuanM/NzQzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2ltcGxlS2V5c3RvcmUgPSB2b2lkIDA7XG5jb25zdCBjb3JlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2NvcmVcIikpO1xuY29uc3QgeyBuZWtvdG9uIH0gPSBjb3JlXzEuZGVmYXVsdDtcbi8qKlxuICogQGNhdGVnb3J5IEtleXN0b3JlXG4gKi9cbmNsYXNzIFNpbXBsZUtleXN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihlbnRyaWVzID0ge30pIHtcbiAgICAgICAgdGhpcy5zaWduZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNpZ25lcnNCeVB1YmxpY0tleSA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBbaWQsIHNpZ25lcl0gb2YgT2JqZWN0LmVudHJpZXMoZW50cmllcykpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkS2V5UGFpcihpZCwgc2lnbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2VuZXJhdGVLZXlQYWlyKCkge1xuICAgICAgICByZXR1cm4gbmVrb3Rvbi5lZDI1NTE5X2dlbmVyYXRlS2V5UGFpcigpO1xuICAgIH1cbiAgICBhZGRLZXlQYWlyKGlkT3JLZXlwYWlyLCByZXN0KSB7XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgbGV0IGtleVBhaXI7XG4gICAgICAgIGlmICh0eXBlb2YgaWRPcktleXBhaXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlkID0gaWRPcktleXBhaXI7XG4gICAgICAgICAgICBrZXlQYWlyID0gcmVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gaWRPcktleXBhaXIucHVibGljS2V5O1xuICAgICAgICAgICAga2V5UGFpciA9IGlkT3JLZXlwYWlyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25lciA9IG5ldyBTaW1wbGVTaWduZXIoa2V5UGFpcik7XG4gICAgICAgIHRoaXMuc2lnbmVycy5zZXQoaWQsIHNpZ25lcik7XG4gICAgICAgIHRoaXMuc2lnbmVyc0J5UHVibGljS2V5LnNldChrZXlQYWlyLnB1YmxpY0tleSwgc2lnbmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlS2V5UGFpcihpZCkge1xuICAgICAgICBjb25zdCBzaWduZXIgPSB0aGlzLnNpZ25lcnMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKHNpZ25lciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNpZ25lcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIHRoaXMuc2lnbmVyc0J5UHVibGljS2V5LmRlbGV0ZShzaWduZXIucHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbmQgYWRkIGEgbmV3IGtleVxuICAgICAqXG4gICAgICogQHJldHVybnMga2V5SWQgb2YgdGhlIG5ldyBzaWduZXJcbiAgICAgKi9cbiAgICBhc3luYyB3aXRoTmV3S2V5KGYsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBuZXdLZXkgPSBTaW1wbGVLZXlzdG9yZS5nZW5lcmF0ZUtleVBhaXIoKTtcbiAgICAgICAgY29uc3Qga2V5SWQgPSBvcHRpb25zLmtleUlkICE9IG51bGwgPyBvcHRpb25zLmtleUlkIDogbmV3S2V5LnB1YmxpY0tleTtcbiAgICAgICAgY29uc3Qga2VlcE9uRXJyb3IgPSBvcHRpb25zLmtlZXBPbkVycm9yIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmFkZEtleVBhaXIoa2V5SWQsIG5ld0tleSk7XG4gICAgICAgIHJldHVybiBmKGtleUlkKVxuICAgICAgICAgICAgLnRoZW4ocmV0YWluID0+IHtcbiAgICAgICAgICAgIGlmIChyZXRhaW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVLZXlQYWlyKGtleUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXlJZDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFrZWVwT25FcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlS2V5UGFpcihrZXlJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2lnbmVyKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25lcnMuZ2V0KGlkKSB8fCB0aGlzLnNpZ25lcnNCeVB1YmxpY0tleS5nZXQoaWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2ltcGxlS2V5c3RvcmUgPSBTaW1wbGVLZXlzdG9yZTtcbmNsYXNzIFNpbXBsZVNpZ25lciB7XG4gICAgY29uc3RydWN0b3Ioa2V5UGFpcikge1xuICAgICAgICB0aGlzLmtleVBhaXIgPSBrZXlQYWlyO1xuICAgICAgICB0aGlzLnB1YmxpY0tleSA9IHRoaXMua2V5UGFpci5wdWJsaWNLZXk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ24ocmF3RGF0YSkge1xuICAgICAgICByZXR1cm4gbmVrb3Rvbi5lZDI1NTE5X3NpZ24odGhpcy5rZXlQYWlyLnNlY3JldEtleSwgcmF3RGF0YSk7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///837\n')},344:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getUniqueId = exports.convertVersionToInt32 = exports.SafeEventEmitter = void 0;\nconst events_1 = __webpack_require__(187);\nfunction safeApply(handler, context, args) {\n    try {\n        Reflect.apply(handler, context, args);\n    }\n    catch (err) {\n        // Throw error after timeout so as not to interrupt the stack\n        setTimeout(() => {\n            throw err;\n        });\n    }\n}\nfunction arrayClone(arr) {\n    const n = arr.length;\n    const copy = new Array(n);\n    for (let i = 0; i < n; i += 1) {\n        copy[i] = arr[i];\n    }\n    return copy;\n}\nclass SafeEventEmitter extends events_1.EventEmitter {\n    emit(type, ...args) {\n        let doError = type === 'error';\n        const events = this._events;\n        if (events !== undefined) {\n            doError = doError && events.error === undefined;\n        }\n        else if (!doError) {\n            return false;\n        }\n        if (doError) {\n            let er;\n            if (args.length > 0) {\n                ;\n                [er] = args;\n            }\n            if (er instanceof Error) {\n                throw er;\n            }\n            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);\n            err.context = er;\n            throw err;\n        }\n        const handler = events[type];\n        if (handler === undefined) {\n            return false;\n        }\n        if (typeof handler === 'function') {\n            safeApply(handler, this, args);\n        }\n        else {\n            const len = handler.length;\n            const listeners = arrayClone(handler);\n            for (let i = 0; i < len; i += 1) {\n                safeApply(listeners[i], this, args);\n            }\n        }\n        return true;\n    }\n}\nexports.SafeEventEmitter = SafeEventEmitter;\n/**\n * @category Utils\n */\nconst convertVersionToInt32 = (version) => {\n    const parts = version.split('.');\n    if (parts.length !== 3) {\n        throw new Error('Received invalid version string');\n    }\n    parts.forEach((part) => {\n        if (~~part > 999) {\n            throw new Error(`Version string invalid, ${part} is too large`);\n        }\n    });\n    let multiplier = 1000000;\n    let numericVersion = 0;\n    for (let i = 0; i < 3; i++) {\n        numericVersion += ~~parts[i] * multiplier;\n        multiplier /= 1000;\n    }\n    return numericVersion;\n};\nexports.convertVersionToInt32 = convertVersionToInt32;\nconst MAX = 4294967295;\nlet idCounter = Math.floor(Math.random() * MAX);\nfunction getUniqueId() {\n    idCounter = (idCounter + 1) % MAX;\n    return idCounter;\n}\nexports.getUniqueId = getUniqueId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvdXRpbHMuanM/ZWYyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0VW5pcXVlSWQgPSBleHBvcnRzLmNvbnZlcnRWZXJzaW9uVG9JbnQzMiA9IGV4cG9ydHMuU2FmZUV2ZW50RW1pdHRlciA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmZ1bmN0aW9uIHNhZmVBcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgUmVmbGVjdC5hcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBUaHJvdyBlcnJvciBhZnRlciB0aW1lb3V0IHNvIGFzIG5vdCB0byBpbnRlcnJ1cHQgdGhlIHN0YWNrXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcnJheUNsb25lKGFycikge1xuICAgIGNvbnN0IG4gPSBhcnIubGVuZ3RoO1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpICs9IDEpIHtcbiAgICAgICAgY29weVtpXSA9IGFycltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5jbGFzcyBTYWZlRXZlbnRFbWl0dGVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBlbWl0KHR5cGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGRvRXJyb3IgPSB0eXBlID09PSAnZXJyb3InO1xuICAgICAgICBjb25zdCBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICAgIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZG9FcnJvciA9IGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRvRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9FcnJvcikge1xuICAgICAgICAgICAgbGV0IGVyO1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBbZXJdID0gYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYFVuaGFuZGxlZCBlcnJvci4ke2VyID8gYCAoJHtlci5tZXNzYWdlfSlgIDogJyd9YCk7XG4gICAgICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG4gICAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNhZmVBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBzYWZlQXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLlNhZmVFdmVudEVtaXR0ZXIgPSBTYWZlRXZlbnRFbWl0dGVyO1xuLyoqXG4gKiBAY2F0ZWdvcnkgVXRpbHNcbiAqL1xuY29uc3QgY29udmVydFZlcnNpb25Ub0ludDMyID0gKHZlcnNpb24pID0+IHtcbiAgICBjb25zdCBwYXJ0cyA9IHZlcnNpb24uc3BsaXQoJy4nKTtcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVjZWl2ZWQgaW52YWxpZCB2ZXJzaW9uIHN0cmluZycpO1xuICAgIH1cbiAgICBwYXJ0cy5mb3JFYWNoKChwYXJ0KSA9PiB7XG4gICAgICAgIGlmICh+fnBhcnQgPiA5OTkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmVyc2lvbiBzdHJpbmcgaW52YWxpZCwgJHtwYXJ0fSBpcyB0b28gbGFyZ2VgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBtdWx0aXBsaWVyID0gMTAwMDAwMDtcbiAgICBsZXQgbnVtZXJpY1ZlcnNpb24gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIG51bWVyaWNWZXJzaW9uICs9IH5+cGFydHNbaV0gKiBtdWx0aXBsaWVyO1xuICAgICAgICBtdWx0aXBsaWVyIC89IDEwMDA7XG4gICAgfVxuICAgIHJldHVybiBudW1lcmljVmVyc2lvbjtcbn07XG5leHBvcnRzLmNvbnZlcnRWZXJzaW9uVG9JbnQzMiA9IGNvbnZlcnRWZXJzaW9uVG9JbnQzMjtcbmNvbnN0IE1BWCA9IDQyOTQ5NjcyOTU7XG5sZXQgaWRDb3VudGVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTUFYKTtcbmZ1bmN0aW9uIGdldFVuaXF1ZUlkKCkge1xuICAgIGlkQ291bnRlciA9IChpZENvdW50ZXIgKyAxKSAlIE1BWDtcbiAgICByZXR1cm4gaWRDb3VudGVyO1xufVxuZXhwb3J0cy5nZXRVbmlxdWVJZCA9IGdldFVuaXF1ZUlkO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///344\n")},521:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst core = {\n    ensureNekotonLoaded: undefined,\n    nekoton: undefined,\n    fetch: undefined,\n    fetchAgent: () => undefined,\n    debugLog: undefined,\n};\nexports.default = core;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jb3JlLmpzP2M5ODQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb3JlID0ge1xuICAgIGVuc3VyZU5la290b25Mb2FkZWQ6IHVuZGVmaW5lZCxcbiAgICBuZWtvdG9uOiB1bmRlZmluZWQsXG4gICAgZmV0Y2g6IHVuZGVmaW5lZCxcbiAgICBmZXRjaEFnZW50OiAoKSA9PiB1bmRlZmluZWQsXG4gICAgZGVidWdMb2c6IHVuZGVmaW5lZCxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBjb3JlO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///521\n')},91:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst nekoton_wasm_1 = __importStar(__webpack_require__(559)), nt = nekoton_wasm_1;\nconst core_1 = __importDefault(__webpack_require__(521));\nlet clientInitializationStarted = false;\nlet notifyClientInitialized;\nconst initializationPromise = new Promise((resolve, reject) => {\n    notifyClientInitialized = { resolve, reject };\n});\ncore_1.default.ensureNekotonLoaded = (initInput) => {\n    if (!clientInitializationStarted) {\n        clientInitializationStarted = true;\n        (0, nekoton_wasm_1.default)(initInput).then(notifyClientInitialized.resolve).catch(notifyClientInitialized.reject);\n    }\n    return initializationPromise;\n};\ncore_1.default.nekoton = nt;\ncore_1.default.fetch = fetch;\ncore_1.default.debugLog = console.debug;\n__exportStar(__webpack_require__(637), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2luZGV4LmpzPzBlNzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBuZWtvdG9uX3dhc21fMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibmVrb3Rvbi13YXNtXCIpKSwgbnQgPSBuZWtvdG9uX3dhc21fMTtcbmNvbnN0IGNvcmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb3JlXCIpKTtcbmxldCBjbGllbnRJbml0aWFsaXphdGlvblN0YXJ0ZWQgPSBmYWxzZTtcbmxldCBub3RpZnlDbGllbnRJbml0aWFsaXplZDtcbmNvbnN0IGluaXRpYWxpemF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBub3RpZnlDbGllbnRJbml0aWFsaXplZCA9IHsgcmVzb2x2ZSwgcmVqZWN0IH07XG59KTtcbmNvcmVfMS5kZWZhdWx0LmVuc3VyZU5la290b25Mb2FkZWQgPSAoaW5pdElucHV0KSA9PiB7XG4gICAgaWYgKCFjbGllbnRJbml0aWFsaXphdGlvblN0YXJ0ZWQpIHtcbiAgICAgICAgY2xpZW50SW5pdGlhbGl6YXRpb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgKDAsIG5la290b25fd2FzbV8xLmRlZmF1bHQpKGluaXRJbnB1dCkudGhlbihub3RpZnlDbGllbnRJbml0aWFsaXplZC5yZXNvbHZlKS5jYXRjaChub3RpZnlDbGllbnRJbml0aWFsaXplZC5yZWplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25Qcm9taXNlO1xufTtcbmNvcmVfMS5kZWZhdWx0Lm5la290b24gPSBudDtcbmNvcmVfMS5kZWZhdWx0LmZldGNoID0gZmV0Y2g7XG5jb3JlXzEuZGVmYXVsdC5kZWJ1Z0xvZyA9IGNvbnNvbGUuZGVidWc7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2xpZW50XCIpLCBleHBvcnRzKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///91\n')},445:module=>{eval("module.exports = stringify\nstringify.default = stringify\nstringify.stable = deterministicStringify\nstringify.stableStringify = deterministicStringify\n\nvar LIMIT_REPLACE_NODE = '[...]'\nvar CIRCULAR_REPLACE_NODE = '[Circular]'\n\nvar arr = []\nvar replacerStack = []\n\nfunction defaultOptions () {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER\n  }\n}\n\n// Regular stringify\nfunction stringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  decirc(obj, '', 0, [], undefined, 0, options)\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer)\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction setReplace (replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, { value: replace })\n      arr.push([parent, k, val, propertyDescriptor])\n    } else {\n      replacerStack.push([val, k, replace])\n    }\n  } else {\n    parent[k] = replace\n    arr.push([parent, k, val])\n  }\n}\n\nfunction decirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      var keys = Object.keys(val)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        decirc(val[key], key, i, stack, val, depth, options)\n      }\n    }\n    stack.pop()\n  }\n}\n\n// Stable-stringify\nfunction compareFunction (a, b) {\n  if (a < b) {\n    return -1\n  }\n  if (a > b) {\n    return 1\n  }\n  return 0\n}\n\nfunction deterministicStringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer)\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n    try {\n      if (typeof val.toJSON === 'function') {\n        return\n      }\n    } catch (_) {\n      return\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {}\n      var keys = Object.keys(val).sort(compareFunction)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        deterministicDecirc(val[key], key, i, stack, val, depth, options)\n        tmp[key] = val[key]\n      }\n      if (typeof parent !== 'undefined') {\n        arr.push([parent, k, val])\n        parent[k] = tmp\n      } else {\n        return tmp\n      }\n    }\n    stack.pop()\n  }\n}\n\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues (replacer) {\n  replacer =\n    typeof replacer !== 'undefined'\n      ? replacer\n      : function (k, v) {\n        return v\n      }\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i]\n        if (part[1] === key && part[0] === val) {\n          val = part[2]\n          replacerStack.splice(i, 1)\n          break\n        }\n      }\n    }\n    return replacer.call(this, key, val)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2Zhc3Qtc2FmZS1zdHJpbmdpZnkvaW5kZXguanM/ZTVlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHN0cmluZ2lmeVxuc3RyaW5naWZ5LmRlZmF1bHQgPSBzdHJpbmdpZnlcbnN0cmluZ2lmeS5zdGFibGUgPSBkZXRlcm1pbmlzdGljU3RyaW5naWZ5XG5zdHJpbmdpZnkuc3RhYmxlU3RyaW5naWZ5ID0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeVxuXG52YXIgTElNSVRfUkVQTEFDRV9OT0RFID0gJ1suLi5dJ1xudmFyIENJUkNVTEFSX1JFUExBQ0VfTk9ERSA9ICdbQ2lyY3VsYXJdJ1xuXG52YXIgYXJyID0gW11cbnZhciByZXBsYWNlclN0YWNrID0gW11cblxuZnVuY3Rpb24gZGVmYXVsdE9wdGlvbnMgKCkge1xuICByZXR1cm4ge1xuICAgIGRlcHRoTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgIGVkZ2VzTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gIH1cbn1cblxuLy8gUmVndWxhciBzdHJpbmdpZnlcbmZ1bmN0aW9uIHN0cmluZ2lmeSAob2JqLCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKVxuICB9XG5cbiAgZGVjaXJjKG9iaiwgJycsIDAsIFtdLCB1bmRlZmluZWQsIDAsIG9wdGlvbnMpXG4gIHZhciByZXNcbiAgdHJ5IHtcbiAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlcilcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlR2V0dGVyVmFsdWVzKHJlcGxhY2VyKSwgc3BhY2VyKVxuICAgIH1cbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSgnW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXScpXG4gIH0gZmluYWxseSB7XG4gICAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpXG4gICAgICBpZiAocGFydC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnRbMF0sIHBhcnRbMV0sIHBhcnRbM10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHNldFJlcGxhY2UgKHJlcGxhY2UsIHZhbCwgaywgcGFyZW50KSB7XG4gIHZhciBwcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgaylcbiAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyZW50LCBrLCB7IHZhbHVlOiByZXBsYWNlIH0pXG4gICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWwsIHByb3BlcnR5RGVzY3JpcHRvcl0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGxhY2VyU3RhY2sucHVzaChbdmFsLCBrLCByZXBsYWNlXSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50W2tdID0gcmVwbGFjZVxuICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVjaXJjICh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgZGVwdGggKz0gMVxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RhY2tbaV0gPT09IHZhbCkge1xuICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBkZXB0aCA+IG9wdGlvbnMuZGVwdGhMaW1pdFxuICAgICkge1xuICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMuZWRnZXNMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGVkZ2VJbmRleCArIDEgPiBvcHRpb25zLmVkZ2VzTGltaXRcbiAgICApIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHN0YWNrLnB1c2godmFsKVxuICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVjaXJjKHZhbFtpXSwgaSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgICAgZGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKVxuICB9XG59XG5cbi8vIFN0YWJsZS1zdHJpbmdpZnlcbmZ1bmN0aW9uIGNvbXBhcmVGdW5jdGlvbiAoYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMVxuICB9XG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNTdHJpbmdpZnkgKG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKClcbiAgfVxuXG4gIHZhciB0bXAgPSBkZXRlcm1pbmlzdGljRGVjaXJjKG9iaiwgJycsIDAsIFtdLCB1bmRlZmluZWQsIDAsIG9wdGlvbnMpIHx8IG9ialxuICB2YXIgcmVzXG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VyLCBzcGFjZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KHRtcCwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcilcbiAgICB9XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJ1t1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV0nKVxuICB9IGZpbmFsbHkge1xuICAgIC8vIEVuc3VyZSB0aGF0IHdlIHJlc3RvcmUgdGhlIG9iamVjdCBhcyBpdCB3YXMuXG4gICAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpXG4gICAgICBpZiAocGFydC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnRbMF0sIHBhcnRbMV0sIHBhcnRbM10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNEZWNpcmMgKHZhbCwgaywgZWRnZUluZGV4LCBzdGFjaywgcGFyZW50LCBkZXB0aCwgb3B0aW9ucykge1xuICBkZXB0aCArPSAxXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgIHNldFJlcGxhY2UoQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHZhbC50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGRlcHRoID4gb3B0aW9ucy5kZXB0aExpbWl0XG4gICAgKSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgZWRnZUluZGV4ICsgMSA+IG9wdGlvbnMuZWRnZXNMaW1pdFxuICAgICkge1xuICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc3RhY2sucHVzaCh2YWwpXG4gICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtpXSwgaSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBvYmplY3QgaW4gdGhlIHJlcXVpcmVkIHdheVxuICAgICAgdmFyIHRtcCA9IHt9XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCkuc29ydChjb21wYXJlRnVuY3Rpb24pXG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxuICAgICAgICB0bXBba2V5XSA9IHZhbFtrZXldXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhcmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSlcbiAgICAgICAgcGFyZW50W2tdID0gdG1wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG1wXG4gICAgICB9XG4gICAgfVxuICAgIHN0YWNrLnBvcCgpXG4gIH1cbn1cblxuLy8gd3JhcHMgcmVwbGFjZXIgZnVuY3Rpb24gdG8gaGFuZGxlIHZhbHVlcyB3ZSBjb3VsZG4ndCByZXBsYWNlXG4vLyBhbmQgbWFyayB0aGVtIGFzIHJlcGxhY2VkIHZhbHVlXG5mdW5jdGlvbiByZXBsYWNlR2V0dGVyVmFsdWVzIChyZXBsYWNlcikge1xuICByZXBsYWNlciA9XG4gICAgdHlwZW9mIHJlcGxhY2VyICE9PSAndW5kZWZpbmVkJ1xuICAgICAgPyByZXBsYWNlclxuICAgICAgOiBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICByZXR1cm4gdlxuICAgICAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBsYWNlclN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcmVwbGFjZXJTdGFja1tpXVxuICAgICAgICBpZiAocGFydFsxXSA9PT0ga2V5ICYmIHBhcnRbMF0gPT09IHZhbCkge1xuICAgICAgICAgIHZhbCA9IHBhcnRbMl1cbiAgICAgICAgICByZXBsYWNlclN0YWNrLnNwbGljZShpLCAxKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWwpXG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///445\n")},559:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "checkAddress": () => (/* binding */ checkAddress),\n/* harmony export */   "repackAddress": () => (/* binding */ repackAddress),\n/* harmony export */   "runLocal": () => (/* binding */ runLocal),\n/* harmony export */   "makeFullAccountBoc": () => (/* binding */ makeFullAccountBoc),\n/* harmony export */   "parseFullAccountBoc": () => (/* binding */ parseFullAccountBoc),\n/* harmony export */   "executeLocal": () => (/* binding */ executeLocal),\n/* harmony export */   "getExpectedAddress": () => (/* binding */ getExpectedAddress),\n/* harmony export */   "getBocHash": () => (/* binding */ getBocHash),\n/* harmony export */   "packIntoCell": () => (/* binding */ packIntoCell),\n/* harmony export */   "unpackFromCell": () => (/* binding */ unpackFromCell),\n/* harmony export */   "extractContractData": () => (/* binding */ extractContractData),\n/* harmony export */   "extractPublicKey": () => (/* binding */ extractPublicKey),\n/* harmony export */   "codeToTvc": () => (/* binding */ codeToTvc),\n/* harmony export */   "mergeTvc": () => (/* binding */ mergeTvc),\n/* harmony export */   "splitTvc": () => (/* binding */ splitTvc),\n/* harmony export */   "setCodeSalt": () => (/* binding */ setCodeSalt),\n/* harmony export */   "getCodeSalt": () => (/* binding */ getCodeSalt),\n/* harmony export */   "encodeInternalInput": () => (/* binding */ encodeInternalInput),\n/* harmony export */   "encodeInternalMessage": () => (/* binding */ encodeInternalMessage),\n/* harmony export */   "decodeInput": () => (/* binding */ decodeInput),\n/* harmony export */   "decodeEvent": () => (/* binding */ decodeEvent),\n/* harmony export */   "decodeOutput": () => (/* binding */ decodeOutput),\n/* harmony export */   "decodeTransaction": () => (/* binding */ decodeTransaction),\n/* harmony export */   "decodeTransactionEvents": () => (/* binding */ decodeTransactionEvents),\n/* harmony export */   "getDataHash": () => (/* binding */ getDataHash),\n/* harmony export */   "ed25519_generateKeyPair": () => (/* binding */ ed25519_generateKeyPair),\n/* harmony export */   "ed25519_sign": () => (/* binding */ ed25519_sign),\n/* harmony export */   "extendSignature": () => (/* binding */ extendSignature),\n/* harmony export */   "verifySignature": () => (/* binding */ verifySignature),\n/* harmony export */   "createRawExternalMessage": () => (/* binding */ createRawExternalMessage),\n/* harmony export */   "createExternalMessageWithoutSignature": () => (/* binding */ createExternalMessageWithoutSignature),\n/* harmony export */   "createExternalMessage": () => (/* binding */ createExternalMessage),\n/* harmony export */   "ClockWithOffset": () => (/* binding */ ClockWithOffset),\n/* harmony export */   "GenericContract": () => (/* binding */ GenericContract),\n/* harmony export */   "GqlConnection": () => (/* binding */ GqlConnection),\n/* harmony export */   "GqlQuery": () => (/* binding */ GqlQuery),\n/* harmony export */   "JrpcConnection": () => (/* binding */ JrpcConnection),\n/* harmony export */   "JrpcQuery": () => (/* binding */ JrpcQuery),\n/* harmony export */   "Transport": () => (/* binding */ Transport),\n/* harmony export */   "UnsignedMessage": () => (/* binding */ UnsignedMessage),\n/* harmony export */   "initSync": () => (/* binding */ initSync),\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n\nlet wasm;\n\nconst cachedTextDecoder = new TextDecoder(\'utf-8\', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = new Uint8Array();\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedFloat64Memory0 = new Float64Array();\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nlet cachedInt32Memory0 = new Int32Array();\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = new TextEncoder(\'utf-8\');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === \'function\'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == \'number\' || type == \'boolean\' || val == null) {\n        return  `${val}`;\n    }\n    if (type == \'string\') {\n        return `"${val}"`;\n    }\n    if (type == \'symbol\') {\n        const description = val.description;\n        if (description == null) {\n            return \'Symbol\';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == \'function\') {\n        const name = val.name;\n        if (typeof name == \'string\' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return \'Function\';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = \'[\';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += \', \' + debugString(val[i]);\n        }\n        debug += \']\';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard \'[object ClassName]\'\n        return toString.call(val);\n    }\n    if (className == \'Object\') {\n        // we\'re a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return \'Object(\' + JSON.stringify(val) + \')\';\n        } catch (_) {\n            return \'Object\';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won\'t\n        // be deallocated while we\'re invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);\n\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_32(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hcb77729c6af9d376(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n/**\n* @param {string} address\n* @returns {boolean}\n*/\nfunction checkAddress(address) {\n    const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.checkAddress(ptr0, len0);\n    return ret !== 0;\n}\n\n/**\n* @param {string} address\n* @returns {string}\n*/\nfunction repackAddress(address) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.repackAddress(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {ClockWithOffset} clock\n* @param {string} account_stuff_boc\n* @param {string} contract_abi\n* @param {string} method\n* @param {TokensObject} input\n* @param {boolean} responsible\n* @returns {ExecutionOutput}\n*/\nfunction runLocal(clock, account_stuff_boc, contract_abi, method, input, responsible) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(clock, ClockWithOffset);\n        const ptr0 = passStringToWasm0(account_stuff_boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(method, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        wasm.runLocal(retptr, clock.ptr, ptr0, len0, ptr1, len1, ptr2, len2, addHeapObject(input), responsible);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} account_stuff_boc\n* @returns {string}\n*/\nfunction makeFullAccountBoc(account_stuff_boc) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(account_stuff_boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.makeFullAccountBoc(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {string} account\n* @returns {FullContractState | undefined}\n*/\nfunction parseFullAccountBoc(account) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(account, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.parseFullAccountBoc(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} config\n* @param {string} account\n* @param {string} message\n* @param {number} utime\n* @param {boolean} disable_signature_check\n* @returns {TransactionExecutorOutput}\n*/\nfunction executeLocal(config, account, message, utime, disable_signature_check) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(config, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(account, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        wasm.executeLocal(retptr, ptr0, len0, ptr1, len1, ptr2, len2, utime, disable_signature_check);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} tvc\n* @param {string} contract_abi\n* @param {number} workchain_id\n* @param {string | undefined} public_key\n* @param {TokensObject} init_data\n* @returns {ExpectedAddress}\n*/\nfunction getExpectedAddress(tvc, contract_abi, workchain_id, public_key, init_data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(tvc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(public_key) ? 0 : passStringToWasm0(public_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        wasm.getExpectedAddress(retptr, ptr0, len0, ptr1, len1, workchain_id, ptr2, len2, addHeapObject(init_data));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} boc\n* @returns {string}\n*/\nfunction getBocHash(boc) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.getBocHash(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {Array<AbiParam>} params\n* @param {TokensObject} tokens\n* @param {string | undefined} abi_version\n* @returns {string}\n*/\nfunction packIntoCell(params, tokens, abi_version) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = isLikeNone(abi_version) ? 0 : passStringToWasm0(abi_version, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.packIntoCell(retptr, addHeapObject(params), addHeapObject(tokens), ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {Array<AbiParam>} params\n* @param {string} boc\n* @param {boolean} allow_partial\n* @param {string | undefined} abi_version\n* @returns {TokensObject}\n*/\nfunction unpackFromCell(params, boc, allow_partial, abi_version) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(abi_version) ? 0 : passStringToWasm0(abi_version, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        wasm.unpackFromCell(retptr, addHeapObject(params), ptr0, len0, allow_partial, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} boc\n* @returns {string | undefined}\n*/\nfunction extractContractData(boc) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.extractContractData(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        let v1;\n        if (r0 !== 0) {\n            v1 = getStringFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n        }\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} boc\n* @returns {string}\n*/\nfunction extractPublicKey(boc) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.extractPublicKey(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {string} code\n* @returns {string}\n*/\nfunction codeToTvc(code) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.codeToTvc(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {string} code\n* @param {string} data\n* @returns {string}\n*/\nfunction mergeTvc(code, data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.mergeTvc(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr2 = r0;\n        var len2 = r1;\n        if (r3) {\n            ptr2 = 0; len2 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr2, len2);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr2, len2);\n    }\n}\n\n/**\n* @param {string} tvc\n* @returns {StateInit}\n*/\nfunction splitTvc(tvc) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(tvc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.splitTvc(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} code\n* @param {string} salt\n* @returns {string}\n*/\nfunction setCodeSalt(code, salt) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(salt, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.setCodeSalt(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr2 = r0;\n        var len2 = r1;\n        if (r3) {\n            ptr2 = 0; len2 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr2, len2);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr2, len2);\n    }\n}\n\n/**\n* @param {string} code\n* @returns {string | undefined}\n*/\nfunction getCodeSalt(code) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.getCodeSalt(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        let v1;\n        if (r0 !== 0) {\n            v1 = getStringFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n        }\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} contract_abi\n* @param {string} method\n* @param {TokensObject} input\n* @returns {string}\n*/\nfunction encodeInternalInput(contract_abi, method, input) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(method, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.encodeInternalInput(retptr, ptr0, len0, ptr1, len1, addHeapObject(input));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr2 = r0;\n        var len2 = r1;\n        if (r3) {\n            ptr2 = 0; len2 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr2, len2);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr2, len2);\n    }\n}\n\n/**\n* @param {string | undefined} src\n* @param {string} dst\n* @param {boolean} bounce\n* @param {string | undefined} state_init\n* @param {string | undefined} body\n* @param {string} amount\n* @returns {string}\n*/\nfunction encodeInternalMessage(src, dst, bounce, state_init, body, amount) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = isLikeNone(src) ? 0 : passStringToWasm0(src, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(dst, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(state_init) ? 0 : passStringToWasm0(state_init, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        var ptr3 = isLikeNone(body) ? 0 : passStringToWasm0(body, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len3 = WASM_VECTOR_LEN;\n        const ptr4 = passStringToWasm0(amount, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len4 = WASM_VECTOR_LEN;\n        wasm.encodeInternalMessage(retptr, ptr0, len0, ptr1, len1, bounce, ptr2, len2, ptr3, len3, ptr4, len4);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr5 = r0;\n        var len5 = r1;\n        if (r3) {\n            ptr5 = 0; len5 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr5, len5);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr5, len5);\n    }\n}\n\n/**\n* @param {string} message_body\n* @param {string} contract_abi\n* @param {MethodName} method\n* @param {boolean} internal\n* @returns {DecodedInput | undefined}\n*/\nfunction decodeInput(message_body, contract_abi, method, internal) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(message_body, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.decodeInput(retptr, ptr0, len0, ptr1, len1, addHeapObject(method), internal);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} message_body\n* @param {string} contract_abi\n* @param {MethodName} event\n* @returns {DecodedEvent | undefined}\n*/\nfunction decodeEvent(message_body, contract_abi, event) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(message_body, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.decodeEvent(retptr, ptr0, len0, ptr1, len1, addHeapObject(event));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} message_body\n* @param {string} contract_abi\n* @param {MethodName} method\n* @returns {DecodedOutput | undefined}\n*/\nfunction decodeOutput(message_body, contract_abi, method) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(message_body, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.decodeOutput(retptr, ptr0, len0, ptr1, len1, addHeapObject(method));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {Transaction} transaction\n* @param {string} contract_abi\n* @param {MethodName} method\n* @returns {DecodedTransaction | undefined}\n*/\nfunction decodeTransaction(transaction, contract_abi, method) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.decodeTransaction(retptr, addHeapObject(transaction), ptr0, len0, addHeapObject(method));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {Transaction} transaction\n* @param {string} contract_abi\n* @returns {DecodedTransactionEvents}\n*/\nfunction decodeTransactionEvents(transaction, contract_abi) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.decodeTransactionEvents(retptr, addHeapObject(transaction), ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} data\n* @returns {string}\n*/\nfunction getDataHash(data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.getDataHash(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @returns {Ed25519KeyPair}\n*/\nfunction ed25519_generateKeyPair() {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.ed25519_generateKeyPair(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} secret_key\n* @param {string} data\n* @returns {string}\n*/\nfunction ed25519_sign(secret_key, data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(secret_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.ed25519_sign(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr2 = r0;\n        var len2 = r1;\n        if (r3) {\n            ptr2 = 0; len2 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr2, len2);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr2, len2);\n    }\n}\n\n/**\n* @param {string} signature\n* @returns {ExtendedSignature}\n*/\nfunction extendSignature(signature) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(signature, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.extendSignature(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} public_key\n* @param {string} data\n* @param {string} signature\n* @returns {boolean}\n*/\nfunction verifySignature(public_key, data, signature) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(public_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(signature, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        wasm.verifySignature(retptr, ptr0, len0, ptr1, len1, ptr2, len2);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return r0 !== 0;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} dst\n* @param {string | undefined} state_init\n* @param {string | undefined} body\n* @param {number} expire_at\n* @returns {SignedMessage}\n*/\nfunction createRawExternalMessage(dst, state_init, body, expire_at) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(dst, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(state_init) ? 0 : passStringToWasm0(state_init, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(body) ? 0 : passStringToWasm0(body, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        wasm.createRawExternalMessage(retptr, ptr0, len0, ptr1, len1, ptr2, len2, expire_at);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {ClockWithOffset} clock\n* @param {string} dst\n* @param {string} contract_abi\n* @param {string} method\n* @param {string | undefined} state_init\n* @param {TokensObject} input\n* @param {number} timeout\n* @returns {SignedMessage}\n*/\nfunction createExternalMessageWithoutSignature(clock, dst, contract_abi, method, state_init, input, timeout) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(clock, ClockWithOffset);\n        const ptr0 = passStringToWasm0(dst, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(method, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        var ptr3 = isLikeNone(state_init) ? 0 : passStringToWasm0(state_init, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len3 = WASM_VECTOR_LEN;\n        wasm.createExternalMessageWithoutSignature(retptr, clock.ptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, addHeapObject(input), timeout);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {ClockWithOffset} clock\n* @param {string} dst\n* @param {string} contract_abi\n* @param {string} method\n* @param {string | undefined} state_init\n* @param {TokensObject} input\n* @param {string} public_key\n* @param {number} timeout\n* @returns {UnsignedMessage}\n*/\nfunction createExternalMessage(clock, dst, contract_abi, method, state_init, input, public_key, timeout) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(clock, ClockWithOffset);\n        const ptr0 = passStringToWasm0(dst, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(method, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        var ptr3 = isLikeNone(state_init) ? 0 : passStringToWasm0(state_init, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len3 = WASM_VECTOR_LEN;\n        const ptr4 = passStringToWasm0(public_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len4 = WASM_VECTOR_LEN;\n        wasm.createExternalMessage(retptr, clock.ptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, addHeapObject(input), ptr4, len4, timeout);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return UnsignedMessage.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\nfunction __wbg_adapter_163(arg0, arg1, arg2, arg3) {\n    wasm.wasm_bindgen__convert__closures__invoke2_mut__hecba896d1563d223(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\n/**\n*/\nclass ClockWithOffset {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ClockWithOffset.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_clockwithoffset_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.clockwithoffset_new();\n        return ClockWithOffset.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    get nowMs() {\n        const ret = wasm.clockwithoffset_nowMs(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} offset_ms\n    */\n    updateOffset(offset_ms) {\n        wasm.clockwithoffset_updateOffset(this.ptr, offset_ms);\n    }\n    /**\n    * @returns {number}\n    */\n    offsetMs() {\n        const ret = wasm.clockwithoffset_offsetMs(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nclass GenericContract {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenericContract.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genericcontract_free(ptr);\n    }\n    /**\n    * @returns {string}\n    */\n    get address() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genericcontract_address(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {SignedMessage} message\n    * @returns {Promise<Transaction>}\n    */\n    sendMessageLocally(message) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genericcontract_sendMessageLocally(retptr, this.ptr, addHeapObject(message));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {SignedMessage} message\n    * @returns {Promise<PendingTransaction>}\n    */\n    sendMessage(message) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genericcontract_sendMessage(retptr, this.ptr, addHeapObject(message));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Promise<void>}\n    */\n    refresh() {\n        const ret = wasm.genericcontract_refresh(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} block_id\n    * @returns {Promise<void>}\n    */\n    handleBlock(block_id) {\n        const ptr0 = passStringToWasm0(block_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.genericcontract_handleBlock(this.ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} lt\n    * @returns {Promise<void>}\n    */\n    preloadTransactions(lt) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(lt, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.genericcontract_preloadTransactions(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {PollingMethod}\n    */\n    get pollingMethod() {\n        const ret = wasm.genericcontract_pollingMethod(this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n*/\nclass GqlConnection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GqlConnection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_gqlconnection_free(ptr);\n    }\n    /**\n    * @param {ClockWithOffset} clock\n    * @param {IGqlSender} sender\n    */\n    constructor(clock, sender) {\n        _assertClass(clock, ClockWithOffset);\n        const ret = wasm.gqlconnection_new(clock.ptr, addHeapObject(sender));\n        return GqlConnection.__wrap(ret);\n    }\n    /**\n    * @param {string} address\n    * @returns {Promise<LatestBlock>}\n    */\n    getLatestBlock(address) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.gqlconnection_getLatestBlock(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} current_block_id\n    * @param {string} address\n    * @param {number} timeout\n    * @returns {Promise<string>}\n    */\n    waitForNextBlock(current_block_id, address, timeout) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(current_block_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.gqlconnection_waitForNextBlock(retptr, this.ptr, ptr0, len0, ptr1, len1, timeout);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass GqlQuery {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GqlQuery.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_gqlquery_free(ptr);\n    }\n    /**\n    * @param {string} data\n    */\n    onReceive(data) {\n        const ptr = this.__destroy_into_raw();\n        const ptr0 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.gqlquery_onReceive(ptr, ptr0, len0);\n    }\n    /**\n    * @param {any} arg0\n    */\n    onError(arg0) {\n        const ptr = this.__destroy_into_raw();\n        wasm.gqlquery_onError(ptr, addHeapObject(arg0));\n    }\n    /**\n    */\n    onTimeout() {\n        const ptr = this.__destroy_into_raw();\n        wasm.gqlquery_onTimeout(ptr);\n    }\n}\n/**\n*/\nclass JrpcConnection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(JrpcConnection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jrpcconnection_free(ptr);\n    }\n    /**\n    * @param {ClockWithOffset} clock\n    * @param {any} sender\n    */\n    constructor(clock, sender) {\n        _assertClass(clock, ClockWithOffset);\n        const ret = wasm.jrpcconnection_new(clock.ptr, addHeapObject(sender));\n        return JrpcConnection.__wrap(ret);\n    }\n}\n/**\n*/\nclass JrpcQuery {\n\n    static __wrap(ptr) {\n        const obj = Object.create(JrpcQuery.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jrpcquery_free(ptr);\n    }\n    /**\n    * @param {string} data\n    */\n    onReceive(data) {\n        const ptr = this.__destroy_into_raw();\n        const ptr0 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.jrpcquery_onReceive(ptr, ptr0, len0);\n    }\n    /**\n    * @param {any} arg0\n    */\n    onError(arg0) {\n        const ptr = this.__destroy_into_raw();\n        wasm.jrpcquery_onError(ptr, addHeapObject(arg0));\n    }\n    /**\n    */\n    onTimeout() {\n        const ptr = this.__destroy_into_raw();\n        wasm.jrpcquery_onTimeout(ptr);\n    }\n}\n/**\n*/\nclass Transport {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Transport.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transport_free(ptr);\n    }\n    /**\n    * @param {GqlConnection} gql\n    * @returns {Transport}\n    */\n    static fromGqlConnection(gql) {\n        _assertClass(gql, GqlConnection);\n        const ret = wasm.transport_fromGqlConnection(gql.ptr);\n        return Transport.__wrap(ret);\n    }\n    /**\n    * @param {JrpcConnection} jrpc\n    * @returns {Transport}\n    */\n    static fromJrpcConnection(jrpc) {\n        _assertClass(jrpc, JrpcConnection);\n        const ret = wasm.transport_fromJrpcConnection(jrpc.ptr);\n        return Transport.__wrap(ret);\n    }\n    /**\n    * @param {string} address\n    * @param {any} handler\n    * @returns {Promise<GenericContract>}\n    */\n    subscribeToGenericContract(address, handler) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transport_subscribeToGenericContract(retptr, this.ptr, ptr0, len0, addHeapObject(handler));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} address\n    * @returns {Promise<FullContractState | undefined>}\n    */\n    getFullContractState(address) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transport_getFullContractState(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} code_hash\n    * @param {number} limit\n    * @param {string | undefined} continuation\n    * @returns {Promise<AccountsList>}\n    */\n    getAccountsByCodeHash(code_hash, limit, continuation) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(code_hash, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            var ptr1 = isLikeNone(continuation) ? 0 : passStringToWasm0(continuation, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.transport_getAccountsByCodeHash(retptr, this.ptr, ptr0, len0, limit, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} address\n    * @param {string | undefined} continuation\n    * @param {number} limit\n    * @returns {Promise<TransactionsList>}\n    */\n    getTransactions(address, continuation, limit) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            var ptr1 = isLikeNone(continuation) ? 0 : passStringToWasm0(continuation, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.transport_getTransactions(retptr, this.ptr, ptr0, len0, ptr1, len1, limit);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} hash\n    * @returns {Promise<Transaction | undefined>}\n    */\n    getTransaction(hash) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hash, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transport_getTransaction(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} message_hash\n    * @returns {Promise<Transaction | undefined>}\n    */\n    getDstTransaction(message_hash) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(message_hash, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transport_getDstTransaction(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass UnsignedMessage {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnsignedMessage.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unsignedmessage_free(ptr);\n    }\n    /**\n    * @param {ClockWithOffset} clock\n    */\n    refreshTimeout(clock) {\n        _assertClass(clock, ClockWithOffset);\n        wasm.unsignedmessage_refreshTimeout(this.ptr, clock.ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    expireAt() {\n        const ret = wasm.unsignedmessage_expireAt(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {string}\n    */\n    get hash() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unsignedmessage_hash(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} signature\n    * @returns {SignedMessage}\n    */\n    sign(signature) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(signature, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.unsignedmessage_sign(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {SignedMessage}\n    */\n    signFake() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unsignedmessage_signFake(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nasync function load(module, imports) {\n    if (typeof Response === \'function\' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === \'function\') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get(\'Content-Type\') != \'application/wasm\') {\n                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction getImports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_length_6e3bbe7c8bd4dbd8 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === \'number\' ? obj : undefined;\n        getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n    };\n    imports.wbg.__wbindgen_is_null = function(arg0) {\n        const ret = getObject(arg0) === null;\n        return ret;\n    };\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === \'string\' ? obj : undefined;\n        var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === \'object\' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === \'string\';\n        return ret;\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_now_58886682b7e790d7 = function() {\n        const ret = Date.now();\n        return ret;\n    };\n    imports.wbg.__wbg_new_8d2af00bc1e329ee = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_0b9bfdd97583284e = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_send_55c5735308610fc0 = function(arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).send(getStringFromWasm0(arg1, arg2), GqlQuery.__wrap(arg3), arg4 !== 0);\n    };\n    imports.wbg.__wbg_send_c4fe5ef5f4851b5a = function(arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).send(getStringFromWasm0(arg1, arg2), JrpcQuery.__wrap(arg3), arg4 !== 0);\n    };\n    imports.wbg.__wbg_new_1d9a920c6bfc44a8 = function() {\n        const ret = new Array();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_push_740e4b286702d964 = function(arg0, arg1) {\n        const ret = getObject(arg0).push(getObject(arg1));\n        return ret;\n    };\n    imports.wbg.__wbg_genericcontract_new = function(arg0) {\n        const ret = GenericContract.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_onMessageSent_fc2ded3b8153507a = function(arg0, arg1, arg2) {\n        getObject(arg0).onMessageSent(takeObject(arg1), takeObject(arg2));\n    };\n    imports.wbg.__wbg_onMessageExpired_fbdb4b1a8bb0e7c5 = function(arg0, arg1) {\n        getObject(arg0).onMessageExpired(takeObject(arg1));\n    };\n    imports.wbg.__wbg_onStateChanged_e696a7b987dba9ea = function(arg0, arg1) {\n        getObject(arg0).onStateChanged(takeObject(arg1));\n    };\n    imports.wbg.__wbg_onTransactionsFound_33b7b56c770e2e88 = function(arg0, arg1, arg2) {\n        getObject(arg0).onTransactionsFound(takeObject(arg1), takeObject(arg2));\n    };\n    imports.wbg.__wbg_keys_0702294afaeb6044 = function(arg0) {\n        const ret = Object.keys(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_57245cc7d7c7619d = function(arg0, arg1) {\n        const ret = getObject(arg0)[arg1 >>> 0];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = getObject(arg0);\n        const ret = typeof(v) === \'boolean\' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbg_isLocal_0cc0f6258c8cf6ca = function(arg0) {\n        const ret = getObject(arg0).isLocal();\n        return ret;\n    };\n    imports.wbg.__wbg_new_9962f939219f1820 = function(arg0, arg1) {\n        try {\n            var state0 = {a: arg0, b: arg1};\n            var cb0 = (arg0, arg1) => {\n                const a = state0.a;\n                state0.a = 0;\n                try {\n                    return __wbg_adapter_163(a, state0.b, arg0, arg1);\n                } finally {\n                    state0.a = a;\n                }\n            };\n            const ret = new Promise(cb0);\n            return addHeapObject(ret);\n        } finally {\n            state0.a = state0.b = 0;\n        }\n    };\n    imports.wbg.__wbg_static_accessor_NODE_MODULE_cf6401cc1091279e = function() {\n        const ret = module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_process_0cc2ada8524d6f83 = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_versions_c11acceab27a6c87 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_node_7ff1ce49caf23815 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_a746e79b322b9336 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_crypto_2036bed7c44c25e7 = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_msCrypto_a21fc88caf1ecdc8 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_f5933855e4f48a19 = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_765201544a2b6869 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_self_6d479506f72c6a71 = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_window_f2557cc78490aceb = function() { return handleError(function () {\n        const ret = window.window;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_7f206bda628d5286 = function() { return handleError(function () {\n        const ret = globalThis.globalThis;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_global_ba75c50d1cf384f4 = function() { return handleError(function () {\n        const ret = __webpack_require__.g.global;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_newnoargs_b5b063fc6c2f0376 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_call_97ae9d8645dc388b = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_isArray_27c46c67f498e15d = function(arg0) {\n        const ret = Array.isArray(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_call_168da88779e35f61 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_set_bf3f89b92d5a34bf = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_randomFillSync_065afffde01daa66 = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_subarray_58ad4efbb5bcb886 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getRandomValues_b99eec4244a475bb = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_length_9e1ae1900cb0fbd5 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_buffer_3f3d764d4747d564 = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_8c3f0052272a457a = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_83db9690f9353e79 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(getObject(arg1));\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbg_then_11f7a54d67b4bfad = function(arg0, arg1) {\n        const ret = getObject(arg0).then(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cb_drop = function(arg0) {\n        const obj = takeObject(arg0).original;\n        if (obj.cnt-- == 1) {\n            obj.a = 0;\n            return true;\n        }\n        const ret = false;\n        return ret;\n    };\n    imports.wbg.__wbg_resolve_99fe17964f31ffc0 = function(arg0) {\n        const ret = Promise.resolve(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6437 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 925, __wbg_adapter_32);\n        return addHeapObject(ret);\n    };\n\n    return imports;\n}\n\nfunction initMemory(imports, maybe_memory) {\n\n}\n\nfunction finalizeInit(instance, module) {\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n    cachedFloat64Memory0 = new Float64Array();\n    cachedInt32Memory0 = new Int32Array();\n    cachedUint8Memory0 = new Uint8Array();\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    const imports = getImports();\n\n    initMemory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return finalizeInit(instance, module);\n}\n\nasync function init(input) {\n    if (typeof input === \'undefined\') {\n        input = new URL(/* asset import */ __webpack_require__(444), __webpack_require__.b);\n    }\n    const imports = getImports();\n\n    if (typeof input === \'string\' || (typeof Request === \'function\' && input instanceof Request) || (typeof URL === \'function\' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    initMemory(imports);\n\n    const { instance, module } = await load(await input, imports);\n\n    return finalizeInit(instance, module);\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (init);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTU5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL25la290b24td2FzbS9uZWtvdG9uX3dhc20uanM/ZDUyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmxldCB3YXNtO1xuXG5jb25zdCBjYWNoZWRUZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGlnbm9yZUJPTTogdHJ1ZSwgZmF0YWw6IHRydWUgfSk7XG5cbmNhY2hlZFRleHREZWNvZGVyLmRlY29kZSgpO1xuXG5sZXQgY2FjaGVkVWludDhNZW1vcnkwID0gbmV3IFVpbnQ4QXJyYXkoKTtcblxuZnVuY3Rpb24gZ2V0VWludDhNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWRVaW50OE1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRVaW50OE1lbW9yeTAgPSBuZXcgVWludDhBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkVWludDhNZW1vcnkwO1xufVxuXG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyLCBsZW4pIHtcbiAgICByZXR1cm4gY2FjaGVkVGV4dERlY29kZXIuZGVjb2RlKGdldFVpbnQ4TWVtb3J5MCgpLnN1YmFycmF5KHB0ciwgcHRyICsgbGVuKSk7XG59XG5cbmNvbnN0IGhlYXAgPSBuZXcgQXJyYXkoMzIpLmZpbGwodW5kZWZpbmVkKTtcblxuaGVhcC5wdXNoKHVuZGVmaW5lZCwgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xuXG5sZXQgaGVhcF9uZXh0ID0gaGVhcC5sZW5ndGg7XG5cbmZ1bmN0aW9uIGFkZEhlYXBPYmplY3Qob2JqKSB7XG4gICAgaWYgKGhlYXBfbmV4dCA9PT0gaGVhcC5sZW5ndGgpIGhlYXAucHVzaChoZWFwLmxlbmd0aCArIDEpO1xuICAgIGNvbnN0IGlkeCA9IGhlYXBfbmV4dDtcbiAgICBoZWFwX25leHQgPSBoZWFwW2lkeF07XG5cbiAgICBoZWFwW2lkeF0gPSBvYmo7XG4gICAgcmV0dXJuIGlkeDtcbn1cblxuZnVuY3Rpb24gZ2V0T2JqZWN0KGlkeCkgeyByZXR1cm4gaGVhcFtpZHhdOyB9XG5cbmZ1bmN0aW9uIGlzTGlrZU5vbmUoeCkge1xuICAgIHJldHVybiB4ID09PSB1bmRlZmluZWQgfHwgeCA9PT0gbnVsbDtcbn1cblxubGV0IGNhY2hlZEZsb2F0NjRNZW1vcnkwID0gbmV3IEZsb2F0NjRBcnJheSgpO1xuXG5mdW5jdGlvbiBnZXRGbG9hdDY0TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkRmxvYXQ2NE1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRGbG9hdDY0TWVtb3J5MCA9IG5ldyBGbG9hdDY0QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZEZsb2F0NjRNZW1vcnkwO1xufVxuXG5sZXQgY2FjaGVkSW50MzJNZW1vcnkwID0gbmV3IEludDMyQXJyYXkoKTtcblxuZnVuY3Rpb24gZ2V0SW50MzJNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWRJbnQzMk1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRJbnQzMk1lbW9yeTAgPSBuZXcgSW50MzJBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkSW50MzJNZW1vcnkwO1xufVxuXG5sZXQgV0FTTV9WRUNUT1JfTEVOID0gMDtcblxuY29uc3QgY2FjaGVkVGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoJ3V0Zi04Jyk7XG5cbmNvbnN0IGVuY29kZVN0cmluZyA9ICh0eXBlb2YgY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlSW50byA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZnVuY3Rpb24gKGFyZywgdmlldykge1xuICAgIHJldHVybiBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGVJbnRvKGFyZywgdmlldyk7XG59XG4gICAgOiBmdW5jdGlvbiAoYXJnLCB2aWV3KSB7XG4gICAgY29uc3QgYnVmID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlKGFyZyk7XG4gICAgdmlldy5zZXQoYnVmKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWFkOiBhcmcubGVuZ3RoLFxuICAgICAgICB3cml0dGVuOiBidWYubGVuZ3RoXG4gICAgfTtcbn0pO1xuXG5mdW5jdGlvbiBwYXNzU3RyaW5nVG9XYXNtMChhcmcsIG1hbGxvYywgcmVhbGxvYykge1xuXG4gICAgaWYgKHJlYWxsb2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBidWYgPSBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGUoYXJnKTtcbiAgICAgICAgY29uc3QgcHRyID0gbWFsbG9jKGJ1Zi5sZW5ndGgpO1xuICAgICAgICBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIsIHB0ciArIGJ1Zi5sZW5ndGgpLnNldChidWYpO1xuICAgICAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBidWYubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGxldCBsZW4gPSBhcmcubGVuZ3RoO1xuICAgIGxldCBwdHIgPSBtYWxsb2MobGVuKTtcblxuICAgIGNvbnN0IG1lbSA9IGdldFVpbnQ4TWVtb3J5MCgpO1xuXG4gICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICBmb3IgKDsgb2Zmc2V0IDwgbGVuOyBvZmZzZXQrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gYXJnLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgaWYgKGNvZGUgPiAweDdGKSBicmVhaztcbiAgICAgICAgbWVtW3B0ciArIG9mZnNldF0gPSBjb2RlO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXQgIT09IGxlbikge1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBwdHIgPSByZWFsbG9jKHB0ciwgbGVuLCBsZW4gPSBvZmZzZXQgKyBhcmcubGVuZ3RoICogMyk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIgKyBvZmZzZXQsIHB0ciArIGxlbik7XG4gICAgICAgIGNvbnN0IHJldCA9IGVuY29kZVN0cmluZyhhcmcsIHZpZXcpO1xuXG4gICAgICAgIG9mZnNldCArPSByZXQud3JpdHRlbjtcbiAgICB9XG5cbiAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHB0cjtcbn1cblxuZnVuY3Rpb24gZHJvcE9iamVjdChpZHgpIHtcbiAgICBpZiAoaWR4IDwgMzYpIHJldHVybjtcbiAgICBoZWFwW2lkeF0gPSBoZWFwX25leHQ7XG4gICAgaGVhcF9uZXh0ID0gaWR4O1xufVxuXG5mdW5jdGlvbiB0YWtlT2JqZWN0KGlkeCkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChpZHgpO1xuICAgIGRyb3BPYmplY3QoaWR4KTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkZWJ1Z1N0cmluZyh2YWwpIHtcbiAgICAvLyBwcmltaXRpdmUgdHlwZXNcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbDtcbiAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdib29sZWFuJyB8fCB2YWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIGAke3ZhbH1gO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYFwiJHt2YWx9XCJgO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSAnc3ltYm9sJykge1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbC5kZXNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnU3ltYm9sJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgU3ltYm9sKCR7ZGVzY3JpcHRpb259KWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBuYW1lID0gdmFsLm5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyAmJiBuYW1lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBgRnVuY3Rpb24oJHtuYW1lfSlgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdGdW5jdGlvbic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb2JqZWN0c1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdmFsLmxlbmd0aDtcbiAgICAgICAgbGV0IGRlYnVnID0gJ1snO1xuICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGVidWcgKz0gZGVidWdTdHJpbmcodmFsWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRlYnVnICs9ICcsICcgKyBkZWJ1Z1N0cmluZyh2YWxbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnICs9ICddJztcbiAgICAgICAgcmV0dXJuIGRlYnVnO1xuICAgIH1cbiAgICAvLyBUZXN0IGZvciBidWlsdC1pblxuICAgIGNvbnN0IGJ1aWx0SW5NYXRjaGVzID0gL1xcW29iamVjdCAoW15cXF1dKylcXF0vLmV4ZWModG9TdHJpbmcuY2FsbCh2YWwpKTtcbiAgICBsZXQgY2xhc3NOYW1lO1xuICAgIGlmIChidWlsdEluTWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IGJ1aWx0SW5NYXRjaGVzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZhaWxlZCB0byBtYXRjaCB0aGUgc3RhbmRhcmQgJ1tvYmplY3QgQ2xhc3NOYW1lXSdcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKTtcbiAgICB9XG4gICAgaWYgKGNsYXNzTmFtZSA9PSAnT2JqZWN0Jykge1xuICAgICAgICAvLyB3ZSdyZSBhIHVzZXIgZGVmaW5lZCBjbGFzcyBvciBPYmplY3RcbiAgICAgICAgLy8gSlNPTi5zdHJpbmdpZnkgYXZvaWRzIHByb2JsZW1zIHdpdGggY3ljbGVzLCBhbmQgaXMgZ2VuZXJhbGx5IG11Y2hcbiAgICAgICAgLy8gZWFzaWVyIHRoYW4gbG9vcGluZyB0aHJvdWdoIG93blByb3BlcnRpZXMgb2YgYHZhbGAuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gJ09iamVjdCgnICsgSlNPTi5zdHJpbmdpZnkodmFsKSArICcpJztcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuICdPYmplY3QnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVycm9yc1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gYCR7dmFsLm5hbWV9OiAke3ZhbC5tZXNzYWdlfVxcbiR7dmFsLnN0YWNrfWA7XG4gICAgfVxuICAgIC8vIFRPRE8gd2UgY291bGQgdGVzdCBmb3IgbW9yZSB0aGluZ3MgaGVyZSwgbGlrZSBgU2V0YHMgYW5kIGBNYXBgcy5cbiAgICByZXR1cm4gY2xhc3NOYW1lO1xufVxuXG5mdW5jdGlvbiBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCBkdG9yLCBmKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB7IGE6IGFyZzAsIGI6IGFyZzEsIGNudDogMSwgZHRvciB9O1xuICAgIGNvbnN0IHJlYWwgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAvLyBGaXJzdCB1cCB3aXRoIGEgY2xvc3VyZSB3ZSBpbmNyZW1lbnQgdGhlIGludGVybmFsIHJlZmVyZW5jZVxuICAgICAgICAvLyBjb3VudC4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIFJ1c3QgY2xvc3VyZSBlbnZpcm9ubWVudCB3b24ndFxuICAgICAgICAvLyBiZSBkZWFsbG9jYXRlZCB3aGlsZSB3ZSdyZSBpbnZva2luZyBpdC5cbiAgICAgICAgc3RhdGUuY250Kys7XG4gICAgICAgIGNvbnN0IGEgPSBzdGF0ZS5hO1xuICAgICAgICBzdGF0ZS5hID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmKGEsIHN0YXRlLmIsIC4uLmFyZ3MpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKC0tc3RhdGUuY250ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yLmdldChzdGF0ZS5kdG9yKShhLCBzdGF0ZS5iKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmVhbC5vcmlnaW5hbCA9IHN0YXRlO1xuXG4gICAgcmV0dXJuIHJlYWw7XG59XG5mdW5jdGlvbiBfX3diZ19hZGFwdGVyXzMyKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICB3YXNtLl9keW5fY29yZV9fb3BzX19mdW5jdGlvbl9fRm5NdXRfX0FfX19fT3V0cHV0X19fUl9hc193YXNtX2JpbmRnZW5fX2Nsb3N1cmVfX1dhc21DbG9zdXJlX19fZGVzY3JpYmVfX2ludm9rZV9faGNiNzc3MjljNmFmOWQzNzYoYXJnMCwgYXJnMSwgYWRkSGVhcE9iamVjdChhcmcyKSk7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRDbGFzcyhpbnN0YW5jZSwga2xhc3MpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIGtsYXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIGluc3RhbmNlIG9mICR7a2xhc3MubmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlLnB0cjtcbn1cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYWRkcmVzcywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgY29uc3QgcmV0ID0gd2FzbS5jaGVja0FkZHJlc3MocHRyMCwgbGVuMCk7XG4gICAgcmV0dXJuIHJldCAhPT0gMDtcbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzXG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGFja0FkZHJlc3MoYWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYWRkcmVzcywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLnJlcGFja0FkZHJlc3MocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICB2YXIgcHRyMSA9IHIwO1xuICAgICAgICB2YXIgbGVuMSA9IHIxO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHB0cjEgPSAwOyBsZW4xID0gMDtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMSwgbGVuMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocHRyMSwgbGVuMSk7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtDbG9ja1dpdGhPZmZzZXR9IGNsb2NrXG4qIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50X3N0dWZmX2JvY1xuKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RfYWJpXG4qIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiogQHBhcmFtIHtUb2tlbnNPYmplY3R9IGlucHV0XG4qIEBwYXJhbSB7Ym9vbGVhbn0gcmVzcG9uc2libGVcbiogQHJldHVybnMge0V4ZWN1dGlvbk91dHB1dH1cbiovXG5leHBvcnQgZnVuY3Rpb24gcnVuTG9jYWwoY2xvY2ssIGFjY291bnRfc3R1ZmZfYm9jLCBjb250cmFjdF9hYmksIG1ldGhvZCwgaW5wdXQsIHJlc3BvbnNpYmxlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjbG9jaywgQ2xvY2tXaXRoT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFjY291bnRfc3R1ZmZfYm9jLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChjb250cmFjdF9hYmksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMiA9IHBhc3NTdHJpbmdUb1dhc20wKG1ldGhvZCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLnJ1bkxvY2FsKHJldHB0ciwgY2xvY2sucHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBwdHIyLCBsZW4yLCBhZGRIZWFwT2JqZWN0KGlucHV0KSwgcmVzcG9uc2libGUpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50X3N0dWZmX2JvY1xuKiBAcmV0dXJucyB7c3RyaW5nfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRnVsbEFjY291bnRCb2MoYWNjb3VudF9zdHVmZl9ib2MpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFjY291bnRfc3R1ZmZfYm9jLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20ubWFrZUZ1bGxBY2NvdW50Qm9jKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgdmFyIHB0cjEgPSByMDtcbiAgICAgICAgdmFyIGxlbjEgPSByMTtcbiAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICBwdHIxID0gMDsgbGVuMSA9IDA7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjEsIGxlbjEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHB0cjEsIGxlbjEpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50XG4qIEByZXR1cm5zIHtGdWxsQ29udHJhY3RTdGF0ZSB8IHVuZGVmaW5lZH1cbiovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGdWxsQWNjb3VudEJvYyhhY2NvdW50KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhY2NvdW50LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20ucGFyc2VGdWxsQWNjb3VudEJvYyhyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBjb25maWdcbiogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRcbiogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiogQHBhcmFtIHtudW1iZXJ9IHV0aW1lXG4qIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZV9zaWduYXR1cmVfY2hlY2tcbiogQHJldHVybnMge1RyYW5zYWN0aW9uRXhlY3V0b3JPdXRwdXR9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVMb2NhbChjb25maWcsIGFjY291bnQsIG1lc3NhZ2UsIHV0aW1lLCBkaXNhYmxlX3NpZ25hdHVyZV9jaGVjaykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY29uZmlnLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChhY2NvdW50LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjIgPSBwYXNzU3RyaW5nVG9XYXNtMChtZXNzYWdlLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjIgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uZXhlY3V0ZUxvY2FsKHJldHB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgcHRyMiwgbGVuMiwgdXRpbWUsIGRpc2FibGVfc2lnbmF0dXJlX2NoZWNrKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gdHZjXG4qIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdF9hYmlcbiogQHBhcmFtIHtudW1iZXJ9IHdvcmtjaGFpbl9pZFxuKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gcHVibGljX2tleVxuKiBAcGFyYW0ge1Rva2Vuc09iamVjdH0gaW5pdF9kYXRhXG4qIEByZXR1cm5zIHtFeHBlY3RlZEFkZHJlc3N9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEV4cGVjdGVkQWRkcmVzcyh0dmMsIGNvbnRyYWN0X2FiaSwgd29ya2NoYWluX2lkLCBwdWJsaWNfa2V5LCBpbml0X2RhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHR2Yywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAoY29udHJhY3RfYWJpLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIyID0gaXNMaWtlTm9uZShwdWJsaWNfa2V5KSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChwdWJsaWNfa2V5LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmdldEV4cGVjdGVkQWRkcmVzcyhyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIHdvcmtjaGFpbl9pZCwgcHRyMiwgbGVuMiwgYWRkSGVhcE9iamVjdChpbml0X2RhdGEpKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gYm9jXG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJvY0hhc2goYm9jKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChib2MsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5nZXRCb2NIYXNoKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgdmFyIHB0cjEgPSByMDtcbiAgICAgICAgdmFyIGxlbjEgPSByMTtcbiAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICBwdHIxID0gMDsgbGVuMSA9IDA7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjEsIGxlbjEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHB0cjEsIGxlbjEpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7QXJyYXk8QWJpUGFyYW0+fSBwYXJhbXNcbiogQHBhcmFtIHtUb2tlbnNPYmplY3R9IHRva2Vuc1xuKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gYWJpX3ZlcnNpb25cbiogQHJldHVybnMge3N0cmluZ31cbiovXG5leHBvcnQgZnVuY3Rpb24gcGFja0ludG9DZWxsKHBhcmFtcywgdG9rZW5zLCBhYmlfdmVyc2lvbikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoYWJpX3ZlcnNpb24pID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKGFiaV92ZXJzaW9uLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLnBhY2tJbnRvQ2VsbChyZXRwdHIsIGFkZEhlYXBPYmplY3QocGFyYW1zKSwgYWRkSGVhcE9iamVjdCh0b2tlbnMpLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICB2YXIgcHRyMSA9IHIwO1xuICAgICAgICB2YXIgbGVuMSA9IHIxO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHB0cjEgPSAwOyBsZW4xID0gMDtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMSwgbGVuMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocHRyMSwgbGVuMSk7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtBcnJheTxBYmlQYXJhbT59IHBhcmFtc1xuKiBAcGFyYW0ge3N0cmluZ30gYm9jXG4qIEBwYXJhbSB7Ym9vbGVhbn0gYWxsb3dfcGFydGlhbFxuKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gYWJpX3ZlcnNpb25cbiogQHJldHVybnMge1Rva2Vuc09iamVjdH1cbiovXG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrRnJvbUNlbGwocGFyYW1zLCBib2MsIGFsbG93X3BhcnRpYWwsIGFiaV92ZXJzaW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChib2MsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgdmFyIHB0cjEgPSBpc0xpa2VOb25lKGFiaV92ZXJzaW9uKSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChhYmlfdmVyc2lvbiwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS51bnBhY2tGcm9tQ2VsbChyZXRwdHIsIGFkZEhlYXBPYmplY3QocGFyYW1zKSwgcHRyMCwgbGVuMCwgYWxsb3dfcGFydGlhbCwgcHRyMSwgbGVuMSk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IGJvY1xuKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0Q29udHJhY3REYXRhKGJvYykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYm9jLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uZXh0cmFjdENvbnRyYWN0RGF0YShyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICB2YXIgcjMgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgM107XG4gICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHYxO1xuICAgICAgICBpZiAocjAgIT09IDApIHtcbiAgICAgICAgICAgIHYxID0gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHIwLCByMSAqIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2MTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBib2NcbiogQHJldHVybnMge3N0cmluZ31cbiovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFB1YmxpY0tleShib2MpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGJvYywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmV4dHJhY3RQdWJsaWNLZXkocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICB2YXIgcHRyMSA9IHIwO1xuICAgICAgICB2YXIgbGVuMSA9IHIxO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHB0cjEgPSAwOyBsZW4xID0gMDtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMSwgbGVuMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocHRyMSwgbGVuMSk7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiogQHJldHVybnMge3N0cmluZ31cbiovXG5leHBvcnQgZnVuY3Rpb24gY29kZVRvVHZjKGNvZGUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGNvZGUsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5jb2RlVG9UdmMocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICB2YXIgcHRyMSA9IHIwO1xuICAgICAgICB2YXIgbGVuMSA9IHIxO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHB0cjEgPSAwOyBsZW4xID0gMDtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMSwgbGVuMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocHRyMSwgbGVuMSk7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiogQHJldHVybnMge3N0cmluZ31cbiovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VUdmMoY29kZSwgZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY29kZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAoZGF0YSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLm1lcmdlVHZjKHJldHB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgdmFyIHB0cjIgPSByMDtcbiAgICAgICAgdmFyIGxlbjIgPSByMTtcbiAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICBwdHIyID0gMDsgbGVuMiA9IDA7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjIsIGxlbjIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHB0cjIsIGxlbjIpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSB0dmNcbiogQHJldHVybnMge1N0YXRlSW5pdH1cbiovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRUdmModHZjKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMCh0dmMsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5zcGxpdFR2YyhyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4qIEBwYXJhbSB7c3RyaW5nfSBzYWx0XG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHNldENvZGVTYWx0KGNvZGUsIHNhbHQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGNvZGUsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHNhbHQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5zZXRDb2RlU2FsdChyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICB2YXIgcjMgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgM107XG4gICAgICAgIHZhciBwdHIyID0gcjA7XG4gICAgICAgIHZhciBsZW4yID0gcjE7XG4gICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgcHRyMiA9IDA7IGxlbjIgPSAwO1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIyLCBsZW4yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShwdHIyLCBsZW4yKTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2RlU2FsdChjb2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChjb2RlLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uZ2V0Q29kZVNhbHQocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICAgICAgICB2MSA9IGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyMCwgcjEgKiAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjE7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RfYWJpXG4qIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiogQHBhcmFtIHtUb2tlbnNPYmplY3R9IGlucHV0XG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUludGVybmFsSW5wdXQoY29udHJhY3RfYWJpLCBtZXRob2QsIGlucHV0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChjb250cmFjdF9hYmksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKG1ldGhvZCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmVuY29kZUludGVybmFsSW5wdXQocmV0cHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBhZGRIZWFwT2JqZWN0KGlucHV0KSk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgdmFyIHB0cjIgPSByMDtcbiAgICAgICAgdmFyIGxlbjIgPSByMTtcbiAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICBwdHIyID0gMDsgbGVuMiA9IDA7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjIsIGxlbjIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHB0cjIsIGxlbjIpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBzcmNcbiogQHBhcmFtIHtzdHJpbmd9IGRzdFxuKiBAcGFyYW0ge2Jvb2xlYW59IGJvdW5jZVxuKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gc3RhdGVfaW5pdFxuKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gYm9keVxuKiBAcGFyYW0ge3N0cmluZ30gYW1vdW50XG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUludGVybmFsTWVzc2FnZShzcmMsIGRzdCwgYm91bmNlLCBzdGF0ZV9pbml0LCBib2R5LCBhbW91bnQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKHNyYykgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoc3JjLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAoZHN0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIyID0gaXNMaWtlTm9uZShzdGF0ZV9pbml0KSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChzdGF0ZV9pbml0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMyA9IGlzTGlrZU5vbmUoYm9keSkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoYm9keSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMyA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyNCA9IHBhc3NTdHJpbmdUb1dhc20wKGFtb3VudCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW40ID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmVuY29kZUludGVybmFsTWVzc2FnZShyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIGJvdW5jZSwgcHRyMiwgbGVuMiwgcHRyMywgbGVuMywgcHRyNCwgbGVuNCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgdmFyIHB0cjUgPSByMDtcbiAgICAgICAgdmFyIGxlbjUgPSByMTtcbiAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICBwdHI1ID0gMDsgbGVuNSA9IDA7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjUsIGxlbjUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHB0cjUsIGxlbjUpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlX2JvZHlcbiogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0X2FiaVxuKiBAcGFyYW0ge01ldGhvZE5hbWV9IG1ldGhvZFxuKiBAcGFyYW0ge2Jvb2xlYW59IGludGVybmFsXG4qIEByZXR1cm5zIHtEZWNvZGVkSW5wdXQgfCB1bmRlZmluZWR9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUlucHV0KG1lc3NhZ2VfYm9keSwgY29udHJhY3RfYWJpLCBtZXRob2QsIGludGVybmFsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChtZXNzYWdlX2JvZHksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKGNvbnRyYWN0X2FiaSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmRlY29kZUlucHV0KHJldHB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgYWRkSGVhcE9iamVjdChtZXRob2QpLCBpbnRlcm5hbCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VfYm9keVxuKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RfYWJpXG4qIEBwYXJhbSB7TWV0aG9kTmFtZX0gZXZlbnRcbiogQHJldHVybnMge0RlY29kZWRFdmVudCB8IHVuZGVmaW5lZH1cbiovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRXZlbnQobWVzc2FnZV9ib2R5LCBjb250cmFjdF9hYmksIGV2ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChtZXNzYWdlX2JvZHksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKGNvbnRyYWN0X2FiaSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmRlY29kZUV2ZW50KHJldHB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgYWRkSGVhcE9iamVjdChldmVudCkpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlX2JvZHlcbiogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0X2FiaVxuKiBAcGFyYW0ge01ldGhvZE5hbWV9IG1ldGhvZFxuKiBAcmV0dXJucyB7RGVjb2RlZE91dHB1dCB8IHVuZGVmaW5lZH1cbiovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlT3V0cHV0KG1lc3NhZ2VfYm9keSwgY29udHJhY3RfYWJpLCBtZXRob2QpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKG1lc3NhZ2VfYm9keSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAoY29udHJhY3RfYWJpLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uZGVjb2RlT3V0cHV0KHJldHB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgYWRkSGVhcE9iamVjdChtZXRob2QpKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RfYWJpXG4qIEBwYXJhbSB7TWV0aG9kTmFtZX0gbWV0aG9kXG4qIEByZXR1cm5zIHtEZWNvZGVkVHJhbnNhY3Rpb24gfCB1bmRlZmluZWR9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb250cmFjdF9hYmksIG1ldGhvZCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY29udHJhY3RfYWJpLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uZGVjb2RlVHJhbnNhY3Rpb24ocmV0cHRyLCBhZGRIZWFwT2JqZWN0KHRyYW5zYWN0aW9uKSwgcHRyMCwgbGVuMCwgYWRkSGVhcE9iamVjdChtZXRob2QpKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RfYWJpXG4qIEByZXR1cm5zIHtEZWNvZGVkVHJhbnNhY3Rpb25FdmVudHN9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVRyYW5zYWN0aW9uRXZlbnRzKHRyYW5zYWN0aW9uLCBjb250cmFjdF9hYmkpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGNvbnRyYWN0X2FiaSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmRlY29kZVRyYW5zYWN0aW9uRXZlbnRzKHJldHB0ciwgYWRkSGVhcE9iamVjdCh0cmFuc2FjdGlvbiksIHB0cjAsIGxlbjApO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGFIYXNoKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGRhdGEsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5nZXREYXRhSGFzaChyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICB2YXIgcjMgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgM107XG4gICAgICAgIHZhciBwdHIxID0gcjA7XG4gICAgICAgIHZhciBsZW4xID0gcjE7XG4gICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgcHRyMSA9IDA7IGxlbjEgPSAwO1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIxLCBsZW4xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShwdHIxLCBsZW4xKTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcmV0dXJucyB7RWQyNTUxOUtleVBhaXJ9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGVkMjU1MTlfZ2VuZXJhdGVLZXlQYWlyKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICB3YXNtLmVkMjU1MTlfZ2VuZXJhdGVLZXlQYWlyKHJldHB0cik7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IHNlY3JldF9rZXlcbiogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiogQHJldHVybnMge3N0cmluZ31cbiovXG5leHBvcnQgZnVuY3Rpb24gZWQyNTUxOV9zaWduKHNlY3JldF9rZXksIGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHNlY3JldF9rZXksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKGRhdGEsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5lZDI1NTE5X3NpZ24ocmV0cHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICB2YXIgcHRyMiA9IHIwO1xuICAgICAgICB2YXIgbGVuMiA9IHIxO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHB0cjIgPSAwOyBsZW4yID0gMDtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMiwgbGVuMik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocHRyMiwgbGVuMik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZVxuKiBAcmV0dXJucyB7RXh0ZW5kZWRTaWduYXR1cmV9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHNpZ25hdHVyZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmV4dGVuZFNpZ25hdHVyZShyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNfa2V5XG4qIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4qIEBwYXJhbSB7c3RyaW5nfSBzaWduYXR1cmVcbiogQHJldHVybnMge2Jvb2xlYW59XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZShwdWJsaWNfa2V5LCBkYXRhLCBzaWduYXR1cmUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHB1YmxpY19rZXksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKGRhdGEsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMiA9IHBhc3NTdHJpbmdUb1dhc20wKHNpZ25hdHVyZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLnZlcmlmeVNpZ25hdHVyZShyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIHB0cjIsIGxlbjIpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByMCAhPT0gMDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBkc3RcbiogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHN0YXRlX2luaXRcbiogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGJvZHlcbiogQHBhcmFtIHtudW1iZXJ9IGV4cGlyZV9hdFxuKiBAcmV0dXJucyB7U2lnbmVkTWVzc2FnZX1cbiovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmF3RXh0ZXJuYWxNZXNzYWdlKGRzdCwgc3RhdGVfaW5pdCwgYm9keSwgZXhwaXJlX2F0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChkc3QsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgdmFyIHB0cjEgPSBpc0xpa2VOb25lKHN0YXRlX2luaXQpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHN0YXRlX2luaXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIyID0gaXNMaWtlTm9uZShib2R5KSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChib2R5LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmNyZWF0ZVJhd0V4dGVybmFsTWVzc2FnZShyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIHB0cjIsIGxlbjIsIGV4cGlyZV9hdCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtDbG9ja1dpdGhPZmZzZXR9IGNsb2NrXG4qIEBwYXJhbSB7c3RyaW5nfSBkc3RcbiogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0X2FiaVxuKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4qIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBzdGF0ZV9pbml0XG4qIEBwYXJhbSB7VG9rZW5zT2JqZWN0fSBpbnB1dFxuKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuKiBAcmV0dXJucyB7U2lnbmVkTWVzc2FnZX1cbiovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXh0ZXJuYWxNZXNzYWdlV2l0aG91dFNpZ25hdHVyZShjbG9jaywgZHN0LCBjb250cmFjdF9hYmksIG1ldGhvZCwgc3RhdGVfaW5pdCwgaW5wdXQsIHRpbWVvdXQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGNsb2NrLCBDbG9ja1dpdGhPZmZzZXQpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoZHN0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChjb250cmFjdF9hYmksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMiA9IHBhc3NTdHJpbmdUb1dhc20wKG1ldGhvZCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMyA9IGlzTGlrZU5vbmUoc3RhdGVfaW5pdCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoc3RhdGVfaW5pdCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMyA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5jcmVhdGVFeHRlcm5hbE1lc3NhZ2VXaXRob3V0U2lnbmF0dXJlKHJldHB0ciwgY2xvY2sucHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBwdHIyLCBsZW4yLCBwdHIzLCBsZW4zLCBhZGRIZWFwT2JqZWN0KGlucHV0KSwgdGltZW91dCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtDbG9ja1dpdGhPZmZzZXR9IGNsb2NrXG4qIEBwYXJhbSB7c3RyaW5nfSBkc3RcbiogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0X2FiaVxuKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4qIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBzdGF0ZV9pbml0XG4qIEBwYXJhbSB7VG9rZW5zT2JqZWN0fSBpbnB1dFxuKiBAcGFyYW0ge3N0cmluZ30gcHVibGljX2tleVxuKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuKiBAcmV0dXJucyB7VW5zaWduZWRNZXNzYWdlfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFeHRlcm5hbE1lc3NhZ2UoY2xvY2ssIGRzdCwgY29udHJhY3RfYWJpLCBtZXRob2QsIHN0YXRlX2luaXQsIGlucHV0LCBwdWJsaWNfa2V5LCB0aW1lb3V0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjbG9jaywgQ2xvY2tXaXRoT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGRzdCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAoY29udHJhY3RfYWJpLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjIgPSBwYXNzU3RyaW5nVG9XYXNtMChtZXRob2QsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMiA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgdmFyIHB0cjMgPSBpc0xpa2VOb25lKHN0YXRlX2luaXQpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHN0YXRlX2luaXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjMgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjQgPSBwYXNzU3RyaW5nVG9XYXNtMChwdWJsaWNfa2V5LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjQgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uY3JlYXRlRXh0ZXJuYWxNZXNzYWdlKHJldHB0ciwgY2xvY2sucHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBwdHIyLCBsZW4yLCBwdHIzLCBsZW4zLCBhZGRIZWFwT2JqZWN0KGlucHV0KSwgcHRyNCwgbGVuNCwgdGltZW91dCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVuc2lnbmVkTWVzc2FnZS5fX3dyYXAocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihmLCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhuX3N0b3JlKGFkZEhlYXBPYmplY3QoZSkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXlVOEZyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHJldHVybiBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIgLyAxLCBwdHIgLyAxICsgbGVuKTtcbn1cbmZ1bmN0aW9uIF9fd2JnX2FkYXB0ZXJfMTYzKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICB3YXNtLndhc21fYmluZGdlbl9fY29udmVydF9fY2xvc3VyZXNfX2ludm9rZTJfbXV0X19oZWNiYTg5NmQxNTYzZDIyMyhhcmcwLCBhcmcxLCBhZGRIZWFwT2JqZWN0KGFyZzIpLCBhZGRIZWFwT2JqZWN0KGFyZzMpKTtcbn1cblxuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIENsb2NrV2l0aE9mZnNldCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKENsb2NrV2l0aE9mZnNldC5wcm90b3R5cGUpO1xuICAgICAgICBvYmoucHRyID0gcHRyO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLnB0cjtcbiAgICAgICAgdGhpcy5wdHIgPSAwO1xuXG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19jbG9ja3dpdGhvZmZzZXRfZnJlZShwdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmNsb2Nrd2l0aG9mZnNldF9uZXcoKTtcbiAgICAgICAgcmV0dXJuIENsb2NrV2l0aE9mZnNldC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgZ2V0IG5vd01zKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmNsb2Nrd2l0aG9mZnNldF9ub3dNcyh0aGlzLnB0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldF9tc1xuICAgICovXG4gICAgdXBkYXRlT2Zmc2V0KG9mZnNldF9tcykge1xuICAgICAgICB3YXNtLmNsb2Nrd2l0aG9mZnNldF91cGRhdGVPZmZzZXQodGhpcy5wdHIsIG9mZnNldF9tcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIG9mZnNldE1zKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmNsb2Nrd2l0aG9mZnNldF9vZmZzZXRNcyh0aGlzLnB0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIEdlbmVyaWNDb250cmFjdCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEdlbmVyaWNDb250cmFjdC5wcm90b3R5cGUpO1xuICAgICAgICBvYmoucHRyID0gcHRyO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLnB0cjtcbiAgICAgICAgdGhpcy5wdHIgPSAwO1xuXG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19nZW5lcmljY29udHJhY3RfZnJlZShwdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgKi9cbiAgICBnZXQgYWRkcmVzcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5nZW5lcmljY29udHJhY3RfYWRkcmVzcyhyZXRwdHIsIHRoaXMucHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyMCwgcjEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtTaWduZWRNZXNzYWdlfSBtZXNzYWdlXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvbj59XG4gICAgKi9cbiAgICBzZW5kTWVzc2FnZUxvY2FsbHkobWVzc2FnZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmdlbmVyaWNjb250cmFjdF9zZW5kTWVzc2FnZUxvY2FsbHkocmV0cHRyLCB0aGlzLnB0ciwgYWRkSGVhcE9iamVjdChtZXNzYWdlKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1NpZ25lZE1lc3NhZ2V9IG1lc3NhZ2VcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPFBlbmRpbmdUcmFuc2FjdGlvbj59XG4gICAgKi9cbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uZ2VuZXJpY2NvbnRyYWN0X3NlbmRNZXNzYWdlKHJldHB0ciwgdGhpcy5wdHIsIGFkZEhlYXBPYmplY3QobWVzc2FnZSkpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgKi9cbiAgICByZWZyZXNoKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmdlbmVyaWNjb250cmFjdF9yZWZyZXNoKHRoaXMucHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gYmxvY2tfaWRcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICovXG4gICAgaGFuZGxlQmxvY2soYmxvY2tfaWQpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGJsb2NrX2lkLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZ2VuZXJpY2NvbnRyYWN0X2hhbmRsZUJsb2NrKHRoaXMucHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gbHRcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICovXG4gICAgcHJlbG9hZFRyYW5zYWN0aW9ucyhsdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAobHQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmdlbmVyaWNjb250cmFjdF9wcmVsb2FkVHJhbnNhY3Rpb25zKHJldHB0ciwgdGhpcy5wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1BvbGxpbmdNZXRob2R9XG4gICAgKi9cbiAgICBnZXQgcG9sbGluZ01ldGhvZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5nZW5lcmljY29udHJhY3RfcG9sbGluZ01ldGhvZCh0aGlzLnB0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxufVxuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIEdxbENvbm5lY3Rpb24ge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShHcWxDb25uZWN0aW9uLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5wdHIgPSBwdHI7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMucHRyO1xuICAgICAgICB0aGlzLnB0ciA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2dxbGNvbm5lY3Rpb25fZnJlZShwdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7Q2xvY2tXaXRoT2Zmc2V0fSBjbG9ja1xuICAgICogQHBhcmFtIHtJR3FsU2VuZGVyfSBzZW5kZXJcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsb2NrLCBzZW5kZXIpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGNsb2NrLCBDbG9ja1dpdGhPZmZzZXQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmdxbGNvbm5lY3Rpb25fbmV3KGNsb2NrLnB0ciwgYWRkSGVhcE9iamVjdChzZW5kZXIpKTtcbiAgICAgICAgcmV0dXJuIEdxbENvbm5lY3Rpb24uX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPExhdGVzdEJsb2NrPn1cbiAgICAqL1xuICAgIGdldExhdGVzdEJsb2NrKGFkZHJlc3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFkZHJlc3MsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmdxbGNvbm5lY3Rpb25fZ2V0TGF0ZXN0QmxvY2socmV0cHRyLCB0aGlzLnB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudF9ibG9ja19pZFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxuICAgICovXG4gICAgd2FpdEZvck5leHRCbG9jayhjdXJyZW50X2Jsb2NrX2lkLCBhZGRyZXNzLCB0aW1lb3V0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChjdXJyZW50X2Jsb2NrX2lkLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKGFkZHJlc3MsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmdxbGNvbm5lY3Rpb25fd2FpdEZvck5leHRCbG9jayhyZXRwdHIsIHRoaXMucHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBHcWxRdWVyeSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEdxbFF1ZXJ5LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5wdHIgPSBwdHI7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMucHRyO1xuICAgICAgICB0aGlzLnB0ciA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2dxbHF1ZXJ5X2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICAgICovXG4gICAgb25SZWNlaXZlKGRhdGEpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGRhdGEsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5ncWxxdWVyeV9vblJlY2VpdmUocHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge2FueX0gYXJnMFxuICAgICovXG4gICAgb25FcnJvcihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uZ3FscXVlcnlfb25FcnJvcihwdHIsIGFkZEhlYXBPYmplY3QoYXJnMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAqL1xuICAgIG9uVGltZW91dCgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5ncWxxdWVyeV9vblRpbWVvdXQocHRyKTtcbiAgICB9XG59XG4vKipcbiovXG5leHBvcnQgY2xhc3MgSnJwY0Nvbm5lY3Rpb24ge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShKcnBjQ29ubmVjdGlvbi5wcm90b3R5cGUpO1xuICAgICAgICBvYmoucHRyID0gcHRyO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLnB0cjtcbiAgICAgICAgdGhpcy5wdHIgPSAwO1xuXG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19qcnBjY29ubmVjdGlvbl9mcmVlKHB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtDbG9ja1dpdGhPZmZzZXR9IGNsb2NrXG4gICAgKiBAcGFyYW0ge2FueX0gc2VuZGVyXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbG9jaywgc2VuZGVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjbG9jaywgQ2xvY2tXaXRoT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5qcnBjY29ubmVjdGlvbl9uZXcoY2xvY2sucHRyLCBhZGRIZWFwT2JqZWN0KHNlbmRlcikpO1xuICAgICAgICByZXR1cm4gSnJwY0Nvbm5lY3Rpb24uX193cmFwKHJldCk7XG4gICAgfVxufVxuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIEpycGNRdWVyeSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEpycGNRdWVyeS5wcm90b3R5cGUpO1xuICAgICAgICBvYmoucHRyID0gcHRyO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLnB0cjtcbiAgICAgICAgdGhpcy5wdHIgPSAwO1xuXG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19qcnBjcXVlcnlfZnJlZShwdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4gICAgKi9cbiAgICBvblJlY2VpdmUoZGF0YSkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoZGF0YSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmpycGNxdWVyeV9vblJlY2VpdmUocHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge2FueX0gYXJnMFxuICAgICovXG4gICAgb25FcnJvcihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uanJwY3F1ZXJ5X29uRXJyb3IocHRyLCBhZGRIZWFwT2JqZWN0KGFyZzApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKi9cbiAgICBvblRpbWVvdXQoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uanJwY3F1ZXJ5X29uVGltZW91dChwdHIpO1xuICAgIH1cbn1cbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBUcmFuc3BvcnQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc3BvcnQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLnB0ciA9IHB0cjtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5wdHI7XG4gICAgICAgIHRoaXMucHRyID0gMDtcblxuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhbnNwb3J0X2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0dxbENvbm5lY3Rpb259IGdxbFxuICAgICogQHJldHVybnMge1RyYW5zcG9ydH1cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tR3FsQ29ubmVjdGlvbihncWwpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGdxbCwgR3FsQ29ubmVjdGlvbik7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNwb3J0X2Zyb21HcWxDb25uZWN0aW9uKGdxbC5wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNwb3J0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7SnJwY0Nvbm5lY3Rpb259IGpycGNcbiAgICAqIEByZXR1cm5zIHtUcmFuc3BvcnR9XG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpycGNDb25uZWN0aW9uKGpycGMpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGpycGMsIEpycGNDb25uZWN0aW9uKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc3BvcnRfZnJvbUpycGNDb25uZWN0aW9uKGpycGMucHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zcG9ydC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICAgICogQHBhcmFtIHthbnl9IGhhbmRsZXJcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdlbmVyaWNDb250cmFjdD59XG4gICAgKi9cbiAgICBzdWJzY3JpYmVUb0dlbmVyaWNDb250cmFjdChhZGRyZXNzLCBoYW5kbGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhZGRyZXNzLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS50cmFuc3BvcnRfc3Vic2NyaWJlVG9HZW5lcmljQ29udHJhY3QocmV0cHRyLCB0aGlzLnB0ciwgcHRyMCwgbGVuMCwgYWRkSGVhcE9iamVjdChoYW5kbGVyKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICAgICogQHJldHVybnMge1Byb21pc2U8RnVsbENvbnRyYWN0U3RhdGUgfCB1bmRlZmluZWQ+fVxuICAgICovXG4gICAgZ2V0RnVsbENvbnRyYWN0U3RhdGUoYWRkcmVzcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYWRkcmVzcywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20udHJhbnNwb3J0X2dldEZ1bGxDb250cmFjdFN0YXRlKHJldHB0ciwgdGhpcy5wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVfaGFzaFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0XG4gICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gY29udGludWF0aW9uXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBY2NvdW50c0xpc3Q+fVxuICAgICovXG4gICAgZ2V0QWNjb3VudHNCeUNvZGVIYXNoKGNvZGVfaGFzaCwgbGltaXQsIGNvbnRpbnVhdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY29kZV9oYXNoLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgdmFyIHB0cjEgPSBpc0xpa2VOb25lKGNvbnRpbnVhdGlvbikgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoY29udGludWF0aW9uLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICB2YXIgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20udHJhbnNwb3J0X2dldEFjY291bnRzQnlDb2RlSGFzaChyZXRwdHIsIHRoaXMucHRyLCBwdHIwLCBsZW4wLCBsaW1pdCwgcHRyMSwgbGVuMSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGNvbnRpbnVhdGlvblxuICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0XG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvbnNMaXN0Pn1cbiAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9ucyhhZGRyZXNzLCBjb250aW51YXRpb24sIGxpbWl0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhZGRyZXNzLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgdmFyIHB0cjEgPSBpc0xpa2VOb25lKGNvbnRpbnVhdGlvbikgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoY29udGludWF0aW9uLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICB2YXIgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20udHJhbnNwb3J0X2dldFRyYW5zYWN0aW9ucyhyZXRwdHIsIHRoaXMucHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBsaW1pdCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gaGFzaFxuICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb24gfCB1bmRlZmluZWQ+fVxuICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb24oaGFzaCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoaGFzaCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20udHJhbnNwb3J0X2dldFRyYW5zYWN0aW9uKHJldHB0ciwgdGhpcy5wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VfaGFzaFxuICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb24gfCB1bmRlZmluZWQ+fVxuICAgICovXG4gICAgZ2V0RHN0VHJhbnNhY3Rpb24obWVzc2FnZV9oYXNoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChtZXNzYWdlX2hhc2gsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnRyYW5zcG9ydF9nZXREc3RUcmFuc2FjdGlvbihyZXRwdHIsIHRoaXMucHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBVbnNpZ25lZE1lc3NhZ2Uge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShVbnNpZ25lZE1lc3NhZ2UucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLnB0ciA9IHB0cjtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5wdHI7XG4gICAgICAgIHRoaXMucHRyID0gMDtcblxuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdW5zaWduZWRtZXNzYWdlX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0Nsb2NrV2l0aE9mZnNldH0gY2xvY2tcbiAgICAqL1xuICAgIHJlZnJlc2hUaW1lb3V0KGNsb2NrKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjbG9jaywgQ2xvY2tXaXRoT2Zmc2V0KTtcbiAgICAgICAgd2FzbS51bnNpZ25lZG1lc3NhZ2VfcmVmcmVzaFRpbWVvdXQodGhpcy5wdHIsIGNsb2NrLnB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGV4cGlyZUF0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnVuc2lnbmVkbWVzc2FnZV9leHBpcmVBdCh0aGlzLnB0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAqL1xuICAgIGdldCBoYXNoKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnVuc2lnbmVkbWVzc2FnZV9oYXNoKHJldHB0ciwgdGhpcy5wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHIwLCByMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlXG4gICAgKiBAcmV0dXJucyB7U2lnbmVkTWVzc2FnZX1cbiAgICAqL1xuICAgIHNpZ24oc2lnbmF0dXJlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChzaWduYXR1cmUsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnVuc2lnbmVkbWVzc2FnZV9zaWduKHJldHB0ciwgdGhpcy5wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1NpZ25lZE1lc3NhZ2V9XG4gICAgKi9cbiAgICBzaWduRmFrZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS51bnNpZ25lZG1lc3NhZ2Vfc2lnbkZha2UocmV0cHRyLCB0aGlzLnB0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWQobW9kdWxlLCBpbXBvcnRzKSB7XG4gICAgaWYgKHR5cGVvZiBSZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJyAmJiBtb2R1bGUgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhtb2R1bGUsIGltcG9ydHMpO1xuXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgIT0gJ2FwcGxpY2F0aW9uL3dhc20nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcImBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ2AgZmFpbGVkIGJlY2F1c2UgeW91ciBzZXJ2ZXIgZG9lcyBub3Qgc2VydmUgd2FzbSB3aXRoIGBhcHBsaWNhdGlvbi93YXNtYCBNSU1FIHR5cGUuIEZhbGxpbmcgYmFjayB0byBgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVgIHdoaWNoIGlzIHNsb3dlci4gT3JpZ2luYWwgZXJyb3I6XFxuXCIsIGUpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBieXRlcyA9IGF3YWl0IG1vZHVsZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYnl0ZXMsIGltcG9ydHMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShtb2R1bGUsIGltcG9ydHMpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lkluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpbnN0YW5jZSwgbW9kdWxlIH07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0SW1wb3J0cygpIHtcbiAgICBjb25zdCBpbXBvcnRzID0ge307XG4gICAgaW1wb3J0cy53YmcgPSB7fTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX3N0cmluZ19uZXcgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2xlbmd0aF82ZTNiYmU3YzhiZDRkYmQ4ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc191bmRlZmluZWQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9udW1iZXJfZ2V0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCBvYmogPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZihvYmopID09PSAnbnVtYmVyJyA/IG9iaiA6IHVuZGVmaW5lZDtcbiAgICAgICAgZ2V0RmxvYXQ2NE1lbW9yeTAoKVthcmcwIC8gOCArIDFdID0gaXNMaWtlTm9uZShyZXQpID8gMCA6IHJldDtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAwXSA9ICFpc0xpa2VOb25lKHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2lzX251bGwgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKSA9PT0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fc3RyaW5nX2dldCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2Yob2JqKSA9PT0gJ3N0cmluZycgPyBvYmogOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShyZXQpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAxXSA9IGxlbjA7XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMF0gPSBwdHIwO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc19vYmplY3QgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGdldE9iamVjdChhcmcwKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKHZhbCkgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5faXNfc3RyaW5nID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YoZ2V0T2JqZWN0KGFyZzApKSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX29iamVjdF9kcm9wX3JlZiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgdGFrZU9iamVjdChhcmcwKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fbnVtYmVyX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gYXJnMDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vd181ODg4NjY4MmI3ZTc5MGQ3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfOGQyYWYwMGJjMWUzMjllZSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEVycm9yKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfMGI5YmZkZDk3NTgzMjg0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgT2JqZWN0KCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZW5kXzU1YzU3MzUzMDg2MTBmYzAgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5zZW5kKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSwgR3FsUXVlcnkuX193cmFwKGFyZzMpLCBhcmc0ICE9PSAwKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NlbmRfYzRmZTVlZjVmNDg1MWI1YSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnNlbmQoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpLCBKcnBjUXVlcnkuX193cmFwKGFyZzMpLCBhcmc0ICE9PSAwKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld18xZDlhOTIwYzZiZmM0NGE4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBBcnJheSgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcHVzaF83NDBlNGIyODY3MDJkOTY0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkucHVzaChnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2VuZXJpY2NvbnRyYWN0X25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gR2VuZXJpY0NvbnRyYWN0Ll9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX29uTWVzc2FnZVNlbnRfZmMyZGVkM2I4MTUzNTA3YSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9uTWVzc2FnZVNlbnQodGFrZU9iamVjdChhcmcxKSwgdGFrZU9iamVjdChhcmcyKSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19vbk1lc3NhZ2VFeHBpcmVkX2ZiZGI0YjFhOGJiMGU3YzUgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbk1lc3NhZ2VFeHBpcmVkKHRha2VPYmplY3QoYXJnMSkpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfb25TdGF0ZUNoYW5nZWRfZTY5NmE3Yjk4N2RiYTllYSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9uU3RhdGVDaGFuZ2VkKHRha2VPYmplY3QoYXJnMSkpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfb25UcmFuc2FjdGlvbnNGb3VuZF8zM2I3YjU2Yzc3MGUyZTg4ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub25UcmFuc2FjdGlvbnNGb3VuZCh0YWtlT2JqZWN0KGFyZzEpLCB0YWtlT2JqZWN0KGFyZzIpKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2tleXNfMDcwMjI5NGFmYWViNjA0NCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gT2JqZWN0LmtleXMoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldF81NzI0NWNjN2Q3Yzc2MTlkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMClbYXJnMSA+Pj4gMF07XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Jvb2xlYW5fZ2V0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCB2ID0gZ2V0T2JqZWN0KGFyZzApO1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YodikgPT09ICdib29sZWFuJyA/ICh2ID8gMSA6IDApIDogMjtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2lzTG9jYWxfMGNjMGY2MjU4YzhjZjZjYSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmlzTG9jYWwoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld185OTYyZjkzOTIxOWYxODIwID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHN0YXRlMCA9IHthOiBhcmcwLCBiOiBhcmcxfTtcbiAgICAgICAgICAgIHZhciBjYjAgPSAoYXJnMCwgYXJnMSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBzdGF0ZTAuYTtcbiAgICAgICAgICAgICAgICBzdGF0ZTAuYSA9IDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fd2JnX2FkYXB0ZXJfMTYzKGEsIHN0YXRlMC5iLCBhcmcwLCBhcmcxKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTAuYSA9IGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKGNiMCk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc3RhdGUwLmEgPSBzdGF0ZTAuYiA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9OT0RFX01PRFVMRV9jZjY0MDFjYzEwOTEyNzllID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG1vZHVsZTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fb2JqZWN0X2Nsb25lX3JlZiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcHJvY2Vzc18wY2MyYWRhODUyNGQ2ZjgzID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkucHJvY2VzcztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3ZlcnNpb25zX2MxMWFjY2VhYjI3YTZjODcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS52ZXJzaW9ucztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vZGVfN2ZmMWNlNDljYWYyMzgxNSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm5vZGU7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZXF1aXJlX2E3NDZlNzliMzIyYjkzMzYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5yZXF1aXJlKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NyeXB0b18yMDM2YmVkN2M0NGMyNWU3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuY3J5cHRvO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbXNDcnlwdG9fYTIxZmM4OGNhZjFlY2RjOCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm1zQ3J5cHRvO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3d2l0aGxlbmd0aF9mNTkzMzg1NWU0ZjQ4YTE5ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShhcmcwID4+PiAwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldF83NjUyMDE1NDRhMmI2ODY5ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBSZWZsZWN0LmdldChnZXRPYmplY3QoYXJnMCksIGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NlbGZfNmQ0Nzk1MDZmNzJjNmE3MSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXQgPSBzZWxmLnNlbGY7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3dpbmRvd19mMjU1N2NjNzg0OTBhY2ViID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdpbmRvdy53aW5kb3c7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dsb2JhbFRoaXNfN2YyMDZiZGE2MjhkNTI4NiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXQgPSBnbG9iYWxUaGlzLmdsb2JhbFRoaXM7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dsb2JhbF9iYTc1YzUwZDFjZjM4NGY0ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdsb2JhbC5nbG9iYWw7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld25vYXJnc19iNWIwNjNmYzZjMmYwMzc2ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgRnVuY3Rpb24oZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NhbGxfOTdhZTlkODY0NWRjMzg4YiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNhbGwoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaXNBcnJheV8yN2M0NmM2N2Y0OThlMTVkID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBBcnJheS5pc0FycmF5KGdldE9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jYWxsXzE2OGRhODg3NzllMzVmNjEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5jYWxsKGdldE9iamVjdChhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X2JmM2Y4OWI5MmQ1YTM0YmYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFJlZmxlY3Quc2V0KGdldE9iamVjdChhcmcwKSwgZ2V0T2JqZWN0KGFyZzEpLCBnZXRPYmplY3QoYXJnMikpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yYW5kb21GaWxsU3luY18wNjVhZmZmZGUwMWRhYTY2ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkucmFuZG9tRmlsbFN5bmMoZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcxLCBhcmcyKSk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N1YmFycmF5XzU4YWQ0ZWZiYjViY2I4ODYgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5zdWJhcnJheShhcmcxID4+PiAwLCBhcmcyID4+PiAwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFJhbmRvbVZhbHVlc19iOTllZWM0MjQ0YTQ3NWJiID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuZ2V0UmFuZG9tVmFsdWVzKGdldE9iamVjdChhcmcxKSk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2xlbmd0aF85ZTFhZTE5MDBjYjBmYmQ1ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9tZW1vcnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5tZW1vcnk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19idWZmZXJfM2YzZDc2NGQ0NzQ3ZDU2NCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld184YzNmMDA1MjI3MmE0NTdhID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0XzgzZGI5NjkwZjkzNTNlNzkgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5zZXQoZ2V0T2JqZWN0KGFyZzEpLCBhcmcyID4+PiAwKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fZGVidWdfc3RyaW5nID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBkZWJ1Z1N0cmluZyhnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gcHRyMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fdGhyb3cgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdGhlbl8xMWY3YTU0ZDY3YjRiZmFkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudGhlbihnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jYl9kcm9wID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCBvYmogPSB0YWtlT2JqZWN0KGFyZzApLm9yaWdpbmFsO1xuICAgICAgICBpZiAob2JqLmNudC0tID09IDEpIHtcbiAgICAgICAgICAgIG9iai5hID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVzb2x2ZV85OWZlMTc5NjRmMzFmZmMwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBQcm9taXNlLnJlc29sdmUoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2xvc3VyZV93cmFwcGVyNjQzNyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbWFrZU11dENsb3N1cmUoYXJnMCwgYXJnMSwgOTI1LCBfX3diZ19hZGFwdGVyXzMyKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGltcG9ydHM7XG59XG5cbmZ1bmN0aW9uIGluaXRNZW1vcnkoaW1wb3J0cywgbWF5YmVfbWVtb3J5KSB7XG5cbn1cblxuZnVuY3Rpb24gZmluYWxpemVJbml0KGluc3RhbmNlLCBtb2R1bGUpIHtcbiAgICB3YXNtID0gaW5zdGFuY2UuZXhwb3J0cztcbiAgICBpbml0Ll9fd2JpbmRnZW5fd2FzbV9tb2R1bGUgPSBtb2R1bGU7XG4gICAgY2FjaGVkRmxvYXQ2NE1lbW9yeTAgPSBuZXcgRmxvYXQ2NEFycmF5KCk7XG4gICAgY2FjaGVkSW50MzJNZW1vcnkwID0gbmV3IEludDMyQXJyYXkoKTtcbiAgICBjYWNoZWRVaW50OE1lbW9yeTAgPSBuZXcgVWludDhBcnJheSgpO1xuXG5cbiAgICByZXR1cm4gd2FzbTtcbn1cblxuZnVuY3Rpb24gaW5pdFN5bmMobW9kdWxlKSB7XG4gICAgY29uc3QgaW1wb3J0cyA9IGdldEltcG9ydHMoKTtcblxuICAgIGluaXRNZW1vcnkoaW1wb3J0cyk7XG5cbiAgICBpZiAoIShtb2R1bGUgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5Nb2R1bGUpKSB7XG4gICAgICAgIG1vZHVsZSA9IG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobW9kdWxlKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShtb2R1bGUsIGltcG9ydHMpO1xuXG4gICAgcmV0dXJuIGZpbmFsaXplSW5pdChpbnN0YW5jZSwgbW9kdWxlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5pdChpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlucHV0ID0gbmV3IFVSTCgnbmVrb3Rvbl93YXNtX2JnLndhc20nLCBpbXBvcnQubWV0YS51cmwpO1xuICAgIH1cbiAgICBjb25zdCBpbXBvcnRzID0gZ2V0SW1wb3J0cygpO1xuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgKHR5cGVvZiBSZXF1ZXN0ID09PSAnZnVuY3Rpb24nICYmIGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkgfHwgKHR5cGVvZiBVUkwgPT09ICdmdW5jdGlvbicgJiYgaW5wdXQgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIGlucHV0ID0gZmV0Y2goaW5wdXQpO1xuICAgIH1cblxuICAgIGluaXRNZW1vcnkoaW1wb3J0cyk7XG5cbiAgICBjb25zdCB7IGluc3RhbmNlLCBtb2R1bGUgfSA9IGF3YWl0IGxvYWQoYXdhaXQgaW5wdXQsIGltcG9ydHMpO1xuXG4gICAgcmV0dXJuIGZpbmFsaXplSW5pdChpbnN0YW5jZSwgbW9kdWxlKTtcbn1cblxuZXhwb3J0IHsgaW5pdFN5bmMgfVxuZXhwb3J0IGRlZmF1bHQgaW5pdDtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///559\n')},444:(g,I,n)=>{"use strict";g.exports=n.p+"3610d36b17fcc23a1d17.wasm"}},__webpack_module_cache__={};function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var n=__webpack_module_cache__[g]={id:g,loaded:!1,exports:{}};return __webpack_modules__[g].call(n.exports,n,n.exports,__webpack_require__),n.loaded=!0,n.exports}__webpack_require__.m=__webpack_modules__,__webpack_require__.d=(g,I)=>{for(var n in I)__webpack_require__.o(I,n)&&!__webpack_require__.o(g,n)&&Object.defineProperty(g,n,{enumerable:!0,get:I[n]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(g){if("object"==typeof window)return window}}(),__webpack_require__.hmd=g=>((g=Object.create(g)).children||(g.children=[]),Object.defineProperty(g,"exports",{enumerable:!0,set:()=>{throw new Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: "+g.id)}}),g),__webpack_require__.o=(g,I)=>Object.prototype.hasOwnProperty.call(g,I),__webpack_require__.r=g=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},(()=>{var g;__webpack_require__.g.importScripts&&(g=__webpack_require__.g.location+"");var I=__webpack_require__.g.document;if(!g&&I&&(I.currentScript&&(g=I.currentScript.src),!g)){var n=I.getElementsByTagName("script");n.length&&(g=n[n.length-1].src)}if(!g)throw new Error("Automatic publicPath is not supported in this browser");g=g.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=g})(),__webpack_require__.b=document.baseURI||self.location.href;var __webpack_exports__=__webpack_require__(437)})();