(()=>{var __webpack_modules__={150:g=>{"use strict";g.exports=JSON.parse('{"router":"0:319cff1d2a3669d599291d270cfb475b8de644e88c418a93ad03cad09519a557"}')},579:g=>{"use strict";g.exports=JSON.parse('{"ABI version":2,"version":"2.2","header":["pubkey","time","expire"],"functions":[{"name":"constructor","inputs":[{"name":"router","type":"address"},{"name":"ownerPubkey","type":"uint256"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"color","type":"tuple"},{"name":"energy","type":"uint128"}],"outputs":[]},{"name":"getRouter","inputs":[],"outputs":[{"name":"router","type":"address"}]},{"name":"getDetails","inputs":[],"outputs":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"color","type":"tuple"},{"name":"level","type":"uint128"},{"name":"energy","type":"uint128"},{"name":"energySec","type":"uint128"},{"name":"energyMax","type":"uint128"},{"name":"lastCalcTime","type":"uint128"},{"name":"owner","type":"uint256"}]},{"name":"calculateEnergy","inputs":[],"outputs":[{"name":"energy","type":"uint128"}]},{"name":"markCell","inputs":[{"name":"sendGasTo","type":"address"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"targetCoord","type":"tuple"},{"name":"energy","type":"uint128"}],"outputs":[]},{"name":"helpCell","inputs":[{"name":"sendGasTo","type":"address"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"targetCoord","type":"tuple"},{"name":"energy","type":"uint128"}],"outputs":[]},{"name":"_helpCell","inputs":[{"name":"sendGasTo","type":"address"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"color","type":"tuple"},{"name":"energy","type":"uint128"}],"outputs":[]},{"name":"attkCell","inputs":[{"name":"sendGasTo","type":"address"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"targetCoord","type":"tuple"},{"name":"energy","type":"uint128"}],"outputs":[]},{"name":"_attkCell","inputs":[{"name":"sendGasTo","type":"address"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"color","type":"tuple"},{"name":"energy","type":"uint128"}],"outputs":[]},{"name":"upgradeCell","inputs":[{"name":"sendGasTo","type":"address"}],"outputs":[]},{"name":"_resolveCell","inputs":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"}],"outputs":[{"name":"cellAddress","type":"address"}]},{"name":"getOwner","inputs":[],"outputs":[{"name":"pubkey","type":"uint256"}]},{"name":"owner","inputs":[{"name":"answerId","type":"uint32"}],"outputs":[{"name":"pubkey","type":"uint256"}]},{"name":"transferOwnership","inputs":[{"name":"newOwner","type":"uint256"}],"outputs":[]}],"data":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"key":1,"name":"_coord","type":"tuple"}],"events":[{"name":"OwnershipTransferred","inputs":[{"name":"oldOwner","type":"uint256"},{"name":"newOwner","type":"uint256"}],"outputs":[]}],"fields":[{"name":"_pubkey","type":"uint256"},{"name":"_timestamp","type":"uint64"},{"name":"_constructorFlag","type":"bool"},{"name":"_owner","type":"uint256"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"_coord","type":"tuple"},{"name":"_costPerLevel","type":"uint128[]"},{"name":"_energyPerLevel","type":"uint128[]"},{"name":"_energyPerLevelMax","type":"uint128[]"},{"name":"_router","type":"address"},{"name":"_level","type":"uint128"},{"name":"_energy","type":"uint128"},{"name":"_lastCalcTime","type":"uint128"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"_color","type":"tuple"}]}')},750:g=>{"use strict";g.exports=JSON.parse('{"ABI version":2,"version":"2.2","header":["pubkey","time","expire"],"functions":[{"name":"constructor","inputs":[{"name":"ownerPubkey","type":"uint256"},{"name":"codeCell","type":"cell"}],"outputs":[]},{"name":"getDetails","inputs":[],"outputs":[{"name":"nonce","type":"uint16"},{"name":"owner","type":"uint256"}]},{"name":"getAddressCells","inputs":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coords","type":"tuple[]"}],"outputs":[{"name":"addreses","type":"address[]"}]},{"name":"newGame","inputs":[{"name":"sendGasTo","type":"address"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"baseCoord","type":"tuple"}],"outputs":[]},{"name":"_newCell","inputs":[{"name":"sendGasTo","type":"address"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"baseCoord","type":"tuple"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"targetCoord","type":"tuple"},{"components":[{"name":"r","type":"uint8"},{"name":"g","type":"uint8"},{"name":"b","type":"uint8"}],"name":"color","type":"tuple"},{"name":"energy","type":"uint128"}],"outputs":[]},{"name":"_resolveCell","inputs":[{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"}],"outputs":[{"name":"cellAddress","type":"address"}]},{"name":"getOwner","inputs":[],"outputs":[{"name":"pubkey","type":"uint256"}]},{"name":"owner","inputs":[{"name":"answerId","type":"uint32"}],"outputs":[{"name":"pubkey","type":"uint256"}]},{"name":"transferOwnership","inputs":[{"name":"newOwner","type":"uint256"}],"outputs":[]}],"data":[{"key":1,"name":"_nonce","type":"uint16"}],"events":[{"name":"CellCreated","inputs":[{"name":"owner","type":"uint256"},{"components":[{"name":"x","type":"int64"},{"name":"y","type":"int64"},{"name":"z","type":"int64"}],"name":"coord","type":"tuple"}],"outputs":[]},{"name":"OwnershipTransferred","inputs":[{"name":"oldOwner","type":"uint256"},{"name":"newOwner","type":"uint256"}],"outputs":[]}],"fields":[{"name":"_pubkey","type":"uint256"},{"name":"_timestamp","type":"uint64"},{"name":"_constructorFlag","type":"bool"},{"name":"_owner","type":"uint256"},{"name":"_nonce","type":"uint16"},{"name":"_codeCell","type":"cell"}]}')},68:(__unused_webpack_module,exports)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Mutex = exports.Semaphore = void 0;\nfunction ensureCallable(fn) {\n    if (typeof fn !== 'function')\n        throw new TypeError(fn + \" is not a function\");\n    return fn;\n}\nfunction byObserver(Observer) {\n    const node = document.createTextNode('');\n    let queue, currentQueue, bit = 0, i = 0;\n    new Observer(function () {\n        let callback;\n        if (!queue) {\n            if (!currentQueue)\n                return;\n            queue = currentQueue;\n        }\n        else if (currentQueue) {\n            queue = currentQueue.slice(i).concat(queue);\n        }\n        currentQueue = queue;\n        queue = null;\n        i = 0;\n        if (typeof currentQueue === 'function') {\n            callback = currentQueue;\n            currentQueue = null;\n            callback();\n            return;\n        }\n        node.data = (bit = ++bit % 2); // Invoke other batch, to handle leftover callbacks in case of crash\n        while (i < currentQueue.length) {\n            callback = currentQueue[i];\n            i++;\n            if (i === currentQueue.length)\n                currentQueue = null;\n            callback();\n        }\n    }).observe(node, { characterData: true });\n    return function (fn) {\n        ensureCallable(fn);\n        if (queue) {\n            if (typeof queue === 'function')\n                queue = [queue, fn];\n            else\n                queue.push(fn);\n            return;\n        }\n        queue = fn;\n        node.data = (bit = ++bit % 2);\n    };\n}\nconst nextTick = (function () {\n    // queueMicrotask\n    if (typeof queueMicrotask === \"function\") {\n        return function (cb) {\n            queueMicrotask(ensureCallable(cb));\n        };\n    }\n    // MutationObserver\n    if ((typeof document === 'object') && document) {\n        if (typeof MutationObserver === 'function')\n            return byObserver(MutationObserver);\n        if (typeof window.WebKitMutationObserver === 'function')\n            return byObserver(window.WebKitMutationObserver);\n    }\n    // W3C Draft\n    // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html\n    if (typeof setImmediate === 'function') {\n        return function (cb) {\n            setImmediate(ensureCallable(cb));\n        };\n    }\n    // Wide available standard\n    if ((typeof setTimeout === 'function') || (typeof setTimeout === 'object')) {\n        return function (cb) {\n            setTimeout(ensureCallable(cb), 0);\n        };\n    }\n    throw new Error('No `nextTick` implementation found');\n}());\nclass Semaphore {\n    constructor(count) {\n        this.tasks = [];\n        this.count = count;\n    }\n    sched() {\n        if (this.count > 0 && this.tasks.length > 0) {\n            this.count--;\n            let next = this.tasks.shift();\n            if (next === undefined) {\n                throw \"Unexpected undefined value in tasks list\";\n            }\n            next();\n        }\n    }\n    acquire() {\n        return new Promise((res, _rej) => {\n            const task = () => {\n                let released = false;\n                res(() => {\n                    if (!released) {\n                        released = true;\n                        this.count++;\n                        this.sched();\n                    }\n                });\n            };\n            this.tasks.push(task);\n            nextTick(this.sched.bind(this));\n        });\n    }\n    use(f) {\n        return this.acquire()\n            .then(release => {\n            return f()\n                .then((res) => {\n                release();\n                return res;\n            })\n                .catch((err) => {\n                release();\n                throw err;\n            });\n        });\n    }\n}\nexports.Semaphore = Semaphore;\nclass Mutex extends Semaphore {\n    constructor() {\n        super(1);\n    }\n}\nexports.Mutex = Mutex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9ub2RlX21vZHVsZXMvQGJyb3h1cy9hd2FpdC1zZW1hcGhvcmUvZGlzdC9pbmRleC5qcz83YWNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NdXRleCA9IGV4cG9ydHMuU2VtYXBob3JlID0gdm9pZCAwO1xuZnVuY3Rpb24gZW5zdXJlQ2FsbGFibGUoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgcmV0dXJuIGZuO1xufVxuZnVuY3Rpb24gYnlPYnNlcnZlcihPYnNlcnZlcikge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbGV0IHF1ZXVlLCBjdXJyZW50UXVldWUsIGJpdCA9IDAsIGkgPSAwO1xuICAgIG5ldyBPYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCBjYWxsYmFjaztcbiAgICAgICAgaWYgKCFxdWV1ZSkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50UXVldWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5zbGljZShpKS5jb25jYXQocXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IG51bGw7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRRdWV1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjdXJyZW50UXVldWU7XG4gICAgICAgICAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmRhdGEgPSAoYml0ID0gKytiaXQgJSAyKTsgLy8gSW52b2tlIG90aGVyIGJhdGNoLCB0byBoYW5kbGUgbGVmdG92ZXIgY2FsbGJhY2tzIGluIGNhc2Ugb2YgY3Jhc2hcbiAgICAgICAgd2hpbGUgKGkgPCBjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGN1cnJlbnRRdWV1ZVtpXTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGlmIChpID09PSBjdXJyZW50UXVldWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfSkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICBlbnN1cmVDYWxsYWJsZShmbik7XG4gICAgICAgIGlmIChxdWV1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBxdWV1ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IFtxdWV1ZSwgZm5dO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlID0gZm47XG4gICAgICAgIG5vZGUuZGF0YSA9IChiaXQgPSArK2JpdCAlIDIpO1xuICAgIH07XG59XG5jb25zdCBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgLy8gcXVldWVNaWNyb3Rhc2tcbiAgICBpZiAodHlwZW9mIHF1ZXVlTWljcm90YXNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soZW5zdXJlQ2FsbGFibGUoY2IpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTXV0YXRpb25PYnNlcnZlclxuICAgIGlmICgodHlwZW9mIGRvY3VtZW50ID09PSAnb2JqZWN0JykgJiYgZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuIGJ5T2JzZXJ2ZXIoTXV0YXRpb25PYnNlcnZlcik7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm4gYnlPYnNlcnZlcih3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlcik7XG4gICAgfVxuICAgIC8vIFczQyBEcmFmdFxuICAgIC8vIGh0dHA6Ly9kdmNzLnczLm9yZy9oZy93ZWJwZXJmL3Jhdy1maWxlL3RpcC9zcGVjcy9zZXRJbW1lZGlhdGUvT3ZlcnZpZXcuaHRtbFxuICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZShlbnN1cmVDYWxsYWJsZShjYikpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBXaWRlIGF2YWlsYWJsZSBzdGFuZGFyZFxuICAgIGlmICgodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHx8ICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZW5zdXJlQ2FsbGFibGUoY2IpLCAwKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBgbmV4dFRpY2tgIGltcGxlbWVudGF0aW9uIGZvdW5kJyk7XG59KCkpO1xuY2xhc3MgU2VtYXBob3JlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb3VudCkge1xuICAgICAgICB0aGlzLnRhc2tzID0gW107XG4gICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICB9XG4gICAgc2NoZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvdW50ID4gMCAmJiB0aGlzLnRhc2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQtLTtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy50YXNrcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKG5leHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiVW5leHBlY3RlZCB1bmRlZmluZWQgdmFsdWUgaW4gdGFza3MgbGlzdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFjcXVpcmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCBfcmVqKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByZWxlYXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlcygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVsZWFzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudGFza3MucHVzaCh0YXNrKTtcbiAgICAgICAgICAgIG5leHRUaWNrKHRoaXMuc2NoZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1c2UoZikge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3F1aXJlKClcbiAgICAgICAgICAgIC50aGVuKHJlbGVhc2UgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGYoKVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VtYXBob3JlID0gU2VtYXBob3JlO1xuY2xhc3MgTXV0ZXggZXh0ZW5kcyBTZW1hcGhvcmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigxKTtcbiAgICB9XG59XG5leHBvcnRzLk11dGV4ID0gTXV0ZXg7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///68\n")},612:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// NAMESPACE OBJECT: ./src/scripts/ever.js\nvar ever_namespaceObject = {};\n__webpack_require__.r(ever_namespaceObject);\n__webpack_require__.d(ever_namespaceObject, {\n  "attkCell": () => (attkCell),\n  "getAddressCells": () => (getAddressCells),\n  "getDetailsCell": () => (getDetailsCell),\n  "helpCell": () => (helpCell),\n  "init": () => (init),\n  "markCell": () => (markCell),\n  "newGame": () => (newGame),\n  "routerDetails": () => (routerDetails),\n  "subscribeCellState": () => (subscribeCellState),\n  "subscribePermissionsChanged": () => (subscribePermissionsChanged),\n  "upgradeCell": () => (upgradeCell)\n});\n\n;// CONCATENATED MODULE: ./node_modules/honeycomb-grid/dist/honeycomb.esm.min.js\n"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof self&&self;var t=function(t,n){return t(n={exports:{}},n.exports),n.exports}((function(t,n){\n/*! axis.js v1.2.1 | (c) 2016 @toddmotto | https://github.com/toddmotto/axis */\nt.exports=function(){var t={},n="Array Object String Date RegExp Function Boolean Number Null Undefined".split(" ");function r(){return Object.prototype.toString.call(this).slice(8,-1)}for(var e=n.length;e--;)t["is"+n[e]]=function(t){return function(n){return r.call(n)===t}}(n[e]);return t}()})),n=t.isObject,r=t.isNumber,e=t.isArray,i=t.isString;function s(t,n){return n+t*(1&n)>>1}function o(t,n){return(t%n+n)%n}function u(t,n){if(!/^(N|S)?(E|W)?$/i.test(t))throw new Error(`Invalid compass direction: ${t}. Choose from E, SE, S, SW, W, NW, N or NE.`);if(n=n.toLowerCase(),t=t.toUpperCase(),"pointy"===n&&["N","S"].includes(t))throw new Error(`Direction ${t} is ambiguous for pointy hexes. Did you mean ${t}E or ${t}W?`);if("flat"===n&&["E","W"].includes(t))throw new Error(`Direction ${t} is ambiguous for flat hexes. Did you mean N${t} or S${t}?`);return{pointy:{E:0,SE:1,SW:2,W:3,NW:4,NE:5},flat:{SE:0,S:1,SW:2,NW:3,N:4,NE:5}}[n][t]}function c(t,n){return r(t)||r(n)?r(t)?r(n)||(n=t):t=n:t=n=0,{x:t,y:n}}const a=[{q:1,r:0,s:-1},{q:0,r:1,s:-1},{q:-1,r:1,s:0},{q:-1,r:0,s:1},{q:0,r:-1,s:1},{q:1,r:-1,s:0}],h=[{q:2,r:-1,s:-1},{q:1,r:1,s:-2},{q:-1,r:2,s:-1},{q:-2,r:1,s:1},{q:-1,r:-1,s:2},{q:1,r:-2,s:1}],f={q:1e-6,r:1e-6,s:-2e-6};function l(t){return r(t)?this[t]:this[this.indexOf(t)]}function d({isValidHex:t}){return function(n,e){if(!t(e))return this;const i=r(n)?n:this.indexOf(n);return i<0?this.push(e):this[i]=e,this}}function x(t,n){const r=t.distance(n),e=1/Math.max(r,1);let i=[];for(let s=0;s<=r;s++){const r=t.nudge().lerp(n.nudge(),e*s).round();i.push(this.get(r))}return i}function y({isValidHex:t}){return function(n,r=0,e=!0){if(!t(n))throw new Error(`Invalid center hex: ${n}.`);if(!this.get(n))throw new Error(`Center hex with coordinates ${n} not present in grid.`);let i=[];for(let t=-r;t<=r;t++)for(let s=Math.max(-r,-t-r);s<=Math.min(r,-t+r);s++){const r=this.get(n.cubeToCartesian({q:n.q+t,r:n.r+s}));n.equals(r)&&!e||i.push(r)}return i.filter(Boolean)}}function p({isValidHex:t,signedModulo:n,compassToNumberDirection:r}){return function(e,s="all",o=!1){if(!t(e))throw new Error(`Invalid hex: ${e}.`);const u=o?h:a;return"all"===s&&(s=[0,1,2,3,4,5]),[].concat(s).map(t=>{i(t)&&(t=r(t,e.orientation)),(t<0||t>5)&&(t=n(t,6));const{q:s,r:o}=u[t];return this.get(e.cubeToCartesian({q:e.q+s,r:e.r+o}))})}}function g(){if(0===this.length)return 0;const{0:t,length:n,[n-1]:r}=this[0].isPointy()?[...this].sort((t,n)=>n.s-t.s||t.q-n.q):[...this].sort((t,n)=>t.q-n.q);return r.toPoint().x-t.toPoint().x+this[0].width()}function b(){if(0===this.length)return 0;const{0:t,length:n,[n-1]:r}=this[0].isPointy()?[...this].sort((t,n)=>t.r-n.r):[...this].sort((t,n)=>n.s-t.s||t.r-n.r);return r.toPoint().y-t.toPoint().y+this[0].height()}function q({Hex:t}){return function(n,r){return t().fromPoint(n,r)}}function P({Grid:t,Hex:n}){return function({width:r,height:e,start:i,direction:s=1,onCreate:o=(()=>{})}){i=n(i);const[u,c,a]={1:["q","r","s"],3:["r","s","q"],5:["s","q","r"]}[s],h=new t;h.width=r,h.height=e,h.start=i,h.direction=s;for(let t=0;t<r;t++)for(let r=0;r<e;r++){const e=n({[u]:t+i[u],[c]:r+i[c],[a]:-t-r+i[a]});o(e,h),h.push(e)}return h}}function w({Grid:t,Hex:n}){return function({size:r,start:e,direction:i=1,onCreate:s=(()=>{})}){e=n(e);const o={1:{rStart:()=>0,rEnd:t=>r-t},5:{rStart:t=>r-t,rEnd:()=>r+1}},{rStart:u,rEnd:c}=o[i],a=new t;a.size=r,a.start=e,a.direction=i;for(let t=0;t<r;t++)for(let r=u(t);r<c(t);r++){const i=n({q:t+e.q,r:r+e.r,s:-t-r+e.s});s(i,a),a.push(i)}return a}}function m({Grid:t,Hex:n}){return function({radius:r,center:e,onCreate:i=(()=>{})}){e=n(e);const s=new t;s.radius=r,s.center=e;for(let t=-r;t<=r;t++){const o=Math.max(-r,-t-r),u=Math.min(r,-t+r);for(let r=o;r<=u;r++){const o=n({q:t+e.q,r:r+e.r,s:-t-r+e.s});i(o,s),s.push(o)}}return s}}function H({Grid:t,Hex:n,compassToNumberDirection:r,signedModulo:e}){return function({width:o,height:u,start:c,direction:a=(n().isPointy()?0:1),onCreate:h=(()=>{})}){c=n(c),i(a)&&(a=r(a,c.orientation)),(a<0||a>5)&&(a=e(a,6));const[f,l,d]=[["q","r","s"],["r","q","s"],["r","s","q"],["s","r","q"],["s","q","r"],["q","s","r"]][a],[x,y]=c.isPointy()?[o,u]:[u,o],p=new t;p.width=o,p.height=u,p.start=c,p.direction=a;for(let t=0;t<y;t++){const r=s(c.offset,t);for(let e=-r;e<x-r;e++){const r=n({[f]:e+c[f],[l]:t+c[l],[d]:-e-t+c[d]});h(r,p),p.push(r)}}return p}}function O({Grid:t,Hex:n}){return function({radius:r,center:e,onCreate:i=(()=>{})}){e=n(e);const s=new t;s.radius=r,s.center=e;const{q:o,r:u,s:c}=e;let h=n({q:o,r:u-r,s:c+r});for(let t=0;t<6;t++)for(let e=0;e<r;e++){i(h,s),s.push(h);const{q:r,r:e,s:o}=a[t];h=n({q:h.q+r,r:h.r+e,s:h.s+o})}return s}}function j({Grid:t,Hex:n}){return function({radius:r,center:e,onCreate:i=(()=>{})}){e=n(e);let s=new t;i(e,s),s.push(e);for(let t=1;t<=r;t++)s=s.concat(this.ring({radius:t,center:e,onCreate:i}));return s.radius=r,s.center=e,s}}function M({Point:t}){return function(n,r){let e;return({x:e,y:r}=t(n,r)),t(this.x+e,this.y+r)}}function E({Point:t}){return function(n,r){let e;return({x:e,y:r}=t(n,r)),t(this.x-e,this.y-r)}}function C({Point:t}){return function(n,r){let e;return({x:e,y:r}=t(n,r)),t(this.x*e,this.y*r)}}function N({Point:t}){return function(n,r){let e;return({x:e,y:r}=t(n,r)),t(this.x/e,this.y/r)}}function S({ensureXY:t}){const i={add:M({Point:s}),subtract:E({Point:s}),multiply:C({Point:s}),divide:N({Point:s})};function s(s,o){let u;return u=r(s)?t(s,o):e(s)?t(...s):n(s)?t(s.x,s.y):t(0),Object.assign(Object.create(i),u)}return s}const R=S({ensureXY:c});class $ extends Array{static isValidHex(t){return!0===(t||{}).__isHoneycombHex}fill(){throw new TypeError("Grid.prototype.fill is not implemented")}includes(t,n=0){return!!(this.indexOf(t,n)+1)}indexOf(t,n=0){const{length:r}=this;let e=Number(n);for(t=R(t),e=Math.max(e>=0?e:r+e,0);e<r;e++)if(this[e].equals(t))return e;return-1}lastIndexOf(t,n=this.length-1){const{length:r}=this;let e=Number(n);for(t=R(t),e=e>=0?Math.min(e,r-1):r+e;e>=0;e--)if(this[e].equals(t))return e;return-1}push(...t){return super.push(...t.filter($.isValidHex))}splice(t,n,...r){return null==n?super.splice(t):super.splice(t,n,...r.filter($.isValidHex))}unshift(...t){return super.unshift(...t.filter($.isValidHex))}}function v(t,n,r){return n in t?Object.defineProperty(t,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[n]=r,t}function T(t,n){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var e=Object.getOwnPropertySymbols(t);n&&(e=e.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),r.push.apply(r,e)}return r}function G(t){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?T(Object(r),!0).forEach((function(n){v(t,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):T(Object(r)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(r,n))}))}return t}function D(t,n){if(null==t)return{};var r,e,i=function(t,n){if(null==t)return{};var r,e,i={},s=Object.keys(t);for(e=0;e<s.length;e++)r=s[e],n.indexOf(r)>=0||(i[r]=t[r]);return i}(t,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(e=0;e<s.length;e++)r=s[e],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(t,r)&&(i[r]=t[r])}return i}function z({Hex:t}){return function(...n){return Object.assign(this,t(...n))}}function V(){return{x:this.x,y:this.y}}function W(){return{q:this.q,r:this.r,s:this.s}}function I({q:t,r:n}){let r,e;return this.isPointy()?(r=t+s(this.offset,n),e=n):(r=t,e=n+s(this.offset,t)),{x:r,y:e}}function X(){return"pointy"===this.orientation.toLowerCase()}function Y(){return"flat"===this.orientation.toLowerCase()}function B(){const{xRadius:t}=this.size;return this.isPointy()?t*Math.sqrt(3):2*t}function _(){const{yRadius:t}=this.size;return this.isPointy()?2*t:t*Math.sqrt(3)}function A({Point:t}){return function(){const n=this.width(),r=this.height(),{x:e,y:i}=this.origin;return this.isPointy()?[t(n-e,.25*r-i),t(n-e,.75*r-i),t(.5*n-e,r-i),t(0-e,.75*r-i),t(0-e,.25*r-i),t(.5*n-e,0-i)]:[t(n-e,.5*r-i),t(.75*n-e,r-i),t(.25*n-e,r-i),t(0-e,.5*r-i),t(.25*n-e,0-i),t(.75*n-e,0-i)]}}function L({Point:t}){return function(){const{x:n,y:r}=this.origin;return t(this.width()/2-n,this.height()/2-r)}}function k({Point:t}){return function(){const{q:n,r:r,size:e}=this,{xRadius:i,yRadius:s}=e;let o,u;return this.isPointy()?(o=i*Math.sqrt(3)*(n+r/2),u=3*s/2*r):(o=3*i/2*n,u=s*Math.sqrt(3)*(r+n/2)),t(o,u)}}function F({Point:t,Hex:n}){return function(r,e){const{xRadius:i,yRadius:s}=this.size;let o,u,c;return({x:o,y:e}=t(r,e).subtract(this.center())),this.isPointy()?(u=Math.sqrt(3)*o/(3*i)-e/(3*s),c=2/3*(e/s)):(u=2/3*(o/i),c=Math.sqrt(3)*e/(3*s)-o/(3*i)),n({q:u,r:c,s:-u-c}).round()}}function U({Hex:t,Point:n}){return function(r){const{x:e,y:i}=n(r);return t(this.x+e,this.y+i,G({},this))}}function J({Hex:t,Point:n}){return function(r){const{x:e,y:i}=n(r);return t(this.x-e,this.y-i,G({},this))}}function K({Point:t}){return function(n){if(null!=n&&(e(n)||r(n.x)&&r(n.y))){const{x:r,y:e}=t(n);return this.x===r&&this.y===e}return!1}}function Q(t){return Math.max(Math.abs(this.q-t.q),Math.abs(this.r-t.r),Math.abs(this.s-t.s))}function Z({Hex:t}){return function(){let{q:n,r:r,s:e}=this,i=Math.round(n),s=Math.round(r),o=Math.round(e);const u=Math.abs(n-i),c=Math.abs(r-s),a=Math.abs(e-o);return u>c&&u>a?i=-s-o:c>a?s=-i-o:o=-i-s,t(G(G({},this),{},{q:i,r:s,s:o}))}}function tt({Hex:t}){return function(n,r){const e=this.q*(1-r)+n.q*r,i=this.r*(1-r)+n.r*r;return t(G(G({},this),{},{q:e,r:i,s:-e-i}))}}function nt({Hex:t}){return function(){const{q:n,r:r,s:e}=f;return t(G(G({},this),{},{q:this.q+n,r:this.r+r,s:this.s+e}))}}function rt(){return`${this.x},${this.y}`}const et={thirdCoordinate:function(t,n){return-t-n}};const it=S({ensureXY:c}),st=function({ensureXY:t,normalizeRadiuses:i,Point:o}){return function(u={}){const c=function({Point:t}){return function(n,r){let e,i,o;return({x:e,y:r}=t(n,r)),this.isPointy()?(i=e-s(this.offset,r),o=r):(i=e,o=r-s(this.offset,e)),{q:i,r:o,s:-i-o}}}({Point:o}),a={__isHoneycombHex:!0,orientation:"pointy",origin:0,size:{xRadius:1,yRadius:1},offset:-1,get q(){return this.cartesianToCube(this).q},get r(){return this.cartesianToCube(this).r},get s(){return this.cartesianToCube(this).s},add:U({Hex:f,Point:o}),cartesian:V,cartesianToCube:c,center:L({Point:o}),coordinates:V,corners:A({Point:o}),cube:W,cubeToCartesian:I,distance:Q,equals:K({Point:o}),fromPoint:F({Point:o,Hex:f}),height:_,isFlat:Y,isPointy:X,lerp:tt({Hex:f}),nudge:nt({Hex:f}),round:Z({Hex:f}),set:z({Hex:f}),subtract:J({Hex:f,Point:o}),toCartesian:I,toCube:c,toPoint:k({Point:o}),toString:rt,width:B},h=Object.assign(a,u);function f(i,s,o={}){let u;if(n(i)){let{q:t,r:n,s:e}=i,c=D(i,["q","r","s"]);if(r(t)||r(n)||r(e)){const r=t+n+e;if(Number.isNaN(r)||r>1e-12)throw new Error(`Cube coordinates must have a sum of 0. q: ${t}, r: ${n}, s: ${e}, sum: ${t+n+e}.`);({x:u,y:s}=h.cubeToCartesian({q:t,r:n,s:e}))}else({x:u,y:s}=i);o=c}else e(i)?([u,s]=i,o={}):u=i;return Object.assign(Object.create(h),Object.assign(o,t(u,s)))}return h.size=i(h.size,h.isPointy()),h.origin=o(h.origin),Object.assign(f,et,{toJSON:()=>u}),f}}({ensureXY:c,normalizeRadiuses:function(t,e){if(n(t)){if(r(t.xRadius)&&r(t.yRadius))return t;const{width:n,height:i}=t;if(r(n)&&r(i))return e?{xRadius:n/Math.sqrt(3),yRadius:i/2}:{xRadius:n/2,yRadius:i/Math.sqrt(3)}}if(r(t))return{xRadius:t,yRadius:t};throw new Error(`Invalid size: ${t}. Set it as a number or as an object containing width and height.`)},Point:it}),ot=function({extendHex:t,Grid:n,Point:i}){const{isValidHex:s}=n;return function(c=t()){function a(...t){return t=t.filter(Boolean),e(t[0])&&(0===t[0].length||t[0].some(t=>!r(t)))&&(t=t[0]),new n(...t.map(t=>c(t)))}return Object.assign(a,{Hex:c,isValidHex:s,pointToHex:q({Point:i,Hex:c}),parallelogram:P({Grid:n,Hex:c}),triangle:w({Grid:n,Hex:c}),hexagon:m({Grid:n,Hex:c}),rectangle:H({Grid:n,Hex:c,compassToNumberDirection:u,signedModulo:o}),ring:O({Grid:n,Hex:c}),spiral:j({Grid:n,Hex:c})}),Object.assign(n.prototype,{get:l,hexesBetween:x,hexesInRange:y({isValidHex:s}),neighborsOf:p({isValidHex:s,signedModulo:o,compassToNumberDirection:u}),pointHeight:b,pointWidth:g,set:d({isValidHex:s})}),a}}({extendHex:st,Grid:$,Point:it});\n//# sourceMappingURL=honeycomb.esm.min.js.map\n\n;// CONCATENATED MODULE: ./src/scripts/mapgenerator.js\n//Imports\n //Public variables\n//-\n//Private variables\n\nlet Grid = ot(st({\n  orientation: \'flat\'\n})); //Public functions\n\nfunction getRandomMap(width, height) {\n  let map = Grid.rectangle({\n    width: width,\n    height: height\n  }); //Basic water layer\n\n  for (let hex of map) {\n    hex.type = "64, 128, 255";\n    hex.highlight = false;\n  } // //Ring of sand\n  // let island = map.hexesInRange(map.get([Math.floor(size / 2), Math.floor(size / 2)]), (size - 7) / 2)\n  // island.forEach((hex) => {\n  // hex.type = "234,206,106"\n  // hex.walkable = true\n  // })\n  // //Inland terrain\n  // island = map.hexesInRange(map.get([Math.floor(size / 2), Math.floor(size / 2)]), ((size - 7) / 2) - 1)\n  // island.forEach((hex) => {\n  // hex.type = "0,128,0" //["0,128,0", "139,69,19"].random()\n  // })\n  // //Vision blocking blocks\n  // island.forEach((hex) => {\n  // if (Math.random() > 0.85) {\n  // hex.type = "50,50,50"\n  // hex.seeThrough = false\n  // hex.walkable = false\n  // }\n  // })\n\n\n  return map;\n} //Private functions\n\nArray.prototype.random = function () {\n  return this[Math.floor(Math.random() * this.length)];\n};\n/*\nlet img = new Image()\nimg.src = \'url\'\nlet pattern = ctx.createPattern(img, \'repeat\')\n*/\n;// CONCATENATED MODULE: ./src/scripts/display.js\n//Imports\n //Public variables\n\nconst camera = {\n  x: 0,\n  y: 0,\n  zoom: 1\n};\nlet currentMap; //Private variables\n\nconst mainCanvas = document.querySelector("#mainCanvas");\nconst animCanvas = document.querySelector("#animationCanvas");\nconst mainCtx = mainCanvas.getContext("2d");\nconst animCtx = animCanvas.getContext("2d");\nlet scales = [];\nlet hexSize;\nlet a_full, b_full, c_full, a_hex, b_hex, c_hex;\nlet halfCanvasWidth, halfCanvasHeight;\nlet display_Grid = ot(st({}));\nlet PROVIDER;\nlet isdblclick = false;\n\nasync function sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n} //Public functions\n\n\nasync function initiateMap(map, ever) {\n  currentMap = map;\n  mainCanvas.width = window.innerWidth;\n  mainCanvas.height = window.innerHeight;\n  animCanvas.width = window.innerWidth;\n  animCanvas.height = window.innerHeight;\n  calculateHexDimensions();\n  windowResizeUpdate();\n  zoomUpdate();\n  drawMap();\n  camera.x = halfCanvasWidth;\n  camera.y = halfCanvasHeight;\n  PROVIDER = ever;\n  await PROVIDER.init(currentMap);\n  recalcEnergy();\n}\n\nfunction recalcEnergy() {\n  for (let hex of currentMap) {\n    if (!hex.details) continue;\n    calculateEnergy(hex);\n  }\n\n  setTimeout(recalcEnergy, 1000);\n}\n\nfunction calculateEnergy(hex) {\n  let dateNow = Math.round(Date.now() / 1000);\n\n  if (1 * hex.details.energy >= 1 * hex.details.energyMax || 1 * hex.details.lastCalcTime >= dateNow) {\n    return;\n  }\n\n  let energy = Math.min(1 * hex.details.energy + hex.details.energySec * (dateNow - hex.details.lastCalcTime), 1 * hex.details.energyMax);\n  hex.details.lastCalcTime = dateNow;\n  hex.details.energy = energy;\n}\n\nfunction zoomUpdate() {\n  const hex = display_Grid.pointToHex(camera.x, camera.y);\n  const x = hex.x;\n  const y = hex.y;\n  hexSize = scales[camera.zoom];\n  calculateHexDimensions();\n  display_Grid = ot(st({\n    size: hexSize,\n    orientation: \'flat\'\n  }));\n  const replacementMap = display_Grid.rectangle({\n    width: currentMap.width,\n    height: currentMap.height\n  });\n\n  for (let i = 0; i < currentMap.length; i++) {\n    currentMap[i].size = replacementMap[i].size;\n\n    if (currentMap[i].x === x && currentMap[i].y === y) {\n      camera.x = Math.round(currentMap[i].toPoint().x + b_full + hexSize / 2);\n      camera.y = Math.round(currentMap[i].toPoint().y + c_full);\n    }\n  }\n} //Private functions\n\nfunction drawMap() {\n  //Clearing\n  mainCtx.setTransform(1, 0, 0, 1, 0, 0);\n  mainCtx.fillStyle = "black";\n  mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height); //Positioning the camera\n\n  mainCtx.translate(-camera.x + halfCanvasWidth, -camera.y + halfCanvasHeight);\n\n  for (let hex of currentMap) {\n    //Hex is ignored if it wasn\'t seen yet\n    //if (hex.visibility === \'unseen\') continue\n    let x = hex.toPoint().x,\n        y = hex.toPoint().y; //Checking if hex is visible within canvas\n\n    if (Math.abs(x - camera.x) > halfCanvasWidth + hexSize || Math.abs(y - camera.y) > halfCanvasHeight + hexSize) continue; //Drawing highlight around hex\n\n    if (hex.highlight) {\n      mainCtx.strokeStyle = "white";\n      mainCtx.beginPath();\n      mainCtx.moveTo(x + a_full, y - c_full);\n      mainCtx.lineTo(x + b_full, y);\n      mainCtx.lineTo(x + a_full, y + c_full);\n      mainCtx.lineTo(x - a_full, y + c_full);\n      mainCtx.lineTo(x - b_full, y);\n      mainCtx.lineTo(x - a_full, y - c_full);\n      mainCtx.closePath();\n      mainCtx.stroke();\n    } //Drawing the hex\n\n\n    let color = hex.details ? `${hex.details.color.r}, ${hex.details.color.g}, ${hex.details.color.b}` : hex.type;\n    mainCtx.fillStyle = `rgba(${color},1)`;\n    mainCtx.beginPath();\n    mainCtx.moveTo(x + a_hex, y - c_hex);\n    mainCtx.lineTo(x + b_hex, y);\n    mainCtx.lineTo(x + a_hex, y + c_hex);\n    mainCtx.lineTo(x - a_hex, y + c_hex);\n    mainCtx.lineTo(x - b_hex, y);\n    mainCtx.lineTo(x - a_hex, y - c_hex);\n    mainCtx.closePath();\n    mainCtx.fill();\n    setText(mainCtx, x, y - hexSize / 2, `${hex.x};${hex.y}`);\n\n    if (hex.details) {\n      setText(mainCtx, x, y, `${hex.details.energy}`);\n      setText(mainCtx, x, y + hexSize / 2, `lvl: ${1 * hex.details.level + 1}`);\n    }\n  }\n\n  requestAnimationFrame(drawMap);\n}\n\nfunction setText(ctx, x, y, txt, fontSize = 10, style = "white", align = \'center\') {\n  let _font = `${fontSize * (camera.zoom + 1)}px Georgia`;\n  ctx.font = _font;\n  ctx.fillStyle = style;\n  ctx.textAlign = align;\n  ctx.fillText(txt, x, y, hexSize);\n}\n\nfunction calculateHexDimensions() {\n  a_full = hexSize / 2;\n  b_full = hexSize;\n  c_full = hexSize / 2 * Math.sqrt(3);\n  a_hex = a_full * 0.95;\n  b_hex = b_full * 0.95;\n  c_hex = c_full * 0.95;\n}\n\nfunction windowResizeUpdate() {\n  mainCanvas.width = window.innerWidth;\n  mainCanvas.height = window.innerHeight;\n  animCanvas.width = window.innerWidth;\n  animCanvas.height = window.innerHeight;\n  halfCanvasWidth = mainCanvas.width / 2;\n  halfCanvasHeight = mainCanvas.height / 2;\n  const min = Math.min(halfCanvasWidth, halfCanvasHeight);\n  scales = [min / 10, min / 7, min / 5];\n} //Hex Highlighting\n\n\nanimCanvas.addEventListener(\'click\', async ({\n  offsetX,\n  offsetY\n}) => {\n  console.log(\'click\', isdblclick);\n  await sleep(500);\n  console.log(\'click\', isdblclick);\n\n  if (isdblclick) {\n    return;\n  }\n\n  offsetX += camera.x + b_full - mainCanvas.width / 2;\n  offsetY += camera.y + c_full - mainCanvas.height / 2;\n  const hexCoordinates = display_Grid.pointToHex(offsetX, offsetY);\n\n  for (let hex of currentMap) {\n    if (hex.x == hexCoordinates.x && hex.y == hexCoordinates.y) {\n      hex.highlight = !hex.highlight;\n    } else {\n      hex.highlight = false;\n    }\n  }\n});\nanimCanvas.addEventListener(\'dblclick\', async ({\n  offsetX,\n  offsetY\n}) => {\n  isdblclick = true;\n  console.log(\'dblclick\', isdblclick);\n  await sleep(500);\n  isdblclick = false;\n  console.log(\'dblclick\', isdblclick);\n  offsetX += camera.x + b_full - mainCanvas.width / 2;\n  offsetY += camera.y + c_full - mainCanvas.height / 2;\n  const hexCoordinates = display_Grid.pointToHex(offsetX, offsetY);\n  console.log(hexCoordinates);\n  let hHex;\n  let tHex;\n\n  for (let hex of currentMap) {\n    if (hex.highlight) {\n      hHex = hex;\n    }\n\n    if (hex.x == hexCoordinates.x && hex.y == hexCoordinates.y) {\n      tHex = hex;\n    }\n  }\n\n  if (!tHex) return;\n  if (hHex && !hHex.details) return;\n  console.log(\'hHex\', hHex);\n  console.log(\'tHex\', tHex);\n  let cellCoord = {\n    x: hexCoordinates.x,\n    y: hexCoordinates.y,\n    z: -hexCoordinates.x - hexCoordinates.y\n  };\n\n  if (!hHex) {\n    if (!tHex.details) {\n      await PROVIDER.newGame(cellCoord);\n    }\n  } else if (hHex.address.toString() == tHex.address.toString()) {\n    await PROVIDER.upgradeCell(tHex.address);\n  } else {\n    if (!isNeighborHex(hHex, tHex)) return;\n    let energy = 1000;\n\n    if (!tHex.details) {\n      await PROVIDER.markCell(hHex.address, cellCoord, energy);\n    } else if (colorIsEqual(hHex.details.color, tHex.details.color)) {\n      // переписать условие по владельцу ячейки и цвета\n      await PROVIDER.helpCell(hHex.address, cellCoord, energy);\n    } else {\n      await PROVIDER.attkCell(hHex.address, cellCoord, energy);\n    }\n  }\n});\n\nfunction colorIsEqual(color1, color2) {\n  return color1.r == color2.r && color1.g == color2.g && color1.b == color2.b;\n}\n\nfunction isNeighborHex(hex1, hex2) {\n  return cube_distance(hex1, hex2) == 1;\n}\n\nfunction cube_distance(hex1, hex2) {\n  return Math.max(Math.abs(hex1.x - hex2.x), Math.abs(hex1.y - hex2.y), Math.abs(-hex1.x - hex1.y - (-hex2.x - hex2.y)));\n}\n\nwindow.addEventListener(\'resize\', () => {\n  windowResizeUpdate();\n  zoomUpdate();\n}); //http://jsfiddle.net/gfcarv/QKgHs/ or http://jsfiddle.net/gfcarv/tAwQV/\n//https://jsfiddle.net/931wk75n/2/\n;// CONCATENATED MODULE: ./src/scripts/controls.js\n//Imports\n //Public variables\n//-\n//Private variables\n//-\n//Public functions\n\nfunction initiateControls() {\n  //Zoom controls\n  document.querySelector("#zoom_out").addEventListener(\'mousedown\', () => {\n    if (camera.zoom > 0) camera.zoom--;\n    zoomUpdate();\n  });\n  document.querySelector("#zoom_in").addEventListener(\'mousedown\', () => {\n    if (camera.zoom < 2) camera.zoom++;\n    zoomUpdate();\n  }); //Camera position controls\n\n  let timer = null;\n  document.addEventListener(\'mouseup\', () => {\n    clearInterval(timer);\n  });\n  document.addEventListener(\'keyup\', () => {\n    clearInterval(timer);\n  });\n  document.querySelector("#camera_up").addEventListener(\'mousedown\', () => {\n    timer = setInterval(() => {\n      camera.y -= 5;\n    }, 10);\n  });\n  document.querySelector("#camera_left").addEventListener(\'mousedown\', () => {\n    timer = setInterval(() => {\n      camera.x -= 5;\n    }, 10);\n  });\n  document.querySelector("#camera_right").addEventListener(\'mousedown\', () => {\n    timer = setInterval(() => {\n      camera.x += 5;\n    }, 10);\n  });\n  document.querySelector("#camera_down").addEventListener(\'mousedown\', () => {\n    timer = setInterval(() => {\n      camera.y += 5;\n    }, 10);\n  }); //Keyboard controls\n\n  document.addEventListener(\'keydown\', e => {\n    switch (e.code) {\n      case "ArrowUp":\n        clearInterval(timer);\n        timer = setInterval(() => {\n          camera.y -= 5;\n        }, 10);\n        break;\n\n      case "ArrowLeft":\n        clearInterval(timer);\n        timer = setInterval(() => {\n          camera.x -= 5;\n        }, 10);\n        break;\n\n      case "ArrowRight":\n        clearInterval(timer);\n        timer = setInterval(() => {\n          camera.x += 5;\n        }, 10);\n        break;\n\n      case "ArrowDown":\n        clearInterval(timer);\n        timer = setInterval(() => {\n          camera.y += 5;\n        }, 10);\n        break;\n    }\n  });\n} //Private functions\n// EXTERNAL MODULE: ./node_modules/everscale-inpage-provider/dist/index.js\nvar dist = __webpack_require__(511);\n// EXTERNAL MODULE: ./node_modules/everscale-standalone-client/index.js\nvar everscale_standalone_client = __webpack_require__(91);\n;// CONCATENATED MODULE: ./src/scripts/ever.js\n\n\n\nconst routerAbi = __webpack_require__(750);\n\nconst cellAbi = __webpack_require__(579);\n\nconst Config = __webpack_require__(150);\n\nlet ever_currentMap;\nconst ever = new dist.ProviderRpcClient({});\n\nfunction behavior(name, fn) {\n  document.querySelectorAll(`[data-behavior=${name}]`).forEach(fn);\n}\n\nconst innerText = text => elem => {\n  elem.innerText = text;\n};\n\nfunction requestPermissions() {\n  return ever.requestPermissions({\n    permissions: [\'basic\', \'accountInteraction\']\n  });\n}\n\nasync function disconnectAction() {\n  console.log(\'disconnectAction\');\n  await ever.disconnect();\n}\n\nasync function connect() {\n  await ever.requestPermissions({\n    permissions: [\'basic\', \'accountInteraction\']\n  });\n}\n\nasync function checkConnect() {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  const network = providerState.selectedConnection;\n\n  if (!contractAddress(network) || !permissions.accountInteraction) {\n    behavior(\'connect\', elem => elem.onclick = requestPermissions);\n    switchScreen("login");\n\n    const connectText = elem => {\n      const disabled = !contractAddress(network);\n      elem.disabled = disabled;\n      elem.innerText = disabled ? `Contract not found` : `Connect with ${network}`;\n    };\n\n    behavior(\'connect\', connectText);\n  } else {\n    // INFO for transactionsFound and contractStateChanged need permissions\n    const providerState = await ever.getProviderState();\n    (await ever.subscribe(\'transactionsFound\', {\n      address: contractAddress(providerState.selectedConnection)\n    })).on(\'data\', event => {\n      console.log(\':\', {\n        address: event.address,\n        transactions: event.transactions,\n        info: event.info\n      });\n    });\n    (await ever.subscribe(\'contractStateChanged\', {\n      address: contractAddress(providerState.selectedConnection)\n    })).on(\'data\', event => {\n      console.log(\'permissionsChanged:\', {\n        address: event.address,\n        state: event.state\n      });\n    });\n    switchScreen("main");\n    const account = permissions.accountInteraction;\n    let address = account.address.toString();\n    let pubkey = account.address.toString();\n    behavior(\'address\', innerText(`${address.substr(0, 6)}...${address.substr(-4, 4)}`));\n    behavior(\'publicKey\', innerText(`${pubkey.substr(0, 6)}...${pubkey.substr(-4, 4)}`));\n    behavior(\'disconnectAction\', elem => elem.onclick = disconnectAction);\n    loadMap();\n  }\n}\n\nasync function setNetworkChanged(network) {\n  const mod = network === \'mainnet\' ? \'success\' : \'secondary\';\n  const out = `<span class="badge bg-${mod}">${network}</span>`;\n  behavior(\'network\', elem => elem.innerHTML = out);\n  await checkConnect();\n}\n\nfunction contractAddress(network, name = "router") {\n  // if (addr[network] && addr[network][name]) {\n  // return new Address(addr[network][name]);\n  // }\n  // return null\n  return new dist.Address(Config.router);\n} // async function Contract() {\n// const providerState = await ever.getProviderState();\n// const address = contractAddress(providerState.selectedConnection);\n// return new ever.Contract(abi, address);\n// }\n\n\nfunction switchScreen(to) {\n  console.log(\'switchScreen:\', to);\n  ["extension", "login", "main"].forEach(screen => {\n    const switcher = elem => elem.style.display = to === screen ? \'table-row\' : \'none\';\n\n    behavior(screen, switcher);\n  });\n}\n\nasync function mainFlow() {\n  const providerState = await ever.getProviderState();\n  console.log(\'selectedConnection:\', providerState.selectedConnection);\n  await setNetworkChanged(providerState.selectedConnection);\n  (await ever.subscribe(\'networkChanged\')).on(\'data\', event => {\n    console.log(\'networkChanged:\', event.selectedConnection);\n    setNetworkChanged(event.selectedConnection);\n  });\n  (await ever.subscribe(\'permissionsChanged\')).on(\'data\', async event => {\n    console.log(\'permissionsChanged:\', event.permissions);\n    await checkConnect();\n  });\n}\n\nasync function loadMap() {\n  await routerDetails();\n  let coords = [];\n\n  for (let i = 0; i < ever_currentMap.length; i++) {\n    let hex = ever_currentMap[i];\n    coords.push({\n      x: hex.x,\n      y: hex.y,\n      z: -hex.x - hex.y\n    });\n  }\n\n  let addreses = await getAddressCells(coords);\n\n  for (let i = 0; i < ever_currentMap.length; i++) {\n    let hex = ever_currentMap[i];\n    hex.address = addreses[i];\n    await subscribeCellState(addreses[i], hex);\n    hex.details = await getDetailsCell(addreses[i]);\n  }\n}\n\nasync function init(map) {\n  ever_currentMap = map;\n\n  if (await ever.hasProvider()) {\n    try {\n      await ever.ensureInitialized();\n      await mainFlow();\n    } catch (error) {\n      throw error; // TODO handle it\n    }\n  } else {\n    switchScreen("extension");\n  }\n}\nasync function routerDetails() {\n  const providerState = await ever.getProviderState();\n  const router = new ever.Contract(routerAbi, contractAddress(providerState.selectedConnection, \'router\'));\n\n  try {\n    let details;\n    details = await router.methods.getDetails({}).call();\n    console.log(\'getDetails router\', details);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function subscribeCellState(address, hex) {\n  try {\n    (await ever.subscribe(\'contractStateChanged\', {\n      address: address\n    })).on(\'data\', async event => {\n      // console.log(\'contractStateChanged:\', {\n      // address: event.address,\n      // state: event.state,\n      // });\n      hex.details = await getDetailsCell(event.address);\n    });\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function getAddressCells(coords) {\n  const providerState = await ever.getProviderState();\n  const router = new ever.Contract(routerAbi, contractAddress(providerState.selectedConnection, \'router\'));\n\n  try {\n    let details;\n    details = await router.methods.getAddressCells({\n      coords\n    }).call();\n    console.log(\'getAddressCells router\', details);\n    return details.addreses;\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function newGame(cellCoord) {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  if (!permissions.accountInteraction) return;\n  const account = permissions.accountInteraction;\n  const router = new ever.Contract(routerAbi, contractAddress(providerState.selectedConnection, \'router\'));\n\n  try {\n    console.log(\'newGame\', 1);\n    let res = await router.methods.newGame({\n      sendGasTo: account.address.toString(),\n      baseCoord: cellCoord\n    }).send({\n      from: account.address.toString(),\n      amount: \'2000000000\'\n    });\n    console.log(\'newGame\', res);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function markCell(address, cellCoord, energy) {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  if (!permissions.accountInteraction) return;\n  const account = permissions.accountInteraction;\n  const cell = new ever.Contract(cellAbi, address);\n\n  try {\n    console.log(\'markCell\', 1);\n    let res = await cell.methods.markCell({\n      sendGasTo: account.address.toString(),\n      targetCoord: cellCoord,\n      energy: energy\n    }).send({\n      from: account.address.toString(),\n      amount: \'2000000000\'\n    });\n    console.log(\'markCell\', res);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function upgradeCell(address) {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  if (!permissions.accountInteraction) return;\n  const account = permissions.accountInteraction;\n  const cell = new ever.Contract(cellAbi, address);\n\n  try {\n    console.log(\'upgradeCell\', 1);\n    let res = await cell.methods.upgradeCell({\n      sendGasTo: account.address.toString()\n    }).send({\n      from: account.address.toString(),\n      amount: \'1000000000\'\n    });\n    console.log(\'upgradeCell\', res);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function helpCell(address, cellCoord, energy) {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  if (!permissions.accountInteraction) return;\n  const account = permissions.accountInteraction;\n  const cell = new ever.Contract(cellAbi, address);\n\n  try {\n    console.log(\'helpCell\', 1);\n    let res = await cell.methods.helpCell({\n      sendGasTo: account.address.toString(),\n      targetCoord: cellCoord,\n      energy: energy\n    }).send({\n      from: account.address.toString(),\n      amount: \'1000000000\'\n    });\n    console.log(\'helpCell\', res);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function attkCell(address, cellCoord, energy) {\n  const providerState = await ever.getProviderState();\n  const permissions = providerState.permissions;\n  if (!permissions.accountInteraction) return;\n  const account = permissions.accountInteraction;\n  const cell = new ever.Contract(cellAbi, address);\n\n  try {\n    console.log(\'attkCell\', 1);\n    let res = await cell.methods.attkCell({\n      sendGasTo: account.address.toString(),\n      targetCoord: cellCoord,\n      energy: energy\n    }).send({\n      from: account.address.toString(),\n      amount: \'1000000000\'\n    });\n    console.log(\'attkCell\', res);\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function getDetailsCell(address) {\n  const cell = new ever.Contract(cellAbi, address);\n\n  try {\n    const stateRes = await cell.getFullState();\n\n    if (stateRes.state == null || !stateRes.state.isDeployed) {\n      return null;\n    } //console.log(\'state\', stateRes.state);\n\n\n    let details;\n    details = await cell.methods.getDetails({}).call();\n    console.log(\'getDetails cell\', details);\n    return details;\n  } catch (e) {\n    console.error(e);\n\n    if (e instanceof dist.TvmException) {\n      console.error(e.code);\n    }\n  }\n}\nasync function subscribePermissionsChanged() {\n  await ever.subscribe(\'permissionsChanged\').on(\'data\', permissions => {\n    console.log(permissions);\n  });\n}\n;// CONCATENATED MODULE: ./src/index.js\n //Import CSS\n\n //Import JS\n\n\n\n\n //https://github.com/flauwekeul/honeycomb\n//console.clear();\n\nlet map = getRandomMap(20, 15);\ninitiateMap(map, ever_namespaceObject);\ninitiateControls();\n\nif (false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2hvbmV5Y29tYi1ncmlkL2Rpc3QvaG9uZXljb21iLmVzbS5taW4uanM/MTMyYyIsIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9zcmMvc2NyaXB0cy9tYXBnZW5lcmF0b3IuanM/YjA3ZSIsIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9zcmMvc2NyaXB0cy9kaXNwbGF5LmpzPzMyNzkiLCJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vc3JjL3NjcmlwdHMvY29udHJvbHMuanM/MDcxNCIsIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9zcmMvc2NyaXB0cy9ldmVyLmpzPzA5ZDEiLCJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vc3JjL2luZGV4LmpzPzk1YjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmc2VsZjt2YXIgdD1mdW5jdGlvbih0LG4pe3JldHVybiB0KG49e2V4cG9ydHM6e319LG4uZXhwb3J0cyksbi5leHBvcnRzfSgoZnVuY3Rpb24odCxuKXtcbi8qISBheGlzLmpzIHYxLjIuMSB8IChjKSAyMDE2IEB0b2RkbW90dG8gfCBodHRwczovL2dpdGh1Yi5jb20vdG9kZG1vdHRvL2F4aXMgKi9cbnQuZXhwb3J0cz1mdW5jdGlvbigpe3ZhciB0PXt9LG49XCJBcnJheSBPYmplY3QgU3RyaW5nIERhdGUgUmVnRXhwIEZ1bmN0aW9uIEJvb2xlYW4gTnVtYmVyIE51bGwgVW5kZWZpbmVkXCIuc3BsaXQoXCIgXCIpO2Z1bmN0aW9uIHIoKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpLnNsaWNlKDgsLTEpfWZvcih2YXIgZT1uLmxlbmd0aDtlLS07KXRbXCJpc1wiK25bZV1dPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gci5jYWxsKG4pPT09dH19KG5bZV0pO3JldHVybiB0fSgpfSkpLG49dC5pc09iamVjdCxyPXQuaXNOdW1iZXIsZT10LmlzQXJyYXksaT10LmlzU3RyaW5nO2Z1bmN0aW9uIHModCxuKXtyZXR1cm4gbit0KigxJm4pPj4xfWZ1bmN0aW9uIG8odCxuKXtyZXR1cm4odCVuK24pJW59ZnVuY3Rpb24gdSh0LG4pe2lmKCEvXihOfFMpPyhFfFcpPyQvaS50ZXN0KHQpKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb21wYXNzIGRpcmVjdGlvbjogJHt0fS4gQ2hvb3NlIGZyb20gRSwgU0UsIFMsIFNXLCBXLCBOVywgTiBvciBORS5gKTtpZihuPW4udG9Mb3dlckNhc2UoKSx0PXQudG9VcHBlckNhc2UoKSxcInBvaW50eVwiPT09biYmW1wiTlwiLFwiU1wiXS5pbmNsdWRlcyh0KSl0aHJvdyBuZXcgRXJyb3IoYERpcmVjdGlvbiAke3R9IGlzIGFtYmlndW91cyBmb3IgcG9pbnR5IGhleGVzLiBEaWQgeW91IG1lYW4gJHt0fUUgb3IgJHt0fVc/YCk7aWYoXCJmbGF0XCI9PT1uJiZbXCJFXCIsXCJXXCJdLmluY2x1ZGVzKHQpKXRocm93IG5ldyBFcnJvcihgRGlyZWN0aW9uICR7dH0gaXMgYW1iaWd1b3VzIGZvciBmbGF0IGhleGVzLiBEaWQgeW91IG1lYW4gTiR7dH0gb3IgUyR7dH0/YCk7cmV0dXJue3BvaW50eTp7RTowLFNFOjEsU1c6MixXOjMsTlc6NCxORTo1fSxmbGF0OntTRTowLFM6MSxTVzoyLE5XOjMsTjo0LE5FOjV9fVtuXVt0XX1mdW5jdGlvbiBjKHQsbil7cmV0dXJuIHIodCl8fHIobik/cih0KT9yKG4pfHwobj10KTp0PW46dD1uPTAse3g6dCx5Om59fWNvbnN0IGE9W3txOjEscjowLHM6LTF9LHtxOjAscjoxLHM6LTF9LHtxOi0xLHI6MSxzOjB9LHtxOi0xLHI6MCxzOjF9LHtxOjAscjotMSxzOjF9LHtxOjEscjotMSxzOjB9XSxoPVt7cToyLHI6LTEsczotMX0se3E6MSxyOjEsczotMn0se3E6LTEscjoyLHM6LTF9LHtxOi0yLHI6MSxzOjF9LHtxOi0xLHI6LTEsczoyfSx7cToxLHI6LTIsczoxfV0sZj17cToxZS02LHI6MWUtNixzOi0yZS02fTtmdW5jdGlvbiBsKHQpe3JldHVybiByKHQpP3RoaXNbdF06dGhpc1t0aGlzLmluZGV4T2YodCldfWZ1bmN0aW9uIGQoe2lzVmFsaWRIZXg6dH0pe3JldHVybiBmdW5jdGlvbihuLGUpe2lmKCF0KGUpKXJldHVybiB0aGlzO2NvbnN0IGk9cihuKT9uOnRoaXMuaW5kZXhPZihuKTtyZXR1cm4gaTwwP3RoaXMucHVzaChlKTp0aGlzW2ldPWUsdGhpc319ZnVuY3Rpb24geCh0LG4pe2NvbnN0IHI9dC5kaXN0YW5jZShuKSxlPTEvTWF0aC5tYXgociwxKTtsZXQgaT1bXTtmb3IobGV0IHM9MDtzPD1yO3MrKyl7Y29uc3Qgcj10Lm51ZGdlKCkubGVycChuLm51ZGdlKCksZSpzKS5yb3VuZCgpO2kucHVzaCh0aGlzLmdldChyKSl9cmV0dXJuIGl9ZnVuY3Rpb24geSh7aXNWYWxpZEhleDp0fSl7cmV0dXJuIGZ1bmN0aW9uKG4scj0wLGU9ITApe2lmKCF0KG4pKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjZW50ZXIgaGV4OiAke259LmApO2lmKCF0aGlzLmdldChuKSl0aHJvdyBuZXcgRXJyb3IoYENlbnRlciBoZXggd2l0aCBjb29yZGluYXRlcyAke259IG5vdCBwcmVzZW50IGluIGdyaWQuYCk7bGV0IGk9W107Zm9yKGxldCB0PS1yO3Q8PXI7dCsrKWZvcihsZXQgcz1NYXRoLm1heCgtciwtdC1yKTtzPD1NYXRoLm1pbihyLC10K3IpO3MrKyl7Y29uc3Qgcj10aGlzLmdldChuLmN1YmVUb0NhcnRlc2lhbih7cTpuLnErdCxyOm4ucitzfSkpO24uZXF1YWxzKHIpJiYhZXx8aS5wdXNoKHIpfXJldHVybiBpLmZpbHRlcihCb29sZWFuKX19ZnVuY3Rpb24gcCh7aXNWYWxpZEhleDp0LHNpZ25lZE1vZHVsbzpuLGNvbXBhc3NUb051bWJlckRpcmVjdGlvbjpyfSl7cmV0dXJuIGZ1bmN0aW9uKGUscz1cImFsbFwiLG89ITEpe2lmKCF0KGUpKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBoZXg6ICR7ZX0uYCk7Y29uc3QgdT1vP2g6YTtyZXR1cm5cImFsbFwiPT09cyYmKHM9WzAsMSwyLDMsNCw1XSksW10uY29uY2F0KHMpLm1hcCh0PT57aSh0KSYmKHQ9cih0LGUub3JpZW50YXRpb24pKSwodDwwfHx0PjUpJiYodD1uKHQsNikpO2NvbnN0e3E6cyxyOm99PXVbdF07cmV0dXJuIHRoaXMuZ2V0KGUuY3ViZVRvQ2FydGVzaWFuKHtxOmUucStzLHI6ZS5yK299KSl9KX19ZnVuY3Rpb24gZygpe2lmKDA9PT10aGlzLmxlbmd0aClyZXR1cm4gMDtjb25zdHswOnQsbGVuZ3RoOm4sW24tMV06cn09dGhpc1swXS5pc1BvaW50eSgpP1suLi50aGlzXS5zb3J0KCh0LG4pPT5uLnMtdC5zfHx0LnEtbi5xKTpbLi4udGhpc10uc29ydCgodCxuKT0+dC5xLW4ucSk7cmV0dXJuIHIudG9Qb2ludCgpLngtdC50b1BvaW50KCkueCt0aGlzWzBdLndpZHRoKCl9ZnVuY3Rpb24gYigpe2lmKDA9PT10aGlzLmxlbmd0aClyZXR1cm4gMDtjb25zdHswOnQsbGVuZ3RoOm4sW24tMV06cn09dGhpc1swXS5pc1BvaW50eSgpP1suLi50aGlzXS5zb3J0KCh0LG4pPT50LnItbi5yKTpbLi4udGhpc10uc29ydCgodCxuKT0+bi5zLXQuc3x8dC5yLW4ucik7cmV0dXJuIHIudG9Qb2ludCgpLnktdC50b1BvaW50KCkueSt0aGlzWzBdLmhlaWdodCgpfWZ1bmN0aW9uIHEoe0hleDp0fSl7cmV0dXJuIGZ1bmN0aW9uKG4scil7cmV0dXJuIHQoKS5mcm9tUG9pbnQobixyKX19ZnVuY3Rpb24gUCh7R3JpZDp0LEhleDpufSl7cmV0dXJuIGZ1bmN0aW9uKHt3aWR0aDpyLGhlaWdodDplLHN0YXJ0OmksZGlyZWN0aW9uOnM9MSxvbkNyZWF0ZTpvPSgoKT0+e30pfSl7aT1uKGkpO2NvbnN0W3UsYyxhXT17MTpbXCJxXCIsXCJyXCIsXCJzXCJdLDM6W1wiclwiLFwic1wiLFwicVwiXSw1OltcInNcIixcInFcIixcInJcIl19W3NdLGg9bmV3IHQ7aC53aWR0aD1yLGguaGVpZ2h0PWUsaC5zdGFydD1pLGguZGlyZWN0aW9uPXM7Zm9yKGxldCB0PTA7dDxyO3QrKylmb3IobGV0IHI9MDtyPGU7cisrKXtjb25zdCBlPW4oe1t1XTp0K2lbdV0sW2NdOnIraVtjXSxbYV06LXQtcitpW2FdfSk7byhlLGgpLGgucHVzaChlKX1yZXR1cm4gaH19ZnVuY3Rpb24gdyh7R3JpZDp0LEhleDpufSl7cmV0dXJuIGZ1bmN0aW9uKHtzaXplOnIsc3RhcnQ6ZSxkaXJlY3Rpb246aT0xLG9uQ3JlYXRlOnM9KCgpPT57fSl9KXtlPW4oZSk7Y29uc3Qgbz17MTp7clN0YXJ0OigpPT4wLHJFbmQ6dD0+ci10fSw1OntyU3RhcnQ6dD0+ci10LHJFbmQ6KCk9PnIrMX19LHtyU3RhcnQ6dSxyRW5kOmN9PW9baV0sYT1uZXcgdDthLnNpemU9cixhLnN0YXJ0PWUsYS5kaXJlY3Rpb249aTtmb3IobGV0IHQ9MDt0PHI7dCsrKWZvcihsZXQgcj11KHQpO3I8Yyh0KTtyKyspe2NvbnN0IGk9bih7cTp0K2UucSxyOnIrZS5yLHM6LXQtcitlLnN9KTtzKGksYSksYS5wdXNoKGkpfXJldHVybiBhfX1mdW5jdGlvbiBtKHtHcmlkOnQsSGV4Om59KXtyZXR1cm4gZnVuY3Rpb24oe3JhZGl1czpyLGNlbnRlcjplLG9uQ3JlYXRlOmk9KCgpPT57fSl9KXtlPW4oZSk7Y29uc3Qgcz1uZXcgdDtzLnJhZGl1cz1yLHMuY2VudGVyPWU7Zm9yKGxldCB0PS1yO3Q8PXI7dCsrKXtjb25zdCBvPU1hdGgubWF4KC1yLC10LXIpLHU9TWF0aC5taW4ociwtdCtyKTtmb3IobGV0IHI9bztyPD11O3IrKyl7Y29uc3Qgbz1uKHtxOnQrZS5xLHI6citlLnIsczotdC1yK2Uuc30pO2kobyxzKSxzLnB1c2gobyl9fXJldHVybiBzfX1mdW5jdGlvbiBIKHtHcmlkOnQsSGV4Om4sY29tcGFzc1RvTnVtYmVyRGlyZWN0aW9uOnIsc2lnbmVkTW9kdWxvOmV9KXtyZXR1cm4gZnVuY3Rpb24oe3dpZHRoOm8saGVpZ2h0OnUsc3RhcnQ6YyxkaXJlY3Rpb246YT0obigpLmlzUG9pbnR5KCk/MDoxKSxvbkNyZWF0ZTpoPSgoKT0+e30pfSl7Yz1uKGMpLGkoYSkmJihhPXIoYSxjLm9yaWVudGF0aW9uKSksKGE8MHx8YT41KSYmKGE9ZShhLDYpKTtjb25zdFtmLGwsZF09W1tcInFcIixcInJcIixcInNcIl0sW1wiclwiLFwicVwiLFwic1wiXSxbXCJyXCIsXCJzXCIsXCJxXCJdLFtcInNcIixcInJcIixcInFcIl0sW1wic1wiLFwicVwiLFwiclwiXSxbXCJxXCIsXCJzXCIsXCJyXCJdXVthXSxbeCx5XT1jLmlzUG9pbnR5KCk/W28sdV06W3Usb10scD1uZXcgdDtwLndpZHRoPW8scC5oZWlnaHQ9dSxwLnN0YXJ0PWMscC5kaXJlY3Rpb249YTtmb3IobGV0IHQ9MDt0PHk7dCsrKXtjb25zdCByPXMoYy5vZmZzZXQsdCk7Zm9yKGxldCBlPS1yO2U8eC1yO2UrKyl7Y29uc3Qgcj1uKHtbZl06ZStjW2ZdLFtsXTp0K2NbbF0sW2RdOi1lLXQrY1tkXX0pO2gocixwKSxwLnB1c2gocil9fXJldHVybiBwfX1mdW5jdGlvbiBPKHtHcmlkOnQsSGV4Om59KXtyZXR1cm4gZnVuY3Rpb24oe3JhZGl1czpyLGNlbnRlcjplLG9uQ3JlYXRlOmk9KCgpPT57fSl9KXtlPW4oZSk7Y29uc3Qgcz1uZXcgdDtzLnJhZGl1cz1yLHMuY2VudGVyPWU7Y29uc3R7cTpvLHI6dSxzOmN9PWU7bGV0IGg9bih7cTpvLHI6dS1yLHM6YytyfSk7Zm9yKGxldCB0PTA7dDw2O3QrKylmb3IobGV0IGU9MDtlPHI7ZSsrKXtpKGgscykscy5wdXNoKGgpO2NvbnN0e3E6cixyOmUsczpvfT1hW3RdO2g9bih7cTpoLnErcixyOmgucitlLHM6aC5zK299KX1yZXR1cm4gc319ZnVuY3Rpb24gaih7R3JpZDp0LEhleDpufSl7cmV0dXJuIGZ1bmN0aW9uKHtyYWRpdXM6cixjZW50ZXI6ZSxvbkNyZWF0ZTppPSgoKT0+e30pfSl7ZT1uKGUpO2xldCBzPW5ldyB0O2koZSxzKSxzLnB1c2goZSk7Zm9yKGxldCB0PTE7dDw9cjt0Kyspcz1zLmNvbmNhdCh0aGlzLnJpbmcoe3JhZGl1czp0LGNlbnRlcjplLG9uQ3JlYXRlOml9KSk7cmV0dXJuIHMucmFkaXVzPXIscy5jZW50ZXI9ZSxzfX1mdW5jdGlvbiBNKHtQb2ludDp0fSl7cmV0dXJuIGZ1bmN0aW9uKG4scil7bGV0IGU7cmV0dXJuKHt4OmUseTpyfT10KG4scikpLHQodGhpcy54K2UsdGhpcy55K3IpfX1mdW5jdGlvbiBFKHtQb2ludDp0fSl7cmV0dXJuIGZ1bmN0aW9uKG4scil7bGV0IGU7cmV0dXJuKHt4OmUseTpyfT10KG4scikpLHQodGhpcy54LWUsdGhpcy55LXIpfX1mdW5jdGlvbiBDKHtQb2ludDp0fSl7cmV0dXJuIGZ1bmN0aW9uKG4scil7bGV0IGU7cmV0dXJuKHt4OmUseTpyfT10KG4scikpLHQodGhpcy54KmUsdGhpcy55KnIpfX1mdW5jdGlvbiBOKHtQb2ludDp0fSl7cmV0dXJuIGZ1bmN0aW9uKG4scil7bGV0IGU7cmV0dXJuKHt4OmUseTpyfT10KG4scikpLHQodGhpcy54L2UsdGhpcy55L3IpfX1mdW5jdGlvbiBTKHtlbnN1cmVYWTp0fSl7Y29uc3QgaT17YWRkOk0oe1BvaW50OnN9KSxzdWJ0cmFjdDpFKHtQb2ludDpzfSksbXVsdGlwbHk6Qyh7UG9pbnQ6c30pLGRpdmlkZTpOKHtQb2ludDpzfSl9O2Z1bmN0aW9uIHMocyxvKXtsZXQgdTtyZXR1cm4gdT1yKHMpP3QocyxvKTplKHMpP3QoLi4ucyk6bihzKT90KHMueCxzLnkpOnQoMCksT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKGkpLHUpfXJldHVybiBzfWNvbnN0IFI9Uyh7ZW5zdXJlWFk6Y30pO2NsYXNzICQgZXh0ZW5kcyBBcnJheXtzdGF0aWMgaXNWYWxpZEhleCh0KXtyZXR1cm4hMD09PSh0fHx7fSkuX19pc0hvbmV5Y29tYkhleH1maWxsKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkdyaWQucHJvdG90eXBlLmZpbGwgaXMgbm90IGltcGxlbWVudGVkXCIpfWluY2x1ZGVzKHQsbj0wKXtyZXR1cm4hISh0aGlzLmluZGV4T2YodCxuKSsxKX1pbmRleE9mKHQsbj0wKXtjb25zdHtsZW5ndGg6cn09dGhpcztsZXQgZT1OdW1iZXIobik7Zm9yKHQ9Uih0KSxlPU1hdGgubWF4KGU+PTA/ZTpyK2UsMCk7ZTxyO2UrKylpZih0aGlzW2VdLmVxdWFscyh0KSlyZXR1cm4gZTtyZXR1cm4tMX1sYXN0SW5kZXhPZih0LG49dGhpcy5sZW5ndGgtMSl7Y29uc3R7bGVuZ3RoOnJ9PXRoaXM7bGV0IGU9TnVtYmVyKG4pO2Zvcih0PVIodCksZT1lPj0wP01hdGgubWluKGUsci0xKTpyK2U7ZT49MDtlLS0paWYodGhpc1tlXS5lcXVhbHModCkpcmV0dXJuIGU7cmV0dXJuLTF9cHVzaCguLi50KXtyZXR1cm4gc3VwZXIucHVzaCguLi50LmZpbHRlcigkLmlzVmFsaWRIZXgpKX1zcGxpY2UodCxuLC4uLnIpe3JldHVybiBudWxsPT1uP3N1cGVyLnNwbGljZSh0KTpzdXBlci5zcGxpY2UodCxuLC4uLnIuZmlsdGVyKCQuaXNWYWxpZEhleCkpfXVuc2hpZnQoLi4udCl7cmV0dXJuIHN1cGVyLnVuc2hpZnQoLi4udC5maWx0ZXIoJC5pc1ZhbGlkSGV4KSl9fWZ1bmN0aW9uIHYodCxuLHIpe3JldHVybiBuIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbix7dmFsdWU6cixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbbl09cix0fWZ1bmN0aW9uIFQodCxuKXt2YXIgcj1PYmplY3Qua2V5cyh0KTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgZT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpO24mJihlPWUuZmlsdGVyKChmdW5jdGlvbihuKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG4pLmVudW1lcmFibGV9KSkpLHIucHVzaC5hcHBseShyLGUpfXJldHVybiByfWZ1bmN0aW9uIEcodCl7Zm9yKHZhciBuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl7dmFyIHI9bnVsbCE9YXJndW1lbnRzW25dP2FyZ3VtZW50c1tuXTp7fTtuJTI/VChPYmplY3QociksITApLmZvckVhY2goKGZ1bmN0aW9uKG4pe3YodCxuLHJbbl0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocikpOlQoT2JqZWN0KHIpKS5mb3JFYWNoKChmdW5jdGlvbihuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocixuKSl9KSl9cmV0dXJuIHR9ZnVuY3Rpb24gRCh0LG4pe2lmKG51bGw9PXQpcmV0dXJue307dmFyIHIsZSxpPWZ1bmN0aW9uKHQsbil7aWYobnVsbD09dClyZXR1cm57fTt2YXIgcixlLGk9e30scz1PYmplY3Qua2V5cyh0KTtmb3IoZT0wO2U8cy5sZW5ndGg7ZSsrKXI9c1tlXSxuLmluZGV4T2Yocik+PTB8fChpW3JdPXRbcl0pO3JldHVybiBpfSh0LG4pO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModCk7Zm9yKGU9MDtlPHMubGVuZ3RoO2UrKylyPXNbZV0sbi5pbmRleE9mKHIpPj0wfHxPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodCxyKSYmKGlbcl09dFtyXSl9cmV0dXJuIGl9ZnVuY3Rpb24geih7SGV4OnR9KXtyZXR1cm4gZnVuY3Rpb24oLi4ubil7cmV0dXJuIE9iamVjdC5hc3NpZ24odGhpcyx0KC4uLm4pKX19ZnVuY3Rpb24gVigpe3JldHVybnt4OnRoaXMueCx5OnRoaXMueX19ZnVuY3Rpb24gVygpe3JldHVybntxOnRoaXMucSxyOnRoaXMucixzOnRoaXMuc319ZnVuY3Rpb24gSSh7cTp0LHI6bn0pe2xldCByLGU7cmV0dXJuIHRoaXMuaXNQb2ludHkoKT8ocj10K3ModGhpcy5vZmZzZXQsbiksZT1uKToocj10LGU9bitzKHRoaXMub2Zmc2V0LHQpKSx7eDpyLHk6ZX19ZnVuY3Rpb24gWCgpe3JldHVyblwicG9pbnR5XCI9PT10aGlzLm9yaWVudGF0aW9uLnRvTG93ZXJDYXNlKCl9ZnVuY3Rpb24gWSgpe3JldHVyblwiZmxhdFwiPT09dGhpcy5vcmllbnRhdGlvbi50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIEIoKXtjb25zdHt4UmFkaXVzOnR9PXRoaXMuc2l6ZTtyZXR1cm4gdGhpcy5pc1BvaW50eSgpP3QqTWF0aC5zcXJ0KDMpOjIqdH1mdW5jdGlvbiBfKCl7Y29uc3R7eVJhZGl1czp0fT10aGlzLnNpemU7cmV0dXJuIHRoaXMuaXNQb2ludHkoKT8yKnQ6dCpNYXRoLnNxcnQoMyl9ZnVuY3Rpb24gQSh7UG9pbnQ6dH0pe3JldHVybiBmdW5jdGlvbigpe2NvbnN0IG49dGhpcy53aWR0aCgpLHI9dGhpcy5oZWlnaHQoKSx7eDplLHk6aX09dGhpcy5vcmlnaW47cmV0dXJuIHRoaXMuaXNQb2ludHkoKT9bdChuLWUsLjI1KnItaSksdChuLWUsLjc1KnItaSksdCguNSpuLWUsci1pKSx0KDAtZSwuNzUqci1pKSx0KDAtZSwuMjUqci1pKSx0KC41Km4tZSwwLWkpXTpbdChuLWUsLjUqci1pKSx0KC43NSpuLWUsci1pKSx0KC4yNSpuLWUsci1pKSx0KDAtZSwuNSpyLWkpLHQoLjI1Km4tZSwwLWkpLHQoLjc1Km4tZSwwLWkpXX19ZnVuY3Rpb24gTCh7UG9pbnQ6dH0pe3JldHVybiBmdW5jdGlvbigpe2NvbnN0e3g6bix5OnJ9PXRoaXMub3JpZ2luO3JldHVybiB0KHRoaXMud2lkdGgoKS8yLW4sdGhpcy5oZWlnaHQoKS8yLXIpfX1mdW5jdGlvbiBrKHtQb2ludDp0fSl7cmV0dXJuIGZ1bmN0aW9uKCl7Y29uc3R7cTpuLHI6cixzaXplOmV9PXRoaXMse3hSYWRpdXM6aSx5UmFkaXVzOnN9PWU7bGV0IG8sdTtyZXR1cm4gdGhpcy5pc1BvaW50eSgpPyhvPWkqTWF0aC5zcXJ0KDMpKihuK3IvMiksdT0zKnMvMipyKToobz0zKmkvMipuLHU9cypNYXRoLnNxcnQoMykqKHIrbi8yKSksdChvLHUpfX1mdW5jdGlvbiBGKHtQb2ludDp0LEhleDpufSl7cmV0dXJuIGZ1bmN0aW9uKHIsZSl7Y29uc3R7eFJhZGl1czppLHlSYWRpdXM6c309dGhpcy5zaXplO2xldCBvLHUsYztyZXR1cm4oe3g6byx5OmV9PXQocixlKS5zdWJ0cmFjdCh0aGlzLmNlbnRlcigpKSksdGhpcy5pc1BvaW50eSgpPyh1PU1hdGguc3FydCgzKSpvLygzKmkpLWUvKDMqcyksYz0yLzMqKGUvcykpOih1PTIvMyooby9pKSxjPU1hdGguc3FydCgzKSplLygzKnMpLW8vKDMqaSkpLG4oe3E6dSxyOmMsczotdS1jfSkucm91bmQoKX19ZnVuY3Rpb24gVSh7SGV4OnQsUG9pbnQ6bn0pe3JldHVybiBmdW5jdGlvbihyKXtjb25zdHt4OmUseTppfT1uKHIpO3JldHVybiB0KHRoaXMueCtlLHRoaXMueStpLEcoe30sdGhpcykpfX1mdW5jdGlvbiBKKHtIZXg6dCxQb2ludDpufSl7cmV0dXJuIGZ1bmN0aW9uKHIpe2NvbnN0e3g6ZSx5Oml9PW4ocik7cmV0dXJuIHQodGhpcy54LWUsdGhpcy55LWksRyh7fSx0aGlzKSl9fWZ1bmN0aW9uIEsoe1BvaW50OnR9KXtyZXR1cm4gZnVuY3Rpb24obil7aWYobnVsbCE9biYmKGUobil8fHIobi54KSYmcihuLnkpKSl7Y29uc3R7eDpyLHk6ZX09dChuKTtyZXR1cm4gdGhpcy54PT09ciYmdGhpcy55PT09ZX1yZXR1cm4hMX19ZnVuY3Rpb24gUSh0KXtyZXR1cm4gTWF0aC5tYXgoTWF0aC5hYnModGhpcy5xLXQucSksTWF0aC5hYnModGhpcy5yLXQuciksTWF0aC5hYnModGhpcy5zLXQucykpfWZ1bmN0aW9uIFooe0hleDp0fSl7cmV0dXJuIGZ1bmN0aW9uKCl7bGV0e3E6bixyOnIsczplfT10aGlzLGk9TWF0aC5yb3VuZChuKSxzPU1hdGgucm91bmQociksbz1NYXRoLnJvdW5kKGUpO2NvbnN0IHU9TWF0aC5hYnMobi1pKSxjPU1hdGguYWJzKHItcyksYT1NYXRoLmFicyhlLW8pO3JldHVybiB1PmMmJnU+YT9pPS1zLW86Yz5hP3M9LWktbzpvPS1pLXMsdChHKEcoe30sdGhpcykse30se3E6aSxyOnMsczpvfSkpfX1mdW5jdGlvbiB0dCh7SGV4OnR9KXtyZXR1cm4gZnVuY3Rpb24obixyKXtjb25zdCBlPXRoaXMucSooMS1yKStuLnEqcixpPXRoaXMuciooMS1yKStuLnIqcjtyZXR1cm4gdChHKEcoe30sdGhpcykse30se3E6ZSxyOmksczotZS1pfSkpfX1mdW5jdGlvbiBudCh7SGV4OnR9KXtyZXR1cm4gZnVuY3Rpb24oKXtjb25zdHtxOm4scjpyLHM6ZX09ZjtyZXR1cm4gdChHKEcoe30sdGhpcykse30se3E6dGhpcy5xK24scjp0aGlzLnIrcixzOnRoaXMucytlfSkpfX1mdW5jdGlvbiBydCgpe3JldHVybmAke3RoaXMueH0sJHt0aGlzLnl9YH1jb25zdCBldD17dGhpcmRDb29yZGluYXRlOmZ1bmN0aW9uKHQsbil7cmV0dXJuLXQtbn19O2NvbnN0IGl0PVMoe2Vuc3VyZVhZOmN9KSxzdD1mdW5jdGlvbih7ZW5zdXJlWFk6dCxub3JtYWxpemVSYWRpdXNlczppLFBvaW50Om99KXtyZXR1cm4gZnVuY3Rpb24odT17fSl7Y29uc3QgYz1mdW5jdGlvbih7UG9pbnQ6dH0pe3JldHVybiBmdW5jdGlvbihuLHIpe2xldCBlLGksbztyZXR1cm4oe3g6ZSx5OnJ9PXQobixyKSksdGhpcy5pc1BvaW50eSgpPyhpPWUtcyh0aGlzLm9mZnNldCxyKSxvPXIpOihpPWUsbz1yLXModGhpcy5vZmZzZXQsZSkpLHtxOmkscjpvLHM6LWktb319fSh7UG9pbnQ6b30pLGE9e19faXNIb25leWNvbWJIZXg6ITAsb3JpZW50YXRpb246XCJwb2ludHlcIixvcmlnaW46MCxzaXplOnt4UmFkaXVzOjEseVJhZGl1czoxfSxvZmZzZXQ6LTEsZ2V0IHEoKXtyZXR1cm4gdGhpcy5jYXJ0ZXNpYW5Ub0N1YmUodGhpcykucX0sZ2V0IHIoKXtyZXR1cm4gdGhpcy5jYXJ0ZXNpYW5Ub0N1YmUodGhpcykucn0sZ2V0IHMoKXtyZXR1cm4gdGhpcy5jYXJ0ZXNpYW5Ub0N1YmUodGhpcykuc30sYWRkOlUoe0hleDpmLFBvaW50Om99KSxjYXJ0ZXNpYW46VixjYXJ0ZXNpYW5Ub0N1YmU6YyxjZW50ZXI6TCh7UG9pbnQ6b30pLGNvb3JkaW5hdGVzOlYsY29ybmVyczpBKHtQb2ludDpvfSksY3ViZTpXLGN1YmVUb0NhcnRlc2lhbjpJLGRpc3RhbmNlOlEsZXF1YWxzOksoe1BvaW50Om99KSxmcm9tUG9pbnQ6Rih7UG9pbnQ6byxIZXg6Zn0pLGhlaWdodDpfLGlzRmxhdDpZLGlzUG9pbnR5OlgsbGVycDp0dCh7SGV4OmZ9KSxudWRnZTpudCh7SGV4OmZ9KSxyb3VuZDpaKHtIZXg6Zn0pLHNldDp6KHtIZXg6Zn0pLHN1YnRyYWN0Okooe0hleDpmLFBvaW50Om99KSx0b0NhcnRlc2lhbjpJLHRvQ3ViZTpjLHRvUG9pbnQ6ayh7UG9pbnQ6b30pLHRvU3RyaW5nOnJ0LHdpZHRoOkJ9LGg9T2JqZWN0LmFzc2lnbihhLHUpO2Z1bmN0aW9uIGYoaSxzLG89e30pe2xldCB1O2lmKG4oaSkpe2xldHtxOnQscjpuLHM6ZX09aSxjPUQoaSxbXCJxXCIsXCJyXCIsXCJzXCJdKTtpZihyKHQpfHxyKG4pfHxyKGUpKXtjb25zdCByPXQrbitlO2lmKE51bWJlci5pc05hTihyKXx8cj4xZS0xMil0aHJvdyBuZXcgRXJyb3IoYEN1YmUgY29vcmRpbmF0ZXMgbXVzdCBoYXZlIGEgc3VtIG9mIDAuIHE6ICR7dH0sIHI6ICR7bn0sIHM6ICR7ZX0sIHN1bTogJHt0K24rZX0uYCk7KHt4OnUseTpzfT1oLmN1YmVUb0NhcnRlc2lhbih7cTp0LHI6bixzOmV9KSl9ZWxzZSh7eDp1LHk6c309aSk7bz1jfWVsc2UgZShpKT8oW3Usc109aSxvPXt9KTp1PWk7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShoKSxPYmplY3QuYXNzaWduKG8sdCh1LHMpKSl9cmV0dXJuIGguc2l6ZT1pKGguc2l6ZSxoLmlzUG9pbnR5KCkpLGgub3JpZ2luPW8oaC5vcmlnaW4pLE9iamVjdC5hc3NpZ24oZixldCx7dG9KU09OOigpPT51fSksZn19KHtlbnN1cmVYWTpjLG5vcm1hbGl6ZVJhZGl1c2VzOmZ1bmN0aW9uKHQsZSl7aWYobih0KSl7aWYocih0LnhSYWRpdXMpJiZyKHQueVJhZGl1cykpcmV0dXJuIHQ7Y29uc3R7d2lkdGg6bixoZWlnaHQ6aX09dDtpZihyKG4pJiZyKGkpKXJldHVybiBlP3t4UmFkaXVzOm4vTWF0aC5zcXJ0KDMpLHlSYWRpdXM6aS8yfTp7eFJhZGl1czpuLzIseVJhZGl1czppL01hdGguc3FydCgzKX19aWYocih0KSlyZXR1cm57eFJhZGl1czp0LHlSYWRpdXM6dH07dGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpemU6ICR7dH0uIFNldCBpdCBhcyBhIG51bWJlciBvciBhcyBhbiBvYmplY3QgY29udGFpbmluZyB3aWR0aCBhbmQgaGVpZ2h0LmApfSxQb2ludDppdH0pLG90PWZ1bmN0aW9uKHtleHRlbmRIZXg6dCxHcmlkOm4sUG9pbnQ6aX0pe2NvbnN0e2lzVmFsaWRIZXg6c309bjtyZXR1cm4gZnVuY3Rpb24oYz10KCkpe2Z1bmN0aW9uIGEoLi4udCl7cmV0dXJuIHQ9dC5maWx0ZXIoQm9vbGVhbiksZSh0WzBdKSYmKDA9PT10WzBdLmxlbmd0aHx8dFswXS5zb21lKHQ9PiFyKHQpKSkmJih0PXRbMF0pLG5ldyBuKC4uLnQubWFwKHQ9PmModCkpKX1yZXR1cm4gT2JqZWN0LmFzc2lnbihhLHtIZXg6Yyxpc1ZhbGlkSGV4OnMscG9pbnRUb0hleDpxKHtQb2ludDppLEhleDpjfSkscGFyYWxsZWxvZ3JhbTpQKHtHcmlkOm4sSGV4OmN9KSx0cmlhbmdsZTp3KHtHcmlkOm4sSGV4OmN9KSxoZXhhZ29uOm0oe0dyaWQ6bixIZXg6Y30pLHJlY3RhbmdsZTpIKHtHcmlkOm4sSGV4OmMsY29tcGFzc1RvTnVtYmVyRGlyZWN0aW9uOnUsc2lnbmVkTW9kdWxvOm99KSxyaW5nOk8oe0dyaWQ6bixIZXg6Y30pLHNwaXJhbDpqKHtHcmlkOm4sSGV4OmN9KX0pLE9iamVjdC5hc3NpZ24obi5wcm90b3R5cGUse2dldDpsLGhleGVzQmV0d2Vlbjp4LGhleGVzSW5SYW5nZTp5KHtpc1ZhbGlkSGV4OnN9KSxuZWlnaGJvcnNPZjpwKHtpc1ZhbGlkSGV4OnMsc2lnbmVkTW9kdWxvOm8sY29tcGFzc1RvTnVtYmVyRGlyZWN0aW9uOnV9KSxwb2ludEhlaWdodDpiLHBvaW50V2lkdGg6ZyxzZXQ6ZCh7aXNWYWxpZEhleDpzfSl9KSxhfX0oe2V4dGVuZEhleDpzdCxHcmlkOiQsUG9pbnQ6aXR9KTtleHBvcnR7aXQgYXMgUG9pbnQsb3QgYXMgZGVmaW5lR3JpZCxzdCBhcyBleHRlbmRIZXh9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9uZXljb21iLmVzbS5taW4uanMubWFwXG4iLCIvL0ltcG9ydHNcbmltcG9ydCB7IGV4dGVuZEhleCwgZGVmaW5lR3JpZCB9IGZyb20gJ2hvbmV5Y29tYi1ncmlkJzsgLy9QdWJsaWMgdmFyaWFibGVzXG4vLy1cbi8vUHJpdmF0ZSB2YXJpYWJsZXNcblxubGV0IEdyaWQgPSBkZWZpbmVHcmlkKGV4dGVuZEhleCh7XG4gIG9yaWVudGF0aW9uOiAnZmxhdCdcbn0pKTsgLy9QdWJsaWMgZnVuY3Rpb25zXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21NYXAod2lkdGgsIGhlaWdodCkge1xuICBsZXQgbWFwID0gR3JpZC5yZWN0YW5nbGUoe1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9KTsgLy9CYXNpYyB3YXRlciBsYXllclxuXG4gIGZvciAobGV0IGhleCBvZiBtYXApIHtcbiAgICBoZXgudHlwZSA9IFwiNjQsIDEyOCwgMjU1XCI7XG4gICAgaGV4LmhpZ2hsaWdodCA9IGZhbHNlO1xuICB9IC8vIC8vUmluZyBvZiBzYW5kXG4gIC8vIGxldCBpc2xhbmQgPSBtYXAuaGV4ZXNJblJhbmdlKG1hcC5nZXQoW01hdGguZmxvb3Ioc2l6ZSAvIDIpLCBNYXRoLmZsb29yKHNpemUgLyAyKV0pLCAoc2l6ZSAtIDcpIC8gMilcbiAgLy8gaXNsYW5kLmZvckVhY2goKGhleCkgPT4ge1xuICAvLyBoZXgudHlwZSA9IFwiMjM0LDIwNiwxMDZcIlxuICAvLyBoZXgud2Fsa2FibGUgPSB0cnVlXG4gIC8vIH0pXG4gIC8vIC8vSW5sYW5kIHRlcnJhaW5cbiAgLy8gaXNsYW5kID0gbWFwLmhleGVzSW5SYW5nZShtYXAuZ2V0KFtNYXRoLmZsb29yKHNpemUgLyAyKSwgTWF0aC5mbG9vcihzaXplIC8gMildKSwgKChzaXplIC0gNykgLyAyKSAtIDEpXG4gIC8vIGlzbGFuZC5mb3JFYWNoKChoZXgpID0+IHtcbiAgLy8gaGV4LnR5cGUgPSBcIjAsMTI4LDBcIiAvL1tcIjAsMTI4LDBcIiwgXCIxMzksNjksMTlcIl0ucmFuZG9tKClcbiAgLy8gfSlcbiAgLy8gLy9WaXNpb24gYmxvY2tpbmcgYmxvY2tzXG4gIC8vIGlzbGFuZC5mb3JFYWNoKChoZXgpID0+IHtcbiAgLy8gaWYgKE1hdGgucmFuZG9tKCkgPiAwLjg1KSB7XG4gIC8vIGhleC50eXBlID0gXCI1MCw1MCw1MFwiXG4gIC8vIGhleC5zZWVUaHJvdWdoID0gZmFsc2VcbiAgLy8gaGV4LndhbGthYmxlID0gZmFsc2VcbiAgLy8gfVxuICAvLyB9KVxuXG5cbiAgcmV0dXJuIG1hcDtcbn0gLy9Qcml2YXRlIGZ1bmN0aW9uc1xuXG5BcnJheS5wcm90b3R5cGUucmFuZG9tID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLmxlbmd0aCldO1xufTtcbi8qXG5sZXQgaW1nID0gbmV3IEltYWdlKClcbmltZy5zcmMgPSAndXJsJ1xubGV0IHBhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybihpbWcsICdyZXBlYXQnKVxuKi8iLCIvL0ltcG9ydHNcbmltcG9ydCB7IGV4dGVuZEhleCwgZGVmaW5lR3JpZCB9IGZyb20gJ2hvbmV5Y29tYi1ncmlkJzsgLy9QdWJsaWMgdmFyaWFibGVzXG5cbmV4cG9ydCBjb25zdCBjYW1lcmEgPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHpvb206IDFcbn07XG5leHBvcnQgbGV0IGN1cnJlbnRNYXA7IC8vUHJpdmF0ZSB2YXJpYWJsZXNcblxuY29uc3QgbWFpbkNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjbWFpbkNhbnZhc1wiKTtcbmNvbnN0IGFuaW1DYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2FuaW1hdGlvbkNhbnZhc1wiKTtcbmNvbnN0IG1haW5DdHggPSBtYWluQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbmNvbnN0IGFuaW1DdHggPSBhbmltQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbmxldCBzY2FsZXMgPSBbXTtcbmxldCBoZXhTaXplO1xubGV0IGFfZnVsbCwgYl9mdWxsLCBjX2Z1bGwsIGFfaGV4LCBiX2hleCwgY19oZXg7XG5sZXQgaGFsZkNhbnZhc1dpZHRoLCBoYWxmQ2FudmFzSGVpZ2h0O1xubGV0IEdyaWQgPSBkZWZpbmVHcmlkKGV4dGVuZEhleCh7fSkpO1xubGV0IFBST1ZJREVSO1xubGV0IGlzZGJsY2xpY2sgPSBmYWxzZTtcblxuYXN5bmMgZnVuY3Rpb24gc2xlZXAobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufSAvL1B1YmxpYyBmdW5jdGlvbnNcblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdGlhdGVNYXAobWFwLCBldmVyKSB7XG4gIGN1cnJlbnRNYXAgPSBtYXA7XG4gIG1haW5DYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgbWFpbkNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIGFuaW1DYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgYW5pbUNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIGNhbGN1bGF0ZUhleERpbWVuc2lvbnMoKTtcbiAgd2luZG93UmVzaXplVXBkYXRlKCk7XG4gIHpvb21VcGRhdGUoKTtcbiAgZHJhd01hcCgpO1xuICBjYW1lcmEueCA9IGhhbGZDYW52YXNXaWR0aDtcbiAgY2FtZXJhLnkgPSBoYWxmQ2FudmFzSGVpZ2h0O1xuICBQUk9WSURFUiA9IGV2ZXI7XG4gIGF3YWl0IFBST1ZJREVSLmluaXQoY3VycmVudE1hcCk7XG4gIHJlY2FsY0VuZXJneSgpO1xufVxuXG5mdW5jdGlvbiByZWNhbGNFbmVyZ3koKSB7XG4gIGZvciAobGV0IGhleCBvZiBjdXJyZW50TWFwKSB7XG4gICAgaWYgKCFoZXguZGV0YWlscykgY29udGludWU7XG4gICAgY2FsY3VsYXRlRW5lcmd5KGhleCk7XG4gIH1cblxuICBzZXRUaW1lb3V0KHJlY2FsY0VuZXJneSwgMTAwMCk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUVuZXJneShoZXgpIHtcbiAgbGV0IGRhdGVOb3cgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKTtcblxuICBpZiAoMSAqIGhleC5kZXRhaWxzLmVuZXJneSA+PSAxICogaGV4LmRldGFpbHMuZW5lcmd5TWF4IHx8IDEgKiBoZXguZGV0YWlscy5sYXN0Q2FsY1RpbWUgPj0gZGF0ZU5vdykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBlbmVyZ3kgPSBNYXRoLm1pbigxICogaGV4LmRldGFpbHMuZW5lcmd5ICsgaGV4LmRldGFpbHMuZW5lcmd5U2VjICogKGRhdGVOb3cgLSBoZXguZGV0YWlscy5sYXN0Q2FsY1RpbWUpLCAxICogaGV4LmRldGFpbHMuZW5lcmd5TWF4KTtcbiAgaGV4LmRldGFpbHMubGFzdENhbGNUaW1lID0gZGF0ZU5vdztcbiAgaGV4LmRldGFpbHMuZW5lcmd5ID0gZW5lcmd5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gem9vbVVwZGF0ZSgpIHtcbiAgY29uc3QgaGV4ID0gR3JpZC5wb2ludFRvSGV4KGNhbWVyYS54LCBjYW1lcmEueSk7XG4gIGNvbnN0IHggPSBoZXgueDtcbiAgY29uc3QgeSA9IGhleC55O1xuICBoZXhTaXplID0gc2NhbGVzW2NhbWVyYS56b29tXTtcbiAgY2FsY3VsYXRlSGV4RGltZW5zaW9ucygpO1xuICBHcmlkID0gZGVmaW5lR3JpZChleHRlbmRIZXgoe1xuICAgIHNpemU6IGhleFNpemUsXG4gICAgb3JpZW50YXRpb246ICdmbGF0J1xuICB9KSk7XG4gIGNvbnN0IHJlcGxhY2VtZW50TWFwID0gR3JpZC5yZWN0YW5nbGUoe1xuICAgIHdpZHRoOiBjdXJyZW50TWFwLndpZHRoLFxuICAgIGhlaWdodDogY3VycmVudE1hcC5oZWlnaHRcbiAgfSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50TWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgY3VycmVudE1hcFtpXS5zaXplID0gcmVwbGFjZW1lbnRNYXBbaV0uc2l6ZTtcblxuICAgIGlmIChjdXJyZW50TWFwW2ldLnggPT09IHggJiYgY3VycmVudE1hcFtpXS55ID09PSB5KSB7XG4gICAgICBjYW1lcmEueCA9IE1hdGgucm91bmQoY3VycmVudE1hcFtpXS50b1BvaW50KCkueCArIGJfZnVsbCArIGhleFNpemUgLyAyKTtcbiAgICAgIGNhbWVyYS55ID0gTWF0aC5yb3VuZChjdXJyZW50TWFwW2ldLnRvUG9pbnQoKS55ICsgY19mdWxsKTtcbiAgICB9XG4gIH1cbn0gLy9Qcml2YXRlIGZ1bmN0aW9uc1xuXG5mdW5jdGlvbiBkcmF3TWFwKCkge1xuICAvL0NsZWFyaW5nXG4gIG1haW5DdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICBtYWluQ3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgbWFpbkN0eC5maWxsUmVjdCgwLCAwLCBtYWluQ2FudmFzLndpZHRoLCBtYWluQ2FudmFzLmhlaWdodCk7IC8vUG9zaXRpb25pbmcgdGhlIGNhbWVyYVxuXG4gIG1haW5DdHgudHJhbnNsYXRlKC1jYW1lcmEueCArIGhhbGZDYW52YXNXaWR0aCwgLWNhbWVyYS55ICsgaGFsZkNhbnZhc0hlaWdodCk7XG5cbiAgZm9yIChsZXQgaGV4IG9mIGN1cnJlbnRNYXApIHtcbiAgICAvL0hleCBpcyBpZ25vcmVkIGlmIGl0IHdhc24ndCBzZWVuIHlldFxuICAgIC8vaWYgKGhleC52aXNpYmlsaXR5ID09PSAndW5zZWVuJykgY29udGludWVcbiAgICBsZXQgeCA9IGhleC50b1BvaW50KCkueCxcbiAgICAgICAgeSA9IGhleC50b1BvaW50KCkueTsgLy9DaGVja2luZyBpZiBoZXggaXMgdmlzaWJsZSB3aXRoaW4gY2FudmFzXG5cbiAgICBpZiAoTWF0aC5hYnMoeCAtIGNhbWVyYS54KSA+IGhhbGZDYW52YXNXaWR0aCArIGhleFNpemUgfHwgTWF0aC5hYnMoeSAtIGNhbWVyYS55KSA+IGhhbGZDYW52YXNIZWlnaHQgKyBoZXhTaXplKSBjb250aW51ZTsgLy9EcmF3aW5nIGhpZ2hsaWdodCBhcm91bmQgaGV4XG5cbiAgICBpZiAoaGV4LmhpZ2hsaWdodCkge1xuICAgICAgbWFpbkN0eC5zdHJva2VTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgIG1haW5DdHguYmVnaW5QYXRoKCk7XG4gICAgICBtYWluQ3R4Lm1vdmVUbyh4ICsgYV9mdWxsLCB5IC0gY19mdWxsKTtcbiAgICAgIG1haW5DdHgubGluZVRvKHggKyBiX2Z1bGwsIHkpO1xuICAgICAgbWFpbkN0eC5saW5lVG8oeCArIGFfZnVsbCwgeSArIGNfZnVsbCk7XG4gICAgICBtYWluQ3R4LmxpbmVUbyh4IC0gYV9mdWxsLCB5ICsgY19mdWxsKTtcbiAgICAgIG1haW5DdHgubGluZVRvKHggLSBiX2Z1bGwsIHkpO1xuICAgICAgbWFpbkN0eC5saW5lVG8oeCAtIGFfZnVsbCwgeSAtIGNfZnVsbCk7XG4gICAgICBtYWluQ3R4LmNsb3NlUGF0aCgpO1xuICAgICAgbWFpbkN0eC5zdHJva2UoKTtcbiAgICB9IC8vRHJhd2luZyB0aGUgaGV4XG5cblxuICAgIGxldCBjb2xvciA9IGhleC5kZXRhaWxzID8gYCR7aGV4LmRldGFpbHMuY29sb3Iucn0sICR7aGV4LmRldGFpbHMuY29sb3IuZ30sICR7aGV4LmRldGFpbHMuY29sb3IuYn1gIDogaGV4LnR5cGU7XG4gICAgbWFpbkN0eC5maWxsU3R5bGUgPSBgcmdiYSgke2NvbG9yfSwxKWA7XG4gICAgbWFpbkN0eC5iZWdpblBhdGgoKTtcbiAgICBtYWluQ3R4Lm1vdmVUbyh4ICsgYV9oZXgsIHkgLSBjX2hleCk7XG4gICAgbWFpbkN0eC5saW5lVG8oeCArIGJfaGV4LCB5KTtcbiAgICBtYWluQ3R4LmxpbmVUbyh4ICsgYV9oZXgsIHkgKyBjX2hleCk7XG4gICAgbWFpbkN0eC5saW5lVG8oeCAtIGFfaGV4LCB5ICsgY19oZXgpO1xuICAgIG1haW5DdHgubGluZVRvKHggLSBiX2hleCwgeSk7XG4gICAgbWFpbkN0eC5saW5lVG8oeCAtIGFfaGV4LCB5IC0gY19oZXgpO1xuICAgIG1haW5DdHguY2xvc2VQYXRoKCk7XG4gICAgbWFpbkN0eC5maWxsKCk7XG4gICAgc2V0VGV4dChtYWluQ3R4LCB4LCB5IC0gaGV4U2l6ZSAvIDIsIGAke2hleC54fTske2hleC55fWApO1xuXG4gICAgaWYgKGhleC5kZXRhaWxzKSB7XG4gICAgICBzZXRUZXh0KG1haW5DdHgsIHgsIHksIGAke2hleC5kZXRhaWxzLmVuZXJneX1gKTtcbiAgICAgIHNldFRleHQobWFpbkN0eCwgeCwgeSArIGhleFNpemUgLyAyLCBgbHZsOiAkezEgKiBoZXguZGV0YWlscy5sZXZlbCArIDF9YCk7XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXdNYXApO1xufVxuXG5mdW5jdGlvbiBzZXRUZXh0KGN0eCwgeCwgeSwgdHh0LCBmb250U2l6ZSA9IDEwLCBzdHlsZSA9IFwid2hpdGVcIiwgYWxpZ24gPSAnY2VudGVyJykge1xuICBsZXQgX2ZvbnQgPSBgJHtmb250U2l6ZSAqIChjYW1lcmEuem9vbSArIDEpfXB4IEdlb3JnaWFgO1xuICBjdHguZm9udCA9IF9mb250O1xuICBjdHguZmlsbFN0eWxlID0gc3R5bGU7XG4gIGN0eC50ZXh0QWxpZ24gPSBhbGlnbjtcbiAgY3R4LmZpbGxUZXh0KHR4dCwgeCwgeSwgaGV4U2l6ZSk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUhleERpbWVuc2lvbnMoKSB7XG4gIGFfZnVsbCA9IGhleFNpemUgLyAyO1xuICBiX2Z1bGwgPSBoZXhTaXplO1xuICBjX2Z1bGwgPSBoZXhTaXplIC8gMiAqIE1hdGguc3FydCgzKTtcbiAgYV9oZXggPSBhX2Z1bGwgKiAwLjk1O1xuICBiX2hleCA9IGJfZnVsbCAqIDAuOTU7XG4gIGNfaGV4ID0gY19mdWxsICogMC45NTtcbn1cblxuZnVuY3Rpb24gd2luZG93UmVzaXplVXBkYXRlKCkge1xuICBtYWluQ2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gIG1haW5DYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICBhbmltQ2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gIGFuaW1DYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICBoYWxmQ2FudmFzV2lkdGggPSBtYWluQ2FudmFzLndpZHRoIC8gMjtcbiAgaGFsZkNhbnZhc0hlaWdodCA9IG1haW5DYW52YXMuaGVpZ2h0IC8gMjtcbiAgY29uc3QgbWluID0gTWF0aC5taW4oaGFsZkNhbnZhc1dpZHRoLCBoYWxmQ2FudmFzSGVpZ2h0KTtcbiAgc2NhbGVzID0gW21pbiAvIDEwLCBtaW4gLyA3LCBtaW4gLyA1XTtcbn0gLy9IZXggSGlnaGxpZ2h0aW5nXG5cblxuYW5pbUNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICh7XG4gIG9mZnNldFgsXG4gIG9mZnNldFlcbn0pID0+IHtcbiAgY29uc29sZS5sb2coJ2NsaWNrJywgaXNkYmxjbGljayk7XG4gIGF3YWl0IHNsZWVwKDUwMCk7XG4gIGNvbnNvbGUubG9nKCdjbGljaycsIGlzZGJsY2xpY2spO1xuXG4gIGlmIChpc2RibGNsaWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb2Zmc2V0WCArPSBjYW1lcmEueCArIGJfZnVsbCAtIG1haW5DYW52YXMud2lkdGggLyAyO1xuICBvZmZzZXRZICs9IGNhbWVyYS55ICsgY19mdWxsIC0gbWFpbkNhbnZhcy5oZWlnaHQgLyAyO1xuICBjb25zdCBoZXhDb29yZGluYXRlcyA9IEdyaWQucG9pbnRUb0hleChvZmZzZXRYLCBvZmZzZXRZKTtcblxuICBmb3IgKGxldCBoZXggb2YgY3VycmVudE1hcCkge1xuICAgIGlmIChoZXgueCA9PSBoZXhDb29yZGluYXRlcy54ICYmIGhleC55ID09IGhleENvb3JkaW5hdGVzLnkpIHtcbiAgICAgIGhleC5oaWdobGlnaHQgPSAhaGV4LmhpZ2hsaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGV4LmhpZ2hsaWdodCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG5hbmltQ2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgYXN5bmMgKHtcbiAgb2Zmc2V0WCxcbiAgb2Zmc2V0WVxufSkgPT4ge1xuICBpc2RibGNsaWNrID0gdHJ1ZTtcbiAgY29uc29sZS5sb2coJ2RibGNsaWNrJywgaXNkYmxjbGljayk7XG4gIGF3YWl0IHNsZWVwKDUwMCk7XG4gIGlzZGJsY2xpY2sgPSBmYWxzZTtcbiAgY29uc29sZS5sb2coJ2RibGNsaWNrJywgaXNkYmxjbGljayk7XG4gIG9mZnNldFggKz0gY2FtZXJhLnggKyBiX2Z1bGwgLSBtYWluQ2FudmFzLndpZHRoIC8gMjtcbiAgb2Zmc2V0WSArPSBjYW1lcmEueSArIGNfZnVsbCAtIG1haW5DYW52YXMuaGVpZ2h0IC8gMjtcbiAgY29uc3QgaGV4Q29vcmRpbmF0ZXMgPSBHcmlkLnBvaW50VG9IZXgob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gIGNvbnNvbGUubG9nKGhleENvb3JkaW5hdGVzKTtcbiAgbGV0IGhIZXg7XG4gIGxldCB0SGV4O1xuXG4gIGZvciAobGV0IGhleCBvZiBjdXJyZW50TWFwKSB7XG4gICAgaWYgKGhleC5oaWdobGlnaHQpIHtcbiAgICAgIGhIZXggPSBoZXg7XG4gICAgfVxuXG4gICAgaWYgKGhleC54ID09IGhleENvb3JkaW5hdGVzLnggJiYgaGV4LnkgPT0gaGV4Q29vcmRpbmF0ZXMueSkge1xuICAgICAgdEhleCA9IGhleDtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRIZXgpIHJldHVybjtcbiAgaWYgKGhIZXggJiYgIWhIZXguZGV0YWlscykgcmV0dXJuO1xuICBjb25zb2xlLmxvZygnaEhleCcsIGhIZXgpO1xuICBjb25zb2xlLmxvZygndEhleCcsIHRIZXgpO1xuICBsZXQgY2VsbENvb3JkID0ge1xuICAgIHg6IGhleENvb3JkaW5hdGVzLngsXG4gICAgeTogaGV4Q29vcmRpbmF0ZXMueSxcbiAgICB6OiAtaGV4Q29vcmRpbmF0ZXMueCAtIGhleENvb3JkaW5hdGVzLnlcbiAgfTtcblxuICBpZiAoIWhIZXgpIHtcbiAgICBpZiAoIXRIZXguZGV0YWlscykge1xuICAgICAgYXdhaXQgUFJPVklERVIubmV3R2FtZShjZWxsQ29vcmQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChoSGV4LmFkZHJlc3MudG9TdHJpbmcoKSA9PSB0SGV4LmFkZHJlc3MudG9TdHJpbmcoKSkge1xuICAgIGF3YWl0IFBST1ZJREVSLnVwZ3JhZGVDZWxsKHRIZXguYWRkcmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpc05laWdoYm9ySGV4KGhIZXgsIHRIZXgpKSByZXR1cm47XG4gICAgbGV0IGVuZXJneSA9IDEwMDA7XG5cbiAgICBpZiAoIXRIZXguZGV0YWlscykge1xuICAgICAgYXdhaXQgUFJPVklERVIubWFya0NlbGwoaEhleC5hZGRyZXNzLCBjZWxsQ29vcmQsIGVuZXJneSk7XG4gICAgfSBlbHNlIGlmIChjb2xvcklzRXF1YWwoaEhleC5kZXRhaWxzLmNvbG9yLCB0SGV4LmRldGFpbHMuY29sb3IpKSB7XG4gICAgICAvLyDQv9C10YDQtdC/0LjRgdCw0YLRjCDRg9GB0LvQvtCy0LjQtSDQv9C+INCy0LvQsNC00LXQu9GM0YbRgyDRj9GH0LXQudC60Lgg0Lgg0YbQstC10YLQsFxuICAgICAgYXdhaXQgUFJPVklERVIuaGVscENlbGwoaEhleC5hZGRyZXNzLCBjZWxsQ29vcmQsIGVuZXJneSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IFBST1ZJREVSLmF0dGtDZWxsKGhIZXguYWRkcmVzcywgY2VsbENvb3JkLCBlbmVyZ3kpO1xuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNvbG9ySXNFcXVhbChjb2xvcjEsIGNvbG9yMikge1xuICByZXR1cm4gY29sb3IxLnIgPT0gY29sb3IyLnIgJiYgY29sb3IxLmcgPT0gY29sb3IyLmcgJiYgY29sb3IxLmIgPT0gY29sb3IyLmI7XG59XG5cbmZ1bmN0aW9uIGlzTmVpZ2hib3JIZXgoaGV4MSwgaGV4Mikge1xuICByZXR1cm4gY3ViZV9kaXN0YW5jZShoZXgxLCBoZXgyKSA9PSAxO1xufVxuXG5mdW5jdGlvbiBjdWJlX2Rpc3RhbmNlKGhleDEsIGhleDIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGguYWJzKGhleDEueCAtIGhleDIueCksIE1hdGguYWJzKGhleDEueSAtIGhleDIueSksIE1hdGguYWJzKC1oZXgxLnggLSBoZXgxLnkgLSAoLWhleDIueCAtIGhleDIueSkpKTtcbn1cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpID0+IHtcbiAgd2luZG93UmVzaXplVXBkYXRlKCk7XG4gIHpvb21VcGRhdGUoKTtcbn0pOyAvL2h0dHA6Ly9qc2ZpZGRsZS5uZXQvZ2ZjYXJ2L1FLZ0hzLyBvciBodHRwOi8vanNmaWRkbGUubmV0L2dmY2Fydi90QXdRVi9cbi8vaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvOTMxd2s3NW4vMi8iLCIvL0ltcG9ydHNcbmltcG9ydCAqIGFzIERJU1BMQVkgZnJvbSAnLi4vc2NyaXB0cy9kaXNwbGF5LmpzJzsgLy9QdWJsaWMgdmFyaWFibGVzXG4vLy1cbi8vUHJpdmF0ZSB2YXJpYWJsZXNcbi8vLVxuLy9QdWJsaWMgZnVuY3Rpb25zXG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWF0ZUNvbnRyb2xzKCkge1xuICAvL1pvb20gY29udHJvbHNcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN6b29tX291dFwiKS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoKSA9PiB7XG4gICAgaWYgKERJU1BMQVkuY2FtZXJhLnpvb20gPiAwKSBESVNQTEFZLmNhbWVyYS56b29tLS07XG4gICAgRElTUExBWS56b29tVXBkYXRlKCk7XG4gIH0pO1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3pvb21faW5cIikuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKCkgPT4ge1xuICAgIGlmIChESVNQTEFZLmNhbWVyYS56b29tIDwgMikgRElTUExBWS5jYW1lcmEuem9vbSsrO1xuICAgIERJU1BMQVkuem9vbVVwZGF0ZSgpO1xuICB9KTsgLy9DYW1lcmEgcG9zaXRpb24gY29udHJvbHNcblxuICBsZXQgdGltZXIgPSBudWxsO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKCkgPT4ge1xuICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICB9KTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoKSA9PiB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gIH0pO1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2NhbWVyYV91cFwiKS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoKSA9PiB7XG4gICAgdGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBESVNQTEFZLmNhbWVyYS55IC09IDU7XG4gICAgfSwgMTApO1xuICB9KTtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjYW1lcmFfbGVmdFwiKS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoKSA9PiB7XG4gICAgdGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBESVNQTEFZLmNhbWVyYS54IC09IDU7XG4gICAgfSwgMTApO1xuICB9KTtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjYW1lcmFfcmlnaHRcIikuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKCkgPT4ge1xuICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgRElTUExBWS5jYW1lcmEueCArPSA1O1xuICAgIH0sIDEwKTtcbiAgfSk7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjY2FtZXJhX2Rvd25cIikuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKCkgPT4ge1xuICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgRElTUExBWS5jYW1lcmEueSArPSA1O1xuICAgIH0sIDEwKTtcbiAgfSk7IC8vS2V5Ym9hcmQgY29udHJvbHNcblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZSA9PiB7XG4gICAgc3dpdGNoIChlLmNvZGUpIHtcbiAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICB0aW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICBESVNQTEFZLmNhbWVyYS55IC09IDU7XG4gICAgICAgIH0sIDEwKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgIERJU1BMQVkuY2FtZXJhLnggLT0gNTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgIERJU1BMQVkuY2FtZXJhLnggKz0gNTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgICAgdGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgRElTUExBWS5jYW1lcmEueSArPSA1O1xuICAgICAgICB9LCAxMCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG59IC8vUHJpdmF0ZSBmdW5jdGlvbnMiLCJpbXBvcnQgeyBBZGRyZXNzLCBQcm92aWRlclJwY0NsaWVudCwgVHZtRXhjZXB0aW9uIH0gZnJvbSAnZXZlcnNjYWxlLWlucGFnZS1wcm92aWRlcic7XG5pbXBvcnQgeyBFdmVyc2NhbGVTdGFuZGFsb25lQ2xpZW50LCBTaW1wbGVLZXlzdG9yZSwgU2ltcGxlQWNjb3VudHNTdG9yYWdlLCBXYWxsZXRWM0FjY291bnQgfSBmcm9tICdldmVyc2NhbGUtc3RhbmRhbG9uZS1jbGllbnQnO1xuXG5jb25zdCByb3V0ZXJBYmkgPSByZXF1aXJlKCcuLi8uLi9jb250cmFjdHMvYnVpbGQvUm91dGVyLmFiaS5qc29uJyk7XG5cbmNvbnN0IGNlbGxBYmkgPSByZXF1aXJlKCcuLi8uLi9jb250cmFjdHMvYnVpbGQvQ2VsbC5hYmkuanNvbicpO1xuXG5jb25zdCBDb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnLmpzb25cIik7XG5cbmxldCBjdXJyZW50TWFwO1xuY29uc3QgZXZlciA9IG5ldyBQcm92aWRlclJwY0NsaWVudCh7fSk7XG5cbmZ1bmN0aW9uIGJlaGF2aW9yKG5hbWUsIGZuKSB7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLWJlaGF2aW9yPSR7bmFtZX1dYCkuZm9yRWFjaChmbik7XG59XG5cbmNvbnN0IGlubmVyVGV4dCA9IHRleHQgPT4gZWxlbSA9PiB7XG4gIGVsZW0uaW5uZXJUZXh0ID0gdGV4dDtcbn07XG5cbmZ1bmN0aW9uIHJlcXVlc3RQZXJtaXNzaW9ucygpIHtcbiAgcmV0dXJuIGV2ZXIucmVxdWVzdFBlcm1pc3Npb25zKHtcbiAgICBwZXJtaXNzaW9uczogWydiYXNpYycsICdhY2NvdW50SW50ZXJhY3Rpb24nXVxuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZGlzY29ubmVjdEFjdGlvbigpIHtcbiAgY29uc29sZS5sb2coJ2Rpc2Nvbm5lY3RBY3Rpb24nKTtcbiAgYXdhaXQgZXZlci5kaXNjb25uZWN0KCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gIGF3YWl0IGV2ZXIucmVxdWVzdFBlcm1pc3Npb25zKHtcbiAgICBwZXJtaXNzaW9uczogWydiYXNpYycsICdhY2NvdW50SW50ZXJhY3Rpb24nXVxuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tDb25uZWN0KCkge1xuICBjb25zdCBwcm92aWRlclN0YXRlID0gYXdhaXQgZXZlci5nZXRQcm92aWRlclN0YXRlKCk7XG4gIGNvbnN0IHBlcm1pc3Npb25zID0gcHJvdmlkZXJTdGF0ZS5wZXJtaXNzaW9ucztcbiAgY29uc3QgbmV0d29yayA9IHByb3ZpZGVyU3RhdGUuc2VsZWN0ZWRDb25uZWN0aW9uO1xuXG4gIGlmICghY29udHJhY3RBZGRyZXNzKG5ldHdvcmspIHx8ICFwZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb24pIHtcbiAgICBiZWhhdmlvcignY29ubmVjdCcsIGVsZW0gPT4gZWxlbS5vbmNsaWNrID0gcmVxdWVzdFBlcm1pc3Npb25zKTtcbiAgICBzd2l0Y2hTY3JlZW4oXCJsb2dpblwiKTtcblxuICAgIGNvbnN0IGNvbm5lY3RUZXh0ID0gZWxlbSA9PiB7XG4gICAgICBjb25zdCBkaXNhYmxlZCA9ICFjb250cmFjdEFkZHJlc3MobmV0d29yayk7XG4gICAgICBlbGVtLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgICBlbGVtLmlubmVyVGV4dCA9IGRpc2FibGVkID8gYENvbnRyYWN0IG5vdCBmb3VuZGAgOiBgQ29ubmVjdCB3aXRoICR7bmV0d29ya31gO1xuICAgIH07XG5cbiAgICBiZWhhdmlvcignY29ubmVjdCcsIGNvbm5lY3RUZXh0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJTkZPIGZvciB0cmFuc2FjdGlvbnNGb3VuZCBhbmQgY29udHJhY3RTdGF0ZUNoYW5nZWQgbmVlZCBwZXJtaXNzaW9uc1xuICAgIGNvbnN0IHByb3ZpZGVyU3RhdGUgPSBhd2FpdCBldmVyLmdldFByb3ZpZGVyU3RhdGUoKTtcbiAgICAoYXdhaXQgZXZlci5zdWJzY3JpYmUoJ3RyYW5zYWN0aW9uc0ZvdW5kJywge1xuICAgICAgYWRkcmVzczogY29udHJhY3RBZGRyZXNzKHByb3ZpZGVyU3RhdGUuc2VsZWN0ZWRDb25uZWN0aW9uKVxuICAgIH0pKS5vbignZGF0YScsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCc6Jywge1xuICAgICAgICBhZGRyZXNzOiBldmVudC5hZGRyZXNzLFxuICAgICAgICB0cmFuc2FjdGlvbnM6IGV2ZW50LnRyYW5zYWN0aW9ucyxcbiAgICAgICAgaW5mbzogZXZlbnQuaW5mb1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgKGF3YWl0IGV2ZXIuc3Vic2NyaWJlKCdjb250cmFjdFN0YXRlQ2hhbmdlZCcsIHtcbiAgICAgIGFkZHJlc3M6IGNvbnRyYWN0QWRkcmVzcyhwcm92aWRlclN0YXRlLnNlbGVjdGVkQ29ubmVjdGlvbilcbiAgICB9KSkub24oJ2RhdGEnLCBldmVudCA9PiB7XG4gICAgICBjb25zb2xlLmxvZygncGVybWlzc2lvbnNDaGFuZ2VkOicsIHtcbiAgICAgICAgYWRkcmVzczogZXZlbnQuYWRkcmVzcyxcbiAgICAgICAgc3RhdGU6IGV2ZW50LnN0YXRlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBzd2l0Y2hTY3JlZW4oXCJtYWluXCIpO1xuICAgIGNvbnN0IGFjY291bnQgPSBwZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb247XG4gICAgbGV0IGFkZHJlc3MgPSBhY2NvdW50LmFkZHJlc3MudG9TdHJpbmcoKTtcbiAgICBsZXQgcHVia2V5ID0gYWNjb3VudC5hZGRyZXNzLnRvU3RyaW5nKCk7XG4gICAgYmVoYXZpb3IoJ2FkZHJlc3MnLCBpbm5lclRleHQoYCR7YWRkcmVzcy5zdWJzdHIoMCwgNil9Li4uJHthZGRyZXNzLnN1YnN0cigtNCwgNCl9YCkpO1xuICAgIGJlaGF2aW9yKCdwdWJsaWNLZXknLCBpbm5lclRleHQoYCR7cHVia2V5LnN1YnN0cigwLCA2KX0uLi4ke3B1YmtleS5zdWJzdHIoLTQsIDQpfWApKTtcbiAgICBiZWhhdmlvcignZGlzY29ubmVjdEFjdGlvbicsIGVsZW0gPT4gZWxlbS5vbmNsaWNrID0gZGlzY29ubmVjdEFjdGlvbik7XG4gICAgbG9hZE1hcCgpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNldE5ldHdvcmtDaGFuZ2VkKG5ldHdvcmspIHtcbiAgY29uc3QgbW9kID0gbmV0d29yayA9PT0gJ21haW5uZXQnID8gJ3N1Y2Nlc3MnIDogJ3NlY29uZGFyeSc7XG4gIGNvbnN0IG91dCA9IGA8c3BhbiBjbGFzcz1cImJhZGdlIGJnLSR7bW9kfVwiPiR7bmV0d29ya308L3NwYW4+YDtcbiAgYmVoYXZpb3IoJ25ldHdvcmsnLCBlbGVtID0+IGVsZW0uaW5uZXJIVE1MID0gb3V0KTtcbiAgYXdhaXQgY2hlY2tDb25uZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGNvbnRyYWN0QWRkcmVzcyhuZXR3b3JrLCBuYW1lID0gXCJyb3V0ZXJcIikge1xuICAvLyBpZiAoYWRkcltuZXR3b3JrXSAmJiBhZGRyW25ldHdvcmtdW25hbWVdKSB7XG4gIC8vIHJldHVybiBuZXcgQWRkcmVzcyhhZGRyW25ldHdvcmtdW25hbWVdKTtcbiAgLy8gfVxuICAvLyByZXR1cm4gbnVsbFxuICByZXR1cm4gbmV3IEFkZHJlc3MoQ29uZmlnLnJvdXRlcik7XG59IC8vIGFzeW5jIGZ1bmN0aW9uIENvbnRyYWN0KCkge1xuLy8gY29uc3QgcHJvdmlkZXJTdGF0ZSA9IGF3YWl0IGV2ZXIuZ2V0UHJvdmlkZXJTdGF0ZSgpO1xuLy8gY29uc3QgYWRkcmVzcyA9IGNvbnRyYWN0QWRkcmVzcyhwcm92aWRlclN0YXRlLnNlbGVjdGVkQ29ubmVjdGlvbik7XG4vLyByZXR1cm4gbmV3IGV2ZXIuQ29udHJhY3QoYWJpLCBhZGRyZXNzKTtcbi8vIH1cblxuXG5mdW5jdGlvbiBzd2l0Y2hTY3JlZW4odG8pIHtcbiAgY29uc29sZS5sb2coJ3N3aXRjaFNjcmVlbjonLCB0byk7XG4gIFtcImV4dGVuc2lvblwiLCBcImxvZ2luXCIsIFwibWFpblwiXS5mb3JFYWNoKHNjcmVlbiA9PiB7XG4gICAgY29uc3Qgc3dpdGNoZXIgPSBlbGVtID0+IGVsZW0uc3R5bGUuZGlzcGxheSA9IHRvID09PSBzY3JlZW4gPyAndGFibGUtcm93JyA6ICdub25lJztcblxuICAgIGJlaGF2aW9yKHNjcmVlbiwgc3dpdGNoZXIpO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbWFpbkZsb3coKSB7XG4gIGNvbnN0IHByb3ZpZGVyU3RhdGUgPSBhd2FpdCBldmVyLmdldFByb3ZpZGVyU3RhdGUoKTtcbiAgY29uc29sZS5sb2coJ3NlbGVjdGVkQ29ubmVjdGlvbjonLCBwcm92aWRlclN0YXRlLnNlbGVjdGVkQ29ubmVjdGlvbik7XG4gIGF3YWl0IHNldE5ldHdvcmtDaGFuZ2VkKHByb3ZpZGVyU3RhdGUuc2VsZWN0ZWRDb25uZWN0aW9uKTtcbiAgKGF3YWl0IGV2ZXIuc3Vic2NyaWJlKCduZXR3b3JrQ2hhbmdlZCcpKS5vbignZGF0YScsIGV2ZW50ID0+IHtcbiAgICBjb25zb2xlLmxvZygnbmV0d29ya0NoYW5nZWQ6JywgZXZlbnQuc2VsZWN0ZWRDb25uZWN0aW9uKTtcbiAgICBzZXROZXR3b3JrQ2hhbmdlZChldmVudC5zZWxlY3RlZENvbm5lY3Rpb24pO1xuICB9KTtcbiAgKGF3YWl0IGV2ZXIuc3Vic2NyaWJlKCdwZXJtaXNzaW9uc0NoYW5nZWQnKSkub24oJ2RhdGEnLCBhc3luYyBldmVudCA9PiB7XG4gICAgY29uc29sZS5sb2coJ3Blcm1pc3Npb25zQ2hhbmdlZDonLCBldmVudC5wZXJtaXNzaW9ucyk7XG4gICAgYXdhaXQgY2hlY2tDb25uZWN0KCk7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBsb2FkTWFwKCkge1xuICBhd2FpdCByb3V0ZXJEZXRhaWxzKCk7XG4gIGxldCBjb29yZHMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRNYXAubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgaGV4ID0gY3VycmVudE1hcFtpXTtcbiAgICBjb29yZHMucHVzaCh7XG4gICAgICB4OiBoZXgueCxcbiAgICAgIHk6IGhleC55LFxuICAgICAgejogLWhleC54IC0gaGV4LnlcbiAgICB9KTtcbiAgfVxuXG4gIGxldCBhZGRyZXNlcyA9IGF3YWl0IGdldEFkZHJlc3NDZWxscyhjb29yZHMpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudE1hcC5sZW5ndGg7IGkrKykge1xuICAgIGxldCBoZXggPSBjdXJyZW50TWFwW2ldO1xuICAgIGhleC5hZGRyZXNzID0gYWRkcmVzZXNbaV07XG4gICAgYXdhaXQgc3Vic2NyaWJlQ2VsbFN0YXRlKGFkZHJlc2VzW2ldLCBoZXgpO1xuICAgIGhleC5kZXRhaWxzID0gYXdhaXQgZ2V0RGV0YWlsc0NlbGwoYWRkcmVzZXNbaV0pO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0KG1hcCkge1xuICBjdXJyZW50TWFwID0gbWFwO1xuXG4gIGlmIChhd2FpdCBldmVyLmhhc1Byb3ZpZGVyKCkpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZXZlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgYXdhaXQgbWFpbkZsb3coKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIFRPRE8gaGFuZGxlIGl0XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN3aXRjaFNjcmVlbihcImV4dGVuc2lvblwiKTtcbiAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJvdXRlckRldGFpbHMoKSB7XG4gIGNvbnN0IHByb3ZpZGVyU3RhdGUgPSBhd2FpdCBldmVyLmdldFByb3ZpZGVyU3RhdGUoKTtcbiAgY29uc3Qgcm91dGVyID0gbmV3IGV2ZXIuQ29udHJhY3Qocm91dGVyQWJpLCBjb250cmFjdEFkZHJlc3MocHJvdmlkZXJTdGF0ZS5zZWxlY3RlZENvbm5lY3Rpb24sICdyb3V0ZXInKSk7XG5cbiAgdHJ5IHtcbiAgICBsZXQgZGV0YWlscztcbiAgICBkZXRhaWxzID0gYXdhaXQgcm91dGVyLm1ldGhvZHMuZ2V0RGV0YWlscyh7fSkuY2FsbCgpO1xuICAgIGNvbnNvbGUubG9nKCdnZXREZXRhaWxzIHJvdXRlcicsIGRldGFpbHMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcblxuICAgIGlmIChlIGluc3RhbmNlb2YgVHZtRXhjZXB0aW9uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUuY29kZSk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3Vic2NyaWJlQ2VsbFN0YXRlKGFkZHJlc3MsIGhleCkge1xuICB0cnkge1xuICAgIChhd2FpdCBldmVyLnN1YnNjcmliZSgnY29udHJhY3RTdGF0ZUNoYW5nZWQnLCB7XG4gICAgICBhZGRyZXNzOiBhZGRyZXNzXG4gICAgfSkpLm9uKCdkYXRhJywgYXN5bmMgZXZlbnQgPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coJ2NvbnRyYWN0U3RhdGVDaGFuZ2VkOicsIHtcbiAgICAgIC8vIGFkZHJlc3M6IGV2ZW50LmFkZHJlc3MsXG4gICAgICAvLyBzdGF0ZTogZXZlbnQuc3RhdGUsXG4gICAgICAvLyB9KTtcbiAgICAgIGhleC5kZXRhaWxzID0gYXdhaXQgZ2V0RGV0YWlsc0NlbGwoZXZlbnQuYWRkcmVzcyk7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBUdm1FeGNlcHRpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZS5jb2RlKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBZGRyZXNzQ2VsbHMoY29vcmRzKSB7XG4gIGNvbnN0IHByb3ZpZGVyU3RhdGUgPSBhd2FpdCBldmVyLmdldFByb3ZpZGVyU3RhdGUoKTtcbiAgY29uc3Qgcm91dGVyID0gbmV3IGV2ZXIuQ29udHJhY3Qocm91dGVyQWJpLCBjb250cmFjdEFkZHJlc3MocHJvdmlkZXJTdGF0ZS5zZWxlY3RlZENvbm5lY3Rpb24sICdyb3V0ZXInKSk7XG5cbiAgdHJ5IHtcbiAgICBsZXQgZGV0YWlscztcbiAgICBkZXRhaWxzID0gYXdhaXQgcm91dGVyLm1ldGhvZHMuZ2V0QWRkcmVzc0NlbGxzKHtcbiAgICAgIGNvb3Jkc1xuICAgIH0pLmNhbGwoKTtcbiAgICBjb25zb2xlLmxvZygnZ2V0QWRkcmVzc0NlbGxzIHJvdXRlcicsIGRldGFpbHMpO1xuICAgIHJldHVybiBkZXRhaWxzLmFkZHJlc2VzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcblxuICAgIGlmIChlIGluc3RhbmNlb2YgVHZtRXhjZXB0aW9uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUuY29kZSk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbmV3R2FtZShjZWxsQ29vcmQpIHtcbiAgY29uc3QgcHJvdmlkZXJTdGF0ZSA9IGF3YWl0IGV2ZXIuZ2V0UHJvdmlkZXJTdGF0ZSgpO1xuICBjb25zdCBwZXJtaXNzaW9ucyA9IHByb3ZpZGVyU3RhdGUucGVybWlzc2lvbnM7XG4gIGlmICghcGVybWlzc2lvbnMuYWNjb3VudEludGVyYWN0aW9uKSByZXR1cm47XG4gIGNvbnN0IGFjY291bnQgPSBwZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb247XG4gIGNvbnN0IHJvdXRlciA9IG5ldyBldmVyLkNvbnRyYWN0KHJvdXRlckFiaSwgY29udHJhY3RBZGRyZXNzKHByb3ZpZGVyU3RhdGUuc2VsZWN0ZWRDb25uZWN0aW9uLCAncm91dGVyJykpO1xuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ25ld0dhbWUnLCAxKTtcbiAgICBsZXQgcmVzID0gYXdhaXQgcm91dGVyLm1ldGhvZHMubmV3R2FtZSh7XG4gICAgICBzZW5kR2FzVG86IGFjY291bnQuYWRkcmVzcy50b1N0cmluZygpLFxuICAgICAgYmFzZUNvb3JkOiBjZWxsQ29vcmRcbiAgICB9KS5zZW5kKHtcbiAgICAgIGZyb206IGFjY291bnQuYWRkcmVzcy50b1N0cmluZygpLFxuICAgICAgYW1vdW50OiAnMjAwMDAwMDAwMCdcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZygnbmV3R2FtZScsIHJlcyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBUdm1FeGNlcHRpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZS5jb2RlKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtYXJrQ2VsbChhZGRyZXNzLCBjZWxsQ29vcmQsIGVuZXJneSkge1xuICBjb25zdCBwcm92aWRlclN0YXRlID0gYXdhaXQgZXZlci5nZXRQcm92aWRlclN0YXRlKCk7XG4gIGNvbnN0IHBlcm1pc3Npb25zID0gcHJvdmlkZXJTdGF0ZS5wZXJtaXNzaW9ucztcbiAgaWYgKCFwZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb24pIHJldHVybjtcbiAgY29uc3QgYWNjb3VudCA9IHBlcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbjtcbiAgY29uc3QgY2VsbCA9IG5ldyBldmVyLkNvbnRyYWN0KGNlbGxBYmksIGFkZHJlc3MpO1xuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ21hcmtDZWxsJywgMSk7XG4gICAgbGV0IHJlcyA9IGF3YWl0IGNlbGwubWV0aG9kcy5tYXJrQ2VsbCh7XG4gICAgICBzZW5kR2FzVG86IGFjY291bnQuYWRkcmVzcy50b1N0cmluZygpLFxuICAgICAgdGFyZ2V0Q29vcmQ6IGNlbGxDb29yZCxcbiAgICAgIGVuZXJneTogZW5lcmd5XG4gICAgfSkuc2VuZCh7XG4gICAgICBmcm9tOiBhY2NvdW50LmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgIGFtb3VudDogJzIwMDAwMDAwMDAnXG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coJ21hcmtDZWxsJywgcmVzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoZSk7XG5cbiAgICBpZiAoZSBpbnN0YW5jZW9mIFR2bUV4Y2VwdGlvbikge1xuICAgICAgY29uc29sZS5lcnJvcihlLmNvZGUpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZ3JhZGVDZWxsKGFkZHJlc3MpIHtcbiAgY29uc3QgcHJvdmlkZXJTdGF0ZSA9IGF3YWl0IGV2ZXIuZ2V0UHJvdmlkZXJTdGF0ZSgpO1xuICBjb25zdCBwZXJtaXNzaW9ucyA9IHByb3ZpZGVyU3RhdGUucGVybWlzc2lvbnM7XG4gIGlmICghcGVybWlzc2lvbnMuYWNjb3VudEludGVyYWN0aW9uKSByZXR1cm47XG4gIGNvbnN0IGFjY291bnQgPSBwZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb247XG4gIGNvbnN0IGNlbGwgPSBuZXcgZXZlci5Db250cmFjdChjZWxsQWJpLCBhZGRyZXNzKTtcblxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCd1cGdyYWRlQ2VsbCcsIDEpO1xuICAgIGxldCByZXMgPSBhd2FpdCBjZWxsLm1ldGhvZHMudXBncmFkZUNlbGwoe1xuICAgICAgc2VuZEdhc1RvOiBhY2NvdW50LmFkZHJlc3MudG9TdHJpbmcoKVxuICAgIH0pLnNlbmQoe1xuICAgICAgZnJvbTogYWNjb3VudC5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICBhbW91bnQ6ICcxMDAwMDAwMDAwJ1xuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKCd1cGdyYWRlQ2VsbCcsIHJlcyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBUdm1FeGNlcHRpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZS5jb2RlKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoZWxwQ2VsbChhZGRyZXNzLCBjZWxsQ29vcmQsIGVuZXJneSkge1xuICBjb25zdCBwcm92aWRlclN0YXRlID0gYXdhaXQgZXZlci5nZXRQcm92aWRlclN0YXRlKCk7XG4gIGNvbnN0IHBlcm1pc3Npb25zID0gcHJvdmlkZXJTdGF0ZS5wZXJtaXNzaW9ucztcbiAgaWYgKCFwZXJtaXNzaW9ucy5hY2NvdW50SW50ZXJhY3Rpb24pIHJldHVybjtcbiAgY29uc3QgYWNjb3VudCA9IHBlcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbjtcbiAgY29uc3QgY2VsbCA9IG5ldyBldmVyLkNvbnRyYWN0KGNlbGxBYmksIGFkZHJlc3MpO1xuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ2hlbHBDZWxsJywgMSk7XG4gICAgbGV0IHJlcyA9IGF3YWl0IGNlbGwubWV0aG9kcy5oZWxwQ2VsbCh7XG4gICAgICBzZW5kR2FzVG86IGFjY291bnQuYWRkcmVzcy50b1N0cmluZygpLFxuICAgICAgdGFyZ2V0Q29vcmQ6IGNlbGxDb29yZCxcbiAgICAgIGVuZXJneTogZW5lcmd5XG4gICAgfSkuc2VuZCh7XG4gICAgICBmcm9tOiBhY2NvdW50LmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgIGFtb3VudDogJzEwMDAwMDAwMDAnXG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coJ2hlbHBDZWxsJywgcmVzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoZSk7XG5cbiAgICBpZiAoZSBpbnN0YW5jZW9mIFR2bUV4Y2VwdGlvbikge1xuICAgICAgY29uc29sZS5lcnJvcihlLmNvZGUpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF0dGtDZWxsKGFkZHJlc3MsIGNlbGxDb29yZCwgZW5lcmd5KSB7XG4gIGNvbnN0IHByb3ZpZGVyU3RhdGUgPSBhd2FpdCBldmVyLmdldFByb3ZpZGVyU3RhdGUoKTtcbiAgY29uc3QgcGVybWlzc2lvbnMgPSBwcm92aWRlclN0YXRlLnBlcm1pc3Npb25zO1xuICBpZiAoIXBlcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbikgcmV0dXJuO1xuICBjb25zdCBhY2NvdW50ID0gcGVybWlzc2lvbnMuYWNjb3VudEludGVyYWN0aW9uO1xuICBjb25zdCBjZWxsID0gbmV3IGV2ZXIuQ29udHJhY3QoY2VsbEFiaSwgYWRkcmVzcyk7XG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnYXR0a0NlbGwnLCAxKTtcbiAgICBsZXQgcmVzID0gYXdhaXQgY2VsbC5tZXRob2RzLmF0dGtDZWxsKHtcbiAgICAgIHNlbmRHYXNUbzogYWNjb3VudC5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICB0YXJnZXRDb29yZDogY2VsbENvb3JkLFxuICAgICAgZW5lcmd5OiBlbmVyZ3lcbiAgICB9KS5zZW5kKHtcbiAgICAgIGZyb206IGFjY291bnQuYWRkcmVzcy50b1N0cmluZygpLFxuICAgICAgYW1vdW50OiAnMTAwMDAwMDAwMCdcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZygnYXR0a0NlbGwnLCByZXMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcblxuICAgIGlmIChlIGluc3RhbmNlb2YgVHZtRXhjZXB0aW9uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUuY29kZSk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGV0YWlsc0NlbGwoYWRkcmVzcykge1xuICBjb25zdCBjZWxsID0gbmV3IGV2ZXIuQ29udHJhY3QoY2VsbEFiaSwgYWRkcmVzcyk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzdGF0ZVJlcyA9IGF3YWl0IGNlbGwuZ2V0RnVsbFN0YXRlKCk7XG5cbiAgICBpZiAoc3RhdGVSZXMuc3RhdGUgPT0gbnVsbCB8fCAhc3RhdGVSZXMuc3RhdGUuaXNEZXBsb3llZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvL2NvbnNvbGUubG9nKCdzdGF0ZScsIHN0YXRlUmVzLnN0YXRlKTtcblxuXG4gICAgbGV0IGRldGFpbHM7XG4gICAgZGV0YWlscyA9IGF3YWl0IGNlbGwubWV0aG9kcy5nZXREZXRhaWxzKHt9KS5jYWxsKCk7XG4gICAgY29uc29sZS5sb2coJ2dldERldGFpbHMgY2VsbCcsIGRldGFpbHMpO1xuICAgIHJldHVybiBkZXRhaWxzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcblxuICAgIGlmIChlIGluc3RhbmNlb2YgVHZtRXhjZXB0aW9uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUuY29kZSk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3Vic2NyaWJlUGVybWlzc2lvbnNDaGFuZ2VkKCkge1xuICBhd2FpdCBldmVyLnN1YnNjcmliZSgncGVybWlzc2lvbnNDaGFuZ2VkJykub24oJ2RhdGEnLCBwZXJtaXNzaW9ucyA9PiB7XG4gICAgY29uc29sZS5sb2cocGVybWlzc2lvbnMpO1xuICB9KTtcbn0iLCJcInVzZSBzdHJpY3RcIjsgLy9JbXBvcnQgQ1NTXG5cbmltcG9ydCAnLi9zdHlsZXMvbWFpbi5zY3NzJzsgLy9JbXBvcnQgSlNcblxuaW1wb3J0ICogYXMgTUFQR0VORVJBVE9SIGZyb20gJy4vc2NyaXB0cy9tYXBnZW5lcmF0b3IuanMnO1xuaW1wb3J0ICogYXMgRElTUExBWSBmcm9tICcuL3NjcmlwdHMvZGlzcGxheS5qcyc7XG5pbXBvcnQgKiBhcyBDT05UUk9MUyBmcm9tICcuL3NjcmlwdHMvY29udHJvbHMuanMnO1xuaW1wb3J0ICogYXMgUFJPVklERVIgZnJvbSAnLi9zY3JpcHRzL2V2ZXIuanMnOyAvL2h0dHBzOi8vZ2l0aHViLmNvbS9mbGF1d2VrZXVsL2hvbmV5Y29tYlxuLy9jb25zb2xlLmNsZWFyKCk7XG5cbmxldCBtYXAgPSBNQVBHRU5FUkFUT1IuZ2V0UmFuZG9tTWFwKDIwLCAxNSk7XG5ESVNQTEFZLmluaXRpYXRlTWFwKG1hcCwgUFJPVklERVIpO1xuQ09OVFJPTFMuaW5pdGlhdGVDb250cm9scygpO1xuXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpO1xufSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///612\n')},431:function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;;(function (globalObject) {\r\n  'use strict';\r\n\r\n/*\r\n *      bignumber.js v9.1.0\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\n  var BigNumber,\r\n    isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n    mathceil = Math.ceil,\r\n    mathfloor = Math.floor,\r\n\r\n    bignumberError = '[BigNumber Error] ',\r\n    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n    BASE = 1e14,\r\n    LOG_BASE = 14,\r\n    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n    SQRT_BASE = 1e7,\r\n\r\n    // EDITABLE\r\n    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n    // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n    MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n  /*\r\n   * Create and return a BigNumber constructor.\r\n   */\r\n  function clone(configObject) {\r\n    var div, convertBase, parseNumeric,\r\n      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n      ONE = new BigNumber(1),\r\n\r\n\r\n      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n      // The default values below must be integers within the inclusive ranges stated.\r\n      // The values can also be changed at run-time using BigNumber.set.\r\n\r\n      // The maximum number of decimal places for operations involving division.\r\n      DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n      // The rounding mode used when rounding to the above decimal places, and when using\r\n      // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n      // UP         0 Away from zero.\r\n      // DOWN       1 Towards zero.\r\n      // CEIL       2 Towards +Infinity.\r\n      // FLOOR      3 Towards -Infinity.\r\n      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n      // The exponent value at and beneath which toString returns exponential notation.\r\n      // Number type: -7\r\n      TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n      // The exponent value at and above which toString returns exponential notation.\r\n      // Number type: 21\r\n      TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n      // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // Number type: -324  (5e-324)\r\n      MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // Number type:  308  (1.7976931348623157e+308)\r\n      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n      MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      CRYPTO = false,                          // true or false\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN      1 The remainder has the same sign as the dividend.\r\n      //             This modulo mode is commonly known as 'truncated division' and is\r\n      //             equivalent to (a % n) in JavaScript.\r\n      // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n      //             The remainder is always positive.\r\n      //\r\n      // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n      // modes are commonly used for the modulus operation.\r\n      // Although the other rounding modes can also be used, they may not give useful results.\r\n      MODULO_MODE = 1,                         // 0 to 9\r\n\r\n      // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n      // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n      POW_PRECISION = 0,                       // 0 to MAX\r\n\r\n      // The format specification used by the BigNumber.prototype.toFormat method.\r\n      FORMAT = {\r\n        prefix: '',\r\n        groupSize: 3,\r\n        secondaryGroupSize: 0,\r\n        groupSeparator: ',',\r\n        decimalSeparator: '.',\r\n        fractionGroupSize: 0,\r\n        fractionGroupSeparator: '\\xA0',        // non-breaking space\r\n        suffix: ''\r\n      },\r\n\r\n      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n      // '-', '.', whitespace, or repeated character.\r\n      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',\r\n      alphabetHasNormalDecimalDigits = true;\r\n\r\n\r\n    //------------------------------------------------------------------------------------------\r\n\r\n\r\n    // CONSTRUCTOR\r\n\r\n\r\n    /*\r\n     * The BigNumber constructor and exported function.\r\n     * Create and return a new instance of a BigNumber object.\r\n     *\r\n     * v {number|string|BigNumber} A numeric value.\r\n     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n     */\r\n    function BigNumber(v, b) {\r\n      var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n        x = this;\r\n\r\n      // Enable constructor call without `new`.\r\n      if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n      if (b == null) {\r\n\r\n        if (v && v._isBigNumber === true) {\r\n          x.s = v.s;\r\n\r\n          if (!v.c || v.e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else if (v.e < MIN_EXP) {\r\n            x.c = [x.e = 0];\r\n          } else {\r\n            x.e = v.e;\r\n            x.c = v.c.slice();\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n          // Use `1 / n` to handle minus zero also.\r\n          x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n          // Fast path for integers, where n < 2147483648 (2**31).\r\n          if (v === ~~v) {\r\n            for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n            if (e > MAX_EXP) {\r\n              x.c = x.e = null;\r\n            } else {\r\n              x.e = e;\r\n              x.c = [v];\r\n            }\r\n\r\n            return;\r\n          }\r\n\r\n          str = String(v);\r\n        } else {\r\n\r\n          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n        // Exponential form?\r\n        if ((i = str.search(/e/i)) > 0) {\r\n\r\n          // Determine exponent.\r\n          if (e < 0) e = i;\r\n          e += +str.slice(i + 1);\r\n          str = str.substring(0, i);\r\n        } else if (e < 0) {\r\n\r\n          // Integer.\r\n          e = str.length;\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n        // Allow exponential notation to be used with base 10 argument, while\r\n        // also rounding to DECIMAL_PLACES as with other bases.\r\n        if (b == 10 && alphabetHasNormalDecimalDigits) {\r\n          x = new BigNumber(v);\r\n          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n        }\r\n\r\n        str = String(v);\r\n\r\n        if (isNum = typeof v == 'number') {\r\n\r\n          // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n          if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n            throw Error\r\n             (tooManyDigits + v);\r\n          }\r\n        } else {\r\n          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        alphabet = ALPHABET.slice(0, b);\r\n        e = i = 0;\r\n\r\n        // Check that str is a valid base b number.\r\n        // Don't use RegExp, so alphabet can contain special characters.\r\n        for (len = str.length; i < len; i++) {\r\n          if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n            if (c == '.') {\r\n\r\n              // If '.' is not the first character and it has not be found before.\r\n              if (i > e) {\r\n                e = len;\r\n                continue;\r\n              }\r\n            } else if (!caseChanged) {\r\n\r\n              // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                  str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n                caseChanged = true;\r\n                i = -1;\r\n                e = 0;\r\n                continue;\r\n              }\r\n            }\r\n\r\n            return parseNumeric(x, String(v), isNum, b);\r\n          }\r\n        }\r\n\r\n        // Prevent later check for length on converted number.\r\n        isNum = false;\r\n        str = convertBase(str, b, 10, x.s);\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n        else e = str.length;\r\n      }\r\n\r\n      // Determine leading zeros.\r\n      for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n      // Determine trailing zeros.\r\n      for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n      if (str = str.slice(i, ++len)) {\r\n        len -= i;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (isNum && BigNumber.DEBUG &&\r\n          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n            throw Error\r\n             (tooManyDigits + (x.s * v));\r\n        }\r\n\r\n         // Overflow?\r\n        if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n          // Infinity.\r\n          x.c = x.e = null;\r\n\r\n        // Underflow?\r\n        } else if (e < MIN_EXP) {\r\n\r\n          // Zero.\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = e;\r\n          x.c = [];\r\n\r\n          // Transform base\r\n\r\n          // e is the base 10 exponent.\r\n          // i is where to slice str to get the first element of the coefficient array.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n          if (i < len) {\r\n            if (i) x.c.push(+str.slice(0, i));\r\n\r\n            for (len -= LOG_BASE; i < len;) {\r\n              x.c.push(+str.slice(i, i += LOG_BASE));\r\n            }\r\n\r\n            i = LOG_BASE - (str = str.slice(i)).length;\r\n          } else {\r\n            i -= len;\r\n          }\r\n\r\n          for (; i--; str += '0');\r\n          x.c.push(+str);\r\n        }\r\n      } else {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n\r\n    // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n    BigNumber.clone = clone;\r\n\r\n    BigNumber.ROUND_UP = 0;\r\n    BigNumber.ROUND_DOWN = 1;\r\n    BigNumber.ROUND_CEIL = 2;\r\n    BigNumber.ROUND_FLOOR = 3;\r\n    BigNumber.ROUND_HALF_UP = 4;\r\n    BigNumber.ROUND_HALF_DOWN = 5;\r\n    BigNumber.ROUND_HALF_EVEN = 6;\r\n    BigNumber.ROUND_HALF_CEIL = 7;\r\n    BigNumber.ROUND_HALF_FLOOR = 8;\r\n    BigNumber.EUCLID = 9;\r\n\r\n\r\n    /*\r\n     * Configure infrequently-changing library-wide settings.\r\n     *\r\n     * Accept an object with the following optional properties (if the value of a property is\r\n     * a number, it must be an integer within the inclusive range stated):\r\n     *\r\n     *   DECIMAL_PLACES   {number}           0 to MAX\r\n     *   ROUNDING_MODE    {number}           0 to 8\r\n     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n     *   CRYPTO           {boolean}          true or false\r\n     *   MODULO_MODE      {number}           0 to 9\r\n     *   POW_PRECISION       {number}           0 to MAX\r\n     *   ALPHABET         {string}           A string of two or more unique characters which does\r\n     *                                       not contain '.'.\r\n     *   FORMAT           {object}           An object with some of the following properties:\r\n     *     prefix                 {string}\r\n     *     groupSize              {number}\r\n     *     secondaryGroupSize     {number}\r\n     *     groupSeparator         {string}\r\n     *     decimalSeparator       {string}\r\n     *     fractionGroupSize      {number}\r\n     *     fractionGroupSeparator {string}\r\n     *     suffix                 {string}\r\n     *\r\n     * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n     *\r\n     * E.g.\r\n     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n     *\r\n     * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n     *\r\n     * Return an object with the properties current values.\r\n     */\r\n    BigNumber.config = BigNumber.set = function (obj) {\r\n      var p, v;\r\n\r\n      if (obj != null) {\r\n\r\n        if (typeof obj == 'object') {\r\n\r\n          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            DECIMAL_PLACES = v;\r\n          }\r\n\r\n          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 8, p);\r\n            ROUNDING_MODE = v;\r\n          }\r\n\r\n          // EXPONENTIAL_AT {number|number[]}\r\n          // Integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, 0, p);\r\n              intCheck(v[1], 0, MAX, p);\r\n              TO_EXP_NEG = v[0];\r\n              TO_EXP_POS = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n            }\r\n          }\r\n\r\n          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n          if (obj.hasOwnProperty(p = 'RANGE')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, -1, p);\r\n              intCheck(v[1], 1, MAX, p);\r\n              MIN_EXP = v[0];\r\n              MAX_EXP = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              if (v) {\r\n                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n              } else {\r\n                throw Error\r\n                 (bignumberError + p + ' cannot be zero: ' + v);\r\n              }\r\n            }\r\n          }\r\n\r\n          // CRYPTO {boolean} true or false.\r\n          // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n          // '[BigNumber Error] crypto unavailable'\r\n          if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n            v = obj[p];\r\n            if (v === !!v) {\r\n              if (v) {\r\n                if (typeof crypto != 'undefined' && crypto &&\r\n                 (crypto.getRandomValues || crypto.randomBytes)) {\r\n                  CRYPTO = v;\r\n                } else {\r\n                  CRYPTO = !v;\r\n                  throw Error\r\n                   (bignumberError + 'crypto unavailable');\r\n                }\r\n              } else {\r\n                CRYPTO = v;\r\n              }\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' not true or false: ' + v);\r\n            }\r\n          }\r\n\r\n          // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 9, p);\r\n            MODULO_MODE = v;\r\n          }\r\n\r\n          // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            POW_PRECISION = v;\r\n          }\r\n\r\n          // FORMAT {object}\r\n          // '[BigNumber Error] FORMAT not an object: {v}'\r\n          if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n            v = obj[p];\r\n            if (typeof v == 'object') FORMAT = v;\r\n            else throw Error\r\n             (bignumberError + p + ' not an object: ' + v);\r\n          }\r\n\r\n          // ALPHABET {string}\r\n          // '[BigNumber Error] ALPHABET invalid: {v}'\r\n          if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n            v = obj[p];\r\n\r\n            // Disallow if less than two characters,\r\n            // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n            if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';\r\n              ALPHABET = v;\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' invalid: ' + v);\r\n            }\r\n          }\r\n\r\n        } else {\r\n\r\n          // '[BigNumber Error] Object expected: {v}'\r\n          throw Error\r\n           (bignumberError + 'Object expected: ' + obj);\r\n        }\r\n      }\r\n\r\n      return {\r\n        DECIMAL_PLACES: DECIMAL_PLACES,\r\n        ROUNDING_MODE: ROUNDING_MODE,\r\n        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n        RANGE: [MIN_EXP, MAX_EXP],\r\n        CRYPTO: CRYPTO,\r\n        MODULO_MODE: MODULO_MODE,\r\n        POW_PRECISION: POW_PRECISION,\r\n        FORMAT: FORMAT,\r\n        ALPHABET: ALPHABET\r\n      };\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if v is a BigNumber instance, otherwise return false.\r\n     *\r\n     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n     *\r\n     * v {any}\r\n     *\r\n     * '[BigNumber Error] Invalid BigNumber: {v}'\r\n     */\r\n    BigNumber.isBigNumber = function (v) {\r\n      if (!v || v._isBigNumber !== true) return false;\r\n      if (!BigNumber.DEBUG) return true;\r\n\r\n      var i, n,\r\n        c = v.c,\r\n        e = v.e,\r\n        s = v.s;\r\n\r\n      out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n          // If the first element is zero, the BigNumber value must be zero.\r\n          if (c[0] === 0) {\r\n            if (e === 0 && c.length === 1) return true;\r\n            break out;\r\n          }\r\n\r\n          // Calculate number of digits that c[0] should have, based on the exponent.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (i < 1) i += LOG_BASE;\r\n\r\n          // Calculate number of digits of c[0].\r\n          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n          if (String(c[0]).length == i) {\r\n\r\n            for (i = 0; i < c.length; i++) {\r\n              n = c[i];\r\n              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n            }\r\n\r\n            // Last element cannot be zero, unless it is the only element.\r\n            if (n !== 0) return true;\r\n          }\r\n        }\r\n\r\n      // Infinity/NaN\r\n      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n        return true;\r\n      }\r\n\r\n      throw Error\r\n        (bignumberError + 'Invalid BigNumber: ' + v);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the maximum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.maximum = BigNumber.max = function () {\r\n      return maxOrMin(arguments, P.lt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the minimum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.minimum = BigNumber.min = function () {\r\n      return maxOrMin(arguments, P.gt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n     * zeros are produced).\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n     * '[BigNumber Error] crypto unavailable'\r\n     */\r\n    BigNumber.random = (function () {\r\n      var pow2_53 = 0x20000000000000;\r\n\r\n      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n      // Check if Math.random() produces more than 32 bits of randomness.\r\n      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n       ? function () { return mathfloor(Math.random() * pow2_53); }\r\n       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n         (Math.random() * 0x800000 | 0); };\r\n\r\n      return function (dp) {\r\n        var a, b, e, k, v,\r\n          i = 0,\r\n          c = [],\r\n          rand = new BigNumber(ONE);\r\n\r\n        if (dp == null) dp = DECIMAL_PLACES;\r\n        else intCheck(dp, 0, MAX);\r\n\r\n        k = mathceil(dp / LOG_BASE);\r\n\r\n        if (CRYPTO) {\r\n\r\n          // Browsers supporting crypto.getRandomValues.\r\n          if (crypto.getRandomValues) {\r\n\r\n            a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n            for (; i < k;) {\r\n\r\n              // 53 bits:\r\n              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n              // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n              //                                     11111 11111111 11111111\r\n              // 0x20000 is 2^21.\r\n              v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n              // Rejection sampling:\r\n              // 0 <= v < 9007199254740992\r\n              // Probability that v >= 9e15, is\r\n              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n              if (v >= 9e15) {\r\n                b = crypto.getRandomValues(new Uint32Array(2));\r\n                a[i] = b[0];\r\n                a[i + 1] = b[1];\r\n              } else {\r\n\r\n                // 0 <= v <= 8999999999999999\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 2;\r\n              }\r\n            }\r\n            i = k / 2;\r\n\r\n          // Node.js supporting crypto.randomBytes.\r\n          } else if (crypto.randomBytes) {\r\n\r\n            // buffer\r\n            a = crypto.randomBytes(k *= 7);\r\n\r\n            for (; i < k;) {\r\n\r\n              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n              // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n              // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n              // 0 <= v < 9007199254740992\r\n              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n              if (v >= 9e15) {\r\n                crypto.randomBytes(7).copy(a, i);\r\n              } else {\r\n\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 7;\r\n              }\r\n            }\r\n            i = k / 7;\r\n          } else {\r\n            CRYPTO = false;\r\n            throw Error\r\n             (bignumberError + 'crypto unavailable');\r\n          }\r\n        }\r\n\r\n        // Use Math.random.\r\n        if (!CRYPTO) {\r\n\r\n          for (; i < k;) {\r\n            v = random53bitInt();\r\n            if (v < 9e15) c[i++] = v % 1e14;\r\n          }\r\n        }\r\n\r\n        k = c[--i];\r\n        dp %= LOG_BASE;\r\n\r\n        // Convert trailing digits to zeros according to dp.\r\n        if (k && dp) {\r\n          v = POWS_TEN[LOG_BASE - dp];\r\n          c[i] = mathfloor(k / v) * v;\r\n        }\r\n\r\n        // Remove trailing elements which are zero.\r\n        for (; c[i] === 0; c.pop(), i--);\r\n\r\n        // Zero?\r\n        if (i < 0) {\r\n          c = [e = 0];\r\n        } else {\r\n\r\n          // Remove leading elements which are zero and adjust exponent accordingly.\r\n          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n          // Count the digits of the first element of c to determine leading zeros, and...\r\n          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n          // adjust the exponent accordingly.\r\n          if (i < LOG_BASE) e -= LOG_BASE - i;\r\n        }\r\n\r\n        rand.e = e;\r\n        rand.c = c;\r\n        return rand;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the sum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.sum = function () {\r\n      var i = 1,\r\n        args = arguments,\r\n        sum = new BigNumber(args[0]);\r\n      for (; i < args.length;) sum = sum.plus(args[i++]);\r\n      return sum;\r\n    };\r\n\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n\r\n    // Called by BigNumber and BigNumber.prototype.toString.\r\n    convertBase = (function () {\r\n      var decimal = '0123456789';\r\n\r\n      /*\r\n       * Convert string of baseIn to an array of numbers of baseOut.\r\n       * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n       */\r\n      function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n        var j,\r\n          arr = [0],\r\n          arrL,\r\n          i = 0,\r\n          len = str.length;\r\n\r\n        for (; i < len;) {\r\n          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n          arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n          for (j = 0; j < arr.length; j++) {\r\n\r\n            if (arr[j] > baseOut - 1) {\r\n              if (arr[j + 1] == null) arr[j + 1] = 0;\r\n              arr[j + 1] += arr[j] / baseOut | 0;\r\n              arr[j] %= baseOut;\r\n            }\r\n          }\r\n        }\r\n\r\n        return arr.reverse();\r\n      }\r\n\r\n      // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n      // If the caller is toString, we are converting from base 10 to baseOut.\r\n      // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n      return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n        var alphabet, d, e, k, r, x, xc, y,\r\n          i = str.indexOf('.'),\r\n          dp = DECIMAL_PLACES,\r\n          rm = ROUNDING_MODE;\r\n\r\n        // Non-integer.\r\n        if (i >= 0) {\r\n          k = POW_PRECISION;\r\n\r\n          // Unlimited precision.\r\n          POW_PRECISION = 0;\r\n          str = str.replace('.', '');\r\n          y = new BigNumber(baseIn);\r\n          x = y.pow(str.length - i);\r\n          POW_PRECISION = k;\r\n\r\n          // Convert str as if an integer, then restore the fraction part by dividing the\r\n          // result by its base raised to a power.\r\n\r\n          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n           10, baseOut, decimal);\r\n          y.e = y.c.length;\r\n        }\r\n\r\n        // Convert the number as integer.\r\n\r\n        xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n         ? (alphabet = ALPHABET, decimal)\r\n         : (alphabet = decimal, ALPHABET));\r\n\r\n        // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n        e = k = xc.length;\r\n\r\n        // Remove trailing zeros.\r\n        for (; xc[--k] == 0; xc.pop());\r\n\r\n        // Zero?\r\n        if (!xc[0]) return alphabet.charAt(0);\r\n\r\n        // Does str represent an integer? If so, no need for the division.\r\n        if (i < 0) {\r\n          --e;\r\n        } else {\r\n          x.c = xc;\r\n          x.e = e;\r\n\r\n          // The sign is needed for correct rounding.\r\n          x.s = sign;\r\n          x = div(x, y, dp, rm, baseOut);\r\n          xc = x.c;\r\n          r = x.r;\r\n          e = x.e;\r\n        }\r\n\r\n        // xc now represents str converted to baseOut.\r\n\r\n        // THe index of the rounding digit.\r\n        d = e + dp + 1;\r\n\r\n        // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n        i = xc[d];\r\n\r\n        // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n        k = baseOut / 2;\r\n        r = r || d < 0 || xc[d + 1] != null;\r\n\r\n        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n               rm == (x.s < 0 ? 8 : 7));\r\n\r\n        // If the index of the rounding digit is not greater than zero, or xc represents\r\n        // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n        // such as 0.00001.\r\n        if (d < 1 || !xc[0]) {\r\n\r\n          // 1^-dp or 0\r\n          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n        } else {\r\n\r\n          // Truncate xc to the required number of decimal places.\r\n          xc.length = d;\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            // Rounding up may mean the previous digit has to be rounded up and so on.\r\n            for (--baseOut; ++xc[--d] > baseOut;) {\r\n              xc[d] = 0;\r\n\r\n              if (!d) {\r\n                ++e;\r\n                xc = [1].concat(xc);\r\n              }\r\n            }\r\n          }\r\n\r\n          // Determine trailing zeros.\r\n          for (k = xc.length; !xc[--k];);\r\n\r\n          // E.g. [4, 11, 15] becomes 4bf.\r\n          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n          // Add leading zeros, decimal point and trailing zeros as required.\r\n          str = toFixedPoint(str, e, alphabet.charAt(0));\r\n        }\r\n\r\n        // The caller will add the sign.\r\n        return str;\r\n      };\r\n    })();\r\n\r\n\r\n    // Perform division in the specified base. Called by div and convertBase.\r\n    div = (function () {\r\n\r\n      // Assume non-zero x and k.\r\n      function multiply(x, k, base) {\r\n        var m, temp, xlo, xhi,\r\n          carry = 0,\r\n          i = x.length,\r\n          klo = k % SQRT_BASE,\r\n          khi = k / SQRT_BASE | 0;\r\n\r\n        for (x = x.slice(); i--;) {\r\n          xlo = x[i] % SQRT_BASE;\r\n          xhi = x[i] / SQRT_BASE | 0;\r\n          m = khi * xlo + xhi * klo;\r\n          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n          x[i] = temp % base;\r\n        }\r\n\r\n        if (carry) x = [carry].concat(x);\r\n\r\n        return x;\r\n      }\r\n\r\n      function compare(a, b, aL, bL) {\r\n        var i, cmp;\r\n\r\n        if (aL != bL) {\r\n          cmp = aL > bL ? 1 : -1;\r\n        } else {\r\n\r\n          for (i = cmp = 0; i < aL; i++) {\r\n\r\n            if (a[i] != b[i]) {\r\n              cmp = a[i] > b[i] ? 1 : -1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        return cmp;\r\n      }\r\n\r\n      function subtract(a, b, aL, base) {\r\n        var i = 0;\r\n\r\n        // Subtract b from a.\r\n        for (; aL--;) {\r\n          a[aL] -= i;\r\n          i = a[aL] < b[aL] ? 1 : 0;\r\n          a[aL] = i * base + a[aL] - b[aL];\r\n        }\r\n\r\n        // Remove leading zeros.\r\n        for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n      }\r\n\r\n      // x: dividend, y: divisor.\r\n      return function (x, y, dp, rm, base) {\r\n        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n          yL, yz,\r\n          s = x.s == y.s ? 1 : -1,\r\n          xc = x.c,\r\n          yc = y.c;\r\n\r\n        // Either NaN, Infinity or 0?\r\n        if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n          return new BigNumber(\r\n\r\n           // Return NaN if either NaN, or both Infinity or 0.\r\n           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.\r\n            xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n         );\r\n        }\r\n\r\n        q = new BigNumber(s);\r\n        qc = q.c = [];\r\n        e = x.e - y.e;\r\n        s = dp + e + 1;\r\n\r\n        if (!base) {\r\n          base = BASE;\r\n          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n          s = s / LOG_BASE | 0;\r\n        }\r\n\r\n        // Result exponent may be one less then the current value of e.\r\n        // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n        for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n        if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n        if (s < 0) {\r\n          qc.push(1);\r\n          more = true;\r\n        } else {\r\n          xL = xc.length;\r\n          yL = yc.length;\r\n          i = 0;\r\n          s += 2;\r\n\r\n          // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n          n = mathfloor(base / (yc[0] + 1));\r\n\r\n          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n          if (n > 1) {\r\n            yc = multiply(yc, n, base);\r\n            xc = multiply(xc, n, base);\r\n            yL = yc.length;\r\n            xL = xc.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xc.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL; rem[remL++] = 0);\r\n          yz = yc.slice();\r\n          yz = [0].concat(yz);\r\n          yc0 = yc[0];\r\n          if (yc[1] >= base / 2) yc0++;\r\n          // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n          do {\r\n            n = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yc, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, n.\r\n\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // n is how many times the divisor goes into the current remainder.\r\n              n = mathfloor(rem0 / yc0);\r\n\r\n              //  Algorithm:\r\n              //  product = divisor multiplied by trial digit (n).\r\n              //  Compare product and remainder.\r\n              //  If product is greater than remainder:\r\n              //    Subtract divisor from product, decrement trial digit.\r\n              //  Subtract product from remainder.\r\n              //  If product was less than remainder at the last compare:\r\n              //    Compare new remainder and divisor.\r\n              //    If remainder is greater than divisor:\r\n              //      Subtract divisor from remainder, increment trial digit.\r\n\r\n              if (n > 1) {\r\n\r\n                // n may be > base only when base is 3.\r\n                if (n >= base) n = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiply(yc, n, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                // If product > remainder then trial digit n too high.\r\n                // n is 1 too high about 5% of the time, and is not known to have\r\n                // ever been more than 1 too high.\r\n                while (compare(prod, rem, prodL, remL) == 1) {\r\n                  n--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                  prodL = prod.length;\r\n                  cmp = 1;\r\n                }\r\n              } else {\r\n\r\n                // n is 0 or 1, cmp is -1.\r\n                // If n is 0, there is no need to compare yc and rem again below,\r\n                // so change cmp to 1 to avoid it.\r\n                // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n                if (n == 0) {\r\n\r\n                  // divisor < remainder, so n must be at least 1.\r\n                  cmp = n = 1;\r\n                }\r\n\r\n                // product = divisor\r\n                prod = yc.slice();\r\n                prodL = prod.length;\r\n              }\r\n\r\n              if (prodL < remL) prod = [0].concat(prod);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n              remL = rem.length;\r\n\r\n               // If product was < remainder.\r\n              if (cmp == -1) {\r\n\r\n                // Compare divisor and new remainder.\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                // Trial digit n too low.\r\n                // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n                while (compare(yc, rem, yL, remL) < 1) {\r\n                  n++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                  remL = rem.length;\r\n                }\r\n              }\r\n            } else if (cmp === 0) {\r\n              n++;\r\n              rem = [0];\r\n            } // else cmp === 1 and n will be 0\r\n\r\n            // Add the next digit, n, to the result array.\r\n            qc[i++] = n;\r\n\r\n            // Update the remainder.\r\n            if (rem[0]) {\r\n              rem[remL++] = xc[xi] || 0;\r\n            } else {\r\n              rem = [xc[xi]];\r\n              remL = 1;\r\n            }\r\n          } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n          more = rem[0] != null;\r\n\r\n          // Leading zero?\r\n          if (!qc[0]) qc.splice(0, 1);\r\n        }\r\n\r\n        if (base == BASE) {\r\n\r\n          // To calculate q.e, first get the number of digits of qc[0].\r\n          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n        // Caller is convertBase.\r\n        } else {\r\n          q.e = e;\r\n          q.r = +more;\r\n        }\r\n\r\n        return q;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n     * notation rounded to the specified decimal places or significant digits.\r\n     *\r\n     * n: a BigNumber.\r\n     * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n     * rm: the rounding mode.\r\n     * id: 1 (toExponential) or 2 (toPrecision).\r\n     */\r\n    function format(n, i, rm, id) {\r\n      var c0, e, ne, len, str;\r\n\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      if (!n.c) return n.toString();\r\n\r\n      c0 = n.c[0];\r\n      ne = n.e;\r\n\r\n      if (i == null) {\r\n        str = coeffToString(n.c);\r\n        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n         ? toExponential(str, ne)\r\n         : toFixedPoint(str, ne, '0');\r\n      } else {\r\n        n = round(new BigNumber(n), i, rm);\r\n\r\n        // n.e may have changed if the value was rounded up.\r\n        e = n.e;\r\n\r\n        str = coeffToString(n.c);\r\n        len = str.length;\r\n\r\n        // toPrecision returns exponential notation if the number of significant digits\r\n        // specified is less than the number of digits necessary to represent the integer\r\n        // part of the value in fixed-point notation.\r\n\r\n        // Exponential notation.\r\n        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n          // Append zeros?\r\n          for (; len < i; str += '0', len++);\r\n          str = toExponential(str, e);\r\n\r\n        // Fixed-point notation.\r\n        } else {\r\n          i -= ne;\r\n          str = toFixedPoint(str, e, '0');\r\n\r\n          // Append zeros?\r\n          if (e + 1 > len) {\r\n            if (--i > 0) for (str += '.'; i--; str += '0');\r\n          } else {\r\n            i += e - len;\r\n            if (i > 0) {\r\n              if (e + 1 == len) str += '.';\r\n              for (; i--; str += '0');\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return n.s < 0 && c0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // Handle BigNumber.max and BigNumber.min.\r\n    function maxOrMin(args, method) {\r\n      var n,\r\n        i = 1,\r\n        m = new BigNumber(args[0]);\r\n\r\n      for (; i < args.length; i++) {\r\n        n = new BigNumber(args[i]);\r\n\r\n        // If any number is NaN, return NaN.\r\n        if (!n.s) {\r\n          m = n;\r\n          break;\r\n        } else if (method.call(m, n)) {\r\n          m = n;\r\n        }\r\n      }\r\n\r\n      return m;\r\n    }\r\n\r\n\r\n    /*\r\n     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n     * Called by minus, plus and times.\r\n     */\r\n    function normalise(n, c, e) {\r\n      var i = 1,\r\n        j = c.length;\r\n\r\n       // Remove trailing zeros.\r\n      for (; !c[--j]; c.pop());\r\n\r\n      // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n      for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n      // Overflow?\r\n      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        n.c = n.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        n.c = [n.e = 0];\r\n      } else {\r\n        n.e = e;\r\n        n.c = c;\r\n      }\r\n\r\n      return n;\r\n    }\r\n\r\n\r\n    // Handle values that fail the validity test in BigNumber.\r\n    parseNumeric = (function () {\r\n      var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n        dotAfter = /^([^.]+)\\.$/,\r\n        dotBefore = /^\\.([^.]+)$/,\r\n        isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n        whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n      return function (x, str, isNum, b) {\r\n        var base,\r\n          s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n        // No exception on ±Infinity or NaN.\r\n        if (isInfinityOrNaN.test(s)) {\r\n          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n        } else {\r\n          if (!isNum) {\r\n\r\n            // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n            s = s.replace(basePrefix, function (m, p1, p2) {\r\n              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n              return !b || b == base ? p1 : m;\r\n            });\r\n\r\n            if (b) {\r\n              base = b;\r\n\r\n              // E.g. '1.' to '1', '.1' to '0.1'\r\n              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n            }\r\n\r\n            if (str != s) return new BigNumber(s, base);\r\n          }\r\n\r\n          // '[BigNumber Error] Not a number: {n}'\r\n          // '[BigNumber Error] Not a base {b} number: {n}'\r\n          if (BigNumber.DEBUG) {\r\n            throw Error\r\n              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n          }\r\n\r\n          // NaN\r\n          x.s = null;\r\n        }\r\n\r\n        x.c = x.e = null;\r\n      }\r\n    })();\r\n\r\n\r\n    /*\r\n     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n     * If r is truthy, it is known that there are more digits after the rounding digit.\r\n     */\r\n    function round(x, sd, rm, r) {\r\n      var d, i, j, k, n, ni, rd,\r\n        xc = x.c,\r\n        pows10 = POWS_TEN;\r\n\r\n      // if x is not Infinity or NaN...\r\n      if (xc) {\r\n\r\n        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n        // ni is the index of n within x.c.\r\n        // d is the number of digits of n.\r\n        // i is the index of rd within n including leading zeros.\r\n        // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n        out: {\r\n\r\n          // Get the number of digits of the first element of xc.\r\n          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n          i = sd - d;\r\n\r\n          // If the rounding digit is in the first element of xc...\r\n          if (i < 0) {\r\n            i += LOG_BASE;\r\n            j = sd;\r\n            n = xc[ni = 0];\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = n / pows10[d - j - 1] % 10 | 0;\r\n          } else {\r\n            ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n            if (ni >= xc.length) {\r\n\r\n              if (r) {\r\n\r\n                // Needed by sqrt.\r\n                for (; xc.length <= ni; xc.push(0));\r\n                n = rd = 0;\r\n                d = 1;\r\n                i %= LOG_BASE;\r\n                j = i - LOG_BASE + 1;\r\n              } else {\r\n                break out;\r\n              }\r\n            } else {\r\n              n = k = xc[ni];\r\n\r\n              // Get the number of digits of n.\r\n              for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n              // Get the index of rd within n.\r\n              i %= LOG_BASE;\r\n\r\n              // Get the index of rd within n, adjusted for leading zeros.\r\n              // The number of leading zeros of n is given by LOG_BASE - d.\r\n              j = i - LOG_BASE + d;\r\n\r\n              // Get the rounding digit at index j of n.\r\n              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;\r\n            }\r\n          }\r\n\r\n          r = r || sd < 0 ||\r\n\r\n          // Are there any non-zero digits after the rounding digit?\r\n          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n          r = rm < 4\r\n           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n            // Check whether the digit to the left of the rounding digit is odd.\r\n            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n          if (sd < 1 || !xc[0]) {\r\n            xc.length = 0;\r\n\r\n            if (r) {\r\n\r\n              // Convert sd to decimal places.\r\n              sd -= x.e + 1;\r\n\r\n              // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n              x.e = -sd || 0;\r\n            } else {\r\n\r\n              // Zero.\r\n              xc[0] = x.e = 0;\r\n            }\r\n\r\n            return x;\r\n          }\r\n\r\n          // Remove excess digits.\r\n          if (i == 0) {\r\n            xc.length = ni;\r\n            k = 1;\r\n            ni--;\r\n          } else {\r\n            xc.length = ni + 1;\r\n            k = pows10[LOG_BASE - i];\r\n\r\n            // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n            // j > 0 means i > number of leading zeros of n.\r\n            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n          }\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            for (; ;) {\r\n\r\n              // If the digit to be rounded up is in the first element of xc...\r\n              if (ni == 0) {\r\n\r\n                // i will be the length of xc[0] before k is added.\r\n                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n                j = xc[0] += k;\r\n                for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n                // if i != k the length has increased.\r\n                if (i != k) {\r\n                  x.e++;\r\n                  if (xc[0] == BASE) xc[0] = 1;\r\n                }\r\n\r\n                break;\r\n              } else {\r\n                xc[ni] += k;\r\n                if (xc[ni] != BASE) break;\r\n                xc[ni--] = 0;\r\n                k = 1;\r\n              }\r\n            }\r\n          }\r\n\r\n          // Remove trailing zeros.\r\n          for (i = xc.length; xc[--i] === 0; xc.pop());\r\n        }\r\n\r\n        // Overflow? Infinity.\r\n        if (x.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n\r\n        // Underflow? Zero.\r\n        } else if (x.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        }\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n\r\n    function valueOf(n) {\r\n      var str,\r\n        e = n.e;\r\n\r\n      if (e === null) return n.toString();\r\n\r\n      str = coeffToString(n.c);\r\n\r\n      str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n        ? toExponential(str, e)\r\n        : toFixedPoint(str, e, '0');\r\n\r\n      return n.s < 0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n     */\r\n    P.absoluteValue = P.abs = function () {\r\n      var x = new BigNumber(this);\r\n      if (x.s < 0) x.s = 1;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return\r\n     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     *   0 if they have the same value,\r\n     *   or null if the value of either is NaN.\r\n     */\r\n    P.comparedTo = function (y, b) {\r\n      return compare(this, new BigNumber(y, b));\r\n    };\r\n\r\n\r\n    /*\r\n     * If dp is undefined or null or true or false, return the number of decimal places of the\r\n     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n     *\r\n     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.decimalPlaces = P.dp = function (dp, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), dp + x.e + 1, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last number.\r\n      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n      if (n < 0) n = 0;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n / 0 = I\r\n     *  n / N = N\r\n     *  n / I = 0\r\n     *  0 / n = 0\r\n     *  0 / 0 = N\r\n     *  0 / N = N\r\n     *  0 / I = 0\r\n     *  N / n = N\r\n     *  N / 0 = N\r\n     *  N / N = N\r\n     *  N / I = N\r\n     *  I / n = I\r\n     *  I / 0 = I\r\n     *  I / N = N\r\n     *  I / I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.dividedBy = P.div = function (y, b) {\r\n      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n     * BigNumber by the value of BigNumber(y, b).\r\n     */\r\n    P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n      return div(this, new BigNumber(y, b), 0, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n     *\r\n     * If m is present, return the result modulo m.\r\n     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n     *\r\n     * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n     *\r\n     * n {number|string|BigNumber} The exponent. An integer.\r\n     * [m] {number|string|BigNumber} The modulus.\r\n     *\r\n     * '[BigNumber Error] Exponent not an integer: {n}'\r\n     */\r\n    P.exponentiatedBy = P.pow = function (n, m) {\r\n      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n        x = this;\r\n\r\n      n = new BigNumber(n);\r\n\r\n      // Allow NaN and ±Infinity, but not other non-integers.\r\n      if (n.c && !n.isInteger()) {\r\n        throw Error\r\n          (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n      }\r\n\r\n      if (m != null) m = new BigNumber(m);\r\n\r\n      // Exponent of MAX_SAFE_INTEGER is 15.\r\n      nIsBig = n.e > 14;\r\n\r\n      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.\r\n      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n        // The sign of the result of pow when x is negative depends on the evenness of n.\r\n        // If +n overflows to ±Infinity, the evenness of n would be not be known.\r\n        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));\r\n        return m ? y.mod(m) : y;\r\n      }\r\n\r\n      nIsNeg = n.s < 0;\r\n\r\n      if (m) {\r\n\r\n        // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n        isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n        if (isModExp) x = x.mod(m);\r\n\r\n      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.\r\n      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n        // [1, 240000000]\r\n        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n        // [80000000000000]  [99999750000000]\r\n        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n        // If x is negative and n is odd, k = -0, else k = 0.\r\n        k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n        // If x >= 1, k = ±Infinity.\r\n        if (x.e > -1) k = 1 / k;\r\n\r\n        // If n is negative return ±0, else return ±Infinity.\r\n        return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n      } else if (POW_PRECISION) {\r\n\r\n        // Truncating each coefficient array to a length of k after each multiplication\r\n        // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n        // i.e. there will be a minimum of 28 guard digits retained.\r\n        k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n      }\r\n\r\n      if (nIsBig) {\r\n        half = new BigNumber(0.5);\r\n        if (nIsNeg) n.s = 1;\r\n        nIsOdd = isOdd(n);\r\n      } else {\r\n        i = Math.abs(+valueOf(n));\r\n        nIsOdd = i % 2;\r\n      }\r\n\r\n      y = new BigNumber(ONE);\r\n\r\n      // Performs 54 loop iterations for n of 9007199254740991.\r\n      for (; ;) {\r\n\r\n        if (nIsOdd) {\r\n          y = y.times(x);\r\n          if (!y.c) break;\r\n\r\n          if (k) {\r\n            if (y.c.length > k) y.c.length = k;\r\n          } else if (isModExp) {\r\n            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n          }\r\n        }\r\n\r\n        if (i) {\r\n          i = mathfloor(i / 2);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        } else {\r\n          n = n.times(half);\r\n          round(n, n.e + 1, 1);\r\n\r\n          if (n.e > 14) {\r\n            nIsOdd = isOdd(n);\r\n          } else {\r\n            i = +valueOf(n);\r\n            if (i === 0) break;\r\n            nIsOdd = i % 2;\r\n          }\r\n        }\r\n\r\n        x = x.times(x);\r\n\r\n        if (k) {\r\n          if (x.c && x.c.length > k) x.c.length = k;\r\n        } else if (isModExp) {\r\n          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (isModExp) return y;\r\n      if (nIsNeg) y = ONE.div(y);\r\n\r\n      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n     */\r\n    P.integerValue = function (rm) {\r\n      var n = new BigNumber(this);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n      return round(n, n.e + 1, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isEqualTo = P.eq = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n     */\r\n    P.isFinite = function () {\r\n      return !!this.c;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isGreaterThan = P.gt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n     */\r\n    P.isInteger = function () {\r\n      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isLessThan = P.lt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n     */\r\n    P.isNaN = function () {\r\n      return !this.s;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is negative, otherwise return false.\r\n     */\r\n    P.isNegative = function () {\r\n      return this.s < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is positive, otherwise return false.\r\n     */\r\n    P.isPositive = function () {\r\n      return this.s > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n     */\r\n    P.isZero = function () {\r\n      return !!this.c && this.c[0] == 0;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n - 0 = n\r\n     *  n - N = N\r\n     *  n - I = -I\r\n     *  0 - n = -n\r\n     *  0 - 0 = 0\r\n     *  0 - N = N\r\n     *  0 - I = -I\r\n     *  N - n = N\r\n     *  N - 0 = N\r\n     *  N - N = N\r\n     *  N - I = N\r\n     *  I - n = I\r\n     *  I - 0 = I\r\n     *  I - N = N\r\n     *  I - I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.minus = function (y, b) {\r\n      var i, j, t, xLTy,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n      if (a != b) {\r\n        y.s = -b;\r\n        return x.plus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Either Infinity?\r\n        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n        // Either zero?\r\n        if (!xc[0] || !yc[0]) {\r\n\r\n          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n           ROUNDING_MODE == 3 ? -0 : 0);\r\n        }\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Determine which is the bigger number.\r\n      if (a = xe - ye) {\r\n\r\n        if (xLTy = a < 0) {\r\n          a = -a;\r\n          t = xc;\r\n        } else {\r\n          ye = xe;\r\n          t = yc;\r\n        }\r\n\r\n        t.reverse();\r\n\r\n        // Prepend zeros to equalise exponents.\r\n        for (b = a; b--; t.push(0));\r\n        t.reverse();\r\n      } else {\r\n\r\n        // Exponents equal. Check digit by digit.\r\n        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n        for (a = b = 0; b < j; b++) {\r\n\r\n          if (xc[b] != yc[b]) {\r\n            xLTy = xc[b] < yc[b];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // x < y? Point xc to the array of the bigger number.\r\n      if (xLTy) {\r\n        t = xc;\r\n        xc = yc;\r\n        yc = t;\r\n        y.s = -y.s;\r\n      }  \r\n\r\n      b = (j = yc.length) - (i = xc.length);\r\n\r\n      // Append zeros to xc if shorter.\r\n      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n      if (b > 0) for (; b--; xc[i++] = 0);\r\n      b = BASE - 1;\r\n\r\n      // Subtract yc from xc.\r\n      for (; j > a;) {\r\n\r\n        if (xc[--j] < yc[j]) {\r\n          for (i = j; i && !xc[--i]; xc[i] = b);\r\n          --xc[i];\r\n          xc[j] += BASE;\r\n        }\r\n\r\n        xc[j] -= yc[j];\r\n      }\r\n\r\n      // Remove leading zeros and adjust exponent accordingly.\r\n      for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n      // Zero?\r\n      if (!xc[0]) {\r\n\r\n        // Following IEEE 754 (2008) 6.3,\r\n        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n        y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n        y.c = [y.e = 0];\r\n        return y;\r\n      }\r\n\r\n      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n      // for finite x and y.\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     *   n % 0 =  N\r\n     *   n % N =  N\r\n     *   n % I =  n\r\n     *   0 % n =  0\r\n     *  -0 % n = -0\r\n     *   0 % 0 =  N\r\n     *   0 % N =  N\r\n     *   0 % I =  0\r\n     *   N % n =  N\r\n     *   N % 0 =  N\r\n     *   N % N =  N\r\n     *   N % I =  N\r\n     *   I % n =  N\r\n     *   I % 0 =  N\r\n     *   I % N =  N\r\n     *   I % I =  N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n     * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n     */\r\n    P.modulo = P.mod = function (y, b) {\r\n      var q, s,\r\n        x = this;\r\n\r\n      y = new BigNumber(y, b);\r\n\r\n      // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n      if (!x.c || !y.s || y.c && !y.c[0]) {\r\n        return new BigNumber(NaN);\r\n\r\n      // Return x if y is Infinity or x is zero.\r\n      } else if (!y.c || x.c && !x.c[0]) {\r\n        return new BigNumber(x);\r\n      }\r\n\r\n      if (MODULO_MODE == 9) {\r\n\r\n        // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n        // r = x - qy    where  0 <= r < abs(y)\r\n        s = y.s;\r\n        y.s = 1;\r\n        q = div(x, y, 0, 3);\r\n        y.s = s;\r\n        q.s *= s;\r\n      } else {\r\n        q = div(x, y, 0, MODULO_MODE);\r\n      }\r\n\r\n      y = x.minus(q.times(y));\r\n\r\n      // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n      return y;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n * 0 = 0\r\n     *  n * N = N\r\n     *  n * I = I\r\n     *  0 * n = 0\r\n     *  0 * 0 = 0\r\n     *  0 * N = N\r\n     *  0 * I = N\r\n     *  N * n = N\r\n     *  N * 0 = N\r\n     *  N * N = N\r\n     *  N * I = N\r\n     *  I * n = I\r\n     *  I * 0 = N\r\n     *  I * N = N\r\n     *  I * I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n     * of BigNumber(y, b).\r\n     */\r\n    P.multipliedBy = P.times = function (y, b) {\r\n      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n        base, sqrtBase,\r\n        x = this,\r\n        xc = x.c,\r\n        yc = (y = new BigNumber(y, b)).c;\r\n\r\n      // Either NaN, ±Infinity or ±0?\r\n      if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n        // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n          y.c = y.e = y.s = null;\r\n        } else {\r\n          y.s *= x.s;\r\n\r\n          // Return ±Infinity if either is ±Infinity.\r\n          if (!xc || !yc) {\r\n            y.c = y.e = null;\r\n\r\n          // Return ±0 if either is ±0.\r\n          } else {\r\n            y.c = [0];\r\n            y.e = 0;\r\n          }\r\n        }\r\n\r\n        return y;\r\n      }\r\n\r\n      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n      y.s *= x.s;\r\n      xcL = xc.length;\r\n      ycL = yc.length;\r\n\r\n      // Ensure xc points to longer array and xcL to its length.\r\n      if (xcL < ycL) {\r\n        zc = xc;\r\n        xc = yc;\r\n        yc = zc;\r\n        i = xcL;\r\n        xcL = ycL;\r\n        ycL = i;\r\n      }  \r\n\r\n      // Initialise the result array with zeros.\r\n      for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n      base = BASE;\r\n      sqrtBase = SQRT_BASE;\r\n\r\n      for (i = ycL; --i >= 0;) {\r\n        c = 0;\r\n        ylo = yc[i] % sqrtBase;\r\n        yhi = yc[i] / sqrtBase | 0;\r\n\r\n        for (k = xcL, j = i + k; j > i;) {\r\n          xlo = xc[--k] % sqrtBase;\r\n          xhi = xc[k] / sqrtBase | 0;\r\n          m = yhi * xlo + xhi * ylo;\r\n          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n          zc[j--] = xlo % base;\r\n        }\r\n\r\n        zc[j] = c;\r\n      }\r\n\r\n      if (c) {\r\n        ++e;\r\n      } else {\r\n        zc.splice(0, 1);\r\n      }\r\n\r\n      return normalise(y, zc, e);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n     * i.e. multiplied by -1.\r\n     */\r\n    P.negated = function () {\r\n      var x = new BigNumber(this);\r\n      x.s = -x.s || null;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n + 0 = n\r\n     *  n + N = N\r\n     *  n + I = I\r\n     *  0 + n = n\r\n     *  0 + 0 = 0\r\n     *  0 + N = N\r\n     *  0 + I = I\r\n     *  N + n = N\r\n     *  N + 0 = N\r\n     *  N + N = N\r\n     *  N + I = N\r\n     *  I + n = I\r\n     *  I + 0 = I\r\n     *  I + N = N\r\n     *  I + I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.plus = function (y, b) {\r\n      var t,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n       if (a != b) {\r\n        y.s = -b;\r\n        return x.minus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Return ±Infinity if either ±Infinity.\r\n        if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n        // Either zero?\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n      if (a = xe - ye) {\r\n        if (a > 0) {\r\n          ye = xe;\r\n          t = yc;\r\n        } else {\r\n          a = -a;\r\n          t = xc;\r\n        }\r\n\r\n        t.reverse();\r\n        for (; a--; t.push(0));\r\n        t.reverse();\r\n      }\r\n\r\n      a = xc.length;\r\n      b = yc.length;\r\n\r\n      // Point xc to the longer array, and b to the shorter length.\r\n      if (a - b < 0) {\r\n        t = yc;\r\n        yc = xc;\r\n        xc = t;\r\n        b = a;\r\n      }  \r\n\r\n      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n      for (a = 0; b;) {\r\n        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n      }\r\n\r\n      if (a) {\r\n        xc = [a].concat(xc);\r\n        ++ye;\r\n      }\r\n\r\n      // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n      // ye = MAX_EXP + 1 possible\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     * If sd is undefined or null or true or false, return the number of significant digits of\r\n     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n     * If sd is true include integer-part trailing zeros in the count.\r\n     *\r\n     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n     *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.precision = P.sd = function (sd, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (sd != null && sd !== !!sd) {\r\n        intCheck(sd, 1, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), sd, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      v = c.length - 1;\r\n      n = v * LOG_BASE + 1;\r\n\r\n      if (v = c[v]) {\r\n\r\n        // Subtract the number of trailing zeros of the last element.\r\n        for (; v % 10 == 0; v /= 10, n--);\r\n\r\n        // Add the number of digits of the first element.\r\n        for (v = c[0]; v >= 10; v /= 10, n++);\r\n      }\r\n\r\n      if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n     *\r\n     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n     */\r\n    P.shiftedBy = function (k) {\r\n      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n      return this.times('1e' + k);\r\n    };\r\n\r\n\r\n    /*\r\n     *  sqrt(-n) =  N\r\n     *  sqrt(N) =  N\r\n     *  sqrt(-I) =  N\r\n     *  sqrt(I) =  I\r\n     *  sqrt(0) =  0\r\n     *  sqrt(-0) = -0\r\n     *\r\n     * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.squareRoot = P.sqrt = function () {\r\n      var m, n, r, rep, t,\r\n        x = this,\r\n        c = x.c,\r\n        s = x.s,\r\n        e = x.e,\r\n        dp = DECIMAL_PLACES + 4,\r\n        half = new BigNumber('0.5');\r\n\r\n      // Negative/NaN/Infinity/zero?\r\n      if (s !== 1 || !c || !c[0]) {\r\n        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n      }\r\n\r\n      // Initial estimate.\r\n      s = Math.sqrt(+valueOf(x));\r\n\r\n      // Math.sqrt underflow/overflow?\r\n      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n      if (s == 0 || s == 1 / 0) {\r\n        n = coeffToString(c);\r\n        if ((n.length + e) % 2 == 0) n += '0';\r\n        s = Math.sqrt(+n);\r\n        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n        if (s == 1 / 0) {\r\n          n = '5e' + e;\r\n        } else {\r\n          n = s.toExponential();\r\n          n = n.slice(0, n.indexOf('e') + 1) + e;\r\n        }\r\n\r\n        r = new BigNumber(n);\r\n      } else {\r\n        r = new BigNumber(s + '');\r\n      }\r\n\r\n      // Check for zero.\r\n      // r could be zero if MIN_EXP is changed after the this value was created.\r\n      // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n      // coeffToString to throw.\r\n      if (r.c[0]) {\r\n        e = r.e;\r\n        s = e + dp;\r\n        if (s < 3) s = 0;\r\n\r\n        // Newton-Raphson iteration.\r\n        for (; ;) {\r\n          t = r;\r\n          r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n            // The exponent of r may here be one less than the final result exponent,\r\n            // e.g 0.0009999 (e-4) --\x3e 0.001 (e-3), so adjust s so the rounding digits\r\n            // are indexed correctly.\r\n            if (r.e < e) --s;\r\n            n = n.slice(s - 3, s + 1);\r\n\r\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n            // iteration.\r\n            if (n == '9999' || !rep && n == '4999') {\r\n\r\n              // On the first iteration only, check to see if rounding up gives the\r\n              // exact result as the nines may infinitely repeat.\r\n              if (!rep) {\r\n                round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n                if (t.times(t).eq(x)) {\r\n                  r = t;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              dp += 4;\r\n              s += 4;\r\n              rep = 1;\r\n            } else {\r\n\r\n              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n              // result. If not, then there are further digits and m will be truthy.\r\n              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n                // Truncate to the first rounding digit.\r\n                round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n                m = !r.times(r).eq(x);\r\n              }\r\n\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in exponential notation and\r\n     * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toExponential = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp++;\r\n      }\r\n      return format(this, dp, rm, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n     * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toFixed = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp = dp + this.e + 1;\r\n      }\r\n      return format(this, dp, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n     * of the format or FORMAT object (see BigNumber.set).\r\n     *\r\n     * The formatting object may contain some or all of the properties shown below.\r\n     *\r\n     * FORMAT = {\r\n     *   prefix: '',\r\n     *   groupSize: 3,\r\n     *   secondaryGroupSize: 0,\r\n     *   groupSeparator: ',',\r\n     *   decimalSeparator: '.',\r\n     *   fractionGroupSize: 0,\r\n     *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n     *   suffix: ''\r\n     * };\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     * [format] {object} Formatting options. See FORMAT pbject above.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     * '[BigNumber Error] Argument not an object: {format}'\r\n     */\r\n    P.toFormat = function (dp, rm, format) {\r\n      var str,\r\n        x = this;\r\n\r\n      if (format == null) {\r\n        if (dp != null && rm && typeof rm == 'object') {\r\n          format = rm;\r\n          rm = null;\r\n        } else if (dp && typeof dp == 'object') {\r\n          format = dp;\r\n          dp = rm = null;\r\n        } else {\r\n          format = FORMAT;\r\n        }\r\n      } else if (typeof format != 'object') {\r\n        throw Error\r\n          (bignumberError + 'Argument not an object: ' + format);\r\n      }\r\n\r\n      str = x.toFixed(dp, rm);\r\n\r\n      if (x.c) {\r\n        var i,\r\n          arr = str.split('.'),\r\n          g1 = +format.groupSize,\r\n          g2 = +format.secondaryGroupSize,\r\n          groupSeparator = format.groupSeparator || '',\r\n          intPart = arr[0],\r\n          fractionPart = arr[1],\r\n          isNeg = x.s < 0,\r\n          intDigits = isNeg ? intPart.slice(1) : intPart,\r\n          len = intDigits.length;\r\n\r\n        if (g2) {\r\n          i = g1;\r\n          g1 = g2;\r\n          g2 = i;\r\n          len -= i;\r\n        }  \r\n\r\n        if (g1 > 0 && len > 0) {\r\n          i = len % g1 || g1;\r\n          intPart = intDigits.substr(0, i);\r\n          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n          if (isNeg) intPart = '-' + intPart;\r\n        }\r\n\r\n        str = fractionPart\r\n         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n          ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n           '$&' + (format.fractionGroupSeparator || ''))\r\n          : fractionPart)\r\n         : intPart;\r\n      }\r\n\r\n      return (format.prefix || '') + str + (format.suffix || '');\r\n    };\r\n\r\n\r\n    /*\r\n     * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n     * fraction with an integer numerator and an integer denominator.\r\n     * The denominator will be a positive non-zero value less than or equal to the specified\r\n     * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n     * the lowest value necessary to represent the number exactly.\r\n     *\r\n     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n     *\r\n     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n     */\r\n    P.toFraction = function (md) {\r\n      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n        x = this,\r\n        xc = x.c;\r\n\r\n      if (md != null) {\r\n        n = new BigNumber(md);\r\n\r\n        // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n          throw Error\r\n            (bignumberError + 'Argument ' +\r\n              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n        }\r\n      }\r\n\r\n      if (!xc) return new BigNumber(x);\r\n\r\n      d = new BigNumber(ONE);\r\n      n1 = d0 = new BigNumber(ONE);\r\n      d1 = n0 = new BigNumber(ONE);\r\n      s = coeffToString(xc);\r\n\r\n      // Determine initial denominator.\r\n      // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n      e = d.e = s.length - x.e - 1;\r\n      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n      exp = MAX_EXP;\r\n      MAX_EXP = 1 / 0;\r\n      n = new BigNumber(s);\r\n\r\n      // n0 = d1 = 0\r\n      n0.c[0] = 0;\r\n\r\n      for (; ;)  {\r\n        q = div(n, d, 0, 1);\r\n        d2 = d0.plus(q.times(d1));\r\n        if (d2.comparedTo(md) == 1) break;\r\n        d0 = d1;\r\n        d1 = d2;\r\n        n1 = n0.plus(q.times(d2 = n1));\r\n        n0 = d2;\r\n        d = n.minus(q.times(d2 = d));\r\n        n = d2;\r\n      }\r\n\r\n      d2 = div(md.minus(d0), d1, 0, 1);\r\n      n0 = n0.plus(d2.times(n1));\r\n      d0 = d0.plus(d2.times(d1));\r\n      n0.s = n1.s = x.s;\r\n      e = e * 2;\r\n\r\n      // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n      MAX_EXP = exp;\r\n\r\n      return r;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return the value of this BigNumber converted to a number primitive.\r\n     */\r\n    P.toNumber = function () {\r\n      return +valueOf(this);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n     * necessary to represent the integer part of the value in fixed-point notation, then use\r\n     * exponential notation.\r\n     *\r\n     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.toPrecision = function (sd, rm) {\r\n      if (sd != null) intCheck(sd, 1, MAX);\r\n      return format(this, sd, rm, 2);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n     * TO_EXP_NEG, return exponential notation.\r\n     *\r\n     * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n     *\r\n     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n     */\r\n    P.toString = function (b) {\r\n      var str,\r\n        n = this,\r\n        s = n.s,\r\n        e = n.e;\r\n\r\n      // Infinity or NaN?\r\n      if (e === null) {\r\n        if (s) {\r\n          str = 'Infinity';\r\n          if (s < 0) str = '-' + str;\r\n        } else {\r\n          str = 'NaN';\r\n        }\r\n      } else {\r\n        if (b == null) {\r\n          str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n           ? toExponential(coeffToString(n.c), e)\r\n           : toFixedPoint(coeffToString(n.c), e, '0');\r\n        } else if (b === 10 && alphabetHasNormalDecimalDigits) {\r\n          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n          str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n        } else {\r\n          intCheck(b, 2, ALPHABET.length, 'Base');\r\n          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n        }\r\n\r\n        if (s < 0 && n.c[0]) str = '-' + str;\r\n      }\r\n\r\n      return str;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return as toString, but do not accept a base argument, and include the minus sign for\r\n     * negative zero.\r\n     */\r\n    P.valueOf = P.toJSON = function () {\r\n      return valueOf(this);\r\n    };\r\n\r\n\r\n    P._isBigNumber = true;\r\n\r\n    if (configObject != null) BigNumber.set(configObject);\r\n\r\n    return BigNumber;\r\n  }\r\n\r\n\r\n  // PRIVATE HELPER FUNCTIONS\r\n\r\n  // These functions don't need access to variables,\r\n  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\n  function bitFloor(n) {\r\n    var i = n | 0;\r\n    return n > 0 || n === i ? i : i - 1;\r\n  }\r\n\r\n\r\n  // Return a coefficient array as a string of base 10 digits.\r\n  function coeffToString(a) {\r\n    var s, z,\r\n      i = 1,\r\n      j = a.length,\r\n      r = a[0] + '';\r\n\r\n    for (; i < j;) {\r\n      s = a[i++] + '';\r\n      z = LOG_BASE - s.length;\r\n      for (; z--; s = '0' + s);\r\n      r += s;\r\n    }\r\n\r\n    // Determine trailing zeros.\r\n    for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n    return r.slice(0, j + 1 || 1);\r\n  }\r\n\r\n\r\n  // Compare the value of BigNumbers x and y.\r\n  function compare(x, y) {\r\n    var a, b,\r\n      xc = x.c,\r\n      yc = y.c,\r\n      i = x.s,\r\n      j = y.s,\r\n      k = x.e,\r\n      l = y.e;\r\n\r\n    // Either NaN?\r\n    if (!i || !j) return null;\r\n\r\n    a = xc && !xc[0];\r\n    b = yc && !yc[0];\r\n\r\n    // Either zero?\r\n    if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n    // Signs differ?\r\n    if (i != j) return i;\r\n\r\n    a = i < 0;\r\n    b = k == l;\r\n\r\n    // Either Infinity?\r\n    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n    // Compare exponents.\r\n    if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n    j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n    // Compare lengths.\r\n    return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n   */\r\n  function intCheck(n, min, max, name) {\r\n    if (n < min || n > max || n !== mathfloor(n)) {\r\n      throw Error\r\n       (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n         ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n         : ' not a primitive number: ') + String(n));\r\n    }\r\n  }\r\n\r\n\r\n  // Assumes finite n.\r\n  function isOdd(n) {\r\n    var k = n.c.length - 1;\r\n    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n  }\r\n\r\n\r\n  function toExponential(str, e) {\r\n    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n     (e < 0 ? 'e' : 'e+') + e;\r\n  }\r\n\r\n\r\n  function toFixedPoint(str, e, z) {\r\n    var len, zs;\r\n\r\n    // Negative exponent?\r\n    if (e < 0) {\r\n\r\n      // Prepend zeros.\r\n      for (zs = z + '.'; ++e; zs += z);\r\n      str = zs + str;\r\n\r\n    // Positive exponent\r\n    } else {\r\n      len = str.length;\r\n\r\n      // Append zeros.\r\n      if (++e > len) {\r\n        for (zs = z, e -= len; --e; zs += z);\r\n        str += zs;\r\n      } else if (e < len) {\r\n        str = str.slice(0, e) + '.' + str.slice(e);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // EXPORT\r\n\r\n\r\n  BigNumber = clone();\r\n  BigNumber['default'] = BigNumber.BigNumber = BigNumber;\r\n\r\n  // AMD.\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n  // Node.js and other environments that support module.exports.\r\n  } else {}\r\n})(this);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanM/Y2NlZCJdLCJzb3VyY2VzQ29udGVudCI6WyI7KGZ1bmN0aW9uIChnbG9iYWxPYmplY3QpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4vKlxyXG4gKiAgICAgIGJpZ251bWJlci5qcyB2OS4xLjBcclxuICogICAgICBBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBhcml0aG1ldGljLlxyXG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qc1xyXG4gKiAgICAgIENvcHlyaWdodCAoYykgMjAyMiBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gKiAgICAgIE1JVCBMaWNlbnNlZC5cclxuICpcclxuICogICAgICBCaWdOdW1iZXIucHJvdG90eXBlIG1ldGhvZHMgICAgIHwgIEJpZ051bWJlciBtZXRob2RzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgYWJzb2x1dGVWYWx1ZSAgICAgICAgICAgIGFicyAgICB8ICBjbG9uZVxyXG4gKiAgICAgIGNvbXBhcmVkVG8gICAgICAgICAgICAgICAgICAgICAgfCAgY29uZmlnICAgICAgICAgICAgICAgc2V0XHJcbiAqICAgICAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgIGRwICAgICB8ICAgICAgREVDSU1BTF9QTEFDRVNcclxuICogICAgICBkaXZpZGVkQnkgICAgICAgICAgICAgICAgZGl2ICAgIHwgICAgICBST1VORElOR19NT0RFXHJcbiAqICAgICAgZGl2aWRlZFRvSW50ZWdlckJ5ICAgICAgIGlkaXYgICB8ICAgICAgRVhQT05FTlRJQUxfQVRcclxuICogICAgICBleHBvbmVudGlhdGVkQnkgICAgICAgICAgcG93ICAgIHwgICAgICBSQU5HRVxyXG4gKiAgICAgIGludGVnZXJWYWx1ZSAgICAgICAgICAgICAgICAgICAgfCAgICAgIENSWVBUT1xyXG4gKiAgICAgIGlzRXF1YWxUbyAgICAgICAgICAgICAgICBlcSAgICAgfCAgICAgIE1PRFVMT19NT0RFXHJcbiAqICAgICAgaXNGaW5pdGUgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgUE9XX1BSRUNJU0lPTlxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW4gICAgICAgICAgICBndCAgICAgfCAgICAgIEZPUk1BVFxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW5PckVxdWFsVG8gICBndGUgICAgfCAgICAgIEFMUEhBQkVUXHJcbiAqICAgICAgaXNJbnRlZ2VyICAgICAgICAgICAgICAgICAgICAgICB8ICBpc0JpZ051bWJlclxyXG4gKiAgICAgIGlzTGVzc1RoYW4gICAgICAgICAgICAgICBsdCAgICAgfCAgbWF4aW11bSAgICAgICAgICAgICAgbWF4XHJcbiAqICAgICAgaXNMZXNzVGhhbk9yRXF1YWxUbyAgICAgIGx0ZSAgICB8ICBtaW5pbXVtICAgICAgICAgICAgICBtaW5cclxuICogICAgICBpc05hTiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJhbmRvbVxyXG4gKiAgICAgIGlzTmVnYXRpdmUgICAgICAgICAgICAgICAgICAgICAgfCAgc3VtXHJcbiAqICAgICAgaXNQb3NpdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgaXNaZXJvICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbWludXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbW9kdWxvICAgICAgICAgICAgICAgICAgIG1vZCAgICB8XHJcbiAqICAgICAgbXVsdGlwbGllZEJ5ICAgICAgICAgICAgIHRpbWVzICB8XHJcbiAqICAgICAgbmVnYXRlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcGx1cyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcHJlY2lzaW9uICAgICAgICAgICAgICAgIHNkICAgICB8XHJcbiAqICAgICAgc2hpZnRlZEJ5ICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgc3F1YXJlUm9vdCAgICAgICAgICAgICAgIHNxcnQgICB8XHJcbiAqICAgICAgdG9FeHBvbmVudGlhbCAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GaXhlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9Gb3JtYXQgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GcmFjdGlvbiAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9KU09OICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9OdW1iZXIgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9QcmVjaXNpb24gICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9TdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdmFsdWVPZiAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcbiAgdmFyIEJpZ051bWJlcixcclxuICAgIGlzTnVtZXJpYyA9IC9eLT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86ZVsrLV0/XFxkKyk/JC9pLFxyXG4gICAgbWF0aGNlaWwgPSBNYXRoLmNlaWwsXHJcbiAgICBtYXRoZmxvb3IgPSBNYXRoLmZsb29yLFxyXG5cclxuICAgIGJpZ251bWJlckVycm9yID0gJ1tCaWdOdW1iZXIgRXJyb3JdICcsXHJcbiAgICB0b29NYW55RGlnaXRzID0gYmlnbnVtYmVyRXJyb3IgKyAnTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czogJyxcclxuXHJcbiAgICBCQVNFID0gMWUxNCxcclxuICAgIExPR19CQVNFID0gMTQsXHJcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZiwgICAgICAgICAvLyAyXjUzIC0gMVxyXG4gICAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcclxuICAgIFBPV1NfVEVOID0gWzEsIDEwLCAxMDAsIDFlMywgMWU0LCAxZTUsIDFlNiwgMWU3LCAxZTgsIDFlOSwgMWUxMCwgMWUxMSwgMWUxMiwgMWUxM10sXHJcbiAgICBTUVJUX0JBU0UgPSAxZTcsXHJcblxyXG4gICAgLy8gRURJVEFCTEVcclxuICAgIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgREVDSU1BTF9QTEFDRVMsIFRPX0VYUF9ORUcsIFRPX0VYUF9QT1MsIE1JTl9FWFAsIE1BWF9FWFAsIGFuZFxyXG4gICAgLy8gdGhlIGFyZ3VtZW50cyB0byB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCwgYW5kIHRvUHJlY2lzaW9uLlxyXG4gICAgTUFYID0gMUU5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhfSU5UMzJcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2xvbmUoY29uZmlnT2JqZWN0KSB7XHJcbiAgICB2YXIgZGl2LCBjb252ZXJ0QmFzZSwgcGFyc2VOdW1lcmljLFxyXG4gICAgICBQID0gQmlnTnVtYmVyLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IEJpZ051bWJlciwgdG9TdHJpbmc6IG51bGwsIHZhbHVlT2Y6IG51bGwgfSxcclxuICAgICAgT05FID0gbmV3IEJpZ051bWJlcigxKSxcclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVESVRBQkxFIENPTkZJRyBERUZBVUxUUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2VzIHN0YXRlZC5cclxuICAgICAgLy8gVGhlIHZhbHVlcyBjYW4gYWxzbyBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIEJpZ051bWJlci5zZXQuXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxyXG4gICAgICBERUNJTUFMX1BMQUNFUyA9IDIwLCAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLCBhbmQgd2hlbiB1c2luZ1xyXG4gICAgICAvLyB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXHJcbiAgICAgIC8vIFVQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgICAgLy8gRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgICAgLy8gQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBGTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAgIC8vIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgICAgLy8gSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgICAvLyBIQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICBST1VORElOR19NT0RFID0gNCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC03XHJcbiAgICAgIFRPX0VYUF9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAyMVxyXG4gICAgICBUT19FWFBfUE9TID0gMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxyXG5cclxuICAgICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcclxuICAgICAgTUlOX0VYUCA9IC0xZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogIDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXHJcbiAgICAgIE1BWF9FWFAgPSAxZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcclxuXHJcbiAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cclxuICAgICAgQ1JZUFRPID0gZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIG9yIGZhbHNlXHJcblxyXG4gICAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cclxuICAgICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVVAgICAgICAgIDAgVGhlIHJlbWFpbmRlciBpcyBwb3NpdGl2ZSBpZiB0aGUgZGl2aWRlbmQgaXMgbmVnYXRpdmUsIGVsc2UgaXMgbmVnYXRpdmUuXHJcbiAgICAgIC8vIERPV04gICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGlzIG1vZHVsbyBtb2RlIGlzIGNvbW1vbmx5IGtub3duIGFzICd0cnVuY2F0ZWQgZGl2aXNpb24nIGFuZCBpc1xyXG4gICAgICAvLyAgICAgICAgICAgICBlcXVpdmFsZW50IHRvIChhICUgbikgaW4gSmF2YVNjcmlwdC5cclxuICAgICAgLy8gRkxPT1IgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gNiBUaGlzIG1vZHVsbyBtb2RlIGltcGxlbWVudHMgdGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgICAgLy8gRVVDTElEICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGUgcmVtYWluZGVyIGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVGhlIHRydW5jYXRlZCBkaXZpc2lvbiwgZmxvb3JlZCBkaXZpc2lvbiwgRXVjbGlkaWFuIGRpdmlzaW9uIGFuZCBJRUVFIDc1NCByZW1haW5kZXJcclxuICAgICAgLy8gbW9kZXMgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi5cclxuICAgICAgLy8gQWx0aG91Z2ggdGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvIGJlIHVzZWQsIHRoZXkgbWF5IG5vdCBnaXZlIHVzZWZ1bCByZXN1bHRzLlxyXG4gICAgICBNT0RVTE9fTU9ERSA9IDEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSBleHBvbmVudGlhdGVkQnkgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBJZiBQT1dfUFJFQ0lTSU9OIGlzIDAsIHRoZXJlIHdpbGwgYmUgdW5saW1pdGVkIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAgUE9XX1BSRUNJU0lPTiA9IDAsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxyXG4gICAgICBGT1JNQVQgPSB7XHJcbiAgICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgICBncm91cFNpemU6IDMsXHJcbiAgICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgICBzdWZmaXg6ICcnXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBUaGUgYWxwaGFiZXQgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLiBJdCBtdXN0IGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBsb25nLCB3aXRoIG5vICcrJyxcclxuICAgICAgLy8gJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgLy8gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8nXHJcbiAgICAgIEFMUEhBQkVUID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXHJcbiAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHRydWU7XHJcblxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgQmlnTnVtYmVyIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiB2IHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gQSBudW1lcmljIHZhbHVlLlxyXG4gICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIHYuIEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQmlnTnVtYmVyKHYsIGIpIHtcclxuICAgICAgdmFyIGFscGhhYmV0LCBjLCBjYXNlQ2hhbmdlZCwgZSwgaSwgaXNOdW0sIGxlbiwgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBgbmV3YC5cclxuICAgICAgaWYgKCEoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikpIHJldHVybiBuZXcgQmlnTnVtYmVyKHYsIGIpO1xyXG5cclxuICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodiAmJiB2Ll9pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgeC5zID0gdi5zO1xyXG5cclxuICAgICAgICAgIGlmICghdi5jIHx8IHYuZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodi5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgICAgIHguYyA9IHYuYy5zbGljZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykgJiYgdiAqIDAgPT0gMCkge1xyXG5cclxuICAgICAgICAgIC8vIFVzZSBgMSAvIG5gIHRvIGhhbmRsZSBtaW51cyB6ZXJvIGFsc28uXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAodiA9IC12LCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgaW50ZWdlcnMsIHdoZXJlIG4gPCAyMTQ3NDgzNjQ4ICgyKiozMSkuXHJcbiAgICAgICAgICBpZiAodiA9PT0gfn52KSB7XHJcbiAgICAgICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwLCBlKyspO1xyXG5cclxuICAgICAgICAgICAgaWYgKGUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICAgIHguYyA9IFt2XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGlmICghaXNOdW1lcmljLnRlc3Qoc3RyID0gU3RyaW5nKHYpKSkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICAgICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcblxyXG4gICAgICAgIC8vIEFsbG93IGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGJlIHVzZWQgd2l0aCBiYXNlIDEwIGFyZ3VtZW50LCB3aGlsZVxyXG4gICAgICAgIC8vIGFsc28gcm91bmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgICBpZiAoYiA9PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKHYpO1xyXG4gICAgICAgICAgcmV0dXJuIHJvdW5kKHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcblxyXG4gICAgICAgIGlmIChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXZvaWQgcG90ZW50aWFsIGludGVycHJldGF0aW9uIG9mIEluZmluaXR5IGFuZCBOYU4gYXMgYmFzZSA0NCsgdmFsdWVzLlxyXG4gICAgICAgICAgaWYgKHYgKiAwICE9IDApIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSwgYik7XHJcblxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRyAmJiBzdHIucmVwbGFjZSgvXjBcXC4wKnxcXC4vLCAnJykubGVuZ3RoID4gMTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhbHBoYWJldCA9IEFMUEhBQkVULnNsaWNlKDAsIGIpO1xyXG4gICAgICAgIGUgPSBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBzdHIgaXMgYSB2YWxpZCBiYXNlIGIgbnVtYmVyLlxyXG4gICAgICAgIC8vIERvbid0IHVzZSBSZWdFeHAsIHNvIGFscGhhYmV0IGNhbiBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoYyA9IHN0ci5jaGFyQXQoaSkpIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgJy4nIGlzIG5vdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpdCBoYXMgbm90IGJlIGZvdW5kIGJlZm9yZS5cclxuICAgICAgICAgICAgICBpZiAoaSA+IGUpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBsZW47XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNhc2VDaGFuZ2VkKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEFsbG93IGUuZy4gaGV4YWRlY2ltYWwgJ0ZGJyBhcyB3ZWxsIGFzICdmZicuXHJcbiAgICAgICAgICAgICAgaWYgKHN0ciA9PSBzdHIudG9VcHBlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgICAgICAgIHN0ciA9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBTdHJpbmcodiksIGlzTnVtLCBiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxyXG4gICAgICAgIGlzTnVtID0gZmFsc2U7XHJcbiAgICAgICAgc3RyID0gY29udmVydEJhc2Uoc3RyLCBiLCAxMCwgeC5zKTtcclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICBlbHNlIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KC0tbGVuKSA9PT0gNDg7KTtcclxuXHJcbiAgICAgIGlmIChzdHIgPSBzdHIuc2xpY2UoaSwgKytsZW4pKSB7XHJcbiAgICAgICAgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgaWYgKGlzTnVtICYmIEJpZ051bWJlci5ERUJVRyAmJlxyXG4gICAgICAgICAgbGVuID4gMTUgJiYgKHYgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHYgIT09IG1hdGhmbG9vcih2KSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgKHgucyAqIHYpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgICBpZiAoKGUgPSBlIC0gaSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcclxuXHJcbiAgICAgICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxyXG4gICAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoZSA8IDApIGkgKz0gTE9HX0JBU0U7ICAvLyBpIDwgMVxyXG5cclxuICAgICAgICAgIGlmIChpIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChpKSB4LmMucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgICAgIHguYy5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpID0gTE9HX0JBU0UgLSAoc3RyID0gc3RyLnNsaWNlKGkpKS5sZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpIC09IGxlbjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIHguYy5wdXNoKCtzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1IgUFJPUEVSVElFU1xyXG5cclxuXHJcbiAgICBCaWdOdW1iZXIuY2xvbmUgPSBjbG9uZTtcclxuXHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfVVAgPSAwO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0NFSUwgPSAyO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0ZMT09SID0gMztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0RPV04gPSA1O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0ZMT09SID0gODtcclxuICAgIEJpZ051bWJlci5FVUNMSUQgPSA5O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogQ29uZmlndXJlIGluZnJlcXVlbnRseS1jaGFuZ2luZyBsaWJyYXJ5LXdpZGUgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQWNjZXB0IGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgcHJvcGVydGllcyAoaWYgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaXNcclxuICAgICAqIGEgbnVtYmVyLCBpdCBtdXN0IGJlIGFuIGludGVnZXIgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2Ugc3RhdGVkKTpcclxuICAgICAqXHJcbiAgICAgKiAgIERFQ0lNQUxfUExBQ0VTICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIFJPVU5ESU5HX01PREUgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOFxyXG4gICAgICogICBFWFBPTkVOVElBTF9BVCAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAgb3IgIFstTUFYIHRvIDAsIDAgdG8gTUFYXVxyXG4gICAgICogICBSQU5HRSAgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAobm90IHplcm8pICBvciAgWy1NQVggdG8gLTEsIDEgdG8gTUFYXVxyXG4gICAgICogICBDUllQVE8gICAgICAgICAgIHtib29sZWFufSAgICAgICAgICB0cnVlIG9yIGZhbHNlXHJcbiAgICAgKiAgIE1PRFVMT19NT0RFICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOVxyXG4gICAgICogICBQT1dfUFJFQ0lTSU9OICAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBBTFBIQUJFVCAgICAgICAgIHtzdHJpbmd9ICAgICAgICAgICBBIHN0cmluZyBvZiB0d28gb3IgbW9yZSB1bmlxdWUgY2hhcmFjdGVycyB3aGljaCBkb2VzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBjb250YWluICcuJy5cclxuICAgICAqICAgRk9STUFUICAgICAgICAgICB7b2JqZWN0fSAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggc29tZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiAgICAgcHJlZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGdyb3VwU2l6ZSAgICAgICAgICAgICAge251bWJlcn1cclxuICAgICAqICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZ3JvdXBTZXBhcmF0b3IgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGRlY2ltYWxTZXBhcmF0b3IgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB7c3RyaW5nfVxyXG4gICAgICogICAgIHN1ZmZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqXHJcbiAgICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAgICpcclxuICAgICAqIEUuZy5cclxuICAgICAqIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUyA6IDIwLCBST1VORElOR19NT0RFIDogNCB9KVxyXG4gICAgICpcclxuICAgICAqIElnbm9yZSBwcm9wZXJ0aWVzL3BhcmFtZXRlcnMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLCBleGNlcHQgZm9yIEFMUEhBQkVULlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmNvbmZpZyA9IEJpZ051bWJlci5zZXQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgIHZhciBwLCB2O1xyXG5cclxuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgLy8gREVDSU1BTF9QTEFDRVMge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIERFQ0lNQUxfUExBQ0VTIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdERUNJTUFMX1BMQUNFUycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBST1VORElOR19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUk9VTkRJTkdfTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUk9VTkRJTkdfTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDgsIHApO1xyXG4gICAgICAgICAgICBST1VORElOR19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxyXG4gICAgICAgICAgLy8gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbHVzaXZlLCAwIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEVYUE9ORU5USUFMX0FUIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdFWFBPTkVOVElBTF9BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgMCwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXTtcclxuICAgICAgICAgICAgICBUT19FWFBfUE9TID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSAtKFRPX0VYUF9QT1MgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSQU5HRSB7bnVtYmVyfG51bWJlcltdfSBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUkFOR0Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfGNhbm5vdCBiZSB6ZXJvfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JBTkdFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAtMSwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMSwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBNSU5fRVhQID0gdlswXTtcclxuICAgICAgICAgICAgICBNQVhfRVhQID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBNSU5fRVhQID0gLShNQVhfRVhQID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGNhbm5vdCBiZSB6ZXJvOiAnICsgdik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ1JZUFRPIHtib29sZWFufSB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIENSWVBUTyBub3QgdHJ1ZSBvciBmYWxzZToge3Z9J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdDUllQVE8nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gISF2KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0byAmJlxyXG4gICAgICAgICAgICAgICAgIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9ICF2O1xyXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgdHJ1ZSBvciBmYWxzZTogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTU9EVUxPX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA5IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBNT0RVTE9fTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnTU9EVUxPX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA5LCBwKTtcclxuICAgICAgICAgICAgTU9EVUxPX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFBPV19QUkVDSVNJT04ge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1BPV19QUkVDSVNJT04nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBGT1JNQVQge29iamVjdH1cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBGT1JNQVQgbm90IGFuIG9iamVjdDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0ZPUk1BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnb2JqZWN0JykgRk9STUFUID0gdjtcclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IGFuIG9iamVjdDogJyArIHYpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFMUEhBQkVUIHtzdHJpbmd9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQUxQSEFCRVQgaW52YWxpZDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0FMUEhBQkVUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIERpc2FsbG93IGlmIGxlc3MgdGhhbiB0d28gY2hhcmFjdGVycyxcclxuICAgICAgICAgICAgLy8gb3IgaWYgaXQgY29udGFpbnMgJysnLCAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgYSByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnc3RyaW5nJyAmJiAhL14uPyR8WytcXC0uXFxzXXwoLikuKlxcMS8udGVzdCh2KSkge1xyXG4gICAgICAgICAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHYuc2xpY2UoMCwgMTApID09ICcwMTIzNDU2Nzg5JztcclxuICAgICAgICAgICAgICBBTFBIQUJFVCA9IHY7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgaW52YWxpZDogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE9iamVjdCBleHBlY3RlZDoge3Z9J1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnT2JqZWN0IGV4cGVjdGVkOiAnICsgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgREVDSU1BTF9QTEFDRVM6IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgIFJPVU5ESU5HX01PREU6IFJPVU5ESU5HX01PREUsXHJcbiAgICAgICAgRVhQT05FTlRJQUxfQVQ6IFtUT19FWFBfTkVHLCBUT19FWFBfUE9TXSxcclxuICAgICAgICBSQU5HRTogW01JTl9FWFAsIE1BWF9FWFBdLFxyXG4gICAgICAgIENSWVBUTzogQ1JZUFRPLFxyXG4gICAgICAgIE1PRFVMT19NT0RFOiBNT0RVTE9fTU9ERSxcclxuICAgICAgICBQT1dfUFJFQ0lTSU9OOiBQT1dfUFJFQ0lTSU9OLFxyXG4gICAgICAgIEZPUk1BVDogRk9STUFULFxyXG4gICAgICAgIEFMUEhBQkVUOiBBTFBIQUJFVFxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHYgaXMgYSBCaWdOdW1iZXIgaW5zdGFuY2UsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogSWYgQmlnTnVtYmVyLkRFQlVHIGlzIHRydWUsIHRocm93IGlmIGEgQmlnTnVtYmVyIGluc3RhbmNlIGlzIG5vdCB3ZWxsLWZvcm1lZC5cclxuICAgICAqXHJcbiAgICAgKiB2IHthbnl9XHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEludmFsaWQgQmlnTnVtYmVyOiB7dn0nXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgIGlmICghdiB8fCB2Ll9pc0JpZ051bWJlciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoIUJpZ051bWJlci5ERUJVRykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICB2YXIgaSwgbixcclxuICAgICAgICBjID0gdi5jLFxyXG4gICAgICAgIGUgPSB2LmUsXHJcbiAgICAgICAgcyA9IHYucztcclxuXHJcbiAgICAgIG91dDogaWYgKHt9LnRvU3RyaW5nLmNhbGwoYykgPT0gJ1tvYmplY3QgQXJyYXldJykge1xyXG5cclxuICAgICAgICBpZiAoKHMgPT09IDEgfHwgcyA9PT0gLTEpICYmIGUgPj0gLU1BWCAmJiBlIDw9IE1BWCAmJiBlID09PSBtYXRoZmxvb3IoZSkpIHtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgZWxlbWVudCBpcyB6ZXJvLCB0aGUgQmlnTnVtYmVyIHZhbHVlIG11c3QgYmUgemVyby5cclxuICAgICAgICAgIGlmIChjWzBdID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlID09PSAwICYmIGMubGVuZ3RoID09PSAxKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIHRoYXQgY1swXSBzaG91bGQgaGF2ZSwgYmFzZWQgb24gdGhlIGV4cG9uZW50LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChpIDwgMSkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICAgICAgLy9pZiAoTWF0aC5jZWlsKE1hdGgubG9nKGNbMF0gKyAxKSAvIE1hdGguTE4xMCkgPT0gaSkge1xyXG4gICAgICAgICAgaWYgKFN0cmluZyhjWzBdKS5sZW5ndGggPT0gaSkge1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBuID0gY1tpXTtcclxuICAgICAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSBCQVNFIHx8IG4gIT09IG1hdGhmbG9vcihuKSkgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMYXN0IGVsZW1lbnQgY2Fubm90IGJlIHplcm8sIHVubGVzcyBpdCBpcyB0aGUgb25seSBlbGVtZW50LlxyXG4gICAgICAgICAgICBpZiAobiAhPT0gMCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5maW5pdHkvTmFOXHJcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gbnVsbCAmJiBlID09PSBudWxsICYmIChzID09PSBudWxsIHx8IHMgPT09IDEgfHwgcyA9PT0gLTEpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0ludmFsaWQgQmlnTnVtYmVyOiAnICsgdik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5tYXhpbXVtID0gQmlnTnVtYmVyLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5sdCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5taW5pbXVtID0gQmlnTnVtYmVyLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5ndCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSxcclxuICAgICAqIGFuZCB3aXRoIGRwLCBvciBERUNJTUFMX1BMQUNFUyBpZiBkcCBpcyBvbWl0dGVkLCBkZWNpbWFsIHBsYWNlcyAob3IgbGVzcyBpZiB0cmFpbGluZ1xyXG4gICAgICogemVyb3MgYXJlIHByb2R1Y2VkKS5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcH0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIucmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHBvdzJfNTMgPSAweDIwMDAwMDAwMDAwMDAwO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIGEgNTMgYml0IGludGVnZXIgbiwgd2hlcmUgMCA8PSBuIDwgOTAwNzE5OTI1NDc0MDk5Mi5cclxuICAgICAgLy8gQ2hlY2sgaWYgTWF0aC5yYW5kb20oKSBwcm9kdWNlcyBtb3JlIHRoYW4gMzIgYml0cyBvZiByYW5kb21uZXNzLlxyXG4gICAgICAvLyBJZiBpdCBkb2VzLCBhc3N1bWUgYXQgbGVhc3QgNTMgYml0cyBhcmUgcHJvZHVjZWQsIG90aGVyd2lzZSBhc3N1bWUgYXQgbGVhc3QgMzAgYml0cy5cclxuICAgICAgLy8gMHg0MDAwMDAwMCBpcyAyXjMwLCAweDgwMDAwMCBpcyAyXjIzLCAweDFmZmZmZiBpcyAyXjIxIC0gMS5cclxuICAgICAgdmFyIHJhbmRvbTUzYml0SW50ID0gKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKSAmIDB4MWZmZmZmXHJcbiAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhmbG9vcihNYXRoLnJhbmRvbSgpICogcG93Ml81Myk7IH1cclxuICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKChNYXRoLnJhbmRvbSgpICogMHg0MDAwMDAwMCB8IDApICogMHg4MDAwMDApICtcclxuICAgICAgICAgKE1hdGgucmFuZG9tKCkgKiAweDgwMDAwMCB8IDApOyB9O1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkcCkge1xyXG4gICAgICAgIHZhciBhLCBiLCBlLCBrLCB2LFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBjID0gW10sXHJcbiAgICAgICAgICByYW5kID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgICBpZiAoZHAgPT0gbnVsbCkgZHAgPSBERUNJTUFMX1BMQUNFUztcclxuICAgICAgICBlbHNlIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG5cclxuICAgICAgICBrID0gbWF0aGNlaWwoZHAgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgIGlmIChDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgICAgICAgICBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG5cclxuICAgICAgICAgICAgYSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGsgKj0gMikpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyA1MyBiaXRzOlxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgKiBNYXRoLnBvdygyLCAyMSkpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDBcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpID4+PiAxMSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDB4MjAwMDAgaXMgMl4yMS5cclxuICAgICAgICAgICAgICB2ID0gYVtpXSAqIDB4MjAwMDAgKyAoYVtpICsgMV0gPj4+IDExKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gUmVqZWN0aW9uIHNhbXBsaW5nOlxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICAvLyBQcm9iYWJpbGl0eSB0aGF0IHYgPj0gOWUxNSwgaXNcclxuICAgICAgICAgICAgICAvLyA3MTk5MjU0NzQwOTkyIC8gOTAwNzE5OTI1NDc0MDk5MiB+PSAwLjAwMDgsIGkuZS4gMSBpbiAxMjUxXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDIpKTtcclxuICAgICAgICAgICAgICAgIGFbaV0gPSBiWzBdO1xyXG4gICAgICAgICAgICAgICAgYVtpICsgMV0gPSBiWzFdO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSB2IDw9IDg5OTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vZGUuanMgc3VwcG9ydGluZyBjcnlwdG8ucmFuZG9tQnl0ZXMuXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyeXB0by5yYW5kb21CeXRlcykge1xyXG5cclxuICAgICAgICAgICAgLy8gYnVmZmVyXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoayAqPSA3KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAwMDAwIGlzIDJeNDgsIDB4MTAwMDAwMDAwMDAgaXMgMl40MFxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwIGlzIDJeMzIsIDB4MTAwMDAwMCBpcyAyXjI0XHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgdiA9ICgoYVtpXSAmIDMxKSAqIDB4MTAwMDAwMDAwMDAwMCkgKyAoYVtpICsgMV0gKiAweDEwMDAwMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDJdICogMHgxMDAwMDAwMDApICsgKGFbaSArIDNdICogMHgxMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDRdIDw8IDE2KSArIChhW2kgKyA1XSA8PCA4KSArIGFbaSArIDZdO1xyXG5cclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weShhLCBpKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gNztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyA3O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQ1JZUFRPID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVc2UgTWF0aC5yYW5kb20uXHJcbiAgICAgICAgaWYgKCFDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcbiAgICAgICAgICAgIHYgPSByYW5kb201M2JpdEludCgpO1xyXG4gICAgICAgICAgICBpZiAodiA8IDllMTUpIGNbaSsrXSA9IHYgJSAxZTE0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgayA9IGNbLS1pXTtcclxuICAgICAgICBkcCAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIGRwLlxyXG4gICAgICAgIGlmIChrICYmIGRwKSB7XHJcbiAgICAgICAgICB2ID0gUE9XU19URU5bTE9HX0JBU0UgLSBkcF07XHJcbiAgICAgICAgICBjW2ldID0gbWF0aGZsb29yKGsgLyB2KSAqIHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICAgICAgZm9yICg7IGNbaV0gPT09IDA7IGMucG9wKCksIGktLSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICBjID0gW2UgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBmb3IgKGUgPSAtMSA7IGNbMF0gPT09IDA7IGMuc3BsaWNlKDAsIDEpLCBlIC09IExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIGMgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MsIGFuZC4uLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgLy8gYWRqdXN0IHRoZSBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGlmIChpIDwgTE9HX0JBU0UpIGUgLT0gTE9HX0JBU0UgLSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmFuZC5lID0gZTtcclxuICAgICAgICByYW5kLmMgPSBjO1xyXG4gICAgICAgIHJldHVybiByYW5kO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnN1bSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgc3VtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDspIHN1bSA9IHN1bS5wbHVzKGFyZ3NbaSsrXSk7XHJcbiAgICAgIHJldHVybiBzdW07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyBQUklWQVRFIEZVTkNUSU9OU1xyXG5cclxuXHJcbiAgICAvLyBDYWxsZWQgYnkgQmlnTnVtYmVyIGFuZCBCaWdOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nLlxyXG4gICAgY29udmVydEJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgZGVjaW1hbCA9ICcwMTIzNDU2Nzg5JztcclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICAqIENvbnZlcnQgc3RyaW5nIG9mIGJhc2VJbiB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGJhc2VPdXQuXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJzI1NScsIDEwLCAxNikgcmV0dXJucyBbMTUsIDE1XS5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBhbHBoYWJldCkge1xyXG4gICAgICAgIHZhciBqLFxyXG4gICAgICAgICAgYXJyID0gWzBdLFxyXG4gICAgICAgICAgYXJyTCxcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07IGFyclthcnJMXSAqPSBiYXNlSW4pO1xyXG5cclxuICAgICAgICAgIGFyclswXSArPSBhbHBoYWJldC5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XHJcblxyXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGFyci5sZW5ndGg7IGorKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFycltqICsgMV0gPT0gbnVsbCkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcclxuICAgICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnZlcnQgYSBudW1lcmljIHN0cmluZyBvZiBiYXNlSW4gdG8gYSBudW1lcmljIHN0cmluZyBvZiBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIHRvU3RyaW5nLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2UgMTAgdG8gYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyBCaWdOdW1iZXIsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZUluIHRvIGJhc2UgMTAuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIHNpZ24sIGNhbGxlcklzVG9TdHJpbmcpIHtcclxuICAgICAgICB2YXIgYWxwaGFiZXQsIGQsIGUsIGssIHIsIHgsIHhjLCB5LFxyXG4gICAgICAgICAgaSA9IHN0ci5pbmRleE9mKCcuJyksXHJcbiAgICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgICAgcm0gPSBST1VORElOR19NT0RFO1xyXG5cclxuICAgICAgICAvLyBOb24taW50ZWdlci5cclxuICAgICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgICBrID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgICAvLyBVbmxpbWl0ZWQgcHJlY2lzaW9uLlxyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDA7XHJcbiAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGJhc2VJbik7XHJcbiAgICAgICAgICB4ID0geS5wb3coc3RyLmxlbmd0aCAtIGkpO1xyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IGs7XHJcblxyXG4gICAgICAgICAgLy8gQ29udmVydCBzdHIgYXMgaWYgYW4gaW50ZWdlciwgdGhlbiByZXN0b3JlIHRoZSBmcmFjdGlvbiBwYXJ0IGJ5IGRpdmlkaW5nIHRoZVxyXG4gICAgICAgICAgLy8gcmVzdWx0IGJ5IGl0cyBiYXNlIHJhaXNlZCB0byBhIHBvd2VyLlxyXG5cclxuICAgICAgICAgIHkuYyA9IHRvQmFzZU91dCh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyh4LmMpLCB4LmUsICcwJyksXHJcbiAgICAgICAgICAgMTAsIGJhc2VPdXQsIGRlY2ltYWwpO1xyXG4gICAgICAgICAgeS5lID0geS5jLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIG51bWJlciBhcyBpbnRlZ2VyLlxyXG5cclxuICAgICAgICB4YyA9IHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgY2FsbGVySXNUb1N0cmluZ1xyXG4gICAgICAgICA/IChhbHBoYWJldCA9IEFMUEhBQkVULCBkZWNpbWFsKVxyXG4gICAgICAgICA6IChhbHBoYWJldCA9IGRlY2ltYWwsIEFMUEhBQkVUKSk7XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBhcyBhbiBpbnRlZ2VyIGFuZCBjb252ZXJ0ZWQgdG8gYmFzZU91dC4gZSBpcyB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgZSA9IGsgPSB4Yy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgeGNbLS1rXSA9PSAwOyB4Yy5wb3AoKSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSkgcmV0dXJuIGFscGhhYmV0LmNoYXJBdCgwKTtcclxuXHJcbiAgICAgICAgLy8gRG9lcyBzdHIgcmVwcmVzZW50IGFuIGludGVnZXI/IElmIHNvLCBubyBuZWVkIGZvciB0aGUgZGl2aXNpb24uXHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAtLWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguYyA9IHhjO1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgc2lnbiBpcyBuZWVkZWQgZm9yIGNvcnJlY3Qgcm91bmRpbmcuXHJcbiAgICAgICAgICB4LnMgPSBzaWduO1xyXG4gICAgICAgICAgeCA9IGRpdih4LCB5LCBkcCwgcm0sIGJhc2VPdXQpO1xyXG4gICAgICAgICAgeGMgPSB4LmM7XHJcbiAgICAgICAgICByID0geC5yO1xyXG4gICAgICAgICAgZSA9IHguZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBjb252ZXJ0ZWQgdG8gYmFzZU91dC5cclxuXHJcbiAgICAgICAgLy8gVEhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICBkID0gZSArIGRwICsgMTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0OiB0aGUgZGlnaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIGkgPSB4Y1tkXTtcclxuXHJcbiAgICAgICAgLy8gTG9vayBhdCB0aGUgcm91bmRpbmcgZGlnaXRzIGFuZCBtb2RlIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJvdW5kIHVwLlxyXG5cclxuICAgICAgICBrID0gYmFzZU91dCAvIDI7XHJcbiAgICAgICAgciA9IHIgfHwgZCA8IDAgfHwgeGNbZCArIDFdICE9IG51bGw7XHJcblxyXG4gICAgICAgIHIgPSBybSA8IDQgPyAoaSAhPSBudWxsIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgICAgIDogaSA+IGsgfHwgaSA9PSBrICYmKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmIHhjW2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG5vdCBncmVhdGVyIHRoYW4gemVybywgb3IgeGMgcmVwcmVzZW50c1xyXG4gICAgICAgIC8vIHplcm8sIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgYmFzZSBjb252ZXJzaW9uIGlzIHplcm8gb3IsIGlmIHJvdW5kaW5nIHVwLCBhIHZhbHVlXHJcbiAgICAgICAgLy8gc3VjaCBhcyAwLjAwMDAxLlxyXG4gICAgICAgIGlmIChkIDwgMSB8fCAheGNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyAxXi1kcCBvciAwXHJcbiAgICAgICAgICBzdHIgPSByID8gdG9GaXhlZFBvaW50KGFscGhhYmV0LmNoYXJBdCgxKSwgLWRwLCBhbHBoYWJldC5jaGFyQXQoMCkpIDogYWxwaGFiZXQuY2hhckF0KDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gVHJ1bmNhdGUgeGMgdG8gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgIHhjLmxlbmd0aCA9IGQ7XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICAgICAgZm9yICgtLWJhc2VPdXQ7ICsreGNbLS1kXSA+IGJhc2VPdXQ7KSB7XHJcbiAgICAgICAgICAgICAgeGNbZF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoIWQpIHtcclxuICAgICAgICAgICAgICAgICsrZTtcclxuICAgICAgICAgICAgICAgIHhjID0gWzFdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChrID0geGMubGVuZ3RoOyAheGNbLS1rXTspO1xyXG5cclxuICAgICAgICAgIC8vIEUuZy4gWzQsIDExLCAxNV0gYmVjb21lcyA0YmYuXHJcbiAgICAgICAgICBmb3IgKGkgPSAwLCBzdHIgPSAnJzsgaSA8PSBrOyBzdHIgKz0gYWxwaGFiZXQuY2hhckF0KHhjW2krK10pKTtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvcywgZGVjaW1hbCBwb2ludCBhbmQgdHJhaWxpbmcgemVyb3MgYXMgcmVxdWlyZWQuXHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIGFkZCB0aGUgc2lnbi5cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLy8gUGVyZm9ybSBkaXZpc2lvbiBpbiB0aGUgc3BlY2lmaWVkIGJhc2UuIENhbGxlZCBieSBkaXYgYW5kIGNvbnZlcnRCYXNlLlxyXG4gICAgZGl2ID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgIC8vIEFzc3VtZSBub24temVybyB4IGFuZCBrLlxyXG4gICAgICBmdW5jdGlvbiBtdWx0aXBseSh4LCBrLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIG0sIHRlbXAsIHhsbywgeGhpLFxyXG4gICAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgICAgaSA9IHgubGVuZ3RoLFxyXG4gICAgICAgICAga2xvID0gayAlIFNRUlRfQkFTRSxcclxuICAgICAgICAgIGtoaSA9IGsgLyBTUVJUX0JBU0UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTspIHtcclxuICAgICAgICAgIHhsbyA9IHhbaV0gJSBTUVJUX0JBU0U7XHJcbiAgICAgICAgICB4aGkgPSB4W2ldIC8gU1FSVF9CQVNFIHwgMDtcclxuICAgICAgICAgIG0gPSBraGkgKiB4bG8gKyB4aGkgKiBrbG87XHJcbiAgICAgICAgICB0ZW1wID0ga2xvICogeGxvICsgKChtICUgU1FSVF9CQVNFKSAqIFNRUlRfQkFTRSkgKyBjYXJyeTtcclxuICAgICAgICAgIGNhcnJ5ID0gKHRlbXAgLyBiYXNlIHwgMCkgKyAobSAvIFNRUlRfQkFTRSB8IDApICsga2hpICogeGhpO1xyXG4gICAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNhcnJ5KSB4ID0gW2NhcnJ5XS5jb25jYXQoeCk7XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xyXG4gICAgICAgIHZhciBpLCBjbXA7XHJcblxyXG4gICAgICAgIGlmIChhTCAhPSBiTCkge1xyXG4gICAgICAgICAgY21wID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGZvciAoaSA9IGNtcCA9IDA7IGkgPCBhTDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XHJcbiAgICAgICAgICAgICAgY21wID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGFMLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cclxuICAgICAgICBmb3IgKDsgYUwtLTspIHtcclxuICAgICAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xyXG4gICAgICAgICAgYVthTF0gPSBpICogYmFzZSArIGFbYUxdIC0gYlthTF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOyBhLnNwbGljZSgwLCAxKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHg6IGRpdmlkZW5kLCB5OiBkaXZpc29yLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHksIGRwLCBybSwgYmFzZSkge1xyXG4gICAgICAgIHZhciBjbXAsIGUsIGksIG1vcmUsIG4sIHByb2QsIHByb2RMLCBxLCBxYywgcmVtLCByZW1MLCByZW0wLCB4aSwgeEwsIHljMCxcclxuICAgICAgICAgIHlMLCB5eixcclxuICAgICAgICAgIHMgPSB4LnMgPT0geS5zID8gMSA6IC0xLFxyXG4gICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIE5hTiwgSW5maW5pdHkgb3IgMD9cclxuICAgICAgICBpZiAoIXhjIHx8ICF4Y1swXSB8fCAheWMgfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoXHJcblxyXG4gICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YykgPyBOYU4gOlxyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIMKxMCBvciB5IGlzIMKxSW5maW5pdHksIG9yIHJldHVybiDCsUluZmluaXR5IGFzIHkgaXMgwrEwLlxyXG4gICAgICAgICAgICB4YyAmJiB4Y1swXSA9PSAwIHx8ICF5YyA/IHMgKiAwIDogcyAvIDBcclxuICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHEgPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG4gICAgICAgIHFjID0gcS5jID0gW107XHJcbiAgICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgICAgICBzID0gZHAgKyBlICsgMTtcclxuXHJcbiAgICAgICAgaWYgKCFiYXNlKSB7XHJcbiAgICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgLSBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgICAgICBzID0gcyAvIExPR19CQVNFIHwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc3VsdCBleHBvbmVudCBtYXkgYmUgb25lIGxlc3MgdGhlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiBlLlxyXG4gICAgICAgIC8vIFRoZSBjb2VmZmljaWVudHMgb2YgdGhlIEJpZ051bWJlcnMgZnJvbSBjb252ZXJ0QmFzZSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGkgPSAwOyB5Y1tpXSA9PSAoeGNbaV0gfHwgMCk7IGkrKyk7XHJcblxyXG4gICAgICAgIGlmICh5Y1tpXSA+ICh4Y1tpXSB8fCAwKSkgZS0tO1xyXG5cclxuICAgICAgICBpZiAocyA8IDApIHtcclxuICAgICAgICAgIHFjLnB1c2goMSk7XHJcbiAgICAgICAgICBtb3JlID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgcyArPSAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vcm1hbGlzZSB4YyBhbmQgeWMgc28gaGlnaGVzdCBvcmRlciBkaWdpdCBvZiB5YyBpcyA+PSBiYXNlIC8gMi5cclxuXHJcbiAgICAgICAgICBuID0gbWF0aGZsb29yKGJhc2UgLyAoeWNbMF0gKyAxKSk7XHJcblxyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKGJhc2UgLyAyKSAtIDEuXHJcbiAgICAgICAgICAvLyBpZiAobiA+IDEgfHwgbisrID09IDEgJiYgeWNbMF0gPCBiYXNlIC8gMikge1xyXG4gICAgICAgICAgaWYgKG4gPiAxKSB7XHJcbiAgICAgICAgICAgIHljID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB4YyA9IG11bHRpcGx5KHhjLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHhpID0geUw7XHJcbiAgICAgICAgICByZW0gPSB4Yy5zbGljZSgwLCB5TCk7XHJcbiAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gICAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwKTtcclxuICAgICAgICAgIHl6ID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgIHl6ID0gWzBdLmNvbmNhdCh5eik7XHJcbiAgICAgICAgICB5YzAgPSB5Y1swXTtcclxuICAgICAgICAgIGlmICh5Y1sxXSA+PSBiYXNlIC8gMikgeWMwKys7XHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gcHJldmVudCB0cmlhbCBkaWdpdCBuID4gYmFzZSwgd2hlbiB1c2luZyBiYXNlIDMuXHJcbiAgICAgICAgICAvLyBlbHNlIGlmIChiYXNlID09IDMgJiYgeWMwID09IDEpIHljMCA9IDEgKyAxZS0xNTtcclxuXHJcbiAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIG4gPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBuLlxyXG5cclxuICAgICAgICAgICAgICByZW0wID0gcmVtWzBdO1xyXG4gICAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgICAvLyBuIGlzIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byB0aGUgY3VycmVudCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vcihyZW0wIC8geWMwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gIEFsZ29yaXRobTpcclxuICAgICAgICAgICAgICAvLyAgcHJvZHVjdCA9IGRpdmlzb3IgbXVsdGlwbGllZCBieSB0cmlhbCBkaWdpdCAobikuXHJcbiAgICAgICAgICAgICAgLy8gIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IGlzIGdyZWF0ZXIgdGhhbiByZW1haW5kZXI6XHJcbiAgICAgICAgICAgICAgLy8gICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QsIGRlY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAvLyAgU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCB3YXMgbGVzcyB0aGFuIHJlbWFpbmRlciBhdCB0aGUgbGFzdCBjb21wYXJlOlxyXG4gICAgICAgICAgICAgIC8vICAgIENvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvci5cclxuICAgICAgICAgICAgICAvLyAgICBJZiByZW1haW5kZXIgaXMgZ3JlYXRlciB0aGFuIGRpdmlzb3I6XHJcbiAgICAgICAgICAgICAgLy8gICAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLCBpbmNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcblxyXG4gICAgICAgICAgICAgIGlmIChuID4gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gbWF5IGJlID4gYmFzZSBvbmx5IHdoZW4gYmFzZSBpcyAzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPj0gYmFzZSkgbiA9IGJhc2UgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlciB0aGVuIHRyaWFsIGRpZ2l0IG4gdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGhpZ2ggYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCBpcyBub3Qga25vd24gdG8gaGF2ZVxyXG4gICAgICAgICAgICAgICAgLy8gZXZlciBiZWVuIG1vcmUgdGhhbiAxIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICBuLS07XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdC5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgY21wID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMCBvciAxLCBjbXAgaXMgLTEuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgICAgLy8gc28gY2hhbmdlIGNtcCB0byAxIHRvIGF2b2lkIGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAxLCBsZWF2ZSBjbXAgYXMgLTEsIHNvIHljIGFuZCByZW0gYXJlIGNvbXBhcmVkIGFnYWluLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gZGl2aXNvciA8IHJlbWFpbmRlciwgc28gbiBtdXN0IGJlIGF0IGxlYXN0IDEuXHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IG4gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yXHJcbiAgICAgICAgICAgICAgICBwcm9kID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKSBwcm9kID0gWzBdLmNvbmNhdChwcm9kKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHByb2QsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgbmV3IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gVHJpYWwgZGlnaXQgbiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBsb3cgYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCB2ZXJ5IHJhcmVseSAyIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4rKztcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5YywgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgICB9IC8vIGVsc2UgY21wID09PSAxIGFuZCBuIHdpbGwgYmUgMFxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXh0IGRpZ2l0LCBuLCB0byB0aGUgcmVzdWx0IGFycmF5LlxyXG4gICAgICAgICAgICBxY1tpKytdID0gbjtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAocmVtWzBdKSB7XHJcbiAgICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZW0gPSBbeGNbeGldXTtcclxuICAgICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT0gbnVsbCkgJiYgcy0tKTtcclxuXHJcbiAgICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gTGVhZGluZyB6ZXJvP1xyXG4gICAgICAgICAgaWYgKCFxY1swXSkgcWMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJhc2UgPT0gQkFTRSkge1xyXG5cclxuICAgICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBxLmUsIGZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBxY1swXS5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICByb3VuZChxLCBkcCArIChxLmUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgKyAxLCBybSwgbW9yZSk7XHJcblxyXG4gICAgICAgIC8vIENhbGxlciBpcyBjb252ZXJ0QmFzZS5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcS5lID0gZTtcclxuICAgICAgICAgIHEuciA9ICttb3JlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyIG4gaW4gZml4ZWQtcG9pbnQgb3IgZXhwb25lbnRpYWxcclxuICAgICAqIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvciBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgKlxyXG4gICAgICogbjogYSBCaWdOdW1iZXIuXHJcbiAgICAgKiBpOiB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZGlnaXQgcmVxdWlyZWQgKGkuZS4gdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXApLlxyXG4gICAgICogcm06IHRoZSByb3VuZGluZyBtb2RlLlxyXG4gICAgICogaWQ6IDEgKHRvRXhwb25lbnRpYWwpIG9yIDIgKHRvUHJlY2lzaW9uKS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0KG4sIGksIHJtLCBpZCkge1xyXG4gICAgICB2YXIgYzAsIGUsIG5lLCBsZW4sIHN0cjtcclxuXHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgaWYgKCFuLmMpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBjMCA9IG4uY1swXTtcclxuICAgICAgbmUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoaSA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIHN0ciA9IGlkID09IDEgfHwgaWQgPT0gMiAmJiAobmUgPD0gVE9fRVhQX05FRyB8fCBuZSA+PSBUT19FWFBfUE9TKVxyXG4gICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBuZSlcclxuICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBuZSwgJzAnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgaSwgcm0pO1xyXG5cclxuICAgICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIHRvUHJlY2lzaW9uIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAgICAvLyBzcGVjaWZpZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcclxuICAgICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgaWYgKGlkID09IDEgfHwgaWQgPT0gMiAmJiAoaSA8PSBlIHx8IGUgPD0gVE9fRVhQX05FRykpIHtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBmb3IgKDsgbGVuIDwgaTsgc3RyICs9ICcwJywgbGVuKyspO1xyXG4gICAgICAgICAgc3RyID0gdG9FeHBvbmVudGlhbChzdHIsIGUpO1xyXG5cclxuICAgICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSAtPSBuZTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgaWYgKGUgKyAxID4gbGVuKSB7XHJcbiAgICAgICAgICAgIGlmICgtLWkgPiAwKSBmb3IgKHN0ciArPSAnLic7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpICs9IGUgLSBsZW47XHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgIGlmIChlICsgMSA9PSBsZW4pIHN0ciArPSAnLic7XHJcbiAgICAgICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwICYmIGMwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgQmlnTnVtYmVyLm1heCBhbmQgQmlnTnVtYmVyLm1pbi5cclxuICAgIGZ1bmN0aW9uIG1heE9yTWluKGFyZ3MsIG1ldGhvZCkge1xyXG4gICAgICB2YXIgbixcclxuICAgICAgICBpID0gMSxcclxuICAgICAgICBtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuXHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbaV0pO1xyXG5cclxuICAgICAgICAvLyBJZiBhbnkgbnVtYmVyIGlzIE5hTiwgcmV0dXJuIE5hTi5cclxuICAgICAgICBpZiAoIW4ucykge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZC5jYWxsKG0sIG4pKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICAgKiBDYWxsZWQgYnkgbWludXMsIHBsdXMgYW5kIHRpbWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpc2UobiwgYywgZSkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7ICFjWy0tal07IGMucG9wKCkpO1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgZm9yIChqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoKGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgIG4uYyA9IG4uZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICBuLmMgPSBbbi5lID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbi5lID0gZTtcclxuICAgICAgICBuLmMgPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gICAgcGFyc2VOdW1lcmljID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLFxyXG4gICAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgICAgZG90QmVmb3JlID0gL15cXC4oW14uXSspJC8sXHJcbiAgICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgc3RyLCBpc051bSwgYikge1xyXG4gICAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgICAgcyA9IGlzTnVtID8gc3RyIDogc3RyLnJlcGxhY2Uod2hpdGVzcGFjZU9yUGx1cywgJycpO1xyXG5cclxuICAgICAgICAvLyBObyBleGNlcHRpb24gb24gwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgICAgaWYgKGlzSW5maW5pdHlPck5hTi50ZXN0KHMpKSB7XHJcbiAgICAgICAgICB4LnMgPSBpc05hTihzKSA/IG51bGwgOiBzIDwgMCA/IC0xIDogMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCFpc051bSkge1xyXG5cclxuICAgICAgICAgICAgLy8gYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2lcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShiYXNlUHJlZml4LCBmdW5jdGlvbiAobSwgcDEsIHAyKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IChwMiA9IHAyLnRvTG93ZXJDYXNlKCkpID09ICd4JyA/IDE2IDogcDIgPT0gJ2InID8gMiA6IDg7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICFiIHx8IGIgPT0gYmFzZSA/IHAxIDogbTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSBiO1xyXG5cclxuICAgICAgICAgICAgICAvLyBFLmcuICcxLicgdG8gJzEnLCAnLjEnIHRvICcwLjEnXHJcbiAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShkb3RBZnRlciwgJyQxJykucmVwbGFjZShkb3RCZWZvcmUsICcwLiQxJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzdHIgIT0gcykgcmV0dXJuIG5ldyBCaWdOdW1iZXIocywgYmFzZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIG51bWJlcjoge259J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIGJhc2Uge2J9IG51bWJlcjoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRykge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdOb3QgYScgKyAoYiA/ICcgYmFzZSAnICsgYiA6ICcnKSArICcgbnVtYmVyOiAnICsgc3RyKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBOYU5cclxuICAgICAgICAgIHgucyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUm91bmQgeCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybS4gQ2hlY2sgZm9yIG92ZXIvdW5kZXItZmxvdy5cclxuICAgICAqIElmIHIgaXMgdHJ1dGh5LCBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGFyZSBtb3JlIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJvdW5kKHgsIHNkLCBybSwgcikge1xyXG4gICAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHBvd3MxMCA9IFBPV1NfVEVOO1xyXG5cclxuICAgICAgLy8gaWYgeCBpcyBub3QgSW5maW5pdHkgb3IgTmFOLi4uXHJcbiAgICAgIGlmICh4Yykge1xyXG5cclxuICAgICAgICAvLyByZCBpcyB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXHJcbiAgICAgICAgLy8gbmkgaXMgdGhlIGluZGV4IG9mIG4gd2l0aGluIHguYy5cclxuICAgICAgICAvLyBkIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgLy8gaiBpcyB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiBuIChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuICAgICAgICBvdXQ6IHtcclxuXHJcbiAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuXHJcbiAgICAgICAgICBmb3IgKGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcbiAgICAgICAgICBpID0gc2QgLSBkO1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgIGogPSBzZDtcclxuICAgICAgICAgICAgbiA9IHhjW25pID0gMF07XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgcmQgPSBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuaSA9IG1hdGhjZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgICBpZiAobmkgPj0geGMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTmVlZGVkIGJ5IHNxcnQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgeGMubGVuZ3RoIDw9IG5pOyB4Yy5wdXNoKDApKTtcclxuICAgICAgICAgICAgICAgIG4gPSByZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBkID0gMTtcclxuICAgICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBuID0gayA9IHhjW25pXTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgICAgICAgZm9yIChkID0gMTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbi5cclxuICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLCBhZGp1c3RlZCBmb3IgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgbiBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGQuXHJcbiAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIGQ7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgciA9IHIgfHwgc2QgPCAwIHx8XHJcblxyXG4gICAgICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gIG4gJSBwb3dzMTBbZCAtIGogLSAxXSAgcmV0dXJucyBhbGwgZGlnaXRzIG9mIG4gdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAvLyBvZiB0aGUgZGlnaXQgYXQgaiwgZS5nLiBpZiBuIGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvbiBnaXZlcyA3MTQuXHJcbiAgICAgICAgICAgeGNbbmkgKyAxXSAhPSBudWxsIHx8IChqIDwgMCA/IG4gOiBuICUgcG93czEwW2QgLSBqIC0gMV0pO1xyXG5cclxuICAgICAgICAgIHIgPSBybSA8IDRcclxuICAgICAgICAgICA/IChyZCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAgICAgKChpID4gMCA/IGogPiAwID8gbiAvIHBvd3MxMFtkIC0gal0gOiAwIDogeGNbbmkgLSAxXSkgJSAxMCkgJiAxIHx8XHJcbiAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgICAgaWYgKHNkIDwgMSB8fCAheGNbMF0pIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHBvd3MxMFsoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFXTtcclxuICAgICAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaTtcclxuICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgIG5pLS07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaSArIDE7XHJcbiAgICAgICAgICAgIGsgPSBwb3dzMTBbTE9HX0JBU0UgLSBpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4uXHJcbiAgICAgICAgICAgIHhjW25pXSA9IGogPiAwID8gbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGpdICUgcG93czEwW2pdKSAqIGsgOiAwO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICAgICAgaWYgKG5pID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuICAgICAgICAgICAgICAgIGogPSB4Y1swXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCwgaysrKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gaykge1xyXG4gICAgICAgICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgICAgICAgaWYgKHhjWzBdID09IEJBU0UpIHhjWzBdID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeGNbbmldICs9IGs7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGNbbmldICE9IEJBU0UpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgeGNbbmktLV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdmVyZmxvdz8gSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz8gWmVyby5cclxuICAgICAgICB9IGVsc2UgaWYgKHguZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB2YWx1ZU9mKG4pIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcblxyXG4gICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgZSlcclxuICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUFJPVE9UWVBFL0lOU1RBTkNFIE1FVEhPRFNcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuXHJcbiAgICAgKiAgIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gICAgICogICBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgICovXHJcbiAgICBQLmNvbXBhcmVkVG8gPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBkcCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGVcclxuICAgICAqIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIGRwIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2YgZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzOiBpbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgbiA9ICgodiA9IGMubGVuZ3RoIC0gMSkgLSBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IG51bWJlci5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcbiAgICAgIGlmIChuIDwgMCkgbiA9IDA7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAvIDAgPSBJXHJcbiAgICAgKiAgbiAvIE4gPSBOXHJcbiAgICAgKiAgbiAvIEkgPSAwXHJcbiAgICAgKiAgMCAvIG4gPSAwXHJcbiAgICAgKiAgMCAvIDAgPSBOXHJcbiAgICAgKiAgMCAvIE4gPSBOXHJcbiAgICAgKiAgMCAvIEkgPSAwXHJcbiAgICAgKiAgTiAvIG4gPSBOXHJcbiAgICAgKiAgTiAvIDAgPSBOXHJcbiAgICAgKiAgTiAvIE4gPSBOXHJcbiAgICAgKiAgTiAvIEkgPSBOXHJcbiAgICAgKiAgSSAvIG4gPSBJXHJcbiAgICAgKiAgSSAvIDAgPSBJXHJcbiAgICAgKiAgSSAvIE4gPSBOXHJcbiAgICAgKiAgSSAvIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciBieSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuaWRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgMCwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBleHBvbmVudGlhdGVkIGJ5IG4uXHJcbiAgICAgKlxyXG4gICAgICogSWYgbSBpcyBwcmVzZW50LCByZXR1cm4gdGhlIHJlc3VsdCBtb2R1bG8gbS5cclxuICAgICAqIElmIG4gaXMgbmVnYXRpdmUgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICogSWYgUE9XX1BSRUNJU0lPTiBpcyBub24temVybyBhbmQgbSBpcyBub3QgcHJlc2VudCwgcm91bmQgdG8gUE9XX1BSRUNJU0lPTiB1c2luZyBST1VORElOR19NT0RFLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBtb2R1bGFyIHBvd2VyIG9wZXJhdGlvbiB3b3JrcyBlZmZpY2llbnRseSB3aGVuIHgsIG4sIGFuZCBtIGFyZSBpbnRlZ2Vycywgb3RoZXJ3aXNlIGl0XHJcbiAgICAgKiBpcyBlcXVpdmFsZW50IHRvIGNhbGN1bGF0aW5nIHguZXhwb25lbnRpYXRlZEJ5KG4pLm1vZHVsbyhtKSB3aXRoIGEgUE9XX1BSRUNJU0lPTiBvZiAwLlxyXG4gICAgICpcclxuICAgICAqIG4ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgZXhwb25lbnQuIEFuIGludGVnZXIuXHJcbiAgICAgKiBbbV0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgbW9kdWx1cy5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gRXhwb25lbnQgbm90IGFuIGludGVnZXI6IHtufSdcclxuICAgICAqL1xyXG4gICAgUC5leHBvbmVudGlhdGVkQnkgPSBQLnBvdyA9IGZ1bmN0aW9uIChuLCBtKSB7XHJcbiAgICAgIHZhciBoYWxmLCBpc01vZEV4cCwgaSwgaywgbW9yZSwgbklzQmlnLCBuSXNOZWcsIG5Jc09kZCwgeSxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG5cclxuICAgICAgLy8gQWxsb3cgTmFOIGFuZCDCsUluZmluaXR5LCBidXQgbm90IG90aGVyIG5vbi1pbnRlZ2Vycy5cclxuICAgICAgaWYgKG4uYyAmJiAhbi5pc0ludGVnZXIoKSkge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnRXhwb25lbnQgbm90IGFuIGludGVnZXI6ICcgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG0gIT0gbnVsbCkgbSA9IG5ldyBCaWdOdW1iZXIobSk7XHJcblxyXG4gICAgICAvLyBFeHBvbmVudCBvZiBNQVhfU0FGRV9JTlRFR0VSIGlzIDE1LlxyXG4gICAgICBuSXNCaWcgPSBuLmUgPiAxNDtcclxuXHJcbiAgICAgIC8vIElmIHggaXMgTmFOLCDCsUluZmluaXR5LCDCsTAgb3IgwrExLCBvciBuIGlzIMKxSW5maW5pdHksIE5hTiBvciDCsTAuXHJcbiAgICAgIGlmICgheC5jIHx8ICF4LmNbMF0gfHwgeC5jWzBdID09IDEgJiYgIXguZSAmJiB4LmMubGVuZ3RoID09IDEgfHwgIW4uYyB8fCAhbi5jWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzaWduIG9mIHRoZSByZXN1bHQgb2YgcG93IHdoZW4geCBpcyBuZWdhdGl2ZSBkZXBlbmRzIG9uIHRoZSBldmVubmVzcyBvZiBuLlxyXG4gICAgICAgIC8vIElmICtuIG92ZXJmbG93cyB0byDCsUluZmluaXR5LCB0aGUgZXZlbm5lc3Mgb2YgbiB3b3VsZCBiZSBub3QgYmUga25vd24uXHJcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoTWF0aC5wb3coK3ZhbHVlT2YoeCksIG5Jc0JpZyA/IDIgLSBpc09kZChuKSA6ICt2YWx1ZU9mKG4pKSk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5Jc05lZyA9IG4ucyA8IDA7XHJcblxyXG4gICAgICBpZiAobSkge1xyXG5cclxuICAgICAgICAvLyB4ICUgbSByZXR1cm5zIE5hTiBpZiBhYnMobSkgaXMgemVybywgb3IgbSBpcyBOYU4uXHJcbiAgICAgICAgaWYgKG0uYyA/ICFtLmNbMF0gOiAhbS5zKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgICBpc01vZEV4cCA9ICFuSXNOZWcgJiYgeC5pc0ludGVnZXIoKSAmJiBtLmlzSW50ZWdlcigpO1xyXG5cclxuICAgICAgICBpZiAoaXNNb2RFeHApIHggPSB4Lm1vZChtKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93IHRvIMKxSW5maW5pdHk6ID49MioqMWUxMCBvciA+PTEuMDAwMDAyNCoqMWUxNS5cclxuICAgICAgLy8gVW5kZXJmbG93IHRvIMKxMDogPD0wLjc5KioxZTEwIG9yIDw9MC45OTk5OTc1KioxZTE1LlxyXG4gICAgICB9IGVsc2UgaWYgKG4uZSA+IDkgJiYgKHguZSA+IDAgfHwgeC5lIDwgLTEgfHwgKHguZSA9PSAwXHJcbiAgICAgICAgLy8gWzEsIDI0MDAwMDAwMF1cclxuICAgICAgICA/IHguY1swXSA+IDEgfHwgbklzQmlnICYmIHguY1sxXSA+PSAyNGU3XHJcbiAgICAgICAgLy8gWzgwMDAwMDAwMDAwMDAwXSAgWzk5OTk5NzUwMDAwMDAwXVxyXG4gICAgICAgIDogeC5jWzBdIDwgOGUxMyB8fCBuSXNCaWcgJiYgeC5jWzBdIDw9IDk5OTk5NzVlNykpKSB7XHJcblxyXG4gICAgICAgIC8vIElmIHggaXMgbmVnYXRpdmUgYW5kIG4gaXMgb2RkLCBrID0gLTAsIGVsc2UgayA9IDAuXHJcbiAgICAgICAgayA9IHgucyA8IDAgJiYgaXNPZGQobikgPyAtMCA6IDA7XHJcblxyXG4gICAgICAgIC8vIElmIHggPj0gMSwgayA9IMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IC0xKSBrID0gMSAvIGs7XHJcblxyXG4gICAgICAgIC8vIElmIG4gaXMgbmVnYXRpdmUgcmV0dXJuIMKxMCwgZWxzZSByZXR1cm4gwrFJbmZpbml0eS5cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihuSXNOZWcgPyAxIC8gayA6IGspO1xyXG5cclxuICAgICAgfSBlbHNlIGlmIChQT1dfUFJFQ0lTSU9OKSB7XHJcblxyXG4gICAgICAgIC8vIFRydW5jYXRpbmcgZWFjaCBjb2VmZmljaWVudCBhcnJheSB0byBhIGxlbmd0aCBvZiBrIGFmdGVyIGVhY2ggbXVsdGlwbGljYXRpb25cclxuICAgICAgICAvLyBlcXVhdGVzIHRvIHRydW5jYXRpbmcgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIFBPV19QUkVDSVNJT04gKyBbMjgsIDQxXSxcclxuICAgICAgICAvLyBpLmUuIHRoZXJlIHdpbGwgYmUgYSBtaW5pbXVtIG9mIDI4IGd1YXJkIGRpZ2l0cyByZXRhaW5lZC5cclxuICAgICAgICBrID0gbWF0aGNlaWwoUE9XX1BSRUNJU0lPTiAvIExPR19CQVNFICsgMik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChuSXNCaWcpIHtcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcigwLjUpO1xyXG4gICAgICAgIGlmIChuSXNOZWcpIG4ucyA9IDE7XHJcbiAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaSA9IE1hdGguYWJzKCt2YWx1ZU9mKG4pKTtcclxuICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgIC8vIFBlcmZvcm1zIDU0IGxvb3AgaXRlcmF0aW9ucyBmb3IgbiBvZiA5MDA3MTk5MjU0NzQwOTkxLlxyXG4gICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICBpZiAobklzT2RkKSB7XHJcbiAgICAgICAgICB5ID0geS50aW1lcyh4KTtcclxuICAgICAgICAgIGlmICgheS5jKSBicmVhaztcclxuXHJcbiAgICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgICBpZiAoeS5jLmxlbmd0aCA+IGspIHkuYy5sZW5ndGggPSBrO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgICB5ID0geS5tb2QobSk7ICAgIC8veSA9IHkubWludXMoZGl2KHksIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaSkge1xyXG4gICAgICAgICAgaSA9IG1hdGhmbG9vcihpIC8gMik7XHJcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IG4udGltZXMoaGFsZik7XHJcbiAgICAgICAgICByb3VuZChuLCBuLmUgKyAxLCAxKTtcclxuXHJcbiAgICAgICAgICBpZiAobi5lID4gMTQpIHtcclxuICAgICAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpID0gK3ZhbHVlT2Yobik7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4ID0geC50aW1lcyh4KTtcclxuXHJcbiAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgIGlmICh4LmMgJiYgeC5jLmxlbmd0aCA+IGspIHguYy5sZW5ndGggPSBrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgIHggPSB4Lm1vZChtKTsgICAgLy94ID0geC5taW51cyhkaXYoeCwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc01vZEV4cCkgcmV0dXJuIHk7XHJcbiAgICAgIGlmIChuSXNOZWcpIHkgPSBPTkUuZGl2KHkpO1xyXG5cclxuICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IGsgPyByb3VuZCh5LCBQT1dfUFJFQ0lTSU9OLCBST1VORElOR19NT0RFLCBtb3JlKSA6IHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhbiBpbnRlZ2VyXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7cm19J1xyXG4gICAgICovXHJcbiAgICBQLmludGVnZXJWYWx1ZSA9IGZ1bmN0aW9uIChybSkge1xyXG4gICAgICB2YXIgbiA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG4gICAgICByZXR1cm4gcm91bmQobiwgbi5lICsgMSwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0VxdWFsVG8gPSBQLmVxID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGEgZmluaXRlIG51bWJlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gMSB8fCBiID09PSAwO1xyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYW4gaW50ZWdlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0ludGVnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkgPiB0aGlzLmMubGVuZ3RoIC0gMjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW4gPSBQLmx0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IC0xIHx8IGIgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIE5hTiwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05hTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICF0aGlzLnM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIG5lZ2F0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBwb3NpdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiB0aGlzLmNbMF0gPT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAtIDAgPSBuXHJcbiAgICAgKiAgbiAtIE4gPSBOXHJcbiAgICAgKiAgbiAtIEkgPSAtSVxyXG4gICAgICogIDAgLSBuID0gLW5cclxuICAgICAqICAwIC0gMCA9IDBcclxuICAgICAqICAwIC0gTiA9IE5cclxuICAgICAqICAwIC0gSSA9IC1JXHJcbiAgICAgKiAgTiAtIG4gPSBOXHJcbiAgICAgKiAgTiAtIDAgPSBOXHJcbiAgICAgKiAgTiAtIE4gPSBOXHJcbiAgICAgKiAgTiAtIEkgPSBOXHJcbiAgICAgKiAgSSAtIG4gPSBJXHJcbiAgICAgKiAgSSAtIDAgPSBJXHJcbiAgICAgKiAgSSAtIE4gPSBOXHJcbiAgICAgKiAgSSAtIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbWludXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubWludXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgaSwgaiwgdCwgeExUeSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4geGMgPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih5YyA/IHggOiBOYU4pO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgICAgcmV0dXJuIHljWzBdID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDpcclxuXHJcbiAgICAgICAgICAgLy8gSUVFRSA3NTQgKDIwMDgpIDYuMzogbiAtIG4gPSAtMCB3aGVuIHJvdW5kaW5nIHRvIC1JbmZpbml0eVxyXG4gICAgICAgICAgIFJPVU5ESU5HX01PREUgPT0gMyA/IC0wIDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBpcyB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcblxyXG4gICAgICAgIGlmICh4TFR5ID0gYSA8IDApIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAgICAgICBmb3IgKGIgPSBhOyBiLS07IHQucHVzaCgwKSk7XHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50cyBlcXVhbC4gQ2hlY2sgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICAgICAgaiA9ICh4TFR5ID0gKGEgPSB4Yy5sZW5ndGgpIDwgKGIgPSB5Yy5sZW5ndGgpKSA/IGEgOiBiO1xyXG5cclxuICAgICAgICBmb3IgKGEgPSBiID0gMDsgYiA8IGo7IGIrKykge1xyXG5cclxuICAgICAgICAgIGlmICh4Y1tiXSAhPSB5Y1tiXSkge1xyXG4gICAgICAgICAgICB4TFR5ID0geGNbYl0gPCB5Y1tiXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4IDwgeT8gUG9pbnQgeGMgdG8gdGhlIGFycmF5IG9mIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoeExUeSkge1xyXG4gICAgICAgIHQgPSB4YztcclxuICAgICAgICB4YyA9IHljO1xyXG4gICAgICAgIHljID0gdDtcclxuICAgICAgICB5LnMgPSAteS5zO1xyXG4gICAgICB9ICBcclxuXHJcbiAgICAgIGIgPSAoaiA9IHljLmxlbmd0aCkgLSAoaSA9IHhjLmxlbmd0aCk7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci5cclxuICAgICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgICAgaWYgKGIgPiAwKSBmb3IgKDsgYi0tOyB4Y1tpKytdID0gMCk7XHJcbiAgICAgIGIgPSBCQVNFIC0gMTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICAgIGZvciAoOyBqID4gYTspIHtcclxuXHJcbiAgICAgICAgaWYgKHhjWy0tal0gPCB5Y1tqXSkge1xyXG4gICAgICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiKTtcclxuICAgICAgICAgIC0teGNbaV07XHJcbiAgICAgICAgICB4Y1tqXSArPSBCQVNFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGNbal0gLT0geWNbal07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgIGZvciAoOyB4Y1swXSA9PSAwOyB4Yy5zcGxpY2UoMCwgMSksIC0teWUpO1xyXG5cclxuICAgICAgLy8gWmVybz9cclxuICAgICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBGb2xsb3dpbmcgSUVFRSA3NTQgKDIwMDgpIDYuMyxcclxuICAgICAgICAvLyBuIC0gbiA9ICswICBidXQgIG4gLSBuID0gLTAgIHdoZW4gcm91bmRpbmcgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICAgIHkuYyA9IFt5LmUgPSAwXTtcclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgSW5maW5pdHkgYXMgK3ggLSAreSAhPSBJbmZpbml0eSAmJiAteCAtIC15ICE9IEluZmluaXR5XHJcbiAgICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICAgbiAlIDAgPSAgTlxyXG4gICAgICogICBuICUgTiA9ICBOXHJcbiAgICAgKiAgIG4gJSBJID0gIG5cclxuICAgICAqICAgMCAlIG4gPSAgMFxyXG4gICAgICogIC0wICUgbiA9IC0wXHJcbiAgICAgKiAgIDAgJSAwID0gIE5cclxuICAgICAqICAgMCAlIE4gPSAgTlxyXG4gICAgICogICAwICUgSSA9ICAwXHJcbiAgICAgKiAgIE4gJSBuID0gIE5cclxuICAgICAqICAgTiAlIDAgPSAgTlxyXG4gICAgICogICBOICUgTiA9ICBOXHJcbiAgICAgKiAgIE4gJSBJID0gIE5cclxuICAgICAqICAgSSAlIG4gPSAgTlxyXG4gICAgICogICBJICUgMCA9ICBOXHJcbiAgICAgKiAgIEkgJSBOID0gIE5cclxuICAgICAqICAgSSAlIEkgPSAgTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1vZHVsbyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBxLCBzLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgICBpZiAoIXguYyB8fCAheS5zIHx8IHkuYyAmJiAheS5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxyXG4gICAgICB9IGVsc2UgaWYgKCF5LmMgfHwgeC5jICYmICF4LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKE1PRFVMT19NT0RFID09IDkpIHtcclxuXHJcbiAgICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgICAgcyA9IHkucztcclxuICAgICAgICB5LnMgPSAxO1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgMyk7XHJcbiAgICAgICAgeS5zID0gcztcclxuICAgICAgICBxLnMgKj0gcztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIE1PRFVMT19NT0RFKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IHgubWludXMocS50aW1lcyh5KSk7XHJcblxyXG4gICAgICAvLyBUbyBtYXRjaCBKYXZhU2NyaXB0ICUsIGVuc3VyZSBzaWduIG9mIHplcm8gaXMgc2lnbiBvZiBkaXZpZGVuZC5cclxuICAgICAgaWYgKCF5LmNbMF0gJiYgTU9EVUxPX01PREUgPT0gMSkgeS5zID0geC5zO1xyXG5cclxuICAgICAgcmV0dXJuIHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKiAwID0gMFxyXG4gICAgICogIG4gKiBOID0gTlxyXG4gICAgICogIG4gKiBJID0gSVxyXG4gICAgICogIDAgKiBuID0gMFxyXG4gICAgICogIDAgKiAwID0gMFxyXG4gICAgICogIDAgKiBOID0gTlxyXG4gICAgICogIDAgKiBJID0gTlxyXG4gICAgICogIE4gKiBuID0gTlxyXG4gICAgICogIE4gKiAwID0gTlxyXG4gICAgICogIE4gKiBOID0gTlxyXG4gICAgICogIE4gKiBJID0gTlxyXG4gICAgICogIEkgKiBuID0gSVxyXG4gICAgICogIEkgKiAwID0gTlxyXG4gICAgICogIEkgKiBOID0gTlxyXG4gICAgICogIEkgKiBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG11bHRpcGxpZWQgYnkgdGhlIHZhbHVlXHJcbiAgICAgKiBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubXVsdGlwbGllZEJ5ID0gUC50aW1lcyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBjLCBlLCBpLCBqLCBrLCBtLCB4Y0wsIHhsbywgeGhpLCB5Y0wsIHlsbywgeWhpLCB6YyxcclxuICAgICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9ICh5ID0gbmV3IEJpZ051bWJlcih5LCBiKSkuYztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4sIMKxSW5maW5pdHkgb3IgwrEwP1xyXG4gICAgICBpZiAoIXhjIHx8ICF5YyB8fCAheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTiwgb3Igb25lIGlzIDAgYW5kIHRoZSBvdGhlciBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXgucyB8fCAheS5zIHx8IHhjICYmICF4Y1swXSAmJiAheWMgfHwgeWMgJiYgIXljWzBdICYmICF4Yykge1xyXG4gICAgICAgICAgeS5jID0geS5lID0geS5zID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeS5zICo9IHgucztcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgICAgIGlmICgheGMgfHwgIXljKSB7XHJcbiAgICAgICAgICAgIHkuYyA9IHkuZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeS5jID0gWzBdO1xyXG4gICAgICAgICAgICB5LmUgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgKyBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgIHkucyAqPSB4LnM7XHJcbiAgICAgIHhjTCA9IHhjLmxlbmd0aDtcclxuICAgICAgeWNMID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gRW5zdXJlIHhjIHBvaW50cyB0byBsb25nZXIgYXJyYXkgYW5kIHhjTCB0byBpdHMgbGVuZ3RoLlxyXG4gICAgICBpZiAoeGNMIDwgeWNMKSB7XHJcbiAgICAgICAgemMgPSB4YztcclxuICAgICAgICB4YyA9IHljO1xyXG4gICAgICAgIHljID0gemM7XHJcbiAgICAgICAgaSA9IHhjTDtcclxuICAgICAgICB4Y0wgPSB5Y0w7XHJcbiAgICAgICAgeWNMID0gaTtcclxuICAgICAgfSAgXHJcblxyXG4gICAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgICAgZm9yIChpID0geGNMICsgeWNMLCB6YyA9IFtdOyBpLS07IHpjLnB1c2goMCkpO1xyXG5cclxuICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgIHNxcnRCYXNlID0gU1FSVF9CQVNFO1xyXG5cclxuICAgICAgZm9yIChpID0geWNMOyAtLWkgPj0gMDspIHtcclxuICAgICAgICBjID0gMDtcclxuICAgICAgICB5bG8gPSB5Y1tpXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgIHloaSA9IHljW2ldIC8gc3FydEJhc2UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKGsgPSB4Y0wsIGogPSBpICsgazsgaiA+IGk7KSB7XHJcbiAgICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XHJcbiAgICAgICAgICB4aGkgPSB4Y1trXSAvIHNxcnRCYXNlIHwgMDtcclxuICAgICAgICAgIG0gPSB5aGkgKiB4bG8gKyB4aGkgKiB5bG87XHJcbiAgICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoKG0gJSBzcXJ0QmFzZSkgKiBzcXJ0QmFzZSkgKyB6Y1tqXSArIGM7XHJcbiAgICAgICAgICBjID0gKHhsbyAvIGJhc2UgfCAwKSArIChtIC8gc3FydEJhc2UgfCAwKSArIHloaSAqIHhoaTtcclxuICAgICAgICAgIHpjW2otLV0gPSB4bG8gJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgemNbal0gPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYykge1xyXG4gICAgICAgICsrZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB6Yy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgemMsIGUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG5lZ2F0ZWQsXHJcbiAgICAgKiBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICAgKi9cclxuICAgIFAubmVnYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICB4LnMgPSAteC5zIHx8IG51bGw7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICsgMCA9IG5cclxuICAgICAqICBuICsgTiA9IE5cclxuICAgICAqICBuICsgSSA9IElcclxuICAgICAqICAwICsgbiA9IG5cclxuICAgICAqICAwICsgMCA9IDBcclxuICAgICAqICAwICsgTiA9IE5cclxuICAgICAqICAwICsgSSA9IElcclxuICAgICAqICBOICsgbiA9IE5cclxuICAgICAqICBOICsgMCA9IE5cclxuICAgICAqICBOICsgTiA9IE5cclxuICAgICAqICBOICsgSSA9IE5cclxuICAgICAqICBJICsgbiA9IElcclxuICAgICAqICBJICsgMCA9IElcclxuICAgICAqICBJICsgTiA9IE5cclxuICAgICAqICBJICsgSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBwbHVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLnBsdXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoYSAvIDApO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkgcmV0dXJuIHljWzBdID8geSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDogYSAqIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcbiAgICAgICAgaWYgKGEgPiAwKSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgICBmb3IgKDsgYS0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhID0geGMubGVuZ3RoO1xyXG4gICAgICBiID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gUG9pbnQgeGMgdG8gdGhlIGxvbmdlciBhcnJheSwgYW5kIGIgdG8gdGhlIHNob3J0ZXIgbGVuZ3RoLlxyXG4gICAgICBpZiAoYSAtIGIgPCAwKSB7XHJcbiAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIHljID0geGM7XHJcbiAgICAgICAgeGMgPSB0O1xyXG4gICAgICAgIGIgPSBhO1xyXG4gICAgICB9ICBcclxuXHJcbiAgICAgIC8vIE9ubHkgc3RhcnQgYWRkaW5nIGF0IHljLmxlbmd0aCAtIDEgYXMgdGhlIGZ1cnRoZXIgZGlnaXRzIG9mIHhjIGNhbiBiZSBpZ25vcmVkLlxyXG4gICAgICBmb3IgKGEgPSAwOyBiOykge1xyXG4gICAgICAgIGEgPSAoeGNbLS1iXSA9IHhjW2JdICsgeWNbYl0gKyBhKSAvIEJBU0UgfCAwO1xyXG4gICAgICAgIHhjW2JdID0gQkFTRSA9PT0geGNbYl0gPyAwIDogeGNbYl0gJSBCQVNFO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYSkge1xyXG4gICAgICAgIHhjID0gW2FdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgKyt5ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG4gICAgICAvLyB5ZSA9IE1BWF9FWFAgKyAxIHBvc3NpYmxlXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBzZCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2ZcclxuICAgICAqIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKiBJZiBzZCBpcyB0cnVlIGluY2x1ZGUgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zIGluIHRoZSBjb3VudC5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIHNkIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2Ygc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogc2Qge251bWJlcnxib29sZWFufSBudW1iZXI6IHNpZ25pZmljYW50IGRpZ2l0czogaW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICBib29sZWFuOiB3aGV0aGVyIHRvIGNvdW50IGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvczogdHJ1ZSBvciBmYWxzZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChzZCAhPSBudWxsICYmIHNkICE9PSAhIXNkKSB7XHJcbiAgICAgICAgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIHNkLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgdiA9IGMubGVuZ3RoIC0gMTtcclxuICAgICAgbiA9IHYgKiBMT0dfQkFTRSArIDE7XHJcblxyXG4gICAgICBpZiAodiA9IGNbdl0pIHtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAodiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIG4rKyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZCAmJiB4LmUgKyAxID4gbikgbiA9IHguZSArIDE7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBzaGlmdGVkIGJ5IGsgcGxhY2VzXHJcbiAgICAgKiAocG93ZXJzIG9mIDEwKS4gU2hpZnQgdG8gdGhlIHJpZ2h0IGlmIG4gPiAwLCBhbmQgdG8gdGhlIGxlZnQgaWYgbiA8IDAuXHJcbiAgICAgKlxyXG4gICAgICogayB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX1NBRkVfSU5URUdFUiB0byBNQVhfU0FGRV9JTlRFR0VSIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2t9J1xyXG4gICAgICovXHJcbiAgICBQLnNoaWZ0ZWRCeSA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgIGludENoZWNrKGssIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKTtcclxuICAgICAgcmV0dXJuIHRoaXMudGltZXMoJzFlJyArIGspO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBzcXJ0KC1uKSA9ICBOXHJcbiAgICAgKiAgc3FydChOKSA9ICBOXHJcbiAgICAgKiAgc3FydCgtSSkgPSAgTlxyXG4gICAgICogIHNxcnQoSSkgPSAgSVxyXG4gICAgICogIHNxcnQoMCkgPSAgMFxyXG4gICAgICogIHNxcnQoLTApID0gLTBcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsXHJcbiAgICAgKiByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgbSwgbiwgciwgcmVwLCB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGMgPSB4LmMsXHJcbiAgICAgICAgcyA9IHgucyxcclxuICAgICAgICBlID0geC5lLFxyXG4gICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMgKyA0LFxyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKCcwLjUnKTtcclxuXHJcbiAgICAgIC8vIE5lZ2F0aXZlL05hTi9JbmZpbml0eS96ZXJvP1xyXG4gICAgICBpZiAocyAhPT0gMSB8fCAhYyB8fCAhY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCFzIHx8IHMgPCAwICYmICghYyB8fCBjWzBdKSA/IE5hTiA6IGMgPyB4IDogMSAvIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gICAgICBzID0gTWF0aC5zcXJ0KCt2YWx1ZU9mKHgpKTtcclxuXHJcbiAgICAgIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgICAgIC8vIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgICAgIGlmIChzID09IDAgfHwgcyA9PSAxIC8gMCkge1xyXG4gICAgICAgIG4gPSBjb2VmZlRvU3RyaW5nKGMpO1xyXG4gICAgICAgIGlmICgobi5sZW5ndGggKyBlKSAlIDIgPT0gMCkgbiArPSAnMCc7XHJcbiAgICAgICAgcyA9IE1hdGguc3FydCgrbik7XHJcbiAgICAgICAgZSA9IGJpdEZsb29yKChlICsgMSkgLyAyKSAtIChlIDwgMCB8fCBlICUgMik7XHJcblxyXG4gICAgICAgIGlmIChzID09IDEgLyAwKSB7XHJcbiAgICAgICAgICBuID0gJzVlJyArIGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIocyArICcnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIHplcm8uXHJcbiAgICAgIC8vIHIgY291bGQgYmUgemVybyBpZiBNSU5fRVhQIGlzIGNoYW5nZWQgYWZ0ZXIgdGhlIHRoaXMgdmFsdWUgd2FzIGNyZWF0ZWQuXHJcbiAgICAgIC8vIFRoaXMgd291bGQgY2F1c2UgYSBkaXZpc2lvbiBieSB6ZXJvICh4L3QpIGFuZCBoZW5jZSBJbmZpbml0eSBiZWxvdywgd2hpY2ggd291bGQgY2F1c2VcclxuICAgICAgLy8gY29lZmZUb1N0cmluZyB0byB0aHJvdy5cclxuICAgICAgaWYgKHIuY1swXSkge1xyXG4gICAgICAgIGUgPSByLmU7XHJcbiAgICAgICAgcyA9IGUgKyBkcDtcclxuICAgICAgICBpZiAocyA8IDMpIHMgPSAwO1xyXG5cclxuICAgICAgICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgICAgICAgZm9yICg7IDspIHtcclxuICAgICAgICAgIHQgPSByO1xyXG4gICAgICAgICAgciA9IGhhbGYudGltZXModC5wbHVzKGRpdih4LCB0LCBkcCwgMSkpKTtcclxuXHJcbiAgICAgICAgICBpZiAoY29lZmZUb1N0cmluZyh0LmMpLnNsaWNlKDAsIHMpID09PSAobiA9IGNvZWZmVG9TdHJpbmcoci5jKSkuc2xpY2UoMCwgcykpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBleHBvbmVudCBvZiByIG1heSBoZXJlIGJlIG9uZSBsZXNzIHRoYW4gdGhlIGZpbmFsIHJlc3VsdCBleHBvbmVudCxcclxuICAgICAgICAgICAgLy8gZS5nIDAuMDAwOTk5OSAoZS00KSAtLT4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgICBpZiAoci5lIDwgZSkgLS1zO1xyXG4gICAgICAgICAgICBuID0gbi5zbGljZShzIC0gMywgcyArIDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSA5OTk5IG9yIDQ5OTkgKGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSkgY29udGludWUgdGhlXHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlXHJcbiAgICAgICAgICAgICAgLy8gZXhhY3QgcmVzdWx0IGFzIHRoZSBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXHJcbiAgICAgICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgICAgIHJvdW5kKHQsIHQuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgZHAgKz0gNDtcclxuICAgICAgICAgICAgICBzICs9IDQ7XHJcbiAgICAgICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGV4YWN0XHJcbiAgICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMSk7XHJcbiAgICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMSwgUk9VTkRJTkdfTU9ERSwgbSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gYW5kXHJcbiAgICAgKiByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHArKztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRpbmdcclxuICAgICAqIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcclxuICAgICAqIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwID0gZHAgKyB0aGlzLmUgKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGVkXHJcbiAgICAgKiB1c2luZyBybSBvciBST1VORElOR19NT0RFIHRvIGRwIGRlY2ltYWwgcGxhY2VzLCBhbmQgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgcHJvcGVydGllc1xyXG4gICAgICogb2YgdGhlIGZvcm1hdCBvciBGT1JNQVQgb2JqZWN0IChzZWUgQmlnTnVtYmVyLnNldCkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGZvcm1hdHRpbmcgb2JqZWN0IG1heSBjb250YWluIHNvbWUgb3IgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIHNob3duIGJlbG93LlxyXG4gICAgICpcclxuICAgICAqIEZPUk1BVCA9IHtcclxuICAgICAqICAgcHJlZml4OiAnJyxcclxuICAgICAqICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICogICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgKiAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgKiAgIHN1ZmZpeDogJydcclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICogW2Zvcm1hdF0ge29iamVjdH0gRm9ybWF0dGluZyBvcHRpb25zLiBTZWUgRk9STUFUIHBiamVjdCBhYm92ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCBub3QgYW4gb2JqZWN0OiB7Zm9ybWF0fSdcclxuICAgICAqL1xyXG4gICAgUC50b0Zvcm1hdCA9IGZ1bmN0aW9uIChkcCwgcm0sIGZvcm1hdCkge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGRwICE9IG51bGwgJiYgcm0gJiYgdHlwZW9mIHJtID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBybTtcclxuICAgICAgICAgIHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKGRwICYmIHR5cGVvZiBkcCA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gZHA7XHJcbiAgICAgICAgICBkcCA9IHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9ybWF0ID0gRk9STUFUO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ICE9ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCBub3QgYW4gb2JqZWN0OiAnICsgZm9ybWF0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0geC50b0ZpeGVkKGRwLCBybSk7XHJcblxyXG4gICAgICBpZiAoeC5jKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICAgIGcxID0gK2Zvcm1hdC5ncm91cFNpemUsXHJcbiAgICAgICAgICBnMiA9ICtmb3JtYXQuc2Vjb25kYXJ5R3JvdXBTaXplLFxyXG4gICAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBmb3JtYXQuZ3JvdXBTZXBhcmF0b3IgfHwgJycsXHJcbiAgICAgICAgICBpbnRQYXJ0ID0gYXJyWzBdLFxyXG4gICAgICAgICAgZnJhY3Rpb25QYXJ0ID0gYXJyWzFdLFxyXG4gICAgICAgICAgaXNOZWcgPSB4LnMgPCAwLFxyXG4gICAgICAgICAgaW50RGlnaXRzID0gaXNOZWcgPyBpbnRQYXJ0LnNsaWNlKDEpIDogaW50UGFydCxcclxuICAgICAgICAgIGxlbiA9IGludERpZ2l0cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChnMikge1xyXG4gICAgICAgICAgaSA9IGcxO1xyXG4gICAgICAgICAgZzEgPSBnMjtcclxuICAgICAgICAgIGcyID0gaTtcclxuICAgICAgICAgIGxlbiAtPSBpO1xyXG4gICAgICAgIH0gIFxyXG5cclxuICAgICAgICBpZiAoZzEgPiAwICYmIGxlbiA+IDApIHtcclxuICAgICAgICAgIGkgPSBsZW4gJSBnMSB8fCBnMTtcclxuICAgICAgICAgIGludFBhcnQgPSBpbnREaWdpdHMuc3Vic3RyKDAsIGkpO1xyXG4gICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkgKz0gZzEpIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc3Vic3RyKGksIGcxKTtcclxuICAgICAgICAgIGlmIChnMiA+IDApIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc2xpY2UoaSk7XHJcbiAgICAgICAgICBpZiAoaXNOZWcpIGludFBhcnQgPSAnLScgKyBpbnRQYXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gZnJhY3Rpb25QYXJ0XHJcbiAgICAgICAgID8gaW50UGFydCArIChmb3JtYXQuZGVjaW1hbFNlcGFyYXRvciB8fCAnJykgKyAoKGcyID0gK2Zvcm1hdC5mcmFjdGlvbkdyb3VwU2l6ZSlcclxuICAgICAgICAgID8gZnJhY3Rpb25QYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXGR7JyArIGcyICsgJ31cXFxcQicsICdnJyksXHJcbiAgICAgICAgICAgJyQmJyArIChmb3JtYXQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB8fCAnJykpXHJcbiAgICAgICAgICA6IGZyYWN0aW9uUGFydClcclxuICAgICAgICAgOiBpbnRQYXJ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gKGZvcm1hdC5wcmVmaXggfHwgJycpICsgc3RyICsgKGZvcm1hdC5zdWZmaXggfHwgJycpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiB0d28gQmlnTnVtYmVycyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGFzIGEgc2ltcGxlXHJcbiAgICAgKiBmcmFjdGlvbiB3aXRoIGFuIGludGVnZXIgbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLlxyXG4gICAgICogVGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgYSBwb3NpdGl2ZSBub24temVybyB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZFxyXG4gICAgICogbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlXHJcbiAgICAgKiB0aGUgbG93ZXN0IHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAgICpcclxuICAgICAqIFttZF0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBJbnRlZ2VyID49IDEsIG9yIEluZmluaXR5LiBUaGUgbWF4aW11bSBkZW5vbWluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX0gOiB7bWR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRnJhY3Rpb24gPSBmdW5jdGlvbiAobWQpIHtcclxuICAgICAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGV4cCwgbiwgbjAsIG4xLCBxLCByLCBzLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jO1xyXG5cclxuICAgICAgaWYgKG1kICE9IG51bGwpIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XHJcblxyXG4gICAgICAgIC8vIFRocm93IGlmIG1kIGlzIGxlc3MgdGhhbiBvbmUgb3IgaXMgbm90IGFuIGludGVnZXIsIHVubGVzcyBpdCBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkgJiYgKG4uYyB8fCBuLnMgIT09IDEpIHx8IG4ubHQoT05FKSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50ICcgK1xyXG4gICAgICAgICAgICAgIChuLmlzSW50ZWdlcigpID8gJ291dCBvZiByYW5nZTogJyA6ICdub3QgYW4gaW50ZWdlcjogJykgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgheGMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG5cclxuICAgICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgbjEgPSBkMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgZDEgPSBuMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgcyA9IGNvZWZmVG9TdHJpbmcoeGMpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZGVub21pbmF0b3IuXHJcbiAgICAgIC8vIGQgaXMgYSBwb3dlciBvZiAxMCBhbmQgdGhlIG1pbmltdW0gbWF4IGRlbm9taW5hdG9yIHRoYXQgc3BlY2lmaWVzIHRoZSB2YWx1ZSBleGFjdGx5LlxyXG4gICAgICBlID0gZC5lID0gcy5sZW5ndGggLSB4LmUgLSAxO1xyXG4gICAgICBkLmNbMF0gPSBQT1dTX1RFTlsoZXhwID0gZSAlIExPR19CQVNFKSA8IDAgPyBMT0dfQkFTRSArIGV4cCA6IGV4cF07XHJcbiAgICAgIG1kID0gIW1kIHx8IG4uY29tcGFyZWRUbyhkKSA+IDAgPyAoZSA+IDAgPyBkIDogbjEpIDogbjtcclxuXHJcbiAgICAgIGV4cCA9IE1BWF9FWFA7XHJcbiAgICAgIE1BWF9FWFAgPSAxIC8gMDtcclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIocyk7XHJcblxyXG4gICAgICAvLyBuMCA9IGQxID0gMFxyXG4gICAgICBuMC5jWzBdID0gMDtcclxuXHJcbiAgICAgIGZvciAoOyA7KSAge1xyXG4gICAgICAgIHEgPSBkaXYobiwgZCwgMCwgMSk7XHJcbiAgICAgICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcclxuICAgICAgICBpZiAoZDIuY29tcGFyZWRUbyhtZCkgPT0gMSkgYnJlYWs7XHJcbiAgICAgICAgZDAgPSBkMTtcclxuICAgICAgICBkMSA9IGQyO1xyXG4gICAgICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyID0gbjEpKTtcclxuICAgICAgICBuMCA9IGQyO1xyXG4gICAgICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIgPSBkKSk7XHJcbiAgICAgICAgbiA9IGQyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkMiA9IGRpdihtZC5taW51cyhkMCksIGQxLCAwLCAxKTtcclxuICAgICAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XHJcbiAgICAgIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xyXG4gICAgICBuMC5zID0gbjEucyA9IHgucztcclxuICAgICAgZSA9IGUgKiAyO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMVxyXG4gICAgICByID0gZGl2KG4xLCBkMSwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkuY29tcGFyZWRUbyhcclxuICAgICAgICAgIGRpdihuMCwgZDAsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpKSA8IDEgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICAgICAgTUFYX0VYUCA9IGV4cDtcclxuXHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICAgICAqL1xyXG4gICAgUC50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICt2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtIG9yIFJPVU5ESU5HX01PREUuIElmIHNkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0c1xyXG4gICAgICogbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiwgdGhlbiB1c2VcclxuICAgICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIGlmIChzZCAhPSBudWxsKSBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBzZCwgcm0sIDIpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGJhc2UgYiwgb3IgYmFzZSAxMCBpZiBiIGlzXHJcbiAgICAgKiBvbWl0dGVkLiBJZiBhIGJhc2UgaXMgc3BlY2lmaWVkLCBpbmNsdWRpbmcgYmFzZSAxMCwgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxyXG4gICAgICogUk9VTkRJTkdfTU9ERS4gSWYgYSBiYXNlIGlzIG5vdCBzcGVjaWZpZWQsIGFuZCB0aGlzIEJpZ051bWJlciBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgICogdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVE9fRVhQX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW5cclxuICAgICAqIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbYl0ge251bWJlcn0gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAqL1xyXG4gICAgUC50b1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgbiA9IHRoaXMsXHJcbiAgICAgICAgcyA9IG4ucyxcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgLy8gSW5maW5pdHkgb3IgTmFOP1xyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICBzdHIgPSAnSW5maW5pdHknO1xyXG4gICAgICAgICAgaWYgKHMgPCAwKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0ciA9ICdOYU4nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XHJcbiAgICAgICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgICAgPyB0b0V4cG9uZW50aWFsKGNvZWZmVG9TdHJpbmcobi5jKSwgZSlcclxuICAgICAgICAgICA6IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBERUNJTUFMX1BMQUNFUyArIGUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIG4uZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG4gICAgICAgICAgc3RyID0gY29udmVydEJhc2UodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKSwgMTAsIGIsIHMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHMgPCAwICYmIG4uY1swXSkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhcyB0b1N0cmluZywgYnV0IGRvIG5vdCBhY2NlcHQgYSBiYXNlIGFyZ3VtZW50LCBhbmQgaW5jbHVkZSB0aGUgbWludXMgc2lnbiBmb3JcclxuICAgICAqIG5lZ2F0aXZlIHplcm8uXHJcbiAgICAgKi9cclxuICAgIFAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFAuX2lzQmlnTnVtYmVyID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoY29uZmlnT2JqZWN0ICE9IG51bGwpIEJpZ051bWJlci5zZXQoY29uZmlnT2JqZWN0KTtcclxuXHJcbiAgICByZXR1cm4gQmlnTnVtYmVyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFBSSVZBVEUgSEVMUEVSIEZVTkNUSU9OU1xyXG5cclxuICAvLyBUaGVzZSBmdW5jdGlvbnMgZG9uJ3QgbmVlZCBhY2Nlc3MgdG8gdmFyaWFibGVzLFxyXG4gIC8vIGUuZy4gREVDSU1BTF9QTEFDRVMsIGluIHRoZSBzY29wZSBvZiB0aGUgYGNsb25lYCBmdW5jdGlvbiBhYm92ZS5cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGJpdEZsb29yKG4pIHtcclxuICAgIHZhciBpID0gbiB8IDA7XHJcbiAgICByZXR1cm4gbiA+IDAgfHwgbiA9PT0gaSA/IGkgOiBpIC0gMTtcclxuICB9XHJcblxyXG5cclxuICAvLyBSZXR1cm4gYSBjb2VmZmljaWVudCBhcnJheSBhcyBhIHN0cmluZyBvZiBiYXNlIDEwIGRpZ2l0cy5cclxuICBmdW5jdGlvbiBjb2VmZlRvU3RyaW5nKGEpIHtcclxuICAgIHZhciBzLCB6LFxyXG4gICAgICBpID0gMSxcclxuICAgICAgaiA9IGEubGVuZ3RoLFxyXG4gICAgICByID0gYVswXSArICcnO1xyXG5cclxuICAgIGZvciAoOyBpIDwgajspIHtcclxuICAgICAgcyA9IGFbaSsrXSArICcnO1xyXG4gICAgICB6ID0gTE9HX0JBU0UgLSBzLmxlbmd0aDtcclxuICAgICAgZm9yICg7IHotLTsgcyA9ICcwJyArIHMpO1xyXG4gICAgICByICs9IHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChqID0gci5sZW5ndGg7IHIuY2hhckNvZGVBdCgtLWopID09PSA0ODspO1xyXG5cclxuICAgIHJldHVybiByLnNsaWNlKDAsIGogKyAxIHx8IDEpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIENvbXBhcmUgdGhlIHZhbHVlIG9mIEJpZ051bWJlcnMgeCBhbmQgeS5cclxuICBmdW5jdGlvbiBjb21wYXJlKHgsIHkpIHtcclxuICAgIHZhciBhLCBiLFxyXG4gICAgICB4YyA9IHguYyxcclxuICAgICAgeWMgPSB5LmMsXHJcbiAgICAgIGkgPSB4LnMsXHJcbiAgICAgIGogPSB5LnMsXHJcbiAgICAgIGsgPSB4LmUsXHJcbiAgICAgIGwgPSB5LmU7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTj9cclxuICAgIGlmICghaSB8fCAhaikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgYSA9IHhjICYmICF4Y1swXTtcclxuICAgIGIgPSB5YyAmJiAheWNbMF07XHJcblxyXG4gICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICBpZiAoYSB8fCBiKSByZXR1cm4gYSA/IGIgPyAwIDogLWogOiBpO1xyXG5cclxuICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgIGlmIChpICE9IGopIHJldHVybiBpO1xyXG5cclxuICAgIGEgPSBpIDwgMDtcclxuICAgIGIgPSBrID09IGw7XHJcblxyXG4gICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBiID8gMCA6ICF4YyBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgICBpZiAoIWIpIHJldHVybiBrID4gbCBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgaiA9IChrID0geGMubGVuZ3RoKSA8IChsID0geWMubGVuZ3RoKSA/IGsgOiBsO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgajsgaSsrKSBpZiAoeGNbaV0gIT0geWNbaV0pIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgICByZXR1cm4gayA9PSBsID8gMCA6IGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIENoZWNrIHRoYXQgbiBpcyBhIHByaW1pdGl2ZSBudW1iZXIsIGFuIGludGVnZXIsIGFuZCBpbiByYW5nZSwgb3RoZXJ3aXNlIHRocm93LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGludENoZWNrKG4sIG1pbiwgbWF4LCBuYW1lKSB7XHJcbiAgICBpZiAobiA8IG1pbiB8fCBuID4gbWF4IHx8IG4gIT09IG1hdGhmbG9vcihuKSkge1xyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgKGJpZ251bWJlckVycm9yICsgKG5hbWUgfHwgJ0FyZ3VtZW50JykgKyAodHlwZW9mIG4gPT0gJ251bWJlcidcclxuICAgICAgICAgPyBuIDwgbWluIHx8IG4gPiBtYXggPyAnIG91dCBvZiByYW5nZTogJyA6ICcgbm90IGFuIGludGVnZXI6ICdcclxuICAgICAgICAgOiAnIG5vdCBhIHByaW1pdGl2ZSBudW1iZXI6ICcpICsgU3RyaW5nKG4pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBBc3N1bWVzIGZpbml0ZSBuLlxyXG4gIGZ1bmN0aW9uIGlzT2RkKG4pIHtcclxuICAgIHZhciBrID0gbi5jLmxlbmd0aCAtIDE7XHJcbiAgICByZXR1cm4gYml0Rmxvb3Iobi5lIC8gTE9HX0JBU0UpID09IGsgJiYgbi5jW2tdICUgMiAhPSAwO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRXhwb25lbnRpYWwoc3RyLCBlKSB7XHJcbiAgICByZXR1cm4gKHN0ci5sZW5ndGggPiAxID8gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSA6IHN0cikgK1xyXG4gICAgIChlIDwgMCA/ICdlJyA6ICdlKycpICsgZTtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCB6KSB7XHJcbiAgICB2YXIgbGVuLCB6cztcclxuXHJcbiAgICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICAgIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcy5cclxuICAgICAgZm9yICh6cyA9IHogKyAnLic7ICsrZTsgenMgKz0geik7XHJcbiAgICAgIHN0ciA9IHpzICsgc3RyO1xyXG5cclxuICAgIC8vIFBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zLlxyXG4gICAgICBpZiAoKytlID4gbGVuKSB7XHJcbiAgICAgICAgZm9yICh6cyA9IHosIGUgLT0gbGVuOyAtLWU7IHpzICs9IHopO1xyXG4gICAgICAgIHN0ciArPSB6cztcclxuICAgICAgfSBlbHNlIGlmIChlIDwgbGVuKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIGUpICsgJy4nICsgc3RyLnNsaWNlKGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9XHJcblxyXG5cclxuICAvLyBFWFBPUlRcclxuXHJcblxyXG4gIEJpZ051bWJlciA9IGNsb25lKCk7XHJcbiAgQmlnTnVtYmVyWydkZWZhdWx0J10gPSBCaWdOdW1iZXIuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBBTUQuXHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gQmlnTnVtYmVyOyB9KTtcclxuXHJcbiAgLy8gTm9kZS5qcyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cy5cclxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBCcm93c2VyLlxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoIWdsb2JhbE9iamVjdCkge1xyXG4gICAgICBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmID8gc2VsZiA6IHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICBnbG9iYWxPYmplY3QuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG4gIH1cclxufSkodGhpcyk7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBLFdBVUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///431\n")},187:module=>{"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanM/MDk1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///187\n")},219:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXIvZGlzdC9hcGkuanM/MjhiMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///219\n')},510:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TvmException = exports.Contract = void 0;\nconst utils_1 = __webpack_require__(786);\nconst models_1 = __webpack_require__(851);\n/**\n * @category Contract\n */\nclass Contract {\n    constructor(provider, abi, address) {\n        if (!Array.isArray(abi.functions)) {\n            throw new Error('Invalid abi. Functions array required');\n        }\n        if (!Array.isArray(abi.events)) {\n            throw new Error('Invalid abi. Events array required');\n        }\n        this._provider = provider;\n        this._abi = JSON.stringify(abi);\n        this._functions = abi.functions.reduce((functions, item) => {\n            functions[item.name] = { inputs: item.inputs || [], outputs: item.outputs || [] };\n            return functions;\n        }, {});\n        this._events = abi.events.reduce((events, item) => {\n            events[item.name] = { inputs: item.inputs || [] };\n            return events;\n        }, {});\n        this._address = address;\n        this._methods = new Proxy({}, {\n            get: (_object, method) => {\n                const rawAbi = this._functions[method];\n                return (params = {}) => new ContractMethodImpl(this._provider, rawAbi, this._abi, this._address, method, params);\n            },\n        });\n    }\n    get methods() {\n        return this._methods;\n    }\n    get address() {\n        return this._address;\n    }\n    get abi() {\n        return this._abi;\n    }\n    /**\n     * Requests contract data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getFullState() {\n        await this._provider.ensureInitialized();\n        return await this._provider.rawApi.getFullContractState({\n            address: this.address.toString(),\n        });\n    }\n    /**\n     * Creates new contract transactions stream\n     *\n     * @param subscriber\n     */\n    transactions(subscriber) {\n        return subscriber.transactions(this._address)\n            .flatMap(({ transactions }) => transactions);\n    }\n    /**\n     * Creates new contract events stream\n     *\n     * @param subscriber\n     */\n    events(subscriber) {\n        return subscriber.transactions(this._address)\n            .flatMap(({ transactions }) => transactions)\n            .flatMap((tx) => this.decodeTransactionEvents({ transaction: tx }).then((events) => {\n            events.forEach((event) => event.transaction = tx);\n            return events;\n        }));\n    }\n    async waitForEvent(args = {}) {\n        const { range, filter } = args;\n        const filterFn = typeof filter === 'string'\n            ? ({ event }) => event === filter\n            : filter;\n        let subscriber = args.subscriber;\n        const hasTempSubscriber = subscriber == null;\n        if (subscriber == null) {\n            subscriber = new this._provider.Subscriber();\n        }\n        const event = await (((range === null || range === void 0 ? void 0 : range.fromLt) != null || (range === null || range === void 0 ? void 0 : range.fromUtime) != null)\n            ? subscriber.oldTransactions(this._address, range)\n                .merge(subscriber.transactions(this._address))\n            : subscriber.transactions(this.address)).flatMap(item => item.transactions)\n            .takeWhile(item => range == null ||\n            (range.fromLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.fromLt) > 0) &&\n                (range.fromUtime == null || item.createdAt > range.fromUtime) &&\n                (range.toLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.toLt) < 0) &&\n                (range.toUtime == null || item.createdAt < range.toUtime))\n            .flatMap(tx => this.decodeTransactionEvents({ transaction: tx })\n            .then((events) => {\n            events.forEach((event) => event.transaction = tx);\n            return events;\n        }))\n            .filterMap(async (event) => {\n            if (filterFn == null || (await filterFn(event))) {\n                return event;\n            }\n            else {\n                return undefined;\n            }\n        })\n            .first();\n        hasTempSubscriber && (await subscriber.unsubscribe());\n        return event;\n    }\n    async getPastEvents(args) {\n        const { range, filter, limit } = args;\n        const filterFn = typeof filter === 'string'\n            ? ({ event }) => event === filter\n            : filter;\n        const result = [];\n        let currentContinuation = args === null || args === void 0 ? void 0 : args.continuation;\n        outer: while (true) {\n            const { transactions, continuation } = await this._provider.getTransactions({\n                address: this._address,\n                continuation: currentContinuation,\n            });\n            if (transactions.length === null) {\n                break;\n            }\n            const filteredTransactions = transactions.filter((item) => (((range === null || range === void 0 ? void 0 : range.fromLt) == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.fromLt) > 0) &&\n                ((range === null || range === void 0 ? void 0 : range.fromUtime) == null || item.createdAt > range.fromUtime) &&\n                ((range === null || range === void 0 ? void 0 : range.toLt) == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.toLt) < 0) &&\n                ((range === null || range === void 0 ? void 0 : range.toUtime) == null || item.createdAt < range.toUtime)));\n            if (filteredTransactions.length > 0) {\n                const parsedEvents = await Promise.all(filteredTransactions.map(async (tx) => {\n                    return {\n                        tx, events: await this.decodeTransactionEvents({ transaction: tx }).then((events) => {\n                            events.forEach((event) => event.transaction = tx);\n                            return events;\n                        }),\n                    };\n                }));\n                for (let { tx, events } of parsedEvents) {\n                    if (filterFn != null) {\n                        events = await Promise.all(events.map(async (event) => (await filterFn(event)) ? event : undefined)).then(events => events.filter((event) => event != null));\n                    }\n                    currentContinuation = tx.id; // update continuation in case of early break\n                    for (const event of events) {\n                        if (limit != null && result.length >= limit) {\n                            break outer;\n                        }\n                        result.push(event);\n                    }\n                    if (limit != null && result.length >= limit) {\n                        break outer;\n                    }\n                }\n            }\n            currentContinuation = continuation;\n            if (currentContinuation == null) {\n                break;\n            }\n        }\n        return { events: result, continuation: currentContinuation };\n    }\n    async decodeTransaction(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeTransaction({\n                transaction: (0, models_1.serializeTransaction)(args.transaction),\n                abi: this._abi,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            const { method, input, output } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},\n                output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeTransactionEvents(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const { events } = await this._provider.rawApi.decodeTransactionEvents({\n                transaction: (0, models_1.serializeTransaction)(args.transaction),\n                abi: this._abi,\n            });\n            const result = [];\n            for (const { event, data } of events) {\n                const rawAbi = this._events[event];\n                result.push({\n                    event,\n                    data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {},\n                });\n            }\n            return result;\n        }\n        catch (_) {\n            return [];\n        }\n    }\n    async decodeInputMessage(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeInput({\n                abi: this._abi,\n                body: args.body,\n                internal: args.internal,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            const { method, input } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeOutputMessage(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeOutput({\n                abi: this._abi,\n                body: args.body,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            const { method, output } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeEvent(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeEvent({\n                abi: this.abi,\n                body: args.body,\n                event: args.events,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            const { event, data } = result;\n            const rawAbi = this._events[event];\n            return {\n                event,\n                data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n}\nexports.Contract = Contract;\n/**\n * @category Contract\n */\nclass TvmException extends Error {\n    constructor(code) {\n        super(`TvmException: ${code}`);\n        this.code = code;\n    }\n}\nexports.TvmException = TvmException;\nclass ContractMethodImpl {\n    constructor(provider, functionAbi, abi, address, method, params) {\n        this.provider = provider;\n        this.functionAbi = functionAbi;\n        this.abi = abi;\n        this.address = address;\n        this.method = method;\n        this.params = (0, models_1.serializeTokensObject)(params);\n    }\n    async send(args) {\n        await this.provider.ensureInitialized();\n        const { transaction } = await this.provider.rawApi.sendMessage({\n            sender: args.from.toString(),\n            recipient: this.address.toString(),\n            amount: args.amount,\n            bounce: args.bounce == null ? true : args.bounce,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n        });\n        return (0, models_1.parseTransaction)(transaction);\n    }\n    async sendDelayed(args) {\n        await this.provider.ensureInitialized();\n        const transactions = new utils_1.DelayedTransactions;\n        const subscription = await this.provider.subscribe('messageStatusUpdated');\n        subscription.on('data', (data) => {\n            if (!data.address.equals(args.from)) {\n                return;\n            }\n            transactions.fillTransaction(data.hash, data.transaction);\n        });\n        const { message } = await this.provider.rawApi.sendMessageDelayed({\n            sender: args.from.toString(),\n            recipient: this.address.toString(),\n            amount: args.amount,\n            bounce: args.bounce == null ? true : args.bounce,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n        }).catch(e => {\n            subscription.unsubscribe().catch(console.error);\n            throw e;\n        });\n        const transaction = transactions\n            .waitTransaction(this.address, message.hash)\n            .finally(() => subscription.unsubscribe().catch(console.error));\n        return {\n            messageHash: message.hash,\n            expireAt: message.expireAt,\n            transaction,\n        };\n    }\n    async sendWithResult(args) {\n        await this.provider.ensureInitialized();\n        let subscriber = args.subscriber;\n        const hasTempSubscriber = subscriber == null;\n        if (subscriber == null) {\n            subscriber = new this.provider.Subscriber();\n        }\n        try {\n            // Parent transaction from wallet\n            let parentTransaction = undefined;\n            // Child transaction promise\n            let resolveChildTransactionPromise;\n            const childTransactionPromise = new Promise((resolve) => {\n                resolveChildTransactionPromise = (tx) => resolve(tx);\n            });\n            // Array for collecting transactions on target before parent transaction promise resolution\n            const possibleChildren = [];\n            // Subscribe to this account\n            subscriber.transactions(this.address)\n                .flatMap(batch => batch.transactions)\n                // Listen only messages from sender\n                .filter(item => { var _a; return ((_a = item.inMessage.src) === null || _a === void 0 ? void 0 : _a.equals(args.from)) || false; })\n                .on((tx) => {\n                if (parentTransaction == null) {\n                    // If we don't known whether the message was sent just collect all transactions from the sender\n                    possibleChildren.push(tx);\n                }\n                else if (parentTransaction.possibleMessages.findIndex((msg) => msg.hash == tx.inMessage.hash) >= 0) {\n                    // Resolve promise if transaction was found\n                    resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(tx);\n                }\n            });\n            // Send message\n            const transaction = await this.send(args);\n            // Extract all outgoing messages from the parent transaction to this contract\n            const possibleMessages = transaction.outMessages.filter(msg => { var _a; return ((_a = msg.dst) === null || _a === void 0 ? void 0 : _a.equals(this.address)) || false; });\n            // Update stream state\n            parentTransaction = {\n                transaction,\n                possibleMessages,\n            };\n            // Check whether child transaction was already found\n            const alreadyReceived = possibleChildren.find((tx) => {\n                return possibleMessages.findIndex((msg) => msg.hash == tx.inMessage.hash) >= 0;\n            });\n            if (alreadyReceived != null) {\n                resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(alreadyReceived);\n            }\n            const childTransaction = await childTransactionPromise;\n            // Parse output\n            let output = undefined;\n            try {\n                const result = await this.provider.rawApi.decodeTransaction({\n                    transaction: (0, models_1.serializeTransaction)(childTransaction),\n                    abi: this.abi,\n                    method: this.method,\n                });\n                if (result != null) {\n                    output = this.functionAbi.outputs != null\n                        ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, result.output)\n                        : {};\n                }\n            }\n            catch (e) {\n                console.error(e);\n            }\n            // Done\n            return {\n                parentTransaction: parentTransaction.transaction,\n                childTransaction,\n                output,\n            };\n        }\n        finally {\n            hasTempSubscriber && (await subscriber.unsubscribe());\n        }\n    }\n    async estimateFees(args) {\n        await this.provider.ensureInitialized();\n        const { fees } = await this.provider.rawApi.estimateFees({\n            sender: args.from.toString(),\n            recipient: this.address.toString(),\n            amount: args.amount,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n        });\n        return fees;\n    }\n    async sendExternal(args) {\n        await this.provider.ensureInitialized();\n        const method = args.withoutSignature === true\n            ? this.provider.rawApi.sendUnsignedExternalMessage\n            : this.provider.rawApi.sendExternalMessage;\n        const { transaction, output } = await method({\n            publicKey: args.publicKey,\n            recipient: this.address.toString(),\n            stateInit: args.stateInit,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n            local: args.local,\n        });\n        return {\n            transaction: (0, models_1.parseTransaction)(transaction),\n            output: output != null ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, output) : undefined,\n        };\n    }\n    async sendExternalDelayed(args) {\n        await this.provider.ensureInitialized();\n        const transactions = new utils_1.DelayedTransactions;\n        const subscription = await this.provider.subscribe('messageStatusUpdated');\n        subscription.on('data', (data) => {\n            if (!data.address.equals(this.address)) {\n                return;\n            }\n            transactions.fillTransaction(data.hash, data.transaction);\n        });\n        const { message } = await this.provider.rawApi.sendExternalMessageDelayed({\n            publicKey: args.publicKey,\n            recipient: this.address.toString(),\n            stateInit: args.stateInit,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n        }).catch(e => {\n            subscription.unsubscribe().catch(console.error);\n            throw e;\n        });\n        const transaction = transactions\n            .waitTransaction(this.address, message.hash)\n            .finally(() => subscription.unsubscribe().catch(console.error));\n        return {\n            messageHash: message.hash,\n            expireAt: message.expireAt,\n            transaction,\n        };\n    }\n    async call(args = {}) {\n        await this.provider.ensureInitialized();\n        const { output, code } = await this.provider.rawApi.runLocal({\n            address: this.address.toString(),\n            cachedState: args.cachedState,\n            responsible: args.responsible,\n            functionCall: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n        });\n        if (output == null || code != 0) {\n            throw new TvmException(code);\n        }\n        else {\n            return (0, models_1.parseTokensObject)(this.functionAbi.outputs, output);\n        }\n    }\n    async encodeInternal() {\n        await this.provider.ensureInitialized();\n        const { boc } = await this.provider.rawApi.encodeInternalInput({\n            abi: this.abi,\n            method: this.method,\n            params: this.params,\n        });\n        return boc;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXIvZGlzdC9jb250cmFjdC5qcz9jODBkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Udm1FeGNlcHRpb24gPSBleHBvcnRzLkNvbnRyYWN0ID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgbW9kZWxzXzEgPSByZXF1aXJlKFwiLi9tb2RlbHNcIik7XG4vKipcbiAqIEBjYXRlZ29yeSBDb250cmFjdFxuICovXG5jbGFzcyBDb250cmFjdCB7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFiaSwgYWRkcmVzcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWJpLmZ1bmN0aW9ucykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhYmkuIEZ1bmN0aW9ucyBhcnJheSByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhYmkuZXZlbnRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFiaS4gRXZlbnRzIGFycmF5IHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5fYWJpID0gSlNPTi5zdHJpbmdpZnkoYWJpKTtcbiAgICAgICAgdGhpcy5fZnVuY3Rpb25zID0gYWJpLmZ1bmN0aW9ucy5yZWR1Y2UoKGZ1bmN0aW9ucywgaXRlbSkgPT4ge1xuICAgICAgICAgICAgZnVuY3Rpb25zW2l0ZW0ubmFtZV0gPSB7IGlucHV0czogaXRlbS5pbnB1dHMgfHwgW10sIG91dHB1dHM6IGl0ZW0ub3V0cHV0cyB8fCBbXSB9O1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9ucztcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBhYmkuZXZlbnRzLnJlZHVjZSgoZXZlbnRzLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICBldmVudHNbaXRlbS5uYW1lXSA9IHsgaW5wdXRzOiBpdGVtLmlucHV0cyB8fCBbXSB9O1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLl9hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5fbWV0aG9kcyA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgZ2V0OiAoX29iamVjdCwgbWV0aG9kKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3QWJpID0gdGhpcy5fZnVuY3Rpb25zW21ldGhvZF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwYXJhbXMgPSB7fSkgPT4gbmV3IENvbnRyYWN0TWV0aG9kSW1wbCh0aGlzLl9wcm92aWRlciwgcmF3QWJpLCB0aGlzLl9hYmksIHRoaXMuX2FkZHJlc3MsIG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWV0aG9kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGhvZHM7XG4gICAgfVxuICAgIGdldCBhZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkcmVzcztcbiAgICB9XG4gICAgZ2V0IGFiaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FiaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgY29udHJhY3QgZGF0YVxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBnZXRGdWxsU3RhdGUoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3Byb3ZpZGVyLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9wcm92aWRlci5yYXdBcGkuZ2V0RnVsbENvbnRyYWN0U3RhdGUoe1xuICAgICAgICAgICAgYWRkcmVzczogdGhpcy5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG5ldyBjb250cmFjdCB0cmFuc2FjdGlvbnMgc3RyZWFtXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3Vic2NyaWJlclxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9ucyhzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyLnRyYW5zYWN0aW9ucyh0aGlzLl9hZGRyZXNzKVxuICAgICAgICAgICAgLmZsYXRNYXAoKHsgdHJhbnNhY3Rpb25zIH0pID0+IHRyYW5zYWN0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IGNvbnRyYWN0IGV2ZW50cyBzdHJlYW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJzY3JpYmVyXG4gICAgICovXG4gICAgZXZlbnRzKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXIudHJhbnNhY3Rpb25zKHRoaXMuX2FkZHJlc3MpXG4gICAgICAgICAgICAuZmxhdE1hcCgoeyB0cmFuc2FjdGlvbnMgfSkgPT4gdHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgLmZsYXRNYXAoKHR4KSA9PiB0aGlzLmRlY29kZVRyYW5zYWN0aW9uRXZlbnRzKHsgdHJhbnNhY3Rpb246IHR4IH0pLnRoZW4oKGV2ZW50cykgPT4ge1xuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiBldmVudC50cmFuc2FjdGlvbiA9IHR4KTtcbiAgICAgICAgICAgIHJldHVybiBldmVudHM7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgd2FpdEZvckV2ZW50KGFyZ3MgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHJhbmdlLCBmaWx0ZXIgfSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IGZpbHRlckZuID0gdHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gKHsgZXZlbnQgfSkgPT4gZXZlbnQgPT09IGZpbHRlclxuICAgICAgICAgICAgOiBmaWx0ZXI7XG4gICAgICAgIGxldCBzdWJzY3JpYmVyID0gYXJncy5zdWJzY3JpYmVyO1xuICAgICAgICBjb25zdCBoYXNUZW1wU3Vic2NyaWJlciA9IHN1YnNjcmliZXIgPT0gbnVsbDtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlciA9IG5ldyB0aGlzLl9wcm92aWRlci5TdWJzY3JpYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnQgPSBhd2FpdCAoKChyYW5nZSA9PT0gbnVsbCB8fCByYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFuZ2UuZnJvbUx0KSAhPSBudWxsIHx8IChyYW5nZSA9PT0gbnVsbCB8fCByYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFuZ2UuZnJvbVV0aW1lKSAhPSBudWxsKVxuICAgICAgICAgICAgPyBzdWJzY3JpYmVyLm9sZFRyYW5zYWN0aW9ucyh0aGlzLl9hZGRyZXNzLCByYW5nZSlcbiAgICAgICAgICAgICAgICAubWVyZ2Uoc3Vic2NyaWJlci50cmFuc2FjdGlvbnModGhpcy5fYWRkcmVzcykpXG4gICAgICAgICAgICA6IHN1YnNjcmliZXIudHJhbnNhY3Rpb25zKHRoaXMuYWRkcmVzcykpLmZsYXRNYXAoaXRlbSA9PiBpdGVtLnRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIC50YWtlV2hpbGUoaXRlbSA9PiByYW5nZSA9PSBudWxsIHx8XG4gICAgICAgICAgICAocmFuZ2UuZnJvbUx0ID09IG51bGwgfHwgdXRpbHNfMS5MVF9DT0xMQVRPUi5jb21wYXJlKGl0ZW0uaWQubHQsIHJhbmdlLmZyb21MdCkgPiAwKSAmJlxuICAgICAgICAgICAgICAgIChyYW5nZS5mcm9tVXRpbWUgPT0gbnVsbCB8fCBpdGVtLmNyZWF0ZWRBdCA+IHJhbmdlLmZyb21VdGltZSkgJiZcbiAgICAgICAgICAgICAgICAocmFuZ2UudG9MdCA9PSBudWxsIHx8IHV0aWxzXzEuTFRfQ09MTEFUT1IuY29tcGFyZShpdGVtLmlkLmx0LCByYW5nZS50b0x0KSA8IDApICYmXG4gICAgICAgICAgICAgICAgKHJhbmdlLnRvVXRpbWUgPT0gbnVsbCB8fCBpdGVtLmNyZWF0ZWRBdCA8IHJhbmdlLnRvVXRpbWUpKVxuICAgICAgICAgICAgLmZsYXRNYXAodHggPT4gdGhpcy5kZWNvZGVUcmFuc2FjdGlvbkV2ZW50cyh7IHRyYW5zYWN0aW9uOiB0eCB9KVxuICAgICAgICAgICAgLnRoZW4oKGV2ZW50cykgPT4ge1xuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiBldmVudC50cmFuc2FjdGlvbiA9IHR4KTtcbiAgICAgICAgICAgIHJldHVybiBldmVudHM7XG4gICAgICAgIH0pKVxuICAgICAgICAgICAgLmZpbHRlck1hcChhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJGbiA9PSBudWxsIHx8IChhd2FpdCBmaWx0ZXJGbihldmVudCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maXJzdCgpO1xuICAgICAgICBoYXNUZW1wU3Vic2NyaWJlciAmJiAoYXdhaXQgc3Vic2NyaWJlci51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgICBhc3luYyBnZXRQYXN0RXZlbnRzKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgeyByYW5nZSwgZmlsdGVyLCBsaW1pdCB9ID0gYXJncztcbiAgICAgICAgY29uc3QgZmlsdGVyRm4gPSB0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyAoeyBldmVudCB9KSA9PiBldmVudCA9PT0gZmlsdGVyXG4gICAgICAgICAgICA6IGZpbHRlcjtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBjdXJyZW50Q29udGludWF0aW9uID0gYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLmNvbnRpbnVhdGlvbjtcbiAgICAgICAgb3V0ZXI6IHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9ucywgY29udGludWF0aW9uIH0gPSBhd2FpdCB0aGlzLl9wcm92aWRlci5nZXRUcmFuc2FjdGlvbnMoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuX2FkZHJlc3MsXG4gICAgICAgICAgICAgICAgY29udGludWF0aW9uOiBjdXJyZW50Q29udGludWF0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRUcmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMuZmlsdGVyKChpdGVtKSA9PiAoKChyYW5nZSA9PT0gbnVsbCB8fCByYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFuZ2UuZnJvbUx0KSA9PSBudWxsIHx8IHV0aWxzXzEuTFRfQ09MTEFUT1IuY29tcGFyZShpdGVtLmlkLmx0LCByYW5nZS5mcm9tTHQpID4gMCkgJiZcbiAgICAgICAgICAgICAgICAoKHJhbmdlID09PSBudWxsIHx8IHJhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByYW5nZS5mcm9tVXRpbWUpID09IG51bGwgfHwgaXRlbS5jcmVhdGVkQXQgPiByYW5nZS5mcm9tVXRpbWUpICYmXG4gICAgICAgICAgICAgICAgKChyYW5nZSA9PT0gbnVsbCB8fCByYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFuZ2UudG9MdCkgPT0gbnVsbCB8fCB1dGlsc18xLkxUX0NPTExBVE9SLmNvbXBhcmUoaXRlbS5pZC5sdCwgcmFuZ2UudG9MdCkgPCAwKSAmJlxuICAgICAgICAgICAgICAgICgocmFuZ2UgPT09IG51bGwgfHwgcmFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhbmdlLnRvVXRpbWUpID09IG51bGwgfHwgaXRlbS5jcmVhdGVkQXQgPCByYW5nZS50b1V0aW1lKSkpO1xuICAgICAgICAgICAgaWYgKGZpbHRlcmVkVHJhbnNhY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRFdmVudHMgPSBhd2FpdCBQcm9taXNlLmFsbChmaWx0ZXJlZFRyYW5zYWN0aW9ucy5tYXAoYXN5bmMgKHR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eCwgZXZlbnRzOiBhd2FpdCB0aGlzLmRlY29kZVRyYW5zYWN0aW9uRXZlbnRzKHsgdHJhbnNhY3Rpb246IHR4IH0pLnRoZW4oKGV2ZW50cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4gZXZlbnQudHJhbnNhY3Rpb24gPSB0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB7IHR4LCBldmVudHMgfSBvZiBwYXJzZWRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlckZuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cyA9IGF3YWl0IFByb21pc2UuYWxsKGV2ZW50cy5tYXAoYXN5bmMgKGV2ZW50KSA9PiAoYXdhaXQgZmlsdGVyRm4oZXZlbnQpKSA/IGV2ZW50IDogdW5kZWZpbmVkKSkudGhlbihldmVudHMgPT4gZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IGV2ZW50ICE9IG51bGwpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGludWF0aW9uID0gdHguaWQ7IC8vIHVwZGF0ZSBjb250aW51YXRpb24gaW4gY2FzZSBvZiBlYXJseSBicmVha1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbWl0ICE9IG51bGwgJiYgcmVzdWx0Lmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCAhPSBudWxsICYmIHJlc3VsdC5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudENvbnRpbnVhdGlvbiA9IGNvbnRpbnVhdGlvbjtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29udGludWF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBldmVudHM6IHJlc3VsdCwgY29udGludWF0aW9uOiBjdXJyZW50Q29udGludWF0aW9uIH07XG4gICAgfVxuICAgIGFzeW5jIGRlY29kZVRyYW5zYWN0aW9uKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fcHJvdmlkZXIuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3Byb3ZpZGVyLnJhd0FwaS5kZWNvZGVUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246ICgwLCBtb2RlbHNfMS5zZXJpYWxpemVUcmFuc2FjdGlvbikoYXJncy50cmFuc2FjdGlvbiksXG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLl9hYmksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBhcmdzLm1ldGhvZHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IG1ldGhvZCwgaW5wdXQsIG91dHB1dCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgcmF3QWJpID0gdGhpcy5fZnVuY3Rpb25zW21ldGhvZF07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBpbnB1dDogcmF3QWJpLmlucHV0cyAhPSBudWxsID8gKDAsIG1vZGVsc18xLnBhcnNlVG9rZW5zT2JqZWN0KShyYXdBYmkuaW5wdXRzLCBpbnB1dCkgOiB7fSxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHJhd0FiaS5vdXRwdXRzICE9IG51bGwgPyAoMCwgbW9kZWxzXzEucGFyc2VUb2tlbnNPYmplY3QpKHJhd0FiaS5vdXRwdXRzLCBvdXRwdXQpIDoge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlY29kZVRyYW5zYWN0aW9uRXZlbnRzKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fcHJvdmlkZXIuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXZlbnRzIH0gPSBhd2FpdCB0aGlzLl9wcm92aWRlci5yYXdBcGkuZGVjb2RlVHJhbnNhY3Rpb25FdmVudHMoe1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiAoMCwgbW9kZWxzXzEuc2VyaWFsaXplVHJhbnNhY3Rpb24pKGFyZ3MudHJhbnNhY3Rpb24pLFxuICAgICAgICAgICAgICAgIGFiaTogdGhpcy5fYWJpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBldmVudCwgZGF0YSB9IG9mIGV2ZW50cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhd0FiaSA9IHRoaXMuX2V2ZW50c1tldmVudF07XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogcmF3QWJpLmlucHV0cyAhPSBudWxsID8gKDAsIG1vZGVsc18xLnBhcnNlVG9rZW5zT2JqZWN0KShyYXdBYmkuaW5wdXRzLCBkYXRhKSA6IHt9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlY29kZUlucHV0TWVzc2FnZShhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3Byb3ZpZGVyLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9wcm92aWRlci5yYXdBcGkuZGVjb2RlSW5wdXQoe1xuICAgICAgICAgICAgICAgIGFiaTogdGhpcy5fYWJpLFxuICAgICAgICAgICAgICAgIGJvZHk6IGFyZ3MuYm9keSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbDogYXJncy5pbnRlcm5hbCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGFyZ3MubWV0aG9kcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgbWV0aG9kLCBpbnB1dCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgcmF3QWJpID0gdGhpcy5fZnVuY3Rpb25zW21ldGhvZF07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBpbnB1dDogcmF3QWJpLmlucHV0cyAhPSBudWxsID8gKDAsIG1vZGVsc18xLnBhcnNlVG9rZW5zT2JqZWN0KShyYXdBYmkuaW5wdXRzLCBpbnB1dCkgOiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVjb2RlT3V0cHV0TWVzc2FnZShhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3Byb3ZpZGVyLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9wcm92aWRlci5yYXdBcGkuZGVjb2RlT3V0cHV0KHtcbiAgICAgICAgICAgICAgICBhYmk6IHRoaXMuX2FiaSxcbiAgICAgICAgICAgICAgICBib2R5OiBhcmdzLmJvZHksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBhcmdzLm1ldGhvZHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IG1ldGhvZCwgb3V0cHV0IH0gPSByZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCByYXdBYmkgPSB0aGlzLl9mdW5jdGlvbnNbbWV0aG9kXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgIG91dHB1dDogcmF3QWJpLm91dHB1dHMgIT0gbnVsbCA/ICgwLCBtb2RlbHNfMS5wYXJzZVRva2Vuc09iamVjdCkocmF3QWJpLm91dHB1dHMsIG91dHB1dCkgOiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVjb2RlRXZlbnQoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLl9wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fcHJvdmlkZXIucmF3QXBpLmRlY29kZUV2ZW50KHtcbiAgICAgICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgICAgIGJvZHk6IGFyZ3MuYm9keSxcbiAgICAgICAgICAgICAgICBldmVudDogYXJncy5ldmVudHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGV2ZW50LCBkYXRhIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCByYXdBYmkgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBkYXRhOiByYXdBYmkuaW5wdXRzICE9IG51bGwgPyAoMCwgbW9kZWxzXzEucGFyc2VUb2tlbnNPYmplY3QpKHJhd0FiaS5pbnB1dHMsIGRhdGEpIDoge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Db250cmFjdCA9IENvbnRyYWN0O1xuLyoqXG4gKiBAY2F0ZWdvcnkgQ29udHJhY3RcbiAqL1xuY2xhc3MgVHZtRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICAgICAgc3VwZXIoYFR2bUV4Y2VwdGlvbjogJHtjb2RlfWApO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuVHZtRXhjZXB0aW9uID0gVHZtRXhjZXB0aW9uO1xuY2xhc3MgQ29udHJhY3RNZXRob2RJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZnVuY3Rpb25BYmksIGFiaSwgYWRkcmVzcywgbWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uQWJpID0gZnVuY3Rpb25BYmk7XG4gICAgICAgIHRoaXMuYWJpID0gYWJpO1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSAoMCwgbW9kZWxzXzEuc2VyaWFsaXplVG9rZW5zT2JqZWN0KShwYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJhd0FwaS5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICBzZW5kZXI6IGFyZ3MuZnJvbS50b1N0cmluZygpLFxuICAgICAgICAgICAgcmVjaXBpZW50OiB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGFtb3VudDogYXJncy5hbW91bnQsXG4gICAgICAgICAgICBib3VuY2U6IGFyZ3MuYm91bmNlID09IG51bGwgPyB0cnVlIDogYXJncy5ib3VuY2UsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogdGhpcy5wYXJhbXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgwLCBtb2RlbHNfMS5wYXJzZVRyYW5zYWN0aW9uKSh0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIHNlbmREZWxheWVkKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBuZXcgdXRpbHNfMS5EZWxheWVkVHJhbnNhY3Rpb25zO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnN1YnNjcmliZSgnbWVzc2FnZVN0YXR1c1VwZGF0ZWQnKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmICghZGF0YS5hZGRyZXNzLmVxdWFscyhhcmdzLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNhY3Rpb25zLmZpbGxUcmFuc2FjdGlvbihkYXRhLmhhc2gsIGRhdGEudHJhbnNhY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJhd0FwaS5zZW5kTWVzc2FnZURlbGF5ZWQoe1xuICAgICAgICAgICAgc2VuZGVyOiBhcmdzLmZyb20udG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHJlY2lwaWVudDogdGhpcy5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBhbW91bnQ6IGFyZ3MuYW1vdW50LFxuICAgICAgICAgICAgYm91bmNlOiBhcmdzLmJvdW5jZSA9PSBudWxsID8gdHJ1ZSA6IGFyZ3MuYm91bmNlLFxuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgIGFiaTogdGhpcy5hYmksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHRoaXMucGFyYW1zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgLndhaXRUcmFuc2FjdGlvbih0aGlzLmFkZHJlc3MsIG1lc3NhZ2UuaGFzaClcbiAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpLmNhdGNoKGNvbnNvbGUuZXJyb3IpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2VIYXNoOiBtZXNzYWdlLmhhc2gsXG4gICAgICAgICAgICBleHBpcmVBdDogbWVzc2FnZS5leHBpcmVBdCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzZW5kV2l0aFJlc3VsdChhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXIuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgbGV0IHN1YnNjcmliZXIgPSBhcmdzLnN1YnNjcmliZXI7XG4gICAgICAgIGNvbnN0IGhhc1RlbXBTdWJzY3JpYmVyID0gc3Vic2NyaWJlciA9PSBudWxsO1xuICAgICAgICBpZiAoc3Vic2NyaWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyID0gbmV3IHRoaXMucHJvdmlkZXIuU3Vic2NyaWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBQYXJlbnQgdHJhbnNhY3Rpb24gZnJvbSB3YWxsZXRcbiAgICAgICAgICAgIGxldCBwYXJlbnRUcmFuc2FjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIENoaWxkIHRyYW5zYWN0aW9uIHByb21pc2VcbiAgICAgICAgICAgIGxldCByZXNvbHZlQ2hpbGRUcmFuc2FjdGlvblByb21pc2U7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFRyYW5zYWN0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNoaWxkVHJhbnNhY3Rpb25Qcm9taXNlID0gKHR4KSA9PiByZXNvbHZlKHR4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQXJyYXkgZm9yIGNvbGxlY3RpbmcgdHJhbnNhY3Rpb25zIG9uIHRhcmdldCBiZWZvcmUgcGFyZW50IHRyYW5zYWN0aW9uIHByb21pc2UgcmVzb2x1dGlvblxuICAgICAgICAgICAgY29uc3QgcG9zc2libGVDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoaXMgYWNjb3VudFxuICAgICAgICAgICAgc3Vic2NyaWJlci50cmFuc2FjdGlvbnModGhpcy5hZGRyZXNzKVxuICAgICAgICAgICAgICAgIC5mbGF0TWFwKGJhdGNoID0+IGJhdGNoLnRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgICAgICAvLyBMaXN0ZW4gb25seSBtZXNzYWdlcyBmcm9tIHNlbmRlclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSBpdGVtLmluTWVzc2FnZS5zcmMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lcXVhbHMoYXJncy5mcm9tKSkgfHwgZmFsc2U7IH0pXG4gICAgICAgICAgICAgICAgLm9uKCh0eCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGtub3duIHdoZXRoZXIgdGhlIG1lc3NhZ2Ugd2FzIHNlbnQganVzdCBjb2xsZWN0IGFsbCB0cmFuc2FjdGlvbnMgZnJvbSB0aGUgc2VuZGVyXG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2hpbGRyZW4ucHVzaCh0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudFRyYW5zYWN0aW9uLnBvc3NpYmxlTWVzc2FnZXMuZmluZEluZGV4KChtc2cpID0+IG1zZy5oYXNoID09IHR4LmluTWVzc2FnZS5oYXNoKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgcHJvbWlzZSBpZiB0cmFuc2FjdGlvbiB3YXMgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNoaWxkVHJhbnNhY3Rpb25Qcm9taXNlID09PSBudWxsIHx8IHJlc29sdmVDaGlsZFRyYW5zYWN0aW9uUHJvbWlzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzb2x2ZUNoaWxkVHJhbnNhY3Rpb25Qcm9taXNlKHR4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFNlbmQgbWVzc2FnZVxuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLnNlbmQoYXJncyk7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IGFsbCBvdXRnb2luZyBtZXNzYWdlcyBmcm9tIHRoZSBwYXJlbnQgdHJhbnNhY3Rpb24gdG8gdGhpcyBjb250cmFjdFxuICAgICAgICAgICAgY29uc3QgcG9zc2libGVNZXNzYWdlcyA9IHRyYW5zYWN0aW9uLm91dE1lc3NhZ2VzLmZpbHRlcihtc2cgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gbXNnLmRzdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVxdWFscyh0aGlzLmFkZHJlc3MpKSB8fCBmYWxzZTsgfSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgc3RyZWFtIHN0YXRlXG4gICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBwb3NzaWJsZU1lc3NhZ2VzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgY2hpbGQgdHJhbnNhY3Rpb24gd2FzIGFscmVhZHkgZm91bmRcbiAgICAgICAgICAgIGNvbnN0IGFscmVhZHlSZWNlaXZlZCA9IHBvc3NpYmxlQ2hpbGRyZW4uZmluZCgodHgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zc2libGVNZXNzYWdlcy5maW5kSW5kZXgoKG1zZykgPT4gbXNnLmhhc2ggPT0gdHguaW5NZXNzYWdlLmhhc2gpID49IDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhbHJlYWR5UmVjZWl2ZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVDaGlsZFRyYW5zYWN0aW9uUHJvbWlzZSA9PT0gbnVsbCB8fCByZXNvbHZlQ2hpbGRUcmFuc2FjdGlvblByb21pc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc29sdmVDaGlsZFRyYW5zYWN0aW9uUHJvbWlzZShhbHJlYWR5UmVjZWl2ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hpbGRUcmFuc2FjdGlvbiA9IGF3YWl0IGNoaWxkVHJhbnNhY3Rpb25Qcm9taXNlO1xuICAgICAgICAgICAgLy8gUGFyc2Ugb3V0cHV0XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJhd0FwaS5kZWNvZGVUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiAoMCwgbW9kZWxzXzEuc2VyaWFsaXplVHJhbnNhY3Rpb24pKGNoaWxkVHJhbnNhY3Rpb24pLFxuICAgICAgICAgICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLmZ1bmN0aW9uQWJpLm91dHB1dHMgIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoMCwgbW9kZWxzXzEucGFyc2VUb2tlbnNPYmplY3QpKHRoaXMuZnVuY3Rpb25BYmkub3V0cHV0cywgcmVzdWx0Lm91dHB1dClcbiAgICAgICAgICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG9uZVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbjogcGFyZW50VHJhbnNhY3Rpb24udHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgY2hpbGRUcmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaGFzVGVtcFN1YnNjcmliZXIgJiYgKGF3YWl0IHN1YnNjcmliZXIudW5zdWJzY3JpYmUoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZXN0aW1hdGVGZWVzKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IGZlZXMgfSA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmF3QXBpLmVzdGltYXRlRmVlcyh7XG4gICAgICAgICAgICBzZW5kZXI6IGFyZ3MuZnJvbS50b1N0cmluZygpLFxuICAgICAgICAgICAgcmVjaXBpZW50OiB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGFtb3VudDogYXJncy5hbW91bnQsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogdGhpcy5wYXJhbXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZlZXM7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRFeHRlcm5hbChhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXIuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gYXJncy53aXRob3V0U2lnbmF0dXJlID09PSB0cnVlXG4gICAgICAgICAgICA/IHRoaXMucHJvdmlkZXIucmF3QXBpLnNlbmRVbnNpZ25lZEV4dGVybmFsTWVzc2FnZVxuICAgICAgICAgICAgOiB0aGlzLnByb3ZpZGVyLnJhd0FwaS5zZW5kRXh0ZXJuYWxNZXNzYWdlO1xuICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9uLCBvdXRwdXQgfSA9IGF3YWl0IG1ldGhvZCh7XG4gICAgICAgICAgICBwdWJsaWNLZXk6IGFyZ3MucHVibGljS2V5LFxuICAgICAgICAgICAgcmVjaXBpZW50OiB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHN0YXRlSW5pdDogYXJncy5zdGF0ZUluaXQsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogdGhpcy5wYXJhbXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9jYWw6IGFyZ3MubG9jYWwsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246ICgwLCBtb2RlbHNfMS5wYXJzZVRyYW5zYWN0aW9uKSh0cmFuc2FjdGlvbiksXG4gICAgICAgICAgICBvdXRwdXQ6IG91dHB1dCAhPSBudWxsID8gKDAsIG1vZGVsc18xLnBhcnNlVG9rZW5zT2JqZWN0KSh0aGlzLmZ1bmN0aW9uQWJpLm91dHB1dHMsIG91dHB1dCkgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHNlbmRFeHRlcm5hbERlbGF5ZWQoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLnByb3ZpZGVyLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IG5ldyB1dGlsc18xLkRlbGF5ZWRUcmFuc2FjdGlvbnM7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IHRoaXMucHJvdmlkZXIuc3Vic2NyaWJlKCdtZXNzYWdlU3RhdHVzVXBkYXRlZCcpO1xuICAgICAgICBzdWJzY3JpcHRpb24ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkYXRhLmFkZHJlc3MuZXF1YWxzKHRoaXMuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2FjdGlvbnMuZmlsbFRyYW5zYWN0aW9uKGRhdGEuaGFzaCwgZGF0YS50cmFuc2FjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmF3QXBpLnNlbmRFeHRlcm5hbE1lc3NhZ2VEZWxheWVkKHtcbiAgICAgICAgICAgIHB1YmxpY0tleTogYXJncy5wdWJsaWNLZXksXG4gICAgICAgICAgICByZWNpcGllbnQ6IHRoaXMuYWRkcmVzcy50b1N0cmluZygpLFxuICAgICAgICAgICAgc3RhdGVJbml0OiBhcmdzLnN0YXRlSW5pdCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB0aGlzLnBhcmFtcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgIC53YWl0VHJhbnNhY3Rpb24odGhpcy5hZGRyZXNzLCBtZXNzYWdlLmhhc2gpXG4gICAgICAgICAgICAuZmluYWxseSgoKSA9PiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKS5jYXRjaChjb25zb2xlLmVycm9yKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlSGFzaDogbWVzc2FnZS5oYXNoLFxuICAgICAgICAgICAgZXhwaXJlQXQ6IG1lc3NhZ2UuZXhwaXJlQXQsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbChhcmdzID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IG91dHB1dCwgY29kZSB9ID0gYXdhaXQgdGhpcy5wcm92aWRlci5yYXdBcGkucnVuTG9jYWwoe1xuICAgICAgICAgICAgYWRkcmVzczogdGhpcy5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBjYWNoZWRTdGF0ZTogYXJncy5jYWNoZWRTdGF0ZSxcbiAgICAgICAgICAgIHJlc3BvbnNpYmxlOiBhcmdzLnJlc3BvbnNpYmxlLFxuICAgICAgICAgICAgZnVuY3Rpb25DYWxsOiB7XG4gICAgICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogdGhpcy5wYXJhbXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dHB1dCA9PSBudWxsIHx8IGNvZGUgIT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR2bUV4Y2VwdGlvbihjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgbW9kZWxzXzEucGFyc2VUb2tlbnNPYmplY3QpKHRoaXMuZnVuY3Rpb25BYmkub3V0cHV0cywgb3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBlbmNvZGVJbnRlcm5hbCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IGJvYyB9ID0gYXdhaXQgdGhpcy5wcm92aWRlci5yYXdBcGkuZW5jb2RlSW50ZXJuYWxJbnB1dCh7XG4gICAgICAgICAgICBhYmk6IHRoaXMuYWJpLFxuICAgICAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy5wYXJhbXMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYm9jO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///510\n")},511:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ProviderNotInitializedException = exports.ProviderNotFoundException = exports.ProviderRpcClient = exports.hasEverscaleProvider = exports.LT_COLLATOR = exports.mergeTransactions = exports.MessageExpiredException = exports.AddressLiteral = exports.Address = exports.Subscriber = void 0;\nconst models_1 = __webpack_require__(851);\nconst utils_1 = __webpack_require__(786);\nconst subscriber = __importStar(__webpack_require__(25));\nconst contract = __importStar(__webpack_require__(510));\n__exportStar(__webpack_require__(219), exports);\n__exportStar(__webpack_require__(851), exports);\n__exportStar(__webpack_require__(510), exports);\nvar stream_1 = __webpack_require__(25);\nObject.defineProperty(exports, \"Subscriber\", ({ enumerable: true, get: function () { return stream_1.Subscriber; } }));\nvar utils_2 = __webpack_require__(786);\nObject.defineProperty(exports, \"Address\", ({ enumerable: true, get: function () { return utils_2.Address; } }));\nObject.defineProperty(exports, \"AddressLiteral\", ({ enumerable: true, get: function () { return utils_2.AddressLiteral; } }));\nObject.defineProperty(exports, \"MessageExpiredException\", ({ enumerable: true, get: function () { return utils_2.MessageExpiredException; } }));\nObject.defineProperty(exports, \"mergeTransactions\", ({ enumerable: true, get: function () { return utils_2.mergeTransactions; } }));\nObject.defineProperty(exports, \"LT_COLLATOR\", ({ enumerable: true, get: function () { return utils_2.LT_COLLATOR; } }));\nconst isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\nlet ensurePageLoaded;\nif (!isBrowser || document.readyState === 'complete') {\n    ensurePageLoaded = Promise.resolve();\n}\nelse {\n    ensurePageLoaded = new Promise((resolve) => {\n        window.addEventListener('load', () => {\n            resolve();\n        });\n    });\n}\nconst getProvider = () => isBrowser ? window.__ever || window.ton : undefined;\n/**\n * @category Provider\n */\nasync function hasEverscaleProvider() {\n    if (!isBrowser) {\n        return false;\n    }\n    await ensurePageLoaded;\n    return window.__hasEverscaleProvider === true || window.hasTonProvider === true;\n}\nexports.hasEverscaleProvider = hasEverscaleProvider;\n/**\n * @category Provider\n */\nclass ProviderRpcClient {\n    constructor(properties = {}) {\n        this._subscriptions = {\n            connected: new Map(),\n            disconnected: new Map(),\n            transactionsFound: new Map(),\n            contractStateChanged: new Map(),\n            messageStatusUpdated: new Map(),\n            networkChanged: new Map(),\n            permissionsChanged: new Map(),\n            loggedOut: new Map(),\n        };\n        this._contractSubscriptions = new Map();\n        this._properties = properties;\n        const self = this;\n        // Create contract proxy type\n        class ProviderContract extends contract.Contract {\n            constructor(abi, address) {\n                super(self, abi, address);\n            }\n        }\n        this.Contract = ProviderContract;\n        // Create subscriber proxy type\n        class ProviderSubscriber extends subscriber.Subscriber {\n            constructor() {\n                super(self);\n            }\n        }\n        this.Subscriber = ProviderSubscriber;\n        // Wrap provider requests\n        this._api = new Proxy({}, {\n            get: (_object, method) => (params) => {\n                if (this._provider != null) {\n                    return this._provider.request({ method, params });\n                }\n                else {\n                    throw new ProviderNotInitializedException();\n                }\n            },\n        });\n        if (properties.forceUseFallback === true) {\n            this._initializationPromise = properties.fallback != null\n                ? properties.fallback()\n                    .then((provider) => {\n                    this._provider = provider;\n                })\n                : Promise.resolve();\n        }\n        else {\n            // Initialize provider with injected object by default\n            this._provider = getProvider();\n            if (this._provider != null) {\n                // Provider as already injected\n                this._initializationPromise = Promise.resolve();\n            }\n            else {\n                // Wait until page is loaded and initialization complete\n                this._initializationPromise = hasEverscaleProvider()\n                    .then((hasProvider) => new Promise((resolve) => {\n                    if (!hasProvider) {\n                        // Fully loaded page doesn't even contain provider flag\n                        return resolve();\n                    }\n                    // Wait injected provider initialization otherwise\n                    this._provider = getProvider();\n                    if (this._provider != null) {\n                        resolve();\n                    }\n                    else {\n                        const eventName = window.__hasEverscaleProvider === true ? 'ever#initialized' : 'ton#initialized';\n                        window.addEventListener(eventName, (_) => {\n                            this._provider = getProvider();\n                            resolve();\n                        });\n                    }\n                }))\n                    .then(async () => {\n                    if (this._provider == null && properties.fallback != null) {\n                        this._provider = await properties.fallback();\n                    }\n                });\n            }\n        }\n        // Will only register handlers for successfully loaded injected provider\n        this._initializationPromise.then(() => {\n            if (this._provider != null) {\n                this._registerEventHandlers(this._provider);\n            }\n        });\n    }\n    /**\n     * Checks whether this page has injected Everscale provider or\n     * there is a fallback provider.\n     */\n    async hasProvider() {\n        if (this._properties.fallback != null) {\n            return true;\n        }\n        return hasEverscaleProvider();\n    }\n    /**\n     * Waits until provider api will be available. Calls `fallback` if no provider was found\n     *\n     * @throws ProviderNotFoundException when no provider found\n     */\n    async ensureInitialized() {\n        await this._initializationPromise;\n        if (this._provider == null) {\n            throw new ProviderNotFoundException();\n        }\n    }\n    /**\n     * Whether provider api is ready\n     */\n    get isInitialized() {\n        return this._provider != null;\n    }\n    /**\n     * Raw provider\n     */\n    get raw() {\n        if (this._provider != null) {\n            return this._provider;\n        }\n        else {\n            throw new ProviderNotInitializedException();\n        }\n    }\n    /**\n     * Raw provider api\n     */\n    get rawApi() {\n        return this._api;\n    }\n    /**\n     * Creates typed contract wrapper.\n     *\n     * @param abi Readonly object (must be declared with `as const`)\n     * @param address Default contract address\n     *\n     * @deprecated `new ever.Contract(abi, address)` should be used instead\n     */\n    createContract(abi, address) {\n        return new this.Contract(abi, address);\n    }\n    /**\n     * Creates subscriptions group\n     *\n     * @deprecated `new ever.Subscriber()` should be used instead\n     */\n    createSubscriber() {\n        return new this.Subscriber();\n    }\n    /**\n     * Requests new permissions for current origin.\n     * Shows an approval window to the user.\n     * Will overwrite already existing permissions\n     *\n     * ---\n     * Required permissions: none\n     */\n    async requestPermissions(args) {\n        await this.ensureInitialized();\n        const result = await this._api.requestPermissions({\n            permissions: args.permissions,\n        });\n        return (0, models_1.parsePermissions)(result);\n    }\n    /**\n     * Updates `accountInteraction` permission value\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async changeAccount() {\n        await this.ensureInitialized();\n        await this._api.changeAccount();\n    }\n    /**\n     * Removes all permissions for current origin and stops all subscriptions\n     */\n    async disconnect() {\n        await this.ensureInitialized();\n        await this._api.disconnect();\n    }\n    async subscribe(eventName, params) {\n        class SubscriptionImpl {\n            constructor(_subscribe, _unsubscribe) {\n                this._subscribe = _subscribe;\n                this._unsubscribe = _unsubscribe;\n                this._listeners = {\n                    data: [],\n                    subscribed: [],\n                    unsubscribed: [],\n                };\n                this._subscribed = false;\n                this.subscribe = async () => {\n                    if (this._subscribed) {\n                        return;\n                    }\n                    this._subscribed = true;\n                    await this._subscribe(this);\n                    for (const handler of this._listeners['subscribed']) {\n                        handler();\n                    }\n                };\n                this.unsubscribe = async () => {\n                    if (!this._subscribed) {\n                        return;\n                    }\n                    this._subscribed = false;\n                    await this._unsubscribe();\n                    for (const handler of this._listeners['unsubscribed']) {\n                        handler();\n                    }\n                };\n            }\n            on(eventName, listener) {\n                this._listeners[eventName].push(listener);\n                return this;\n            }\n            notify(data) {\n                for (const handler of this._listeners['data']) {\n                    handler(data);\n                }\n            }\n        }\n        const existingSubscriptions = this._subscriptions[eventName];\n        const id = (0, utils_1.getUniqueId)();\n        switch (eventName) {\n            case 'connected':\n            case 'disconnected':\n            case 'messageStatusUpdated':\n            case 'networkChanged':\n            case 'permissionsChanged':\n            case 'loggedOut': {\n                const subscription = new SubscriptionImpl(async (subscription) => {\n                    if (existingSubscriptions.has(id)) {\n                        return;\n                    }\n                    existingSubscriptions.set(id, (data) => {\n                        subscription.notify(data);\n                    });\n                }, async () => {\n                    existingSubscriptions.delete(id);\n                });\n                await subscription.subscribe();\n                return subscription;\n            }\n            case 'transactionsFound':\n            case 'contractStateChanged': {\n                if (params == null) {\n                    throw new Error('Address must be specified for the subscription');\n                }\n                await this.ensureInitialized();\n                const address = params.address.toString();\n                const subscription = new SubscriptionImpl(async (subscription) => {\n                    if (existingSubscriptions.has(id)) {\n                        return;\n                    }\n                    existingSubscriptions.set(id, ((data) => {\n                        if (data.address.toString() === address) {\n                            subscription.notify(data);\n                        }\n                    }));\n                    let contractSubscriptions = this._contractSubscriptions.get(address);\n                    if (contractSubscriptions == null) {\n                        contractSubscriptions = new Map();\n                        this._contractSubscriptions.set(address, contractSubscriptions);\n                    }\n                    const subscriptionState = {\n                        state: eventName === 'contractStateChanged',\n                        transactions: eventName === 'transactionsFound',\n                    };\n                    contractSubscriptions.set(id, subscriptionState);\n                    const { total, withoutExcluded, } = foldSubscriptions(contractSubscriptions.values(), subscriptionState);\n                    try {\n                        if (total.transactions !== withoutExcluded.transactions || total.state !== withoutExcluded.state) {\n                            await this.rawApi.subscribe({ address, subscriptions: total });\n                        }\n                    }\n                    catch (e) {\n                        existingSubscriptions.delete(id);\n                        contractSubscriptions.delete(id);\n                        throw e;\n                    }\n                }, async () => {\n                    existingSubscriptions.delete(id);\n                    const contractSubscriptions = this._contractSubscriptions.get(address);\n                    if (contractSubscriptions == null) {\n                        return;\n                    }\n                    const updates = contractSubscriptions.get(id);\n                    const { total, withoutExcluded } = foldSubscriptions(contractSubscriptions.values(), updates);\n                    contractSubscriptions.delete(id);\n                    if (!withoutExcluded.transactions && !withoutExcluded.state) {\n                        await this.rawApi.unsubscribe({ address });\n                    }\n                    else if (total.transactions !== withoutExcluded.transactions || total.state !== withoutExcluded.state) {\n                        await this.rawApi.subscribe({ address, subscriptions: withoutExcluded });\n                    }\n                });\n                await subscription.subscribe();\n                return subscription;\n            }\n            default: {\n                throw new Error(`Unknown event ${eventName}`);\n            }\n        }\n    }\n    /**\n     * Returns provider api state\n     *\n     * ---\n     * Required permissions: none\n     */\n    async getProviderState() {\n        await this.ensureInitialized();\n        const state = await this._api.getProviderState();\n        return {\n            ...state,\n            permissions: (0, models_1.parsePermissions)(state.permissions),\n        };\n    }\n    /**\n     * Requests contract balance\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getBalance(address) {\n        const { state } = await this.getFullContractState({\n            address,\n        });\n        return state == null ? '0' : state === null || state === void 0 ? void 0 : state.balance;\n    }\n    /**\n     * Requests contract data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getFullContractState(args) {\n        await this.ensureInitialized();\n        return await this._api.getFullContractState({\n            address: args.address.toString(),\n        });\n    }\n    /**\n     * Requests accounts with specified code hash\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getAccountsByCodeHash(args) {\n        await this.ensureInitialized();\n        const { accounts, continuation } = await this._api.getAccountsByCodeHash({\n            ...args,\n        });\n        return {\n            accounts: accounts.map((address) => new utils_1.Address(address)),\n            continuation,\n        };\n    }\n    /**\n     * Requests contract transactions\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getTransactions(args) {\n        await this.ensureInitialized();\n        const { transactions, continuation, info } = await this._api.getTransactions({\n            ...args,\n            address: args.address.toString(),\n        });\n        return {\n            transactions: transactions.map(models_1.parseTransaction),\n            continuation,\n            info,\n        };\n    }\n    /**\n     * Searches transaction by hash\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getTransaction(args) {\n        await this.ensureInitialized();\n        const { transaction } = await this._api.getTransaction({\n            ...args,\n        });\n        return {\n            transaction: transaction ? (0, models_1.parseTransaction)(transaction) : undefined,\n        };\n    }\n    /**\n     * Computes contract address from code and init params\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getExpectedAddress(abi, args) {\n        const { address } = await this.getStateInit(abi, args);\n        return address;\n    }\n    /**\n     * Computes contract address and state from code and init params\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getStateInit(abi, args) {\n        await this.ensureInitialized();\n        const { address, stateInit } = await this._api.getExpectedAddress({\n            abi: JSON.stringify(abi),\n            ...args,\n            initParams: (0, models_1.serializeTokensObject)(args.initParams),\n        });\n        return {\n            address: new utils_1.Address(address),\n            stateInit,\n        };\n    }\n    /**\n     * Computes hash of base64 encoded BOC\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getBocHash(boc) {\n        await this.ensureInitialized();\n        return await this._api.getBocHash({\n            boc,\n        }).then(({ hash }) => hash);\n    }\n    /**\n     * Creates base64 encoded BOC\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async packIntoCell(args) {\n        await this.ensureInitialized();\n        return await this._api.packIntoCell({\n            abiVersion: args.abiVersion,\n            structure: args.structure,\n            data: (0, models_1.serializeTokensObject)(args.data),\n        });\n    }\n    /**\n     * Decodes base64 encoded BOC\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async unpackFromCell(args) {\n        await this.ensureInitialized();\n        const { data } = await this._api.unpackFromCell({\n            ...args,\n            structure: args.structure,\n        });\n        return {\n            data: (0, models_1.parseTokensObject)(args.structure, data),\n        };\n    }\n    /**\n     * Extracts public key from raw account state\n     *\n     * **NOTE:** can only be used on contracts which are deployed and has `pubkey` header\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async extractPublicKey(boc) {\n        await this.ensureInitialized();\n        const { publicKey } = await this._api.extractPublicKey({\n            boc,\n        });\n        return publicKey;\n    }\n    /**\n     * Converts base64 encoded contract code into tvc with default init data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async codeToTvc(code) {\n        await this.ensureInitialized();\n        const { tvc } = await this._api.codeToTvc({\n            code,\n        });\n        return tvc;\n    }\n    /**\n     * Merges code and data into state init\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async mergeTvc(args) {\n        await this.ensureInitialized();\n        return await this._api.mergeTvc(args);\n    }\n    /**\n     * Splits base64 encoded state init into code and data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async splitTvc(tvc) {\n        await this.ensureInitialized();\n        return await this._api.splitTvc({\n            tvc,\n        });\n    }\n    /**\n     * Merges code and data into state init\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async setCodeSalt(args) {\n        let salt;\n        if (typeof args.salt === 'string') {\n            await this.ensureInitialized();\n            salt = args.salt;\n        }\n        else {\n            const { boc } = await this.packIntoCell(args.salt);\n            salt = boc;\n        }\n        return await this._api.setCodeSalt({ code: args.code, salt });\n    }\n    /**\n     * Retrieves salt from code. Returns undefined if code doesn't contain salt\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getCodeSalt(args) {\n        await this.ensureInitialized();\n        const { salt } = await this.rawApi.getCodeSalt({\n            code: args.code,\n        });\n        return salt;\n    }\n    /**\n     * Adds asset to the selected account\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async addAsset(args) {\n        await this.ensureInitialized();\n        let params;\n        switch (args.type) {\n            case 'tip3_token': {\n                params = {\n                    rootContract: args.params.rootContract.toString(),\n                };\n                break;\n            }\n            default:\n                throw new Error('Unknown asset type');\n        }\n        return await this._api.addAsset({\n            account: args.account.toString(),\n            type: args.type,\n            params,\n        });\n    }\n    async verifySignature(args) {\n        await this.ensureInitialized();\n        return await this._api.verifySignature(args);\n    }\n    /**\n     * Signs arbitrary data.\n     *\n     * NOTE: hashes data before signing. Use `signDataRaw` to sign without hash.\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async signData(args) {\n        await this.ensureInitialized();\n        return await this._api.signData(args);\n    }\n    /**\n     * Signs arbitrary data without hashing it\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async signDataRaw(args) {\n        await this.ensureInitialized();\n        return await this._api.signDataRaw(args);\n    }\n    /**\n     * Encrypts arbitrary data with specified algorithm for each specified recipient\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async encryptData(args) {\n        await this.ensureInitialized();\n        const { encryptedData } = await this._api.encryptData(args);\n        return encryptedData;\n    }\n    /**\n     * Decrypts encrypted data. Returns base64 encoded data\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async decryptData(encryptedData) {\n        await this.ensureInitialized();\n        const { data } = await this._api.decryptData({ encryptedData });\n        return data;\n    }\n    /**\n     * Sends an internal message from the user account.\n     * Shows an approval window to the user.\n     *\n     * ---\n     * Required permissions: `accountInteraction`\n     */\n    async sendMessage(args) {\n        await this.ensureInitialized();\n        const { transaction } = await this._api.sendMessage({\n            sender: args.sender.toString(),\n            recipient: args.recipient.toString(),\n            amount: args.amount,\n            bounce: args.bounce,\n            payload: args.payload ? ({\n                abi: args.payload.abi,\n                method: args.payload.method,\n                params: (0, models_1.serializeTokensObject)(args.payload.params),\n            }) : undefined,\n        });\n        return {\n            transaction: (0, models_1.parseTransaction)(transaction),\n        };\n    }\n    /**\n     * Sends an internal message from the user account without waiting for the transaction.\n     * Shows an approval window to the user.\n     *\n     * @see messageStatusUpdated\n     *\n     * ---\n     * Required permissions: `accountInteraction`\n     */\n    async sendMessageDelayed(args) {\n        await this.ensureInitialized();\n        const transactions = new utils_1.DelayedTransactions;\n        const subscription = await this.subscribe('messageStatusUpdated');\n        subscription.on('data', (data) => {\n            if (!data.address.equals(args.sender)) {\n                return;\n            }\n            transactions.fillTransaction(data.hash, data.transaction);\n        });\n        const { message } = await this._api.sendMessageDelayed({\n            sender: args.sender.toString(),\n            recipient: args.recipient.toString(),\n            amount: args.amount,\n            bounce: args.bounce,\n            payload: args.payload ? ({\n                abi: args.payload.abi,\n                method: args.payload.method,\n                params: (0, models_1.serializeTokensObject)(args.payload.params),\n            }) : undefined,\n        }).catch(e => {\n            subscription.unsubscribe().catch(console.error);\n            throw e;\n        });\n        const transaction = transactions\n            .waitTransaction(args.sender, message.hash)\n            .finally(() => subscription.unsubscribe().catch(console.error));\n        return {\n            messageHash: message.hash,\n            expireAt: message.expireAt,\n            transaction,\n        };\n    }\n    _registerEventHandlers(provider) {\n        const knownEvents = {\n            'connected': (data) => data,\n            'disconnected': (data) => data,\n            'transactionsFound': (data) => ({\n                address: new utils_1.Address(data.address),\n                transactions: data.transactions.map(models_1.parseTransaction),\n                info: data.info,\n            }),\n            'contractStateChanged': (data) => ({\n                address: new utils_1.Address(data.address),\n                state: data.state,\n            }),\n            'messageStatusUpdated': (data) => ({\n                address: new utils_1.Address(data.address),\n                hash: data.hash,\n                transaction: data.transaction != null ? (0, models_1.parseTransaction)(data.transaction) : undefined,\n            }),\n            'networkChanged': data => data,\n            'permissionsChanged': (data) => ({\n                permissions: (0, models_1.parsePermissions)(data.permissions),\n            }),\n            'loggedOut': data => data,\n        };\n        for (const [eventName, extractor] of Object.entries(knownEvents)) {\n            provider.addListener(eventName, (data) => {\n                const handlers = this._subscriptions[eventName];\n                const parsed = extractor(data);\n                for (const handler of handlers.values()) {\n                    handler(parsed);\n                }\n            });\n        }\n    }\n}\nexports.ProviderRpcClient = ProviderRpcClient;\n/**\n * @category Provider\n */\nclass ProviderNotFoundException extends Error {\n    constructor() {\n        super('Everscale provider was not found');\n    }\n}\nexports.ProviderNotFoundException = ProviderNotFoundException;\n/**\n * @category Provider\n */\nclass ProviderNotInitializedException extends Error {\n    constructor() {\n        super('Everscale provider was not initialized yet');\n    }\n}\nexports.ProviderNotInitializedException = ProviderNotInitializedException;\nfunction foldSubscriptions(subscriptions, except) {\n    const total = { state: false, transactions: false };\n    const withoutExcluded = Object.assign({}, total);\n    for (const item of subscriptions) {\n        if (withoutExcluded.transactions && withoutExcluded.state) {\n            break;\n        }\n        total.state || (total.state = item.state);\n        total.transactions || (total.transactions = item.transactions);\n        if (item !== except) {\n            withoutExcluded.state || (withoutExcluded.state = item.state);\n            withoutExcluded.transactions || (withoutExcluded.transactions = item.transactions);\n        }\n    }\n    return { total, withoutExcluded };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTExLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXIvZGlzdC9pbmRleC5qcz83MTM1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm92aWRlck5vdEluaXRpYWxpemVkRXhjZXB0aW9uID0gZXhwb3J0cy5Qcm92aWRlck5vdEZvdW5kRXhjZXB0aW9uID0gZXhwb3J0cy5Qcm92aWRlclJwY0NsaWVudCA9IGV4cG9ydHMuaGFzRXZlcnNjYWxlUHJvdmlkZXIgPSBleHBvcnRzLkxUX0NPTExBVE9SID0gZXhwb3J0cy5tZXJnZVRyYW5zYWN0aW9ucyA9IGV4cG9ydHMuTWVzc2FnZUV4cGlyZWRFeGNlcHRpb24gPSBleHBvcnRzLkFkZHJlc3NMaXRlcmFsID0gZXhwb3J0cy5BZGRyZXNzID0gZXhwb3J0cy5TdWJzY3JpYmVyID0gdm9pZCAwO1xuY29uc3QgbW9kZWxzXzEgPSByZXF1aXJlKFwiLi9tb2RlbHNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBzdWJzY3JpYmVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3N0cmVhbVwiKSk7XG5jb25zdCBjb250cmFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9jb250cmFjdFwiKSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXBpXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnRyYWN0XCIpLCBleHBvcnRzKTtcbnZhciBzdHJlYW1fMSA9IHJlcXVpcmUoXCIuL3N0cmVhbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN1YnNjcmliZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmVhbV8xLlN1YnNjcmliZXI7IH0gfSk7XG52YXIgdXRpbHNfMiA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5BZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWRkcmVzc0xpdGVyYWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuQWRkcmVzc0xpdGVyYWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlRXhwaXJlZEV4Y2VwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5NZXNzYWdlRXhwaXJlZEV4Y2VwdGlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1lcmdlVHJhbnNhY3Rpb25zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLm1lcmdlVHJhbnNhY3Rpb25zOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTFRfQ09MTEFUT1JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuTFRfQ09MTEFUT1I7IH0gfSk7XG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbmxldCBlbnN1cmVQYWdlTG9hZGVkO1xuaWYgKCFpc0Jyb3dzZXIgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgIGVuc3VyZVBhZ2VMb2FkZWQgPSBQcm9taXNlLnJlc29sdmUoKTtcbn1cbmVsc2Uge1xuICAgIGVuc3VyZVBhZ2VMb2FkZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5jb25zdCBnZXRQcm92aWRlciA9ICgpID0+IGlzQnJvd3NlciA/IHdpbmRvdy5fX2V2ZXIgfHwgd2luZG93LnRvbiA6IHVuZGVmaW5lZDtcbi8qKlxuICogQGNhdGVnb3J5IFByb3ZpZGVyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhc0V2ZXJzY2FsZVByb3ZpZGVyKCkge1xuICAgIGlmICghaXNCcm93c2VyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXdhaXQgZW5zdXJlUGFnZUxvYWRlZDtcbiAgICByZXR1cm4gd2luZG93Ll9faGFzRXZlcnNjYWxlUHJvdmlkZXIgPT09IHRydWUgfHwgd2luZG93Lmhhc1RvblByb3ZpZGVyID09PSB0cnVlO1xufVxuZXhwb3J0cy5oYXNFdmVyc2NhbGVQcm92aWRlciA9IGhhc0V2ZXJzY2FsZVByb3ZpZGVyO1xuLyoqXG4gKiBAY2F0ZWdvcnkgUHJvdmlkZXJcbiAqL1xuY2xhc3MgUHJvdmlkZXJScGNDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMgPSB7fSkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0ge1xuICAgICAgICAgICAgY29ubmVjdGVkOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBkaXNjb25uZWN0ZWQ6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uc0ZvdW5kOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBjb250cmFjdFN0YXRlQ2hhbmdlZDogbmV3IE1hcCgpLFxuICAgICAgICAgICAgbWVzc2FnZVN0YXR1c1VwZGF0ZWQ6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIG5ldHdvcmtDaGFuZ2VkOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBwZXJtaXNzaW9uc0NoYW5nZWQ6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGxvZ2dlZE91dDogbmV3IE1hcCgpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jb250cmFjdFN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgLy8gQ3JlYXRlIGNvbnRyYWN0IHByb3h5IHR5cGVcbiAgICAgICAgY2xhc3MgUHJvdmlkZXJDb250cmFjdCBleHRlbmRzIGNvbnRyYWN0LkNvbnRyYWN0IHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKGFiaSwgYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHN1cGVyKHNlbGYsIGFiaSwgYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5Db250cmFjdCA9IFByb3ZpZGVyQ29udHJhY3Q7XG4gICAgICAgIC8vIENyZWF0ZSBzdWJzY3JpYmVyIHByb3h5IHR5cGVcbiAgICAgICAgY2xhc3MgUHJvdmlkZXJTdWJzY3JpYmVyIGV4dGVuZHMgc3Vic2NyaWJlci5TdWJzY3JpYmVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuU3Vic2NyaWJlciA9IFByb3ZpZGVyU3Vic2NyaWJlcjtcbiAgICAgICAgLy8gV3JhcCBwcm92aWRlciByZXF1ZXN0c1xuICAgICAgICB0aGlzLl9hcGkgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgIGdldDogKF9vYmplY3QsIG1ldGhvZCkgPT4gKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcm92aWRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm92aWRlci5yZXF1ZXN0KHsgbWV0aG9kLCBwYXJhbXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUHJvdmlkZXJOb3RJbml0aWFsaXplZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvcGVydGllcy5mb3JjZVVzZUZhbGxiYWNrID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXphdGlvblByb21pc2UgPSBwcm9wZXJ0aWVzLmZhbGxiYWNrICE9IG51bGxcbiAgICAgICAgICAgICAgICA/IHByb3BlcnRpZXMuZmFsbGJhY2soKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigocHJvdmlkZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHByb3ZpZGVyIHdpdGggaW5qZWN0ZWQgb2JqZWN0IGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIHRoaXMuX3Byb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcm92aWRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJvdmlkZXIgYXMgYWxyZWFkeSBpbmplY3RlZFxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemF0aW9uUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCBwYWdlIGlzIGxvYWRlZCBhbmQgaW5pdGlhbGl6YXRpb24gY29tcGxldGVcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXphdGlvblByb21pc2UgPSBoYXNFdmVyc2NhbGVQcm92aWRlcigpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChoYXNQcm92aWRlcikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRnVsbHkgbG9hZGVkIHBhZ2UgZG9lc24ndCBldmVuIGNvbnRhaW4gcHJvdmlkZXIgZmxhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IGluamVjdGVkIHByb3ZpZGVyIGluaXRpYWxpemF0aW9uIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm92aWRlciA9IGdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcm92aWRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudE5hbWUgPSB3aW5kb3cuX19oYXNFdmVyc2NhbGVQcm92aWRlciA9PT0gdHJ1ZSA/ICdldmVyI2luaXRpYWxpemVkJyA6ICd0b24jaW5pdGlhbGl6ZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCAoXykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcm92aWRlciA9PSBudWxsICYmIHByb3BlcnRpZXMuZmFsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBhd2FpdCBwcm9wZXJ0aWVzLmZhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXaWxsIG9ubHkgcmVnaXN0ZXIgaGFuZGxlcnMgZm9yIHN1Y2Nlc3NmdWxseSBsb2FkZWQgaW5qZWN0ZWQgcHJvdmlkZXJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Byb3ZpZGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWdpc3RlckV2ZW50SGFuZGxlcnModGhpcy5fcHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBwYWdlIGhhcyBpbmplY3RlZCBFdmVyc2NhbGUgcHJvdmlkZXIgb3JcbiAgICAgKiB0aGVyZSBpcyBhIGZhbGxiYWNrIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGFzeW5jIGhhc1Byb3ZpZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvcGVydGllcy5mYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzRXZlcnNjYWxlUHJvdmlkZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgdW50aWwgcHJvdmlkZXIgYXBpIHdpbGwgYmUgYXZhaWxhYmxlLiBDYWxscyBgZmFsbGJhY2tgIGlmIG5vIHByb3ZpZGVyIHdhcyBmb3VuZFxuICAgICAqXG4gICAgICogQHRocm93cyBQcm92aWRlck5vdEZvdW5kRXhjZXB0aW9uIHdoZW4gbm8gcHJvdmlkZXIgZm91bmRcbiAgICAgKi9cbiAgICBhc3luYyBlbnN1cmVJbml0aWFsaXplZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgICAgICBpZiAodGhpcy5fcHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFByb3ZpZGVyTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHByb3ZpZGVyIGFwaSBpcyByZWFkeVxuICAgICAqL1xuICAgIGdldCBpc0luaXRpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvdmlkZXIgIT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmF3IHByb3ZpZGVyXG4gICAgICovXG4gICAgZ2V0IHJhdygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb3ZpZGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQcm92aWRlck5vdEluaXRpYWxpemVkRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmF3IHByb3ZpZGVyIGFwaVxuICAgICAqL1xuICAgIGdldCByYXdBcGkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcGk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdHlwZWQgY29udHJhY3Qgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhYmkgUmVhZG9ubHkgb2JqZWN0IChtdXN0IGJlIGRlY2xhcmVkIHdpdGggYGFzIGNvbnN0YClcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBEZWZhdWx0IGNvbnRyYWN0IGFkZHJlc3NcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIGBuZXcgZXZlci5Db250cmFjdChhYmksIGFkZHJlc3MpYCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkXG4gICAgICovXG4gICAgY3JlYXRlQ29udHJhY3QoYWJpLCBhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5Db250cmFjdChhYmksIGFkZHJlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHN1YnNjcmlwdGlvbnMgZ3JvdXBcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIGBuZXcgZXZlci5TdWJzY3JpYmVyKClgIHNob3VsZCBiZSB1c2VkIGluc3RlYWRcbiAgICAgKi9cbiAgICBjcmVhdGVTdWJzY3JpYmVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuU3Vic2NyaWJlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBuZXcgcGVybWlzc2lvbnMgZm9yIGN1cnJlbnQgb3JpZ2luLlxuICAgICAqIFNob3dzIGFuIGFwcHJvdmFsIHdpbmRvdyB0byB0aGUgdXNlci5cbiAgICAgKiBXaWxsIG92ZXJ3cml0ZSBhbHJlYWR5IGV4aXN0aW5nIHBlcm1pc3Npb25zXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogbm9uZVxuICAgICAqL1xuICAgIGFzeW5jIHJlcXVlc3RQZXJtaXNzaW9ucyhhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fYXBpLnJlcXVlc3RQZXJtaXNzaW9ucyh7XG4gICAgICAgICAgICBwZXJtaXNzaW9uczogYXJncy5wZXJtaXNzaW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoMCwgbW9kZWxzXzEucGFyc2VQZXJtaXNzaW9ucykocmVzdWx0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBgYWNjb3VudEludGVyYWN0aW9uYCBwZXJtaXNzaW9uIHZhbHVlXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlcyBwZXJtaXNzaW9uczogYGFjY291bnRJbnRlcmFjdGlvbmBcbiAgICAgKi9cbiAgICBhc3luYyBjaGFuZ2VBY2NvdW50KCkge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2FwaS5jaGFuZ2VBY2NvdW50KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHBlcm1pc3Npb25zIGZvciBjdXJyZW50IG9yaWdpbiBhbmQgc3RvcHMgYWxsIHN1YnNjcmlwdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2FwaS5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIGFzeW5jIHN1YnNjcmliZShldmVudE5hbWUsIHBhcmFtcykge1xuICAgICAgICBjbGFzcyBTdWJzY3JpcHRpb25JbXBsIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKF9zdWJzY3JpYmUsIF91bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IF9zdWJzY3JpYmU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSBfdW5zdWJzY3JpYmU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlZDogW10sXG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlZDogW10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMuX2xpc3RlbmVyc1snc3Vic2NyaWJlZCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMuX2xpc3RlbmVyc1sndW5zdWJzY3JpYmVkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50TmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3RpZnkoZGF0YSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiB0aGlzLl9saXN0ZW5lcnNbJ2RhdGEnXSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGlzdGluZ1N1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zW2V2ZW50TmFtZV07XG4gICAgICAgIGNvbnN0IGlkID0gKDAsIHV0aWxzXzEuZ2V0VW5pcXVlSWQpKCk7XG4gICAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2VTdGF0dXNVcGRhdGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ25ldHdvcmtDaGFuZ2VkJzpcbiAgICAgICAgICAgIGNhc2UgJ3Blcm1pc3Npb25zQ2hhbmdlZCc6XG4gICAgICAgICAgICBjYXNlICdsb2dnZWRPdXQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbkltcGwoYXN5bmMgKHN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdTdWJzY3JpcHRpb25zLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1N1YnNjcmlwdGlvbnMuc2V0KGlkLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLm5vdGlmeShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1N1YnNjcmlwdGlvbnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzdWJzY3JpcHRpb24uc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3RyYW5zYWN0aW9uc0ZvdW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRyYWN0U3RhdGVDaGFuZ2VkJzoge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZHJlc3MgbXVzdCBiZSBzcGVjaWZpZWQgZm9yIHRoZSBzdWJzY3JpcHRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBwYXJhbXMuYWRkcmVzcy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25JbXBsKGFzeW5jIChzdWJzY3JpcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nU3Vic2NyaXB0aW9ucy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdTdWJzY3JpcHRpb25zLnNldChpZCwgKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5hZGRyZXNzLnRvU3RyaW5nKCkgPT09IGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24ubm90aWZ5KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250cmFjdFN1YnNjcmlwdGlvbnMgPSB0aGlzLl9jb250cmFjdFN1YnNjcmlwdGlvbnMuZ2V0KGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJhY3RTdWJzY3JpcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0U3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRyYWN0U3Vic2NyaXB0aW9ucy5zZXQoYWRkcmVzcywgY29udHJhY3RTdWJzY3JpcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25TdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBldmVudE5hbWUgPT09ICdjb250cmFjdFN0YXRlQ2hhbmdlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IGV2ZW50TmFtZSA9PT0gJ3RyYW5zYWN0aW9uc0ZvdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RTdWJzY3JpcHRpb25zLnNldChpZCwgc3Vic2NyaXB0aW9uU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRvdGFsLCB3aXRob3V0RXhjbHVkZWQsIH0gPSBmb2xkU3Vic2NyaXB0aW9ucyhjb250cmFjdFN1YnNjcmlwdGlvbnMudmFsdWVzKCksIHN1YnNjcmlwdGlvblN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbC50cmFuc2FjdGlvbnMgIT09IHdpdGhvdXRFeGNsdWRlZC50cmFuc2FjdGlvbnMgfHwgdG90YWwuc3RhdGUgIT09IHdpdGhvdXRFeGNsdWRlZC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmF3QXBpLnN1YnNjcmliZSh7IGFkZHJlc3MsIHN1YnNjcmlwdGlvbnM6IHRvdGFsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1N1YnNjcmlwdGlvbnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0U3Vic2NyaXB0aW9ucy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdTdWJzY3JpcHRpb25zLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0U3Vic2NyaXB0aW9ucyA9IHRoaXMuX2NvbnRyYWN0U3Vic2NyaXB0aW9ucy5nZXQoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cmFjdFN1YnNjcmlwdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBjb250cmFjdFN1YnNjcmlwdGlvbnMuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0b3RhbCwgd2l0aG91dEV4Y2x1ZGVkIH0gPSBmb2xkU3Vic2NyaXB0aW9ucyhjb250cmFjdFN1YnNjcmlwdGlvbnMudmFsdWVzKCksIHVwZGF0ZXMpO1xuICAgICAgICAgICAgICAgICAgICBjb250cmFjdFN1YnNjcmlwdGlvbnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3aXRob3V0RXhjbHVkZWQudHJhbnNhY3Rpb25zICYmICF3aXRob3V0RXhjbHVkZWQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmF3QXBpLnVuc3Vic2NyaWJlKHsgYWRkcmVzcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b3RhbC50cmFuc2FjdGlvbnMgIT09IHdpdGhvdXRFeGNsdWRlZC50cmFuc2FjdGlvbnMgfHwgdG90YWwuc3RhdGUgIT09IHdpdGhvdXRFeGNsdWRlZC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yYXdBcGkuc3Vic2NyaWJlKHsgYWRkcmVzcywgc3Vic2NyaXB0aW9uczogd2l0aG91dEV4Y2x1ZGVkIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3Vic2NyaXB0aW9uLnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGV2ZW50ICR7ZXZlbnROYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcHJvdmlkZXIgYXBpIHN0YXRlXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogbm9uZVxuICAgICAqL1xuICAgIGFzeW5jIGdldFByb3ZpZGVyU3RhdGUoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBhd2FpdCB0aGlzLl9hcGkuZ2V0UHJvdmlkZXJTdGF0ZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBwZXJtaXNzaW9uczogKDAsIG1vZGVsc18xLnBhcnNlUGVybWlzc2lvbnMpKHN0YXRlLnBlcm1pc3Npb25zKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgY29udHJhY3QgYmFsYW5jZVxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCYWxhbmNlKGFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gYXdhaXQgdGhpcy5nZXRGdWxsQ29udHJhY3RTdGF0ZSh7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN0YXRlID09IG51bGwgPyAnMCcgOiBzdGF0ZSA9PT0gbnVsbCB8fCBzdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdGUuYmFsYW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgY29udHJhY3QgZGF0YVxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBnZXRGdWxsQ29udHJhY3RTdGF0ZShhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FwaS5nZXRGdWxsQ29udHJhY3RTdGF0ZSh7XG4gICAgICAgICAgICBhZGRyZXNzOiBhcmdzLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGFjY291bnRzIHdpdGggc3BlY2lmaWVkIGNvZGUgaGFzaFxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY2NvdW50c0J5Q29kZUhhc2goYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGNvbnN0IHsgYWNjb3VudHMsIGNvbnRpbnVhdGlvbiB9ID0gYXdhaXQgdGhpcy5fYXBpLmdldEFjY291bnRzQnlDb2RlSGFzaCh7XG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50cy5tYXAoKGFkZHJlc3MpID0+IG5ldyB1dGlsc18xLkFkZHJlc3MoYWRkcmVzcykpLFxuICAgICAgICAgICAgY29udGludWF0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBjb250cmFjdCB0cmFuc2FjdGlvbnNcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqIFJlcXVpcmVkIHBlcm1pc3Npb25zOiBgYmFzaWNgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25zKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9ucywgY29udGludWF0aW9uLCBpbmZvIH0gPSBhd2FpdCB0aGlzLl9hcGkuZ2V0VHJhbnNhY3Rpb25zKHtcbiAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICBhZGRyZXNzOiBhcmdzLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9ucy5tYXAobW9kZWxzXzEucGFyc2VUcmFuc2FjdGlvbiksXG4gICAgICAgICAgICBjb250aW51YXRpb24sXG4gICAgICAgICAgICBpbmZvLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0cmFuc2FjdGlvbiBieSBoYXNoXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogYGJhc2ljYFxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0aGlzLl9hcGkuZ2V0VHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24gPyAoMCwgbW9kZWxzXzEucGFyc2VUcmFuc2FjdGlvbikodHJhbnNhY3Rpb24pIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBjb250cmFjdCBhZGRyZXNzIGZyb20gY29kZSBhbmQgaW5pdCBwYXJhbXNcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqIFJlcXVpcmVkIHBlcm1pc3Npb25zOiBgYmFzaWNgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RXhwZWN0ZWRBZGRyZXNzKGFiaSwgYXJncykge1xuICAgICAgICBjb25zdCB7IGFkZHJlc3MgfSA9IGF3YWl0IHRoaXMuZ2V0U3RhdGVJbml0KGFiaSwgYXJncyk7XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBjb250cmFjdCBhZGRyZXNzIGFuZCBzdGF0ZSBmcm9tIGNvZGUgYW5kIGluaXQgcGFyYW1zXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogYGJhc2ljYFxuICAgICAqL1xuICAgIGFzeW5jIGdldFN0YXRlSW5pdChhYmksIGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IGFkZHJlc3MsIHN0YXRlSW5pdCB9ID0gYXdhaXQgdGhpcy5fYXBpLmdldEV4cGVjdGVkQWRkcmVzcyh7XG4gICAgICAgICAgICBhYmk6IEpTT04uc3RyaW5naWZ5KGFiaSksXG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgaW5pdFBhcmFtczogKDAsIG1vZGVsc18xLnNlcmlhbGl6ZVRva2Vuc09iamVjdCkoYXJncy5pbml0UGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzOiBuZXcgdXRpbHNfMS5BZGRyZXNzKGFkZHJlc3MpLFxuICAgICAgICAgICAgc3RhdGVJbml0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBoYXNoIG9mIGJhc2U2NCBlbmNvZGVkIEJPQ1xuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCb2NIYXNoKGJvYykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hcGkuZ2V0Qm9jSGFzaCh7XG4gICAgICAgICAgICBib2MsXG4gICAgICAgIH0pLnRoZW4oKHsgaGFzaCB9KSA9PiBoYXNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBiYXNlNjQgZW5jb2RlZCBCT0NcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqIFJlcXVpcmVkIHBlcm1pc3Npb25zOiBgYmFzaWNgXG4gICAgICovXG4gICAgYXN5bmMgcGFja0ludG9DZWxsKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYXBpLnBhY2tJbnRvQ2VsbCh7XG4gICAgICAgICAgICBhYmlWZXJzaW9uOiBhcmdzLmFiaVZlcnNpb24sXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IGFyZ3Muc3RydWN0dXJlLFxuICAgICAgICAgICAgZGF0YTogKDAsIG1vZGVsc18xLnNlcmlhbGl6ZVRva2Vuc09iamVjdCkoYXJncy5kYXRhKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYmFzZTY0IGVuY29kZWQgQk9DXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogYGJhc2ljYFxuICAgICAqL1xuICAgIGFzeW5jIHVucGFja0Zyb21DZWxsKGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHRoaXMuX2FwaS51bnBhY2tGcm9tQ2VsbCh7XG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgc3RydWN0dXJlOiBhcmdzLnN0cnVjdHVyZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiAoMCwgbW9kZWxzXzEucGFyc2VUb2tlbnNPYmplY3QpKGFyZ3Muc3RydWN0dXJlLCBkYXRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgcHVibGljIGtleSBmcm9tIHJhdyBhY2NvdW50IHN0YXRlXG4gICAgICpcbiAgICAgKiAqKk5PVEU6KiogY2FuIG9ubHkgYmUgdXNlZCBvbiBjb250cmFjdHMgd2hpY2ggYXJlIGRlcGxveWVkIGFuZCBoYXMgYHB1YmtleWAgaGVhZGVyXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogYGJhc2ljYFxuICAgICAqL1xuICAgIGFzeW5jIGV4dHJhY3RQdWJsaWNLZXkoYm9jKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgeyBwdWJsaWNLZXkgfSA9IGF3YWl0IHRoaXMuX2FwaS5leHRyYWN0UHVibGljS2V5KHtcbiAgICAgICAgICAgIGJvYyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwdWJsaWNLZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGJhc2U2NCBlbmNvZGVkIGNvbnRyYWN0IGNvZGUgaW50byB0dmMgd2l0aCBkZWZhdWx0IGluaXQgZGF0YVxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBjb2RlVG9UdmMoY29kZSkge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGNvbnN0IHsgdHZjIH0gPSBhd2FpdCB0aGlzLl9hcGkuY29kZVRvVHZjKHtcbiAgICAgICAgICAgIGNvZGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHZjO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgY29kZSBhbmQgZGF0YSBpbnRvIHN0YXRlIGluaXRcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqIFJlcXVpcmVkIHBlcm1pc3Npb25zOiBgYmFzaWNgXG4gICAgICovXG4gICAgYXN5bmMgbWVyZ2VUdmMoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hcGkubWVyZ2VUdmMoYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBiYXNlNjQgZW5jb2RlZCBzdGF0ZSBpbml0IGludG8gY29kZSBhbmQgZGF0YVxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBzcGxpdFR2Yyh0dmMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYXBpLnNwbGl0VHZjKHtcbiAgICAgICAgICAgIHR2YyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBjb2RlIGFuZCBkYXRhIGludG8gc3RhdGUgaW5pdFxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBiYXNpY2BcbiAgICAgKi9cbiAgICBhc3luYyBzZXRDb2RlU2FsdChhcmdzKSB7XG4gICAgICAgIGxldCBzYWx0O1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3Muc2FsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgICAgIHNhbHQgPSBhcmdzLnNhbHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IGJvYyB9ID0gYXdhaXQgdGhpcy5wYWNrSW50b0NlbGwoYXJncy5zYWx0KTtcbiAgICAgICAgICAgIHNhbHQgPSBib2M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FwaS5zZXRDb2RlU2FsdCh7IGNvZGU6IGFyZ3MuY29kZSwgc2FsdCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHNhbHQgZnJvbSBjb2RlLiBSZXR1cm5zIHVuZGVmaW5lZCBpZiBjb2RlIGRvZXNuJ3QgY29udGFpbiBzYWx0XG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlZCBwZXJtaXNzaW9uczogYGJhc2ljYFxuICAgICAqL1xuICAgIGFzeW5jIGdldENvZGVTYWx0KGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB7IHNhbHQgfSA9IGF3YWl0IHRoaXMucmF3QXBpLmdldENvZGVTYWx0KHtcbiAgICAgICAgICAgIGNvZGU6IGFyZ3MuY29kZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzYWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFzc2V0IHRvIHRoZSBzZWxlY3RlZCBhY2NvdW50XG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlcyBwZXJtaXNzaW9uczogYGFjY291bnRJbnRlcmFjdGlvbmBcbiAgICAgKi9cbiAgICBhc3luYyBhZGRBc3NldChhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgc3dpdGNoIChhcmdzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RpcDNfdG9rZW4nOiB7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICByb290Q29udHJhY3Q6IGFyZ3MucGFyYW1zLnJvb3RDb250cmFjdC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBhc3NldCB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FwaS5hZGRBc3NldCh7XG4gICAgICAgICAgICBhY2NvdW50OiBhcmdzLmFjY291bnQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHR5cGU6IGFyZ3MudHlwZSxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeVNpZ25hdHVyZShhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FwaS52ZXJpZnlTaWduYXR1cmUoYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIGFyYml0cmFyeSBkYXRhLlxuICAgICAqXG4gICAgICogTk9URTogaGFzaGVzIGRhdGEgYmVmb3JlIHNpZ25pbmcuIFVzZSBgc2lnbkRhdGFSYXdgIHRvIHNpZ24gd2l0aG91dCBoYXNoLlxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZXMgcGVybWlzc2lvbnM6IGBhY2NvdW50SW50ZXJhY3Rpb25gXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkRhdGEoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hcGkuc2lnbkRhdGEoYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIGFyYml0cmFyeSBkYXRhIHdpdGhvdXQgaGFzaGluZyBpdFxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZXMgcGVybWlzc2lvbnM6IGBhY2NvdW50SW50ZXJhY3Rpb25gXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkRhdGFSYXcoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hcGkuc2lnbkRhdGFSYXcoYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY3J5cHRzIGFyYml0cmFyeSBkYXRhIHdpdGggc3BlY2lmaWVkIGFsZ29yaXRobSBmb3IgZWFjaCBzcGVjaWZpZWQgcmVjaXBpZW50XG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlcyBwZXJtaXNzaW9uczogYGFjY291bnRJbnRlcmFjdGlvbmBcbiAgICAgKi9cbiAgICBhc3luYyBlbmNyeXB0RGF0YShhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgeyBlbmNyeXB0ZWREYXRhIH0gPSBhd2FpdCB0aGlzLl9hcGkuZW5jcnlwdERhdGEoYXJncyk7XG4gICAgICAgIHJldHVybiBlbmNyeXB0ZWREYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNyeXB0cyBlbmNyeXB0ZWQgZGF0YS4gUmV0dXJucyBiYXNlNjQgZW5jb2RlZCBkYXRhXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBSZXF1aXJlcyBwZXJtaXNzaW9uczogYGFjY291bnRJbnRlcmFjdGlvbmBcbiAgICAgKi9cbiAgICBhc3luYyBkZWNyeXB0RGF0YShlbmNyeXB0ZWREYXRhKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCB0aGlzLl9hcGkuZGVjcnlwdERhdGEoeyBlbmNyeXB0ZWREYXRhIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYW4gaW50ZXJuYWwgbWVzc2FnZSBmcm9tIHRoZSB1c2VyIGFjY291bnQuXG4gICAgICogU2hvd3MgYW4gYXBwcm92YWwgd2luZG93IHRvIHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogUmVxdWlyZWQgcGVybWlzc2lvbnM6IGBhY2NvdW50SW50ZXJhY3Rpb25gXG4gICAgICovXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb24gfSA9IGF3YWl0IHRoaXMuX2FwaS5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICBzZW5kZXI6IGFyZ3Muc2VuZGVyLnRvU3RyaW5nKCksXG4gICAgICAgICAgICByZWNpcGllbnQ6IGFyZ3MucmVjaXBpZW50LnRvU3RyaW5nKCksXG4gICAgICAgICAgICBhbW91bnQ6IGFyZ3MuYW1vdW50LFxuICAgICAgICAgICAgYm91bmNlOiBhcmdzLmJvdW5jZSxcbiAgICAgICAgICAgIHBheWxvYWQ6IGFyZ3MucGF5bG9hZCA/ICh7XG4gICAgICAgICAgICAgICAgYWJpOiBhcmdzLnBheWxvYWQuYWJpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogYXJncy5wYXlsb2FkLm1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6ICgwLCBtb2RlbHNfMS5zZXJpYWxpemVUb2tlbnNPYmplY3QpKGFyZ3MucGF5bG9hZC5wYXJhbXMpLFxuICAgICAgICAgICAgfSkgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246ICgwLCBtb2RlbHNfMS5wYXJzZVRyYW5zYWN0aW9uKSh0cmFuc2FjdGlvbiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGFuIGludGVybmFsIG1lc3NhZ2UgZnJvbSB0aGUgdXNlciBhY2NvdW50IHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIFNob3dzIGFuIGFwcHJvdmFsIHdpbmRvdyB0byB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBzZWUgbWVzc2FnZVN0YXR1c1VwZGF0ZWRcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqIFJlcXVpcmVkIHBlcm1pc3Npb25zOiBgYWNjb3VudEludGVyYWN0aW9uYFxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRNZXNzYWdlRGVsYXllZChhcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zID0gbmV3IHV0aWxzXzEuRGVsYXllZFRyYW5zYWN0aW9ucztcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYXdhaXQgdGhpcy5zdWJzY3JpYmUoJ21lc3NhZ2VTdGF0dXNVcGRhdGVkJyk7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRhdGEuYWRkcmVzcy5lcXVhbHMoYXJncy5zZW5kZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNhY3Rpb25zLmZpbGxUcmFuc2FjdGlvbihkYXRhLmhhc2gsIGRhdGEudHJhbnNhY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBhd2FpdCB0aGlzLl9hcGkuc2VuZE1lc3NhZ2VEZWxheWVkKHtcbiAgICAgICAgICAgIHNlbmRlcjogYXJncy5zZW5kZXIudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHJlY2lwaWVudDogYXJncy5yZWNpcGllbnQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGFtb3VudDogYXJncy5hbW91bnQsXG4gICAgICAgICAgICBib3VuY2U6IGFyZ3MuYm91bmNlLFxuICAgICAgICAgICAgcGF5bG9hZDogYXJncy5wYXlsb2FkID8gKHtcbiAgICAgICAgICAgICAgICBhYmk6IGFyZ3MucGF5bG9hZC5hYmksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBhcmdzLnBheWxvYWQubWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogKDAsIG1vZGVsc18xLnNlcmlhbGl6ZVRva2Vuc09iamVjdCkoYXJncy5wYXlsb2FkLnBhcmFtcyksXG4gICAgICAgICAgICB9KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgLndhaXRUcmFuc2FjdGlvbihhcmdzLnNlbmRlciwgbWVzc2FnZS5oYXNoKVxuICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCkuY2F0Y2goY29uc29sZS5lcnJvcikpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZUhhc2g6IG1lc3NhZ2UuaGFzaCxcbiAgICAgICAgICAgIGV4cGlyZUF0OiBtZXNzYWdlLmV4cGlyZUF0LFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9yZWdpc3RlckV2ZW50SGFuZGxlcnMocHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3Qga25vd25FdmVudHMgPSB7XG4gICAgICAgICAgICAnY29ubmVjdGVkJzogKGRhdGEpID0+IGRhdGEsXG4gICAgICAgICAgICAnZGlzY29ubmVjdGVkJzogKGRhdGEpID0+IGRhdGEsXG4gICAgICAgICAgICAndHJhbnNhY3Rpb25zRm91bmQnOiAoZGF0YSkgPT4gKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBuZXcgdXRpbHNfMS5BZGRyZXNzKGRhdGEuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBkYXRhLnRyYW5zYWN0aW9ucy5tYXAobW9kZWxzXzEucGFyc2VUcmFuc2FjdGlvbiksXG4gICAgICAgICAgICAgICAgaW5mbzogZGF0YS5pbmZvLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAnY29udHJhY3RTdGF0ZUNoYW5nZWQnOiAoZGF0YSkgPT4gKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBuZXcgdXRpbHNfMS5BZGRyZXNzKGRhdGEuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgc3RhdGU6IGRhdGEuc3RhdGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICdtZXNzYWdlU3RhdHVzVXBkYXRlZCc6IChkYXRhKSA9PiAoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IG5ldyB1dGlsc18xLkFkZHJlc3MoZGF0YS5hZGRyZXNzKSxcbiAgICAgICAgICAgICAgICBoYXNoOiBkYXRhLmhhc2gsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IGRhdGEudHJhbnNhY3Rpb24gIT0gbnVsbCA/ICgwLCBtb2RlbHNfMS5wYXJzZVRyYW5zYWN0aW9uKShkYXRhLnRyYW5zYWN0aW9uKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgJ25ldHdvcmtDaGFuZ2VkJzogZGF0YSA9PiBkYXRhLFxuICAgICAgICAgICAgJ3Blcm1pc3Npb25zQ2hhbmdlZCc6IChkYXRhKSA9PiAoe1xuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiAoMCwgbW9kZWxzXzEucGFyc2VQZXJtaXNzaW9ucykoZGF0YS5wZXJtaXNzaW9ucyksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICdsb2dnZWRPdXQnOiBkYXRhID0+IGRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgW2V2ZW50TmFtZSwgZXh0cmFjdG9yXSBvZiBPYmplY3QuZW50cmllcyhrbm93bkV2ZW50cykpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuX3N1YnNjcmlwdGlvbnNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBleHRyYWN0b3IoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUHJvdmlkZXJScGNDbGllbnQgPSBQcm92aWRlclJwY0NsaWVudDtcbi8qKlxuICogQGNhdGVnb3J5IFByb3ZpZGVyXG4gKi9cbmNsYXNzIFByb3ZpZGVyTm90Rm91bmRFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdFdmVyc2NhbGUgcHJvdmlkZXIgd2FzIG5vdCBmb3VuZCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdmlkZXJOb3RGb3VuZEV4Y2VwdGlvbiA9IFByb3ZpZGVyTm90Rm91bmRFeGNlcHRpb247XG4vKipcbiAqIEBjYXRlZ29yeSBQcm92aWRlclxuICovXG5jbGFzcyBQcm92aWRlck5vdEluaXRpYWxpemVkRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignRXZlcnNjYWxlIHByb3ZpZGVyIHdhcyBub3QgaW5pdGlhbGl6ZWQgeWV0Jyk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm92aWRlck5vdEluaXRpYWxpemVkRXhjZXB0aW9uID0gUHJvdmlkZXJOb3RJbml0aWFsaXplZEV4Y2VwdGlvbjtcbmZ1bmN0aW9uIGZvbGRTdWJzY3JpcHRpb25zKHN1YnNjcmlwdGlvbnMsIGV4Y2VwdCkge1xuICAgIGNvbnN0IHRvdGFsID0geyBzdGF0ZTogZmFsc2UsIHRyYW5zYWN0aW9uczogZmFsc2UgfTtcbiAgICBjb25zdCB3aXRob3V0RXhjbHVkZWQgPSBPYmplY3QuYXNzaWduKHt9LCB0b3RhbCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgaWYgKHdpdGhvdXRFeGNsdWRlZC50cmFuc2FjdGlvbnMgJiYgd2l0aG91dEV4Y2x1ZGVkLnN0YXRlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0b3RhbC5zdGF0ZSB8fCAodG90YWwuc3RhdGUgPSBpdGVtLnN0YXRlKTtcbiAgICAgICAgdG90YWwudHJhbnNhY3Rpb25zIHx8ICh0b3RhbC50cmFuc2FjdGlvbnMgPSBpdGVtLnRyYW5zYWN0aW9ucyk7XG4gICAgICAgIGlmIChpdGVtICE9PSBleGNlcHQpIHtcbiAgICAgICAgICAgIHdpdGhvdXRFeGNsdWRlZC5zdGF0ZSB8fCAod2l0aG91dEV4Y2x1ZGVkLnN0YXRlID0gaXRlbS5zdGF0ZSk7XG4gICAgICAgICAgICB3aXRob3V0RXhjbHVkZWQudHJhbnNhY3Rpb25zIHx8ICh3aXRob3V0RXhjbHVkZWQudHJhbnNhY3Rpb25zID0gaXRlbS50cmFuc2FjdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHRvdGFsLCB3aXRob3V0RXhjbHVkZWQgfTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///511\n")},851:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseTokensObject = exports.serializeTokensObject = exports.parseAccountInteraction = exports.parsePermissions = exports.parseMessage = exports.serializeMessage = exports.parseTransaction = exports.serializeTransaction = void 0;\nconst utils_1 = __webpack_require__(786);\n/**\n * @category Models\n */\nfunction serializeTransaction(transaction) {\n    return {\n        ...transaction,\n        inMessage: serializeMessage(transaction.inMessage),\n        outMessages: transaction.outMessages.map(serializeMessage),\n    };\n}\nexports.serializeTransaction = serializeTransaction;\n/**\n * @category Models\n */\nfunction parseTransaction(transaction) {\n    return {\n        ...transaction,\n        inMessage: parseMessage(transaction.inMessage),\n        outMessages: transaction.outMessages.map(parseMessage),\n    };\n}\nexports.parseTransaction = parseTransaction;\n/**\n * @category Models\n */\nfunction serializeMessage(message) {\n    return {\n        ...message,\n        src: message.src ? message.src.toString() : undefined,\n        dst: message.dst ? message.dst.toString() : undefined,\n    };\n}\nexports.serializeMessage = serializeMessage;\n/**\n * @category Models\n */\nfunction parseMessage(message) {\n    return {\n        ...message,\n        src: message.src ? new utils_1.Address(message.src) : undefined,\n        dst: message.dst ? new utils_1.Address(message.dst) : undefined,\n    };\n}\nexports.parseMessage = parseMessage;\n/**\n * @category Models\n */\nfunction parsePermissions(permissions) {\n    return {\n        ...permissions,\n        accountInteraction: permissions.accountInteraction ? parseAccountInteraction(permissions.accountInteraction) : undefined,\n    };\n}\nexports.parsePermissions = parsePermissions;\n/**\n * @category Models\n */\nfunction parseAccountInteraction(accountInteraction) {\n    return {\n        ...accountInteraction,\n        address: new utils_1.Address(accountInteraction.address),\n    };\n}\nexports.parseAccountInteraction = parseAccountInteraction;\n/**\n * @category Models\n */\nfunction serializeTokensObject(object) {\n    return serializeTokenValue(object);\n}\nexports.serializeTokensObject = serializeTokensObject;\nfunction serializeTokenValue(token) {\n    if (token instanceof utils_1.Address) {\n        return token.toString();\n    }\n    if (Array.isArray(token)) {\n        const result = [];\n        for (const item of token) {\n            result.push(serializeTokenValue(item));\n        }\n        return result;\n    }\n    else if (token != null && typeof token === 'object') {\n        const result = {};\n        for (const [key, value] of Object.entries(token)) {\n            result[key] = serializeTokenValue(value);\n        }\n        return result;\n    }\n    else {\n        return token;\n    }\n}\n/**\n * @category Models\n */\nfunction parseTokensObject(params, object) {\n    const result = {};\n    for (const param of params) {\n        result[param.name] = parseTokenValue(param, object[param.name]);\n    }\n    return result;\n}\nexports.parseTokensObject = parseTokensObject;\nfunction parseTokenValue(param, token) {\n    if (!param.type.startsWith('map')) {\n        const isArray = param.type.endsWith('[]');\n        const isOptional = !isArray && param.type.startsWith('optional');\n        const rawType = (isArray ?\n            param.type.slice(0, -2) :\n            isOptional ?\n                param.type.slice(9, -1) :\n                param.type);\n        if (isArray) {\n            const rawParam = { name: param.name, type: rawType, components: param.components };\n            const result = [];\n            for (const item of token) {\n                result.push(parseTokenValue(rawParam, item));\n            }\n            return result;\n        }\n        else if (isOptional) {\n            if (token == null) {\n                return null;\n            }\n            else {\n                const rawParam = { name: param.name, type: rawType, components: param.components };\n                return parseTokenValue(rawParam, token);\n            }\n        }\n        else if (rawType === 'tuple') {\n            const result = {};\n            if (param.components != null) {\n                for (const component of param.components) {\n                    result[component.name] = parseTokenValue(component, token[component.name]);\n                }\n            }\n            return result;\n        }\n        else if (rawType === 'address') {\n            return new utils_1.Address(token);\n        }\n        else {\n            return token;\n        }\n    }\n    else {\n        let [keyType, valueType] = param.type.split(',');\n        keyType = keyType.slice(4);\n        valueType = valueType.slice(0, -1);\n        const result = [];\n        for (const [key, value] of token) {\n            result.push([parseTokenValue({\n                    name: '',\n                    type: keyType,\n                }, key), parseTokenValue({\n                    name: '',\n                    type: valueType,\n                    components: param.components,\n                }, value)]);\n        }\n        return result;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODUxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXIvZGlzdC9tb2RlbHMuanM/OGQ4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VUb2tlbnNPYmplY3QgPSBleHBvcnRzLnNlcmlhbGl6ZVRva2Vuc09iamVjdCA9IGV4cG9ydHMucGFyc2VBY2NvdW50SW50ZXJhY3Rpb24gPSBleHBvcnRzLnBhcnNlUGVybWlzc2lvbnMgPSBleHBvcnRzLnBhcnNlTWVzc2FnZSA9IGV4cG9ydHMuc2VyaWFsaXplTWVzc2FnZSA9IGV4cG9ydHMucGFyc2VUcmFuc2FjdGlvbiA9IGV4cG9ydHMuc2VyaWFsaXplVHJhbnNhY3Rpb24gPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIEBjYXRlZ29yeSBNb2RlbHNcbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgaW5NZXNzYWdlOiBzZXJpYWxpemVNZXNzYWdlKHRyYW5zYWN0aW9uLmluTWVzc2FnZSksXG4gICAgICAgIG91dE1lc3NhZ2VzOiB0cmFuc2FjdGlvbi5vdXRNZXNzYWdlcy5tYXAoc2VyaWFsaXplTWVzc2FnZSksXG4gICAgfTtcbn1cbmV4cG9ydHMuc2VyaWFsaXplVHJhbnNhY3Rpb24gPSBzZXJpYWxpemVUcmFuc2FjdGlvbjtcbi8qKlxuICogQGNhdGVnb3J5IE1vZGVsc1xuICovXG5mdW5jdGlvbiBwYXJzZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgIGluTWVzc2FnZTogcGFyc2VNZXNzYWdlKHRyYW5zYWN0aW9uLmluTWVzc2FnZSksXG4gICAgICAgIG91dE1lc3NhZ2VzOiB0cmFuc2FjdGlvbi5vdXRNZXNzYWdlcy5tYXAocGFyc2VNZXNzYWdlKSxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZVRyYW5zYWN0aW9uID0gcGFyc2VUcmFuc2FjdGlvbjtcbi8qKlxuICogQGNhdGVnb3J5IE1vZGVsc1xuICovXG5mdW5jdGlvbiBzZXJpYWxpemVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXNzYWdlLFxuICAgICAgICBzcmM6IG1lc3NhZ2Uuc3JjID8gbWVzc2FnZS5zcmMudG9TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZHN0OiBtZXNzYWdlLmRzdCA/IG1lc3NhZ2UuZHN0LnRvU3RyaW5nKCkgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMuc2VyaWFsaXplTWVzc2FnZSA9IHNlcmlhbGl6ZU1lc3NhZ2U7XG4vKipcbiAqIEBjYXRlZ29yeSBNb2RlbHNcbiAqL1xuZnVuY3Rpb24gcGFyc2VNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXNzYWdlLFxuICAgICAgICBzcmM6IG1lc3NhZ2Uuc3JjID8gbmV3IHV0aWxzXzEuQWRkcmVzcyhtZXNzYWdlLnNyYykgOiB1bmRlZmluZWQsXG4gICAgICAgIGRzdDogbWVzc2FnZS5kc3QgPyBuZXcgdXRpbHNfMS5BZGRyZXNzKG1lc3NhZ2UuZHN0KSA6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZU1lc3NhZ2UgPSBwYXJzZU1lc3NhZ2U7XG4vKipcbiAqIEBjYXRlZ29yeSBNb2RlbHNcbiAqL1xuZnVuY3Rpb24gcGFyc2VQZXJtaXNzaW9ucyhwZXJtaXNzaW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnBlcm1pc3Npb25zLFxuICAgICAgICBhY2NvdW50SW50ZXJhY3Rpb246IHBlcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbiA/IHBhcnNlQWNjb3VudEludGVyYWN0aW9uKHBlcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbikgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyc2VQZXJtaXNzaW9ucyA9IHBhcnNlUGVybWlzc2lvbnM7XG4vKipcbiAqIEBjYXRlZ29yeSBNb2RlbHNcbiAqL1xuZnVuY3Rpb24gcGFyc2VBY2NvdW50SW50ZXJhY3Rpb24oYWNjb3VudEludGVyYWN0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYWNjb3VudEludGVyYWN0aW9uLFxuICAgICAgICBhZGRyZXNzOiBuZXcgdXRpbHNfMS5BZGRyZXNzKGFjY291bnRJbnRlcmFjdGlvbi5hZGRyZXNzKSxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZUFjY291bnRJbnRlcmFjdGlvbiA9IHBhcnNlQWNjb3VudEludGVyYWN0aW9uO1xuLyoqXG4gKiBAY2F0ZWdvcnkgTW9kZWxzXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRva2Vuc09iamVjdChvYmplY3QpIHtcbiAgICByZXR1cm4gc2VyaWFsaXplVG9rZW5WYWx1ZShvYmplY3QpO1xufVxuZXhwb3J0cy5zZXJpYWxpemVUb2tlbnNPYmplY3QgPSBzZXJpYWxpemVUb2tlbnNPYmplY3Q7XG5mdW5jdGlvbiBzZXJpYWxpemVUb2tlblZhbHVlKHRva2VuKSB7XG4gICAgaWYgKHRva2VuIGluc3RhbmNlb2YgdXRpbHNfMS5BZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbikpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0b2tlbikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VyaWFsaXplVG9rZW5WYWx1ZShpdGVtKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSBpZiAodG9rZW4gIT0gbnVsbCAmJiB0eXBlb2YgdG9rZW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0b2tlbikpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gc2VyaWFsaXplVG9rZW5WYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG59XG4vKipcbiAqIEBjYXRlZ29yeSBNb2RlbHNcbiAqL1xuZnVuY3Rpb24gcGFyc2VUb2tlbnNPYmplY3QocGFyYW1zLCBvYmplY3QpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHBhcmFtcykge1xuICAgICAgICByZXN1bHRbcGFyYW0ubmFtZV0gPSBwYXJzZVRva2VuVmFsdWUocGFyYW0sIG9iamVjdFtwYXJhbS5uYW1lXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnBhcnNlVG9rZW5zT2JqZWN0ID0gcGFyc2VUb2tlbnNPYmplY3Q7XG5mdW5jdGlvbiBwYXJzZVRva2VuVmFsdWUocGFyYW0sIHRva2VuKSB7XG4gICAgaWYgKCFwYXJhbS50eXBlLnN0YXJ0c1dpdGgoJ21hcCcpKSB7XG4gICAgICAgIGNvbnN0IGlzQXJyYXkgPSBwYXJhbS50eXBlLmVuZHNXaXRoKCdbXScpO1xuICAgICAgICBjb25zdCBpc09wdGlvbmFsID0gIWlzQXJyYXkgJiYgcGFyYW0udHlwZS5zdGFydHNXaXRoKCdvcHRpb25hbCcpO1xuICAgICAgICBjb25zdCByYXdUeXBlID0gKGlzQXJyYXkgP1xuICAgICAgICAgICAgcGFyYW0udHlwZS5zbGljZSgwLCAtMikgOlxuICAgICAgICAgICAgaXNPcHRpb25hbCA/XG4gICAgICAgICAgICAgICAgcGFyYW0udHlwZS5zbGljZSg5LCAtMSkgOlxuICAgICAgICAgICAgICAgIHBhcmFtLnR5cGUpO1xuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgcmF3UGFyYW0gPSB7IG5hbWU6IHBhcmFtLm5hbWUsIHR5cGU6IHJhd1R5cGUsIGNvbXBvbmVudHM6IHBhcmFtLmNvbXBvbmVudHMgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRva2VuKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VUb2tlblZhbHVlKHJhd1BhcmFtLCBpdGVtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYXdQYXJhbSA9IHsgbmFtZTogcGFyYW0ubmFtZSwgdHlwZTogcmF3VHlwZSwgY29tcG9uZW50czogcGFyYW0uY29tcG9uZW50cyB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuVmFsdWUocmF3UGFyYW0sIHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyYXdUeXBlID09PSAndHVwbGUnKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChwYXJhbS5jb21wb25lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBwYXJhbS5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjb21wb25lbnQubmFtZV0gPSBwYXJzZVRva2VuVmFsdWUoY29tcG9uZW50LCB0b2tlbltjb21wb25lbnQubmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmF3VHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHV0aWxzXzEuQWRkcmVzcyh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBba2V5VHlwZSwgdmFsdWVUeXBlXSA9IHBhcmFtLnR5cGUuc3BsaXQoJywnKTtcbiAgICAgICAga2V5VHlwZSA9IGtleVR5cGUuc2xpY2UoNCk7XG4gICAgICAgIHZhbHVlVHlwZSA9IHZhbHVlVHlwZS5zbGljZSgwLCAtMSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0b2tlbikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW3BhcnNlVG9rZW5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBrZXlUeXBlLFxuICAgICAgICAgICAgICAgIH0sIGtleSksIHBhcnNlVG9rZW5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB2YWx1ZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IHBhcmFtLmNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgfSwgdmFsdWUpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///851\n")},25:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Subscriber = void 0;\nconst utils_1 = __webpack_require__(786);\nconst models_1 = __webpack_require__(851);\n/**\n * @category Stream\n */\nclass Subscriber {\n    constructor(provider) {\n        this.provider = provider;\n        this.subscriptions = new Map();\n        this.scanners = new Map();\n        this.unsubscribe = async () => this._unsubscribe();\n    }\n    /**\n     * Returns a stream of new transactions\n     */\n    transactions(address) {\n        return this._addSubscription('transactionsFound', address, false);\n    }\n    /**\n     * Returns a finite stream of child transactions\n     * @param transaction - root transaction\n     */\n    trace(transaction) {\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl((onData, onEnd) => {\n            const scanner = new TraceTransactionsScanner(this.provider, {\n                origin: transaction,\n                onData,\n                onEnd: (eof) => {\n                    this.scanners.delete(id);\n                    onEnd(eof);\n                },\n            });\n            this.scanners.set(id, scanner);\n            scanner.start();\n            // Subscription is not required\n            return Promise.resolve();\n        }, async () => {\n            const scanner = this.scanners.get(id);\n            if (scanner != null) {\n                this.scanners.delete(id);\n                await scanner.stop();\n            }\n        }, identity, true);\n    }\n    /**\n     * Returns a stream of old transactions\n     */\n    oldTransactions(address, filter) {\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl((onData, onEnd) => {\n            const scanner = new UnorderedTransactionsScanner(this.provider, {\n                address,\n                onData,\n                onEnd: (eof) => {\n                    this.scanners.delete(id);\n                    onEnd(eof);\n                },\n                ...filter,\n            });\n            this.scanners.set(id, scanner);\n            scanner.start();\n            // Subscription is not required\n            return Promise.resolve();\n        }, async () => {\n            const scanner = this.scanners.get(id);\n            if (scanner != null) {\n                this.scanners.delete(id);\n                await scanner.stop();\n            }\n        }, identity, true);\n    }\n    states(address) {\n        return this._addSubscription('contractStateChanged', address, false);\n    }\n    async _unsubscribe() {\n        const tasks = [];\n        for (const item of this.subscriptions.values()) {\n            for (const [event, eventData] of Object.entries(item)) {\n                delete item[event];\n                if (eventData != null) {\n                    tasks.push(eventData.subscription\n                        .then(item => item.unsubscribe())\n                        .catch(() => {\n                    }));\n                }\n            }\n        }\n        this.subscriptions.clear();\n        for (const scanner of this.scanners.values()) {\n            tasks.push(scanner.stop());\n        }\n        this.scanners.clear();\n        await Promise.all(tasks);\n    }\n    _addSubscription(event, address, isFinite) {\n        const rawAddress = address.toString();\n        const stopProducer = (id) => {\n            const subscriptions = this.subscriptions.get(rawAddress);\n            if (subscriptions == null) {\n                // No subscriptions for the address\n                return;\n            }\n            const eventData = subscriptions[event];\n            if (eventData != null) {\n                const handler = eventData.handlers.get(id);\n                if (handler != null) {\n                    // Remove event handler with the id\n                    eventData.handlers.delete(id);\n                    const { queue, onEnd, state } = handler;\n                    if (!state.finished) {\n                        state.finished = true;\n                        queue.clear();\n                        queue.enqueue(async () => onEnd(state.eof));\n                    }\n                }\n                // Remove event data subscription if there are none of them\n                if (eventData.handlers.size === 0) {\n                    const subscription = eventData.subscription;\n                    delete subscriptions[event];\n                    subscription\n                        .then((subscription) => subscription.unsubscribe())\n                        .catch(console.debug);\n                }\n            }\n            // Remove address subscriptions object if it is empty\n            if (subscriptions.contractStateChanged == null && subscriptions.transactionsFound == null) {\n                this.subscriptions.delete(rawAddress);\n            }\n        };\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl((onData, onEnd) => {\n            const subscriptions = this.subscriptions.get(rawAddress);\n            let eventData = subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions[event];\n            const state = { eof: false, finished: false };\n            // Create handler object\n            const handler = {\n                onData,\n                onEnd,\n                queue: new PromiseQueue(),\n                state,\n            };\n            if (eventData != null) {\n                // Add handler if there is already a handler group\n                eventData.handlers.set(id, handler);\n                return Promise.resolve();\n            }\n            // Create handlers group\n            const handlers = new Map();\n            handlers.set(id, handler);\n            // Create subscription\n            const subscription = this.provider.subscribe(event, { address })\n                .then((subscription) => {\n                subscription.on('data', (data) => {\n                    for (const { onData, queue, state } of handlers.values()) {\n                        // Skip closed streams\n                        if (state.eof || state.finished) {\n                            continue;\n                        }\n                        queue.enqueue(async () => {\n                            if (!(await onData(data))) {\n                                state.eof = true;\n                                stopProducer(id);\n                            }\n                        });\n                    }\n                });\n                subscription.on('unsubscribed', () => {\n                    for (const id of handlers.keys()) {\n                        stopProducer(id);\n                    }\n                });\n                return subscription;\n            }).catch((e) => {\n                console.error(e);\n                for (const id of handlers.keys()) {\n                    stopProducer(id);\n                }\n                throw e;\n            });\n            // Add event data to subscriptions\n            eventData = { subscription, handlers };\n            if (subscriptions == null) {\n                this.subscriptions.set(rawAddress, { [event]: eventData });\n            }\n            else {\n                subscriptions[event] = eventData;\n            }\n            // Wait until subscribed\n            return subscription.then(() => {\n            });\n        }, () => stopProducer(id), identity, isFinite);\n    }\n}\nexports.Subscriber = Subscriber;\nasync function identity(item, handler) {\n    return handler(item);\n}\nclass StreamImpl {\n    constructor(makeProducer, stopProducer, extractor, isFinite) {\n        this.makeProducer = makeProducer;\n        this.stopProducer = stopProducer;\n        this.extractor = extractor;\n        this.isFinite = isFinite;\n        /**\n         * Folds every element into an accumulator by applying an operation, returning the final result\n         */\n        this.fold = this.onlyFinite((init, f, ctx) => {\n            let state = init;\n            return new Promise((resolve, reject) => {\n                const subscribed = this.makeProducer(\n                // onData\n                (data) => this.extractor(data, async (item) => {\n                    state = await f(state, item);\n                    return true;\n                }), \n                // onEnd\n                (eof) => {\n                    if (eof) {\n                        resolve(state);\n                    }\n                    else {\n                        reject(new Error('Subscription closed'));\n                    }\n                });\n                if (ctx != null) {\n                    ctx.subscribed = subscribed;\n                }\n            });\n        });\n        /**\n         * Waits until the end of the stream\n         */\n        this.finished = this.onlyFinite((ctx) => {\n            return new Promise((resolve, reject) => {\n                const subscribed = this.makeProducer(\n                // onData\n                (data) => this.extractor(data, (_item) => true), \n                // onEnd\n                (eof) => {\n                    if (eof) {\n                        resolve(undefined);\n                    }\n                    else {\n                        reject(new Error('Subscription closed'));\n                    }\n                });\n                if (ctx != null) {\n                    ctx.subscribed = subscribed;\n                }\n            });\n        });\n    }\n    async delayed(f) {\n        const { subscribed, result } = f({\n            first: (() => {\n                const ctx = {};\n                const result = this.first(ctx);\n                return { subscribed: ctx.subscribed, result };\n            }),\n            on: (handler) => {\n                const ctx = {};\n                this.on(handler, ctx);\n                return { subscribed: ctx.subscribed, result: undefined };\n            },\n            fold: this.fold != null ? (init, f) => {\n                const ctx = {};\n                const result = this.fold(init, f, ctx);\n                return { subscribed: ctx.subscribed, result };\n            } : undefined,\n            finished: this.finished != null ? () => {\n                const ctx = {};\n                const result = this.finished(ctx);\n                return { subscribed: ctx.subscribed, result };\n            } : undefined,\n        });\n        await subscribed;\n        return () => result;\n    }\n    first(ctx) {\n        const state = { found: false };\n        return new Promise((resolve, reject) => {\n            const subscribed = this.makeProducer(\n            // onData\n            (data) => this.extractor(data, (item) => {\n                Object.assign(state, { found: true, result: item });\n                return false;\n            }), \n            // onEnd\n            (eof) => {\n                if (eof) {\n                    if (this.isFinite) {\n                        resolve((state.found ? state.result : undefined));\n                    }\n                    else if (state.found) {\n                        resolve(state.result);\n                    }\n                    else {\n                        reject(new Error('Unexpected end of stream'));\n                    }\n                }\n                else {\n                    reject(new Error('Subscription closed'));\n                }\n            });\n            if (ctx != null) {\n                ctx.subscribed = subscribed;\n            }\n        });\n    }\n    on(handler, ctx) {\n        const subscribed = this.makeProducer((event) => this.extractor(event, async (item) => {\n            await handler(item);\n            return true;\n        }), (_eof) => {\n        });\n        if (ctx != null) {\n            ctx.subscribed = subscribed;\n        }\n    }\n    merge(other) {\n        return new StreamImpl((onData, onEnd) => {\n            const state = {\n                stopped: false,\n                counter: 0,\n            };\n            const checkEnd = (eof) => {\n                if (state.stopped) {\n                    return;\n                }\n                if (++state.counter == 2 || !eof) {\n                    state.stopped = true;\n                    onEnd(eof);\n                }\n            };\n            return Promise.all([\n                this.makeProducer(onData, checkEnd),\n                other.makeProducer(onData, checkEnd),\n            ]).then(() => {\n            });\n        }, () => {\n            this.stopProducer();\n            other.stopProducer();\n        }, this.extractor, (this.isFinite && other.isFinite));\n    }\n    enumerate() {\n        const state = {\n            index: 0,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            return handler({\n                index: state.index++,\n                item,\n            });\n        }), this.isFinite);\n    }\n    tap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            await f(item);\n            return handler(item);\n        }), this.isFinite);\n    }\n    filter(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (await f(item)) {\n                return handler(item);\n            }\n            else {\n                return true;\n            }\n        }), this.isFinite);\n    }\n    filterMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const newItem = await f(item);\n            if (newItem !== undefined) {\n                return handler(newItem);\n            }\n            else {\n                return true;\n            }\n        }), this.isFinite);\n    }\n    map(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const newItem = await f(item);\n            return handler(newItem);\n        }), this.isFinite);\n    }\n    flatMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const items = await f(item);\n            for (const newItem of items) {\n                if (!(await handler(newItem))) {\n                    return false;\n                }\n            }\n            return true;\n        }), this.isFinite);\n    }\n    skip(n) {\n        const state = {\n            index: 0,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, (item) => {\n            if (state.index >= n) {\n                return handler(item);\n            }\n            else {\n                ++state.index;\n                return true;\n            }\n        }), this.isFinite);\n    }\n    skipWhile(f) {\n        const state = {\n            shouldSkip: true,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (!state.shouldSkip || !(await f(item))) {\n                state.shouldSkip = false;\n                return handler(item);\n            }\n            else {\n                return true;\n            }\n        }), this.isFinite);\n    }\n    take(n) {\n        const state = {\n            index: 0,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, (item) => {\n            if (state.index < n) {\n                ++state.index;\n                return handler(item);\n            }\n            else {\n                return false;\n            }\n        }), true);\n    }\n    takeWhile(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (await f(item)) {\n                return handler(item);\n            }\n            else {\n                return false;\n            }\n        }), true);\n    }\n    takeWhileMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const newItem = await f(item);\n            if (newItem !== undefined) {\n                return handler(newItem);\n            }\n            else {\n                return false;\n            }\n        }), true);\n    }\n    onlyFinite(f) {\n        if (this.isFinite) {\n            return f;\n        }\n        else {\n            return undefined;\n        }\n    }\n}\nclass UnorderedTransactionsScanner {\n    constructor(provider, params) {\n        this.provider = provider;\n        this.params = params;\n        this.queue = new PromiseQueue();\n        this.isRunning = false;\n    }\n    start() {\n        if (this.isRunning || this.promise != null) {\n            return;\n        }\n        this.isRunning = true;\n        this.promise = (async () => {\n            const params = this.params;\n            const state = {\n                complete: false,\n            };\n            while (this.isRunning && !state.complete) {\n                try {\n                    const { transactions, continuation } = await this.provider.getTransactions({\n                        address: this.params.address,\n                        continuation: this.continuation,\n                    });\n                    state.complete = !state.complete && transactions.length == null;\n                    if (!this.isRunning || state.complete) {\n                        break;\n                    }\n                    const filteredTransactions = transactions.filter((item) => ((params.fromLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, params.fromLt) > 0) &&\n                        (params.fromUtime == null || item.createdAt > params.fromUtime)));\n                    if (filteredTransactions.length == 0) {\n                        state.complete = true;\n                        break;\n                    }\n                    const info = {\n                        maxLt: filteredTransactions[0].id.lt,\n                        minLt: filteredTransactions[filteredTransactions.length - 1].id.lt,\n                        batchType: 'old',\n                    };\n                    this.queue.enqueue(async () => {\n                        const isRunning = this.params.onData({\n                            address: this.params.address,\n                            transactions: filteredTransactions,\n                            info,\n                        });\n                        if (!isRunning) {\n                            state.complete = true;\n                            this.isRunning = false;\n                        }\n                    });\n                    if (continuation != null) {\n                        this.continuation = continuation;\n                    }\n                    else {\n                        state.complete = true;\n                        break;\n                    }\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            }\n            this.queue.enqueue(async () => this.params.onEnd(state.complete));\n            this.isRunning = false;\n            this.continuation = undefined;\n        })();\n    }\n    async stop() {\n        this.isRunning = false;\n        this.queue.clear();\n        if (this.promise != null) {\n            await this.promise;\n        }\n        else {\n            this.params.onEnd(false);\n        }\n    }\n}\nclass TraceTransactionsScanner {\n    constructor(provider, params) {\n        this.provider = provider;\n        this.params = params;\n        this.queue = new PromiseQueue();\n        this.isRunning = false;\n        this.semaphore = new utils_1.Semaphore(10);\n    }\n    start() {\n        if (this.isRunning || this.promise != null) {\n            return;\n        }\n        const provider = this.provider;\n        this.isRunning = true;\n        this.promise = (async () => {\n            const state = {\n                complete: false,\n            };\n            const makePendingTransaction = (messageHash) => {\n                const state = { stopped: false };\n                const promise = (async () => {\n                    let timeout = 500;\n                    while (true) {\n                        const release = await this.semaphore.acquire();\n                        if (state.stopped) {\n                            release();\n                            return;\n                        }\n                        const result = await provider.rawApi.findTransaction({\n                            inMessageHash: messageHash,\n                        }).catch(() => ({ transaction: undefined })).finally(() => release());\n                        if (state.stopped) {\n                            return;\n                        }\n                        if (result.transaction != null) {\n                            const transaction = (0, models_1.parseTransaction)(result.transaction);\n                            transaction.account = transaction.inMessage.dst;\n                            return transaction;\n                        }\n                        let resolve;\n                        const promise = new Promise((resolvePromise, rejectPromise) => {\n                            resolve = () => resolvePromise();\n                            state.reject = () => rejectPromise();\n                        });\n                        state.timeout = setTimeout(resolve, timeout);\n                        await promise;\n                        if (state.stopped) {\n                            return;\n                        }\n                        state.reject = undefined;\n                        timeout = Math.min(timeout * 2, 3000);\n                    }\n                })();\n                const reject = () => {\n                    var _a;\n                    state.stopped = true;\n                    (_a = state.reject) === null || _a === void 0 ? void 0 : _a.call(state);\n                    if (state.timeout != null) {\n                        clearTimeout(state.timeout);\n                    }\n                };\n                return { promise, reject };\n            };\n            const transactionsQueue = [this.params.origin];\n            try {\n                outer: while (this.isRunning) {\n                    const transaction = transactionsQueue.shift();\n                    if (transaction == null) {\n                        state.complete = true;\n                        break;\n                    }\n                    // Spawn promises\n                    const pendingTransactions = transaction\n                        .outMessages\n                        .filter((message) => message.dst != null)\n                        .map((message) => {\n                        const messageHash = message.hash;\n                        return makePendingTransaction(messageHash);\n                    });\n                    this.pendingTransactions = pendingTransactions;\n                    for (const { promise } of pendingTransactions) {\n                        const childTransaction = await promise;\n                        if (!this.isRunning || state.complete || childTransaction == null) {\n                            break outer;\n                        }\n                        this.queue.enqueue(async () => {\n                            const isRunning = this.params.onData(childTransaction);\n                            if (!isRunning) {\n                                state.complete = true;\n                                this.isRunning = false;\n                                this.rejectPendingTransactions();\n                            }\n                        });\n                        transactionsQueue.push(childTransaction);\n                    }\n                    this.pendingTransactions = undefined;\n                }\n            }\n            catch (e) {\n                console.error(e);\n                /* do nothing */\n            }\n            finally {\n                this.queue.enqueue(async () => this.params.onEnd(state.complete));\n                this.isRunning = false;\n                this.rejectPendingTransactions();\n            }\n        })();\n    }\n    async stop() {\n        this.isRunning = false;\n        this.queue.clear();\n        this.rejectPendingTransactions();\n        if (this.promise != null) {\n            await this.promise;\n        }\n        else {\n            this.params.onEnd(false);\n        }\n    }\n    rejectPendingTransactions() {\n        if (this.pendingTransactions != null) {\n            for (const pendingTransaction of this.pendingTransactions) {\n                pendingTransaction.reject();\n            }\n            this.pendingTransactions = undefined;\n        }\n        this.semaphore.releaseAll();\n    }\n}\nclass PromiseQueue {\n    constructor() {\n        this.queue = [];\n        this.workingOnPromise = false;\n    }\n    enqueue(promise) {\n        this.queue.push(promise);\n        this._dequeue().catch(() => {\n        });\n    }\n    clear() {\n        this.queue.length = 0;\n    }\n    async _dequeue() {\n        if (this.workingOnPromise) {\n            return;\n        }\n        const item = this.queue.shift();\n        if (!item) {\n            return;\n        }\n        this.workingOnPromise = true;\n        item()\n            .then(() => {\n            this.workingOnPromise = false;\n            this._dequeue();\n        })\n            .catch(() => {\n            this.workingOnPromise = false;\n            this._dequeue();\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLWlucGFnZS1wcm92aWRlci9kaXN0L3N0cmVhbS5qcz80NWUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdWJzY3JpYmVyID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgbW9kZWxzXzEgPSByZXF1aXJlKFwiLi9tb2RlbHNcIik7XG4vKipcbiAqIEBjYXRlZ29yeSBTdHJlYW1cbiAqL1xuY2xhc3MgU3Vic2NyaWJlciB7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2Nhbm5lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSBhc3luYyAoKSA9PiB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyZWFtIG9mIG5ldyB0cmFuc2FjdGlvbnNcbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvbnMoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkU3Vic2NyaXB0aW9uKCd0cmFuc2FjdGlvbnNGb3VuZCcsIGFkZHJlc3MsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZpbml0ZSBzdHJlYW0gb2YgY2hpbGQgdHJhbnNhY3Rpb25zXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gcm9vdCB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIHRyYWNlKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGlkID0gKDAsIHV0aWxzXzEuZ2V0VW5pcXVlSWQpKCk7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCgob25EYXRhLCBvbkVuZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2Nhbm5lciA9IG5ldyBUcmFjZVRyYW5zYWN0aW9uc1NjYW5uZXIodGhpcy5wcm92aWRlciwge1xuICAgICAgICAgICAgICAgIG9yaWdpbjogdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgb25EYXRhLFxuICAgICAgICAgICAgICAgIG9uRW5kOiAoZW9mKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgb25FbmQoZW9mKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNjYW5uZXJzLnNldChpZCwgc2Nhbm5lcik7XG4gICAgICAgICAgICBzY2FubmVyLnN0YXJ0KCk7XG4gICAgICAgICAgICAvLyBTdWJzY3JpcHRpb24gaXMgbm90IHJlcXVpcmVkXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH0sIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjYW5uZXIgPSB0aGlzLnNjYW5uZXJzLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoc2Nhbm5lciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FubmVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHNjYW5uZXIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpZGVudGl0eSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJlYW0gb2Ygb2xkIHRyYW5zYWN0aW9uc1xuICAgICAqL1xuICAgIG9sZFRyYW5zYWN0aW9ucyhhZGRyZXNzLCBmaWx0ZXIpIHtcbiAgICAgICAgY29uc3QgaWQgPSAoMCwgdXRpbHNfMS5nZXRVbmlxdWVJZCkoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKChvbkRhdGEsIG9uRW5kKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2FubmVyID0gbmV3IFVub3JkZXJlZFRyYW5zYWN0aW9uc1NjYW5uZXIodGhpcy5wcm92aWRlciwge1xuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgb25EYXRhLFxuICAgICAgICAgICAgICAgIG9uRW5kOiAoZW9mKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgb25FbmQoZW9mKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC4uLmZpbHRlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zY2FubmVycy5zZXQoaWQsIHNjYW5uZXIpO1xuICAgICAgICAgICAgc2Nhbm5lci5zdGFydCgpO1xuICAgICAgICAgICAgLy8gU3Vic2NyaXB0aW9uIGlzIG5vdCByZXF1aXJlZFxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2FubmVyID0gdGhpcy5zY2FubmVycy5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKHNjYW5uZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzY2FubmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaWRlbnRpdHksIHRydWUpO1xuICAgIH1cbiAgICBzdGF0ZXMoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkU3Vic2NyaXB0aW9uKCdjb250cmFjdFN0YXRlQ2hhbmdlZCcsIGFkZHJlc3MsIGZhbHNlKTtcbiAgICB9XG4gICAgYXN5bmMgX3Vuc3Vic2NyaWJlKCkge1xuICAgICAgICBjb25zdCB0YXNrcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5zdWJzY3JpcHRpb25zLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtldmVudCwgZXZlbnREYXRhXSBvZiBPYmplY3QuZW50cmllcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtW2V2ZW50XTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnREYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaChldmVudERhdGEuc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihpdGVtID0+IGl0ZW0udW5zdWJzY3JpYmUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmNsZWFyKCk7XG4gICAgICAgIGZvciAoY29uc3Qgc2Nhbm5lciBvZiB0aGlzLnNjYW5uZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB0YXNrcy5wdXNoKHNjYW5uZXIuc3RvcCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjYW5uZXJzLmNsZWFyKCk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRhc2tzKTtcbiAgICB9XG4gICAgX2FkZFN1YnNjcmlwdGlvbihldmVudCwgYWRkcmVzcywgaXNGaW5pdGUpIHtcbiAgICAgICAgY29uc3QgcmF3QWRkcmVzcyA9IGFkZHJlc3MudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3Qgc3RvcFByb2R1Y2VyID0gKGlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zLmdldChyYXdBZGRyZXNzKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBzdWJzY3JpcHRpb25zIGZvciB0aGUgYWRkcmVzc1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IHN1YnNjcmlwdGlvbnNbZXZlbnRdO1xuICAgICAgICAgICAgaWYgKGV2ZW50RGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IGV2ZW50RGF0YS5oYW5kbGVycy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGV2ZW50IGhhbmRsZXIgd2l0aCB0aGUgaWRcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREYXRhLmhhbmRsZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcXVldWUsIG9uRW5kLCBzdGF0ZSB9ID0gaGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLmVucXVldWUoYXN5bmMgKCkgPT4gb25FbmQoc3RhdGUuZW9mKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGV2ZW50IGRhdGEgc3Vic2NyaXB0aW9uIGlmIHRoZXJlIGFyZSBub25lIG9mIHRoZW1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnREYXRhLmhhbmRsZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gZXZlbnREYXRhLnN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN1YnNjcmlwdGlvbnNbZXZlbnRdO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChzdWJzY3JpcHRpb24pID0+IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGNvbnNvbGUuZGVidWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBhZGRyZXNzIHN1YnNjcmlwdGlvbnMgb2JqZWN0IGlmIGl0IGlzIGVtcHR5XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9ucy5jb250cmFjdFN0YXRlQ2hhbmdlZCA9PSBudWxsICYmIHN1YnNjcmlwdGlvbnMudHJhbnNhY3Rpb25zRm91bmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kZWxldGUocmF3QWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGlkID0gKDAsIHV0aWxzXzEuZ2V0VW5pcXVlSWQpKCk7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCgob25EYXRhLCBvbkVuZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQocmF3QWRkcmVzcyk7XG4gICAgICAgICAgICBsZXQgZXZlbnREYXRhID0gc3Vic2NyaXB0aW9ucyA9PT0gbnVsbCB8fCBzdWJzY3JpcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdWJzY3JpcHRpb25zW2V2ZW50XTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0geyBlb2Y6IGZhbHNlLCBmaW5pc2hlZDogZmFsc2UgfTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBoYW5kbGVyIG9iamVjdFxuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHtcbiAgICAgICAgICAgICAgICBvbkRhdGEsXG4gICAgICAgICAgICAgICAgb25FbmQsXG4gICAgICAgICAgICAgICAgcXVldWU6IG5ldyBQcm9taXNlUXVldWUoKSxcbiAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXZlbnREYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgaGFuZGxlciBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgaGFuZGxlciBncm91cFxuICAgICAgICAgICAgICAgIGV2ZW50RGF0YS5oYW5kbGVycy5zZXQoaWQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENyZWF0ZSBoYW5kbGVycyBncm91cFxuICAgICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBoYW5kbGVycy5zZXQoaWQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5wcm92aWRlci5zdWJzY3JpYmUoZXZlbnQsIHsgYWRkcmVzcyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChzdWJzY3JpcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgb25EYXRhLCBxdWV1ZSwgc3RhdGUgfSBvZiBoYW5kbGVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBjbG9zZWQgc3RyZWFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmVvZiB8fCBzdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYXdhaXQgb25EYXRhKGRhdGEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5lb2YgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wUHJvZHVjZXIoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLm9uKCd1bnN1YnNjcmliZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaWQgb2YgaGFuZGxlcnMua2V5cygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wUHJvZHVjZXIoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGhhbmRsZXJzLmtleXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9wUHJvZHVjZXIoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBZGQgZXZlbnQgZGF0YSB0byBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgICBldmVudERhdGEgPSB7IHN1YnNjcmlwdGlvbiwgaGFuZGxlcnMgfTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuc2V0KHJhd0FkZHJlc3MsIHsgW2V2ZW50XTogZXZlbnREYXRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uc1tldmVudF0gPSBldmVudERhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXYWl0IHVudGlsIHN1YnNjcmliZWRcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb24udGhlbigoKSA9PiB7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgKCkgPT4gc3RvcFByb2R1Y2VyKGlkKSwgaWRlbnRpdHksIGlzRmluaXRlKTtcbiAgICB9XG59XG5leHBvcnRzLlN1YnNjcmliZXIgPSBTdWJzY3JpYmVyO1xuYXN5bmMgZnVuY3Rpb24gaWRlbnRpdHkoaXRlbSwgaGFuZGxlcikge1xuICAgIHJldHVybiBoYW5kbGVyKGl0ZW0pO1xufVxuY2xhc3MgU3RyZWFtSW1wbCB7XG4gICAgY29uc3RydWN0b3IobWFrZVByb2R1Y2VyLCBzdG9wUHJvZHVjZXIsIGV4dHJhY3RvciwgaXNGaW5pdGUpIHtcbiAgICAgICAgdGhpcy5tYWtlUHJvZHVjZXIgPSBtYWtlUHJvZHVjZXI7XG4gICAgICAgIHRoaXMuc3RvcFByb2R1Y2VyID0gc3RvcFByb2R1Y2VyO1xuICAgICAgICB0aGlzLmV4dHJhY3RvciA9IGV4dHJhY3RvcjtcbiAgICAgICAgdGhpcy5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9sZHMgZXZlcnkgZWxlbWVudCBpbnRvIGFuIGFjY3VtdWxhdG9yIGJ5IGFwcGx5aW5nIGFuIG9wZXJhdGlvbiwgcmV0dXJuaW5nIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9sZCA9IHRoaXMub25seUZpbml0ZSgoaW5pdCwgZiwgY3R4KSA9PiB7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSBpbml0O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVkID0gdGhpcy5tYWtlUHJvZHVjZXIoXG4gICAgICAgICAgICAgICAgLy8gb25EYXRhXG4gICAgICAgICAgICAgICAgKGRhdGEpID0+IHRoaXMuZXh0cmFjdG9yKGRhdGEsIGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gYXdhaXQgZihzdGF0ZSwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICAvLyBvbkVuZFxuICAgICAgICAgICAgICAgIChlb2YpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVvZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdTdWJzY3JpcHRpb24gY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdWJzY3JpYmVkID0gc3Vic2NyaWJlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXYWl0cyB1bnRpbCB0aGUgZW5kIG9mIHRoZSBzdHJlYW1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0aGlzLm9ubHlGaW5pdGUoKGN0eCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVkID0gdGhpcy5tYWtlUHJvZHVjZXIoXG4gICAgICAgICAgICAgICAgLy8gb25EYXRhXG4gICAgICAgICAgICAgICAgKGRhdGEpID0+IHRoaXMuZXh0cmFjdG9yKGRhdGEsIChfaXRlbSkgPT4gdHJ1ZSksIFxuICAgICAgICAgICAgICAgIC8vIG9uRW5kXG4gICAgICAgICAgICAgICAgKGVvZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdTdWJzY3JpcHRpb24gY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdWJzY3JpYmVkID0gc3Vic2NyaWJlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGF5ZWQoZikge1xuICAgICAgICBjb25zdCB7IHN1YnNjcmliZWQsIHJlc3VsdCB9ID0gZih7XG4gICAgICAgICAgICBmaXJzdDogKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdHggPSB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmZpcnN0KGN0eCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3Vic2NyaWJlZDogY3R4LnN1YnNjcmliZWQsIHJlc3VsdCB9O1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvbjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdHggPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKGhhbmRsZXIsIGN0eCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3Vic2NyaWJlZDogY3R4LnN1YnNjcmliZWQsIHJlc3VsdDogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9sZDogdGhpcy5mb2xkICE9IG51bGwgPyAoaW5pdCwgZikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZm9sZChpbml0LCBmLCBjdHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN1YnNjcmliZWQ6IGN0eC5zdWJzY3JpYmVkLCByZXN1bHQgfTtcbiAgICAgICAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBmaW5pc2hlZDogdGhpcy5maW5pc2hlZCAhPSBudWxsID8gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZmluaXNoZWQoY3R4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdWJzY3JpYmVkOiBjdHguc3Vic2NyaWJlZCwgcmVzdWx0IH07XG4gICAgICAgICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgc3Vic2NyaWJlZDtcbiAgICAgICAgcmV0dXJuICgpID0+IHJlc3VsdDtcbiAgICB9XG4gICAgZmlyc3QoY3R4KSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0geyBmb3VuZDogZmFsc2UgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZWQgPSB0aGlzLm1ha2VQcm9kdWNlcihcbiAgICAgICAgICAgIC8vIG9uRGF0YVxuICAgICAgICAgICAgKGRhdGEpID0+IHRoaXMuZXh0cmFjdG9yKGRhdGEsIChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdGF0ZSwgeyBmb3VuZDogdHJ1ZSwgcmVzdWx0OiBpdGVtIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgIC8vIG9uRW5kXG4gICAgICAgICAgICAoZW9mKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVvZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0Zpbml0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgoc3RhdGUuZm91bmQgPyBzdGF0ZS5yZXN1bHQgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZS5mb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdGF0ZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2Ygc3RyZWFtJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdTdWJzY3JpcHRpb24gY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN1YnNjcmliZWQgPSBzdWJzY3JpYmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb24oaGFuZGxlciwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZWQgPSB0aGlzLm1ha2VQcm9kdWNlcigoZXZlbnQpID0+IHRoaXMuZXh0cmFjdG9yKGV2ZW50LCBhc3luYyAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlcihpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KSwgKF9lb2YpID0+IHtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgY3R4LnN1YnNjcmliZWQgPSBzdWJzY3JpYmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCgob25EYXRhLCBvbkVuZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgc3RvcHBlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY291bnRlcjogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjaGVja0VuZCA9IChlb2YpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgrK3N0YXRlLmNvdW50ZXIgPT0gMiB8fCAhZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvbkVuZChlb2YpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMubWFrZVByb2R1Y2VyKG9uRGF0YSwgY2hlY2tFbmQpLFxuICAgICAgICAgICAgICAgIG90aGVyLm1ha2VQcm9kdWNlcihvbkRhdGEsIGNoZWNrRW5kKSxcbiAgICAgICAgICAgIF0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFByb2R1Y2VyKCk7XG4gICAgICAgICAgICBvdGhlci5zdG9wUHJvZHVjZXIoKTtcbiAgICAgICAgfSwgdGhpcy5leHRyYWN0b3IsICh0aGlzLmlzRmluaXRlICYmIG90aGVyLmlzRmluaXRlKSk7XG4gICAgfVxuICAgIGVudW1lcmF0ZSgpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKHRoaXMubWFrZVByb2R1Y2VyLCB0aGlzLnN0b3BQcm9kdWNlciwgKGV2ZW50LCBoYW5kbGVyKSA9PiB0aGlzLmV4dHJhY3RvcihldmVudCwgYXN5bmMgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyKHtcbiAgICAgICAgICAgICAgICBpbmRleDogc3RhdGUuaW5kZXgrKyxcbiAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLCB0aGlzLmlzRmluaXRlKTtcbiAgICB9XG4gICAgdGFwKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKHRoaXMubWFrZVByb2R1Y2VyLCB0aGlzLnN0b3BQcm9kdWNlciwgKGV2ZW50LCBoYW5kbGVyKSA9PiB0aGlzLmV4dHJhY3RvcihldmVudCwgYXN5bmMgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGF3YWl0IGYoaXRlbSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlcihpdGVtKTtcbiAgICAgICAgfSksIHRoaXMuaXNGaW5pdGUpO1xuICAgIH1cbiAgICBmaWx0ZXIoZikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwodGhpcy5tYWtlUHJvZHVjZXIsIHRoaXMuc3RvcFByb2R1Y2VyLCAoZXZlbnQsIGhhbmRsZXIpID0+IHRoaXMuZXh0cmFjdG9yKGV2ZW50LCBhc3luYyAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGF3YWl0IGYoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcihpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgdGhpcy5pc0Zpbml0ZSk7XG4gICAgfVxuICAgIGZpbHRlck1hcChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCh0aGlzLm1ha2VQcm9kdWNlciwgdGhpcy5zdG9wUHJvZHVjZXIsIChldmVudCwgaGFuZGxlcikgPT4gdGhpcy5leHRyYWN0b3IoZXZlbnQsIGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtID0gYXdhaXQgZihpdGVtKTtcbiAgICAgICAgICAgIGlmIChuZXdJdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcihuZXdJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgdGhpcy5pc0Zpbml0ZSk7XG4gICAgfVxuICAgIG1hcChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCh0aGlzLm1ha2VQcm9kdWNlciwgdGhpcy5zdG9wUHJvZHVjZXIsIChldmVudCwgaGFuZGxlcikgPT4gdGhpcy5leHRyYWN0b3IoZXZlbnQsIGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtID0gYXdhaXQgZihpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyKG5ld0l0ZW0pO1xuICAgICAgICB9KSwgdGhpcy5pc0Zpbml0ZSk7XG4gICAgfVxuICAgIGZsYXRNYXAoZikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwodGhpcy5tYWtlUHJvZHVjZXIsIHRoaXMuc3RvcFByb2R1Y2VyLCAoZXZlbnQsIGhhbmRsZXIpID0+IHRoaXMuZXh0cmFjdG9yKGV2ZW50LCBhc3luYyAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBhd2FpdCBmKGl0ZW0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBuZXdJdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoYXdhaXQgaGFuZGxlcihuZXdJdGVtKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KSwgdGhpcy5pc0Zpbml0ZSk7XG4gICAgfVxuICAgIHNraXAobikge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwodGhpcy5tYWtlUHJvZHVjZXIsIHRoaXMuc3RvcFByb2R1Y2VyLCAoZXZlbnQsIGhhbmRsZXIpID0+IHRoaXMuZXh0cmFjdG9yKGV2ZW50LCAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmluZGV4ID49IG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcihpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICsrc3RhdGUuaW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCB0aGlzLmlzRmluaXRlKTtcbiAgICB9XG4gICAgc2tpcFdoaWxlKGYpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICBzaG91bGRTa2lwOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwodGhpcy5tYWtlUHJvZHVjZXIsIHRoaXMuc3RvcFByb2R1Y2VyLCAoZXZlbnQsIGhhbmRsZXIpID0+IHRoaXMuZXh0cmFjdG9yKGV2ZW50LCBhc3luYyAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5zaG91bGRTa2lwIHx8ICEoYXdhaXQgZihpdGVtKSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zaG91bGRTa2lwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHRoaXMuaXNGaW5pdGUpO1xuICAgIH1cbiAgICB0YWtlKG4pIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKHRoaXMubWFrZVByb2R1Y2VyLCB0aGlzLnN0b3BQcm9kdWNlciwgKGV2ZW50LCBoYW5kbGVyKSA9PiB0aGlzLmV4dHJhY3RvcihldmVudCwgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pbmRleCA8IG4pIHtcbiAgICAgICAgICAgICAgICArK3N0YXRlLmluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRha2VXaGlsZShmKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCh0aGlzLm1ha2VQcm9kdWNlciwgdGhpcy5zdG9wUHJvZHVjZXIsIChldmVudCwgaGFuZGxlcikgPT4gdGhpcy5leHRyYWN0b3IoZXZlbnQsIGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXdhaXQgZihpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRha2VXaGlsZU1hcChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCh0aGlzLm1ha2VQcm9kdWNlciwgdGhpcy5zdG9wUHJvZHVjZXIsIChldmVudCwgaGFuZGxlcikgPT4gdGhpcy5leHRyYWN0b3IoZXZlbnQsIGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtID0gYXdhaXQgZihpdGVtKTtcbiAgICAgICAgICAgIGlmIChuZXdJdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcihuZXdJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHRydWUpO1xuICAgIH1cbiAgICBvbmx5RmluaXRlKGYpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFVub3JkZXJlZFRyYW5zYWN0aW9uc1NjYW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQcm9taXNlUXVldWUoKTtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUnVubmluZyB8fCB0aGlzLnByb21pc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzUnVubmluZyAmJiAhc3RhdGUuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9ucywgY29udGludWF0aW9uIH0gPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLnBhcmFtcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWF0aW9uOiB0aGlzLmNvbnRpbnVhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlID0gIXN0YXRlLmNvbXBsZXRlICYmIHRyYW5zYWN0aW9ucy5sZW5ndGggPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZyB8fCBzdGF0ZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRUcmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMuZmlsdGVyKChpdGVtKSA9PiAoKHBhcmFtcy5mcm9tTHQgPT0gbnVsbCB8fCB1dGlsc18xLkxUX0NPTExBVE9SLmNvbXBhcmUoaXRlbS5pZC5sdCwgcGFyYW1zLmZyb21MdCkgPiAwKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHBhcmFtcy5mcm9tVXRpbWUgPT0gbnVsbCB8fCBpdGVtLmNyZWF0ZWRBdCA+IHBhcmFtcy5mcm9tVXRpbWUpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJlZFRyYW5zYWN0aW9ucy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEx0OiBmaWx0ZXJlZFRyYW5zYWN0aW9uc1swXS5pZC5sdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkx0OiBmaWx0ZXJlZFRyYW5zYWN0aW9uc1tmaWx0ZXJlZFRyYW5zYWN0aW9ucy5sZW5ndGggLSAxXS5pZC5sdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoVHlwZTogJ29sZCcsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1J1bm5pbmcgPSB0aGlzLnBhcmFtcy5vbkRhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMucGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBmaWx0ZXJlZFRyYW5zYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUnVubmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRpbnVhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVhdGlvbiA9IGNvbnRpbnVhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHRoaXMucGFyYW1zLm9uRW5kKHN0YXRlLmNvbXBsZXRlKSk7XG4gICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jb250aW51YXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGFzeW5jIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucXVldWUuY2xlYXIoKTtcbiAgICAgICAgaWYgKHRoaXMucHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy5vbkVuZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBUcmFjZVRyYW5zYWN0aW9uc1NjYW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQcm9taXNlUXVldWUoKTtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZW1hcGhvcmUgPSBuZXcgdXRpbHNfMS5TZW1hcGhvcmUoMTApO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nIHx8IHRoaXMucHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyO1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbWFrZVBlbmRpbmdUcmFuc2FjdGlvbiA9IChtZXNzYWdlSGFzaCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0geyBzdG9wcGVkOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGltZW91dCA9IDUwMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGVhc2UgPSBhd2FpdCB0aGlzLnNlbWFwaG9yZS5hY3F1aXJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5yYXdBcGkuZmluZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbk1lc3NhZ2VIYXNoOiBtZXNzYWdlSGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKCgpID0+ICh7IHRyYW5zYWN0aW9uOiB1bmRlZmluZWQgfSkpLmZpbmFsbHkoKCkgPT4gcmVsZWFzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC50cmFuc2FjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSAoMCwgbW9kZWxzXzEucGFyc2VUcmFuc2FjdGlvbikocmVzdWx0LnRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5hY2NvdW50ID0gdHJhbnNhY3Rpb24uaW5NZXNzYWdlLmRzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gKCkgPT4gcmVzb2x2ZVByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5yZWplY3QgPSAoKSA9PiByZWplY3RQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUucmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IE1hdGgubWluKHRpbWVvdXQgKiAyLCAzMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVqZWN0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdGF0ZS5yZWplY3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBwcm9taXNlLCByZWplY3QgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbnNRdWV1ZSA9IFt0aGlzLnBhcmFtcy5vcmlnaW5dO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvdXRlcjogd2hpbGUgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25zUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNwYXduIHByb21pc2VzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdUcmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLm91dE1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChtZXNzYWdlKSA9PiBtZXNzYWdlLmRzdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZUhhc2ggPSBtZXNzYWdlLmhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZVBlbmRpbmdUcmFuc2FjdGlvbihtZXNzYWdlSGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUcmFuc2FjdGlvbnMgPSBwZW5kaW5nVHJhbnNhY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcHJvbWlzZSB9IG9mIHBlbmRpbmdUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkVHJhbnNhY3Rpb24gPSBhd2FpdCBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZyB8fCBzdGF0ZS5jb21wbGV0ZSB8fCBjaGlsZFRyYW5zYWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNSdW5uaW5nID0gdGhpcy5wYXJhbXMub25EYXRhKGNoaWxkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3RQZW5kaW5nVHJhbnNhY3Rpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnNRdWV1ZS5wdXNoKGNoaWxkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1RyYW5zYWN0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgLyogZG8gbm90aGluZyAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHRoaXMucGFyYW1zLm9uRW5kKHN0YXRlLmNvbXBsZXRlKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdFBlbmRpbmdUcmFuc2FjdGlvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5xdWV1ZS5jbGVhcigpO1xuICAgICAgICB0aGlzLnJlamVjdFBlbmRpbmdUcmFuc2FjdGlvbnMoKTtcbiAgICAgICAgaWYgKHRoaXMucHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy5vbkVuZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVqZWN0UGVuZGluZ1RyYW5zYWN0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1RyYW5zYWN0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBlbmRpbmdUcmFuc2FjdGlvbiBvZiB0aGlzLnBlbmRpbmdUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nVHJhbnNhY3Rpb24ucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdUcmFuc2FjdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW1hcGhvcmUucmVsZWFzZUFsbCgpO1xuICAgIH1cbn1cbmNsYXNzIFByb21pc2VRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy53b3JraW5nT25Qcm9taXNlID0gZmFsc2U7XG4gICAgfVxuICAgIGVucXVldWUocHJvbWlzZSkge1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2gocHJvbWlzZSk7XG4gICAgICAgIHRoaXMuX2RlcXVldWUoKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5xdWV1ZS5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBhc3luYyBfZGVxdWV1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2luZ09uUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud29ya2luZ09uUHJvbWlzZSA9IHRydWU7XG4gICAgICAgIGl0ZW0oKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53b3JraW5nT25Qcm9taXNlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9kZXF1ZXVlKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53b3JraW5nT25Qcm9taXNlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9kZXF1ZXVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///25\n")},786:(__unused_webpack_module,exports)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getUniqueId = exports.mergeTransactions = exports.LT_COLLATOR = exports.Semaphore = exports.DelayedTransactions = exports.MessageExpiredException = exports.AddressLiteral = exports.Address = void 0;\n/**\n * @category Utils\n */\nclass Address {\n    constructor(address) {\n        this.equals = (other) => this._equals(other);\n        this._address = address;\n    }\n    toString() {\n        return this._address;\n    }\n    toJSON() {\n        return this._address;\n    }\n    _equals(other) {\n        if (other instanceof Address) {\n            return this._address === other._address;\n        }\n        else {\n            return this._address === other;\n        }\n    }\n}\nexports.Address = Address;\n/**\n * @category Utils\n */\nclass AddressLiteral extends Address {\n    constructor(address) {\n        super(address);\n    }\n}\nexports.AddressLiteral = AddressLiteral;\n/**\n * @category Utils\n */\nclass MessageExpiredException extends Error {\n    constructor(address, hash) {\n        super('Message expired');\n        this.address = address;\n        this.hash = hash;\n    }\n}\nexports.MessageExpiredException = MessageExpiredException;\nclass DelayedTransactions {\n    constructor() {\n        this.transactions = new Map();\n    }\n    async waitTransaction(address, hash) {\n        var _a;\n        let transaction = (_a = this.transactions.get(hash)) === null || _a === void 0 ? void 0 : _a.promise;\n        if (transaction == null) {\n            let resolve;\n            let reject;\n            transaction = new Promise((promiseResolve, promiseReject) => {\n                resolve = (tx) => promiseResolve(tx);\n                reject = () => promiseReject();\n            });\n            this.transactions.set(hash, {\n                promise: transaction,\n                resolve: resolve,\n                reject: reject,\n            });\n        }\n        const tx = await transaction;\n        if (tx == null) {\n            throw new MessageExpiredException(address, hash);\n        }\n        return tx;\n    }\n    fillTransaction(hash, transaction) {\n        const pendingTransaction = this.transactions.get(hash);\n        if (pendingTransaction != null) {\n            pendingTransaction.resolve(transaction);\n        }\n        else {\n            this.transactions.set(hash, {\n                promise: Promise.resolve(transaction),\n                resolve: () => {\n                },\n                reject: () => {\n                },\n            });\n        }\n    }\n}\nexports.DelayedTransactions = DelayedTransactions;\n/**\n * @category Utils\n */\nclass Semaphore {\n    constructor(count) {\n        this.tasks = [];\n        this.sched = () => {\n            var _a;\n            if (this.count > 0 && this.tasks.length > 0) {\n                this.count--;\n                (_a = this.tasks.shift()) === null || _a === void 0 ? void 0 : _a();\n            }\n        };\n        this.count = count;\n    }\n    acquire() {\n        return new Promise((res, _rej) => {\n            this.tasks.push(() => {\n                let released = false;\n                res(() => {\n                    if (!released) {\n                        released = true;\n                        this.count++;\n                        this.sched();\n                    }\n                });\n            });\n            nextTick(this.sched);\n        });\n    }\n    releaseAll() {\n        var _a;\n        while (this.tasks.length > 0) {\n            (_a = this.tasks.shift()) === null || _a === void 0 ? void 0 : _a();\n        }\n    }\n}\nexports.Semaphore = Semaphore;\nfunction byObserver(Observer) {\n    const node = document.createTextNode('');\n    let queue, currentQueue, bit = 0, i = 0;\n    new Observer(function () {\n        let callback;\n        if (!queue) {\n            if (!currentQueue)\n                return;\n            queue = currentQueue;\n        }\n        else if (currentQueue) {\n            queue = currentQueue.slice(i).concat(queue);\n        }\n        currentQueue = queue;\n        queue = null;\n        i = 0;\n        if (typeof currentQueue === 'function') {\n            callback = currentQueue;\n            currentQueue = null;\n            callback();\n            return;\n        }\n        node.data = (bit = ++bit % 2);\n        while (i < currentQueue.length) {\n            callback = currentQueue[i];\n            i++;\n            if (i === currentQueue.length)\n                currentQueue = null;\n            callback();\n        }\n    }).observe(node, { characterData: true });\n    return function (fn) {\n        if (queue) {\n            if (typeof queue === 'function')\n                queue = [queue, fn];\n            else\n                queue.push(fn);\n            return;\n        }\n        queue = fn;\n        node.data = (bit = ++bit % 2);\n    };\n}\nconst nextTick = (function () {\n    // queueMicrotask\n    if (typeof queueMicrotask === 'function') {\n        return queueMicrotask;\n    }\n    // MutationObserver\n    if ((typeof document === 'object') && document) {\n        if (typeof MutationObserver === 'function')\n            return byObserver(MutationObserver);\n        if (typeof window.WebKitMutationObserver === 'function')\n            return byObserver(window.WebKitMutationObserver);\n    }\n    /* @ts-ignore */\n    if (typeof setImmediate === 'function') {\n        /* @ts-ignore */\n        return setImmediate;\n    }\n    if ((typeof setTimeout === 'function') || (typeof setTimeout === 'object')) {\n        return function (cb) {\n            setTimeout(cb, 0);\n        };\n    }\n    throw new Error('No `nextTick` implementation found');\n}());\n/**\n * @category Utils\n */\nexports.LT_COLLATOR = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });\n/**\n * Modifies knownTransactions array, merging it with new transactions.\n * All arrays are assumed to be sorted by descending logical time.\n *\n * > Note! This method does not remove duplicates.\n *\n * @param knownTransactions\n * @param newTransactions\n * @param info\n *\n * @category Utils\n */\nfunction mergeTransactions(knownTransactions, newTransactions, info) {\n    if (info.batchType === 'old') {\n        knownTransactions.push(...newTransactions);\n        return knownTransactions;\n    }\n    if (knownTransactions.length === 0) {\n        knownTransactions.push(...newTransactions);\n        return knownTransactions;\n    }\n    // Example:\n    // known lts: [N, N-1, N-2, N-3, (!) N-10,...]\n    // new lts: [N-4, N-5]\n    // batch info: { minLt: N-5, maxLt: N-4, batchType: 'new' }\n    // 1. Skip indices until known transaction lt is greater than the biggest in the batch\n    let i = 0;\n    while (i < knownTransactions.length &&\n        exports.LT_COLLATOR.compare(knownTransactions[i].id.lt, info.maxLt) >= 0) {\n        ++i;\n    }\n    // 2. Insert new transactions\n    knownTransactions.splice(i, 0, ...newTransactions);\n    return knownTransactions;\n}\nexports.mergeTransactions = mergeTransactions;\nconst MAX = 4294967295;\nlet idCounter = Math.floor(Math.random() * MAX);\nfunction getUniqueId() {\n    idCounter = (idCounter + 1) % MAX;\n    return idCounter;\n}\nexports.getUniqueId = getUniqueId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXIvZGlzdC91dGlscy5qcz80M2IyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRVbmlxdWVJZCA9IGV4cG9ydHMubWVyZ2VUcmFuc2FjdGlvbnMgPSBleHBvcnRzLkxUX0NPTExBVE9SID0gZXhwb3J0cy5TZW1hcGhvcmUgPSBleHBvcnRzLkRlbGF5ZWRUcmFuc2FjdGlvbnMgPSBleHBvcnRzLk1lc3NhZ2VFeHBpcmVkRXhjZXB0aW9uID0gZXhwb3J0cy5BZGRyZXNzTGl0ZXJhbCA9IGV4cG9ydHMuQWRkcmVzcyA9IHZvaWQgMDtcbi8qKlxuICogQGNhdGVnb3J5IFV0aWxzXG4gKi9cbmNsYXNzIEFkZHJlc3Mge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MpIHtcbiAgICAgICAgdGhpcy5lcXVhbHMgPSAob3RoZXIpID0+IHRoaXMuX2VxdWFscyhvdGhlcik7XG4gICAgICAgIHRoaXMuX2FkZHJlc3MgPSBhZGRyZXNzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3M7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3M7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQWRkcmVzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3MgPT09IG90aGVyLl9hZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3MgPT09IG90aGVyO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzID0gQWRkcmVzcztcbi8qKlxuICogQGNhdGVnb3J5IFV0aWxzXG4gKi9cbmNsYXNzIEFkZHJlc3NMaXRlcmFsIGV4dGVuZHMgQWRkcmVzcyB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcykge1xuICAgICAgICBzdXBlcihhZGRyZXNzKTtcbiAgICB9XG59XG5leHBvcnRzLkFkZHJlc3NMaXRlcmFsID0gQWRkcmVzc0xpdGVyYWw7XG4vKipcbiAqIEBjYXRlZ29yeSBVdGlsc1xuICovXG5jbGFzcyBNZXNzYWdlRXhwaXJlZEV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBoYXNoKSB7XG4gICAgICAgIHN1cGVyKCdNZXNzYWdlIGV4cGlyZWQnKTtcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5oYXNoID0gaGFzaDtcbiAgICB9XG59XG5leHBvcnRzLk1lc3NhZ2VFeHBpcmVkRXhjZXB0aW9uID0gTWVzc2FnZUV4cGlyZWRFeGNlcHRpb247XG5jbGFzcyBEZWxheWVkVHJhbnNhY3Rpb25zIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRUcmFuc2FjdGlvbihhZGRyZXNzLCBoYXNoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHRyYW5zYWN0aW9uID0gKF9hID0gdGhpcy50cmFuc2FjdGlvbnMuZ2V0KGhhc2gpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvbWlzZTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlO1xuICAgICAgICAgICAgbGV0IHJlamVjdDtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gbmV3IFByb21pc2UoKHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9ICh0eCkgPT4gcHJvbWlzZVJlc29sdmUodHgpO1xuICAgICAgICAgICAgICAgIHJlamVjdCA9ICgpID0+IHByb21pc2VSZWplY3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMuc2V0KGhhc2gsIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlOiB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0cmFuc2FjdGlvbjtcbiAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZXNzYWdlRXhwaXJlZEV4Y2VwdGlvbihhZGRyZXNzLCBoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIGZpbGxUcmFuc2FjdGlvbihoYXNoLCB0cmFuc2FjdGlvbikge1xuICAgICAgICBjb25zdCBwZW5kaW5nVHJhbnNhY3Rpb24gPSB0aGlzLnRyYW5zYWN0aW9ucy5nZXQoaGFzaCk7XG4gICAgICAgIGlmIChwZW5kaW5nVHJhbnNhY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgcGVuZGluZ1RyYW5zYWN0aW9uLnJlc29sdmUodHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMuc2V0KGhhc2gsIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlOiBQcm9taXNlLnJlc29sdmUodHJhbnNhY3Rpb24pLFxuICAgICAgICAgICAgICAgIHJlc29sdmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlamVjdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRGVsYXllZFRyYW5zYWN0aW9ucyA9IERlbGF5ZWRUcmFuc2FjdGlvbnM7XG4vKipcbiAqIEBjYXRlZ29yeSBVdGlsc1xuICovXG5jbGFzcyBTZW1hcGhvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNvdW50KSB7XG4gICAgICAgIHRoaXMudGFza3MgPSBbXTtcbiAgICAgICAgdGhpcy5zY2hlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50ID4gMCAmJiB0aGlzLnRhc2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50LS07XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy50YXNrcy5zaGlmdCgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgIH1cbiAgICBhY3F1aXJlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgX3JlaikgPT4ge1xuICAgICAgICAgICAgdGhpcy50YXNrcy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVsZWFzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXMoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbGVhc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjaGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV4dFRpY2sodGhpcy5zY2hlZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWxlYXNlQWxsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHdoaWxlICh0aGlzLnRhc2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMudGFza3Muc2hpZnQoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNlbWFwaG9yZSA9IFNlbWFwaG9yZTtcbmZ1bmN0aW9uIGJ5T2JzZXJ2ZXIoT2JzZXJ2ZXIpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIGxldCBxdWV1ZSwgY3VycmVudFF1ZXVlLCBiaXQgPSAwLCBpID0gMDtcbiAgICBuZXcgT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgY2FsbGJhY2s7XG4gICAgICAgIGlmICghcXVldWUpIHtcbiAgICAgICAgICAgIGlmICghY3VycmVudFF1ZXVlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuc2xpY2UoaSkuY29uY2F0KHF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBudWxsO1xuICAgICAgICBpID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50UXVldWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY3VycmVudFF1ZXVlO1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5kYXRhID0gKGJpdCA9ICsrYml0ICUgMik7XG4gICAgICAgIHdoaWxlIChpIDwgY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjdXJyZW50UXVldWVbaV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAoaSA9PT0gY3VycmVudFF1ZXVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH0pLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKHF1ZXVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXVlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHF1ZXVlID0gW3F1ZXVlLCBmbl07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcXVldWUgPSBmbjtcbiAgICAgICAgbm9kZS5kYXRhID0gKGJpdCA9ICsrYml0ICUgMik7XG4gICAgfTtcbn1cbmNvbnN0IG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBxdWV1ZU1pY3JvdGFza1xuICAgIGlmICh0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXVlTWljcm90YXNrO1xuICAgIH1cbiAgICAvLyBNdXRhdGlvbk9ic2VydmVyXG4gICAgaWYgKCh0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnKSAmJiBkb2N1bWVudCkge1xuICAgICAgICBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm4gYnlPYnNlcnZlcihNdXRhdGlvbk9ic2VydmVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiBieU9ic2VydmVyKHdpbmRvdy5XZWJLaXRNdXRhdGlvbk9ic2VydmVyKTtcbiAgICB9XG4gICAgLyogQHRzLWlnbm9yZSAqL1xuICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZTtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykgfHwgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gYG5leHRUaWNrYCBpbXBsZW1lbnRhdGlvbiBmb3VuZCcpO1xufSgpKTtcbi8qKlxuICogQGNhdGVnb3J5IFV0aWxzXG4gKi9cbmV4cG9ydHMuTFRfQ09MTEFUT1IgPSBuZXcgSW50bC5Db2xsYXRvcih1bmRlZmluZWQsIHsgbnVtZXJpYzogdHJ1ZSwgc2Vuc2l0aXZpdHk6ICdiYXNlJyB9KTtcbi8qKlxuICogTW9kaWZpZXMga25vd25UcmFuc2FjdGlvbnMgYXJyYXksIG1lcmdpbmcgaXQgd2l0aCBuZXcgdHJhbnNhY3Rpb25zLlxuICogQWxsIGFycmF5cyBhcmUgYXNzdW1lZCB0byBiZSBzb3J0ZWQgYnkgZGVzY2VuZGluZyBsb2dpY2FsIHRpbWUuXG4gKlxuICogPiBOb3RlISBUaGlzIG1ldGhvZCBkb2VzIG5vdCByZW1vdmUgZHVwbGljYXRlcy5cbiAqXG4gKiBAcGFyYW0ga25vd25UcmFuc2FjdGlvbnNcbiAqIEBwYXJhbSBuZXdUcmFuc2FjdGlvbnNcbiAqIEBwYXJhbSBpbmZvXG4gKlxuICogQGNhdGVnb3J5IFV0aWxzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlVHJhbnNhY3Rpb25zKGtub3duVHJhbnNhY3Rpb25zLCBuZXdUcmFuc2FjdGlvbnMsIGluZm8pIHtcbiAgICBpZiAoaW5mby5iYXRjaFR5cGUgPT09ICdvbGQnKSB7XG4gICAgICAgIGtub3duVHJhbnNhY3Rpb25zLnB1c2goLi4ubmV3VHJhbnNhY3Rpb25zKTtcbiAgICAgICAgcmV0dXJuIGtub3duVHJhbnNhY3Rpb25zO1xuICAgIH1cbiAgICBpZiAoa25vd25UcmFuc2FjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGtub3duVHJhbnNhY3Rpb25zLnB1c2goLi4ubmV3VHJhbnNhY3Rpb25zKTtcbiAgICAgICAgcmV0dXJuIGtub3duVHJhbnNhY3Rpb25zO1xuICAgIH1cbiAgICAvLyBFeGFtcGxlOlxuICAgIC8vIGtub3duIGx0czogW04sIE4tMSwgTi0yLCBOLTMsICghKSBOLTEwLC4uLl1cbiAgICAvLyBuZXcgbHRzOiBbTi00LCBOLTVdXG4gICAgLy8gYmF0Y2ggaW5mbzogeyBtaW5MdDogTi01LCBtYXhMdDogTi00LCBiYXRjaFR5cGU6ICduZXcnIH1cbiAgICAvLyAxLiBTa2lwIGluZGljZXMgdW50aWwga25vd24gdHJhbnNhY3Rpb24gbHQgaXMgZ3JlYXRlciB0aGFuIHRoZSBiaWdnZXN0IGluIHRoZSBiYXRjaFxuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGtub3duVHJhbnNhY3Rpb25zLmxlbmd0aCAmJlxuICAgICAgICBleHBvcnRzLkxUX0NPTExBVE9SLmNvbXBhcmUoa25vd25UcmFuc2FjdGlvbnNbaV0uaWQubHQsIGluZm8ubWF4THQpID49IDApIHtcbiAgICAgICAgKytpO1xuICAgIH1cbiAgICAvLyAyLiBJbnNlcnQgbmV3IHRyYW5zYWN0aW9uc1xuICAgIGtub3duVHJhbnNhY3Rpb25zLnNwbGljZShpLCAwLCAuLi5uZXdUcmFuc2FjdGlvbnMpO1xuICAgIHJldHVybiBrbm93blRyYW5zYWN0aW9ucztcbn1cbmV4cG9ydHMubWVyZ2VUcmFuc2FjdGlvbnMgPSBtZXJnZVRyYW5zYWN0aW9ucztcbmNvbnN0IE1BWCA9IDQyOTQ5NjcyOTU7XG5sZXQgaWRDb3VudGVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTUFYKTtcbmZ1bmN0aW9uIGdldFVuaXF1ZUlkKCkge1xuICAgIGlkQ291bnRlciA9IChpZENvdW50ZXIgKyAxKSAlIE1BWDtcbiAgICByZXR1cm4gaWRDb3VudGVyO1xufVxuZXhwb3J0cy5nZXRVbmlxdWVJZCA9IGdldFVuaXF1ZUlkO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///786\n")},758:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.MsigAccount = exports.GenericAccount = void 0;\nconst everscale_inpage_provider_1 = __webpack_require__(511);\n/**\n * @category AccountsStorage\n */\nclass GenericAccount {\n    constructor(args) {\n        this.address = args.address instanceof everscale_inpage_provider_1.Address ? args.address : new everscale_inpage_provider_1.Address(args.address);\n        this.abi = typeof args.abi === \'string\' ? args.abi : JSON.stringify(args.abi);\n        this.prepareMessageImpl = args.prepareMessage;\n        this.publicKey = args.publicKey;\n    }\n    async fetchPublicKey(ctx) {\n        if (this.publicKey != null) {\n            return this.publicKey;\n        }\n        this.publicKey = await ctx.fetchPublicKey(this.address);\n        return this.publicKey;\n    }\n    async prepareMessage(args, ctx) {\n        const publicKey = await this.fetchPublicKey(ctx);\n        const signer = await ctx.getSigner(publicKey);\n        const { method, params, stateInit } = await this.prepareMessageImpl(args, ctx);\n        return await ctx.createExternalMessage({\n            address: this.address,\n            signer,\n            timeout: args.timeout,\n            abi: this.abi,\n            method,\n            params,\n            stateInit,\n        });\n    }\n}\nexports.GenericAccount = GenericAccount;\n/**\n * @category AccountsStorage\n */\nclass MsigAccount extends GenericAccount {\n    constructor(args) {\n        super({\n            address: args.address,\n            publicKey: args.publicKey,\n            abi: MSIG_ABI,\n            prepareMessage: async (args, ctx) => {\n                const payload = args.payload\n                    ? ctx.encodeInternalInput(args.payload)\n                    : \'\';\n                return {\n                    method: \'sendTransaction\',\n                    params: {\n                        dest: args.recipient,\n                        value: args.amount,\n                        bounce: args.bounce,\n                        flags: 3,\n                        payload,\n                    },\n                };\n            },\n        });\n    }\n}\nexports.MsigAccount = MsigAccount;\nconst MSIG_ABI = `{\n  "ABI version": 2,\n  "header": ["pubkey", "time", "expire"],\n  "functions": [{\n    "name": "sendTransaction",\n    "inputs": [\n      {"name":"dest","type":"address"},\n      {"name":"value","type":"uint128"},\n      {"name":"bounce","type":"bool"},\n      {"name":"flags","type":"uint8"},\n      {"name":"payload","type":"cell"}\n    ],\n    "outputs": []\n  }],\n  "events": []\n}`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzU4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvQWNjb3VudHNTdG9yYWdlL0dlbmVyaWMuanM/YzJiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXNpZ0FjY291bnQgPSBleHBvcnRzLkdlbmVyaWNBY2NvdW50ID0gdm9pZCAwO1xuY29uc3QgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xID0gcmVxdWlyZShcImV2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXJcIik7XG4vKipcbiAqIEBjYXRlZ29yeSBBY2NvdW50c1N0b3JhZ2VcbiAqL1xuY2xhc3MgR2VuZXJpY0FjY291bnQge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYXJncy5hZGRyZXNzIGluc3RhbmNlb2YgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3MgPyBhcmdzLmFkZHJlc3MgOiBuZXcgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3MoYXJncy5hZGRyZXNzKTtcbiAgICAgICAgdGhpcy5hYmkgPSB0eXBlb2YgYXJncy5hYmkgPT09ICdzdHJpbmcnID8gYXJncy5hYmkgOiBKU09OLnN0cmluZ2lmeShhcmdzLmFiaSk7XG4gICAgICAgIHRoaXMucHJlcGFyZU1lc3NhZ2VJbXBsID0gYXJncy5wcmVwYXJlTWVzc2FnZTtcbiAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBhcmdzLnB1YmxpY0tleTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hQdWJsaWNLZXkoY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLnB1YmxpY0tleSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNLZXk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBhd2FpdCBjdHguZmV0Y2hQdWJsaWNLZXkodGhpcy5hZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljS2V5O1xuICAgIH1cbiAgICBhc3luYyBwcmVwYXJlTWVzc2FnZShhcmdzLCBjdHgpIHtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgdGhpcy5mZXRjaFB1YmxpY0tleShjdHgpO1xuICAgICAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBjdHguZ2V0U2lnbmVyKHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IHsgbWV0aG9kLCBwYXJhbXMsIHN0YXRlSW5pdCB9ID0gYXdhaXQgdGhpcy5wcmVwYXJlTWVzc2FnZUltcGwoYXJncywgY3R4KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGN0eC5jcmVhdGVFeHRlcm5hbE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgICAgc2lnbmVyLFxuICAgICAgICAgICAgdGltZW91dDogYXJncy50aW1lb3V0LFxuICAgICAgICAgICAgYWJpOiB0aGlzLmFiaSxcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIHN0YXRlSW5pdCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5HZW5lcmljQWNjb3VudCA9IEdlbmVyaWNBY2NvdW50O1xuLyoqXG4gKiBAY2F0ZWdvcnkgQWNjb3VudHNTdG9yYWdlXG4gKi9cbmNsYXNzIE1zaWdBY2NvdW50IGV4dGVuZHMgR2VuZXJpY0FjY291bnQge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgYWRkcmVzczogYXJncy5hZGRyZXNzLFxuICAgICAgICAgICAgcHVibGljS2V5OiBhcmdzLnB1YmxpY0tleSxcbiAgICAgICAgICAgIGFiaTogTVNJR19BQkksXG4gICAgICAgICAgICBwcmVwYXJlTWVzc2FnZTogYXN5bmMgKGFyZ3MsIGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhcmdzLnBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgPyBjdHguZW5jb2RlSW50ZXJuYWxJbnB1dChhcmdzLnBheWxvYWQpXG4gICAgICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnc2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0OiBhcmdzLnJlY2lwaWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhcmdzLmFtb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5jZTogYXJncy5ib3VuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnczogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTXNpZ0FjY291bnQgPSBNc2lnQWNjb3VudDtcbmNvbnN0IE1TSUdfQUJJID0gYHtcbiAgXCJBQkkgdmVyc2lvblwiOiAyLFxuICBcImhlYWRlclwiOiBbXCJwdWJrZXlcIiwgXCJ0aW1lXCIsIFwiZXhwaXJlXCJdLFxuICBcImZ1bmN0aW9uc1wiOiBbe1xuICAgIFwibmFtZVwiOiBcInNlbmRUcmFuc2FjdGlvblwiLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcIm5hbWVcIjpcImRlc3RcIixcInR5cGVcIjpcImFkZHJlc3NcIn0sXG4gICAgICB7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOlwidWludDEyOFwifSxcbiAgICAgIHtcIm5hbWVcIjpcImJvdW5jZVwiLFwidHlwZVwiOlwiYm9vbFwifSxcbiAgICAgIHtcIm5hbWVcIjpcImZsYWdzXCIsXCJ0eXBlXCI6XCJ1aW50OFwifSxcbiAgICAgIHtcIm5hbWVcIjpcInBheWxvYWRcIixcInR5cGVcIjpcImNlbGxcIn1cbiAgICBdLFxuICAgIFwib3V0cHV0c1wiOiBbXVxuICB9XSxcbiAgXCJldmVudHNcIjogW11cbn1gO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///758\n')},766:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.GiverAccount = void 0;\nconst everscale_inpage_provider_1 = __webpack_require__(511);\n/**\n * Any account which supports Giver ABI (GiverV2, GiverV3):\n *\n * ```\n * {\n *   "ABI version": 2,\n *   "header": ["pubkey", "time", "expire"],\n *   "functions": [{\n *     "name": "sendTransaction",\n *     "inputs": [\n *       {"name":"dest","type":"address"},\n *       {"name":"value","type":"uint128"},\n *       {"name":"bounce","type":"bool"},\n *     ],\n *     "outputs": []\n *   }],\n *   "events": []\n * }\n * ```\n *\n * @category AccountsStorage\n */\nclass GiverAccount {\n    constructor(args) {\n        this.address = args.address instanceof everscale_inpage_provider_1.Address ? args.address : new everscale_inpage_provider_1.Address(args.address);\n        this.publicKey = args.publicKey;\n    }\n    static fromVersion(version) {\n        let address;\n        switch (version) {\n            case 2:\n                address = \'0:ece57bcc6c530283becbbd8a3b24d3c5987cdddc3c8b7b33be6e4a6312490415\';\n                break;\n            case 3:\n                address = \'0:78fbd6980c10cf41401b32e9b51810415e7578b52403af80dae68ddf99714498\';\n                break;\n            default:\n                throw new Error(\'Unknown version\');\n        }\n        return new GiverAccount({\n            address,\n            publicKey: GiverAccount.GIVER_KEY_PAIR.publicKey,\n        });\n    }\n    async fetchPublicKey(_ctx) {\n        return this.publicKey;\n    }\n    async prepareMessage(args, ctx) {\n        if (args.payload != null) {\n            console.warn(\'Giver contract does not support payload\');\n        }\n        const signer = await ctx.getSigner(this.publicKey);\n        return await ctx.createExternalMessage({\n            address: this.address,\n            signer,\n            timeout: args.timeout,\n            abi: GIVER_ABI,\n            method: \'sendTransaction\',\n            params: {\n                dest: args.recipient,\n                value: args.amount,\n                bounce: args.bounce,\n            },\n        });\n    }\n}\nexports.GiverAccount = GiverAccount;\nGiverAccount.GIVER_KEY_PAIR = {\n    secretKey: \'172af540e43a524763dd53b26a066d472a97c4de37d5498170564510608250c3\',\n    publicKey: \'2ada2e65ab8eeab09490e3521415f45b6e42df9c760a639bcf53957550b25a16\',\n};\nconst GIVER_ABI = `{\n  "ABI version": 2,\n  "header": ["time", "expire"],\n  "functions": [{\n    "name": "sendTransaction",\n    "inputs": [\n      {"name":"dest","type":"address"},\n      {"name":"value","type":"uint128"},\n      {"name":"bounce","type":"bool"}\n    ],\n    "outputs": []\n  }],\n  "events": []\n}`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzY2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvQWNjb3VudHNTdG9yYWdlL0dpdmVyLmpzP2FjM2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdpdmVyQWNjb3VudCA9IHZvaWQgMDtcbmNvbnN0IGV2ZXJzY2FsZV9pbnBhZ2VfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCJldmVyc2NhbGUtaW5wYWdlLXByb3ZpZGVyXCIpO1xuLyoqXG4gKiBBbnkgYWNjb3VudCB3aGljaCBzdXBwb3J0cyBHaXZlciBBQkkgKEdpdmVyVjIsIEdpdmVyVjMpOlxuICpcbiAqIGBgYFxuICoge1xuICogICBcIkFCSSB2ZXJzaW9uXCI6IDIsXG4gKiAgIFwiaGVhZGVyXCI6IFtcInB1YmtleVwiLCBcInRpbWVcIiwgXCJleHBpcmVcIl0sXG4gKiAgIFwiZnVuY3Rpb25zXCI6IFt7XG4gKiAgICAgXCJuYW1lXCI6IFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gKiAgICAgXCJpbnB1dHNcIjogW1xuICogICAgICAge1wibmFtZVwiOlwiZGVzdFwiLFwidHlwZVwiOlwiYWRkcmVzc1wifSxcbiAqICAgICAgIHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6XCJ1aW50MTI4XCJ9LFxuICogICAgICAge1wibmFtZVwiOlwiYm91bmNlXCIsXCJ0eXBlXCI6XCJib29sXCJ9LFxuICogICAgIF0sXG4gKiAgICAgXCJvdXRwdXRzXCI6IFtdXG4gKiAgIH1dLFxuICogICBcImV2ZW50c1wiOiBbXVxuICogfVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IEFjY291bnRzU3RvcmFnZVxuICovXG5jbGFzcyBHaXZlckFjY291bnQge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYXJncy5hZGRyZXNzIGluc3RhbmNlb2YgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3MgPyBhcmdzLmFkZHJlc3MgOiBuZXcgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3MoYXJncy5hZGRyZXNzKTtcbiAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBhcmdzLnB1YmxpY0tleTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21WZXJzaW9uKHZlcnNpb24pIHtcbiAgICAgICAgbGV0IGFkZHJlc3M7XG4gICAgICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGFkZHJlc3MgPSAnMDplY2U1N2JjYzZjNTMwMjgzYmVjYmJkOGEzYjI0ZDNjNTk4N2NkZGRjM2M4YjdiMzNiZTZlNGE2MzEyNDkwNDE1JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gJzA6NzhmYmQ2OTgwYzEwY2Y0MTQwMWIzMmU5YjUxODEwNDE1ZTc1NzhiNTI0MDNhZjgwZGFlNjhkZGY5OTcxNDQ5OCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB2ZXJzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBHaXZlckFjY291bnQoe1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIHB1YmxpY0tleTogR2l2ZXJBY2NvdW50LkdJVkVSX0tFWV9QQUlSLnB1YmxpY0tleSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoUHVibGljS2V5KF9jdHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljS2V5O1xuICAgIH1cbiAgICBhc3luYyBwcmVwYXJlTWVzc2FnZShhcmdzLCBjdHgpIHtcbiAgICAgICAgaWYgKGFyZ3MucGF5bG9hZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0dpdmVyIGNvbnRyYWN0IGRvZXMgbm90IHN1cHBvcnQgcGF5bG9hZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IGN0eC5nZXRTaWduZXIodGhpcy5wdWJsaWNLZXkpO1xuICAgICAgICByZXR1cm4gYXdhaXQgY3R4LmNyZWF0ZUV4dGVybmFsTWVzc2FnZSh7XG4gICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgICBzaWduZXIsXG4gICAgICAgICAgICB0aW1lb3V0OiBhcmdzLnRpbWVvdXQsXG4gICAgICAgICAgICBhYmk6IEdJVkVSX0FCSSxcbiAgICAgICAgICAgIG1ldGhvZDogJ3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBkZXN0OiBhcmdzLnJlY2lwaWVudCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXJncy5hbW91bnQsXG4gICAgICAgICAgICAgICAgYm91bmNlOiBhcmdzLmJvdW5jZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuR2l2ZXJBY2NvdW50ID0gR2l2ZXJBY2NvdW50O1xuR2l2ZXJBY2NvdW50LkdJVkVSX0tFWV9QQUlSID0ge1xuICAgIHNlY3JldEtleTogJzE3MmFmNTQwZTQzYTUyNDc2M2RkNTNiMjZhMDY2ZDQ3MmE5N2M0ZGUzN2Q1NDk4MTcwNTY0NTEwNjA4MjUwYzMnLFxuICAgIHB1YmxpY0tleTogJzJhZGEyZTY1YWI4ZWVhYjA5NDkwZTM1MjE0MTVmNDViNmU0MmRmOWM3NjBhNjM5YmNmNTM5NTc1NTBiMjVhMTYnLFxufTtcbmNvbnN0IEdJVkVSX0FCSSA9IGB7XG4gIFwiQUJJIHZlcnNpb25cIjogMixcbiAgXCJoZWFkZXJcIjogW1widGltZVwiLCBcImV4cGlyZVwiXSxcbiAgXCJmdW5jdGlvbnNcIjogW3tcbiAgICBcIm5hbWVcIjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XCJuYW1lXCI6XCJkZXN0XCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9LFxuICAgICAge1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjpcInVpbnQxMjhcIn0sXG4gICAgICB7XCJuYW1lXCI6XCJib3VuY2VcIixcInR5cGVcIjpcImJvb2xcIn1cbiAgICBdLFxuICAgIFwib3V0cHV0c1wiOiBbXVxuICB9XSxcbiAgXCJldmVudHNcIjogW11cbn1gO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///766\n')},128:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HighloadWalletV2 = void 0;\nconst everscale_inpage_provider_1 = __webpack_require__(511);\nconst bignumber_js_1 = __importDefault(__webpack_require__(431));\nconst core_1 = __importDefault(__webpack_require__(521));\nconst { ensureNekotonLoaded, nekoton } = core_1.default;\n/**\n * @category AccountsStorage\n */\nclass HighloadWalletV2 {\n    constructor(address) {\n        this.address = address instanceof everscale_inpage_provider_1.Address ? address : new everscale_inpage_provider_1.Address(address);\n    }\n    static async computeAddress(args) {\n        // TODO: Somehow propagate init params\n        await ensureNekotonLoaded();\n        const publicKey = args.publicKey instanceof bignumber_js_1.default\n            ? args.publicKey\n            : new bignumber_js_1.default(`0x${args.publicKey}`);\n        const tvc = makeStateInit(publicKey);\n        const hash = nekoton.getBocHash(tvc);\n        return new everscale_inpage_provider_1.Address(`${args.workchain != null ? args.workchain : 0}:${hash}`);\n    }\n    static async fromPubkey(args) {\n        const publicKey = new bignumber_js_1.default(`0x${args.publicKey}`);\n        const address = await HighloadWalletV2.computeAddress({ publicKey, workchain: args.workchain });\n        const result = new HighloadWalletV2(address);\n        result.publicKey = publicKey;\n        return result;\n    }\n    async fetchPublicKey(ctx) {\n        let publicKey = this.publicKey;\n        if (publicKey == null) {\n            publicKey = this.publicKey = await ctx.fetchPublicKey(this.address)\n                .then(publicKey => new bignumber_js_1.default(`0x${publicKey}`));\n        }\n        return publicKey.toString(16).padStart(64, '0');\n    }\n    async prepareMessage(args, ctx) {\n        const { publicKey, stateInit } = await this.fetchState(ctx);\n        const signer = await ctx.getSigner(publicKey);\n        const expireAt = ctx.nowSec + args.timeout;\n        const attachedPayload = args.payload\n            ? ctx.encodeInternalInput(args.payload)\n            : undefined;\n        const internalMessage = ctx.encodeInternalMessage({\n            dst: args.recipient,\n            bounce: args.bounce,\n            stateInit: args.stateInit,\n            body: attachedPayload,\n            amount: args.amount,\n        });\n        const params = {\n            messages: [[0, {\n                        flags: 3,\n                        message: internalMessage,\n                    }]],\n        };\n        const messages = ctx.packIntoCell({ structure: MESSAGES_STRUCTURE, data: params });\n        const messagesHash = ctx.getBocHash(messages);\n        params.walletId = WALLET_ID;\n        params.expireAt = expireAt;\n        params.messagesHash = `0x${messagesHash.slice(-8)}`;\n        const unsignedPayload = ctx.packIntoCell({ structure: UNSIGNED_TRANSFER_STRUCTURE, data: params });\n        const hash = ctx.getBocHash(unsignedPayload);\n        const signature = await signer.sign(hash);\n        const { signatureParts } = ctx.extendSignature(signature);\n        params.signatureHigh = signatureParts.high;\n        params.signatureLow = signatureParts.low;\n        const signedPayload = ctx.packIntoCell({ structure: SIGNED_TRANSFER_STRUCTURE, data: params });\n        return ctx.createRawExternalMessage({\n            address: this.address.toString(),\n            body: signedPayload,\n            stateInit,\n            expireAt,\n        });\n    }\n    async fetchState(ctx) {\n        let stateInit = undefined;\n        let publicKey;\n        const state = await ctx.getFullContractState(this.address);\n        if (state == null || !state.isDeployed) {\n            if (this.publicKey == null) {\n                throw new Error('Contract not deployed and public key was not specified');\n            }\n            stateInit = makeStateInit(this.publicKey);\n            publicKey = this.publicKey;\n        }\n        else if (this.publicKey == null) {\n            const data = ctx.extractContractData(state.boc);\n            if (data == null) {\n                throw new Error('Failed to extract contract data');\n            }\n            publicKey = parseInitData(ctx, data).publicKey;\n        }\n        else {\n            publicKey = this.publicKey;\n        }\n        if (this.publicKey == null) {\n            this.publicKey = publicKey;\n        }\n        return {\n            publicKey: publicKey.toString(16).padStart(64, '0'),\n            stateInit,\n        };\n    }\n}\nexports.HighloadWalletV2 = HighloadWalletV2;\nconst parseInitData = (ctx, boc) => {\n    const parsed = ctx.unpackFromCell({ structure: DATA_STRUCTURE, boc, allowPartial: true });\n    if (typeof parsed !== 'object' || typeof parsed['publicKey'] !== 'string') {\n        throw new Error('Invalid contract data');\n    }\n    return {\n        publicKey: new bignumber_js_1.default(parsed.publicKey),\n    };\n};\nconst makeStateInit = (publicKey) => {\n    const data = nekoton.packIntoCell(DATA_STRUCTURE, {\n        walletId: WALLET_ID,\n        lastCleaned: 0,\n        publicKey: publicKey.toFixed(0),\n        queries: false,\n    });\n    return nekoton.mergeTvc(HIGHLOAD_WALLET_V2_CODE, data);\n};\nconst MESSAGES_STRUCTURE = [\n    {\n        name: 'messages',\n        type: 'map(uint16,tuple)',\n        components: [\n            { name: 'flags', type: 'uint8' },\n            { name: 'message', type: 'cell' },\n        ],\n    },\n];\nconst UNSIGNED_TRANSFER_STRUCTURE = [\n    { name: 'walletId', type: 'uint32' },\n    { name: 'expireAt', type: 'uint32' },\n    { name: 'messagesHash', type: 'uint32' },\n    ...MESSAGES_STRUCTURE,\n];\nconst SIGNED_TRANSFER_STRUCTURE = [\n    { name: 'signatureHigh', type: 'uint256' },\n    { name: 'signatureLow', type: 'uint256' },\n    ...UNSIGNED_TRANSFER_STRUCTURE,\n];\nconst DATA_STRUCTURE = [\n    { name: 'walletId', type: 'uint32' },\n    { name: 'lastCleaned', type: 'uint64' },\n    { name: 'publicKey', type: 'uint256' },\n    { name: 'queries', type: 'bool' },\n];\nconst HIGHLOAD_WALLET_V2_CODE = 'te6ccgEBCQEA5QABFP8A9KQT9LzyyAsBAgEgBAIB6vKDCNcYINMf0z/4I6ofUyC58mPtRNDTH9M/0//0BNFTYIBA9A5voTHyYFFzuvKiB/kBVBCH+RDyowL0BNH4AH+OFiGAEPR4b6UgmALTB9QwAfsAkTLiAbPmW4MlochANIBA9EOK5jHIEssfE8s/y//0AMntVAMANCCAQPSWb6UyURCUMFMDud4gkzM2AZIyMOKzAgFICAUCASAHBgBBvl+XaiaGmPmOmf6f+Y+gJoqRBAIHoHN9CYyS2/yV3R8UABe9nOdqJoaa+Y64X/wABNAw';\nconst WALLET_ID = 0;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvQWNjb3VudHNTdG9yYWdlL0hpZ2hsb2FkV2FsbGV0VjIuanM/ZDBhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGlnaGxvYWRXYWxsZXRWMiA9IHZvaWQgMDtcbmNvbnN0IGV2ZXJzY2FsZV9pbnBhZ2VfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCJldmVyc2NhbGUtaW5wYWdlLXByb3ZpZGVyXCIpO1xuY29uc3QgYmlnbnVtYmVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJpZ251bWJlci5qc1wiKSk7XG5jb25zdCBjb3JlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2NvcmVcIikpO1xuY29uc3QgeyBlbnN1cmVOZWtvdG9uTG9hZGVkLCBuZWtvdG9uIH0gPSBjb3JlXzEuZGVmYXVsdDtcbi8qKlxuICogQGNhdGVnb3J5IEFjY291bnRzU3RvcmFnZVxuICovXG5jbGFzcyBIaWdobG9hZFdhbGxldFYyIHtcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzKSB7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3MgaW5zdGFuY2VvZiBldmVyc2NhbGVfaW5wYWdlX3Byb3ZpZGVyXzEuQWRkcmVzcyA/IGFkZHJlc3MgOiBuZXcgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3MoYWRkcmVzcyk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjb21wdXRlQWRkcmVzcyhhcmdzKSB7XG4gICAgICAgIC8vIFRPRE86IFNvbWVob3cgcHJvcGFnYXRlIGluaXQgcGFyYW1zXG4gICAgICAgIGF3YWl0IGVuc3VyZU5la290b25Mb2FkZWQoKTtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gYXJncy5wdWJsaWNLZXkgaW5zdGFuY2VvZiBiaWdudW1iZXJfanNfMS5kZWZhdWx0XG4gICAgICAgICAgICA/IGFyZ3MucHVibGljS2V5XG4gICAgICAgICAgICA6IG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KGAweCR7YXJncy5wdWJsaWNLZXl9YCk7XG4gICAgICAgIGNvbnN0IHR2YyA9IG1ha2VTdGF0ZUluaXQocHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgaGFzaCA9IG5la290b24uZ2V0Qm9jSGFzaCh0dmMpO1xuICAgICAgICByZXR1cm4gbmV3IGV2ZXJzY2FsZV9pbnBhZ2VfcHJvdmlkZXJfMS5BZGRyZXNzKGAke2FyZ3Mud29ya2NoYWluICE9IG51bGwgPyBhcmdzLndvcmtjaGFpbiA6IDB9OiR7aGFzaH1gKTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGZyb21QdWJrZXkoYXJncykge1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdChgMHgke2FyZ3MucHVibGljS2V5fWApO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgSGlnaGxvYWRXYWxsZXRWMi5jb21wdXRlQWRkcmVzcyh7IHB1YmxpY0tleSwgd29ya2NoYWluOiBhcmdzLndvcmtjaGFpbiB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEhpZ2hsb2FkV2FsbGV0VjIoYWRkcmVzcyk7XG4gICAgICAgIHJlc3VsdC5wdWJsaWNLZXkgPSBwdWJsaWNLZXk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoUHVibGljS2V5KGN0eCkge1xuICAgICAgICBsZXQgcHVibGljS2V5ID0gdGhpcy5wdWJsaWNLZXk7XG4gICAgICAgIGlmIChwdWJsaWNLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcHVibGljS2V5ID0gdGhpcy5wdWJsaWNLZXkgPSBhd2FpdCBjdHguZmV0Y2hQdWJsaWNLZXkodGhpcy5hZGRyZXNzKVxuICAgICAgICAgICAgICAgIC50aGVuKHB1YmxpY0tleSA9PiBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdChgMHgke3B1YmxpY0tleX1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB1YmxpY0tleS50b1N0cmluZygxNikucGFkU3RhcnQoNjQsICcwJyk7XG4gICAgfVxuICAgIGFzeW5jIHByZXBhcmVNZXNzYWdlKGFyZ3MsIGN0eCkge1xuICAgICAgICBjb25zdCB7IHB1YmxpY0tleSwgc3RhdGVJbml0IH0gPSBhd2FpdCB0aGlzLmZldGNoU3RhdGUoY3R4KTtcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgY3R4LmdldFNpZ25lcihwdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBleHBpcmVBdCA9IGN0eC5ub3dTZWMgKyBhcmdzLnRpbWVvdXQ7XG4gICAgICAgIGNvbnN0IGF0dGFjaGVkUGF5bG9hZCA9IGFyZ3MucGF5bG9hZFxuICAgICAgICAgICAgPyBjdHguZW5jb2RlSW50ZXJuYWxJbnB1dChhcmdzLnBheWxvYWQpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxNZXNzYWdlID0gY3R4LmVuY29kZUludGVybmFsTWVzc2FnZSh7XG4gICAgICAgICAgICBkc3Q6IGFyZ3MucmVjaXBpZW50LFxuICAgICAgICAgICAgYm91bmNlOiBhcmdzLmJvdW5jZSxcbiAgICAgICAgICAgIHN0YXRlSW5pdDogYXJncy5zdGF0ZUluaXQsXG4gICAgICAgICAgICBib2R5OiBhdHRhY2hlZFBheWxvYWQsXG4gICAgICAgICAgICBhbW91bnQ6IGFyZ3MuYW1vdW50LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgbWVzc2FnZXM6IFtbMCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBpbnRlcm5hbE1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBjdHgucGFja0ludG9DZWxsKHsgc3RydWN0dXJlOiBNRVNTQUdFU19TVFJVQ1RVUkUsIGRhdGE6IHBhcmFtcyB9KTtcbiAgICAgICAgY29uc3QgbWVzc2FnZXNIYXNoID0gY3R4LmdldEJvY0hhc2gobWVzc2FnZXMpO1xuICAgICAgICBwYXJhbXMud2FsbGV0SWQgPSBXQUxMRVRfSUQ7XG4gICAgICAgIHBhcmFtcy5leHBpcmVBdCA9IGV4cGlyZUF0O1xuICAgICAgICBwYXJhbXMubWVzc2FnZXNIYXNoID0gYDB4JHttZXNzYWdlc0hhc2guc2xpY2UoLTgpfWA7XG4gICAgICAgIGNvbnN0IHVuc2lnbmVkUGF5bG9hZCA9IGN0eC5wYWNrSW50b0NlbGwoeyBzdHJ1Y3R1cmU6IFVOU0lHTkVEX1RSQU5TRkVSX1NUUlVDVFVSRSwgZGF0YTogcGFyYW1zIH0pO1xuICAgICAgICBjb25zdCBoYXNoID0gY3R4LmdldEJvY0hhc2godW5zaWduZWRQYXlsb2FkKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnbmVyLnNpZ24oaGFzaCk7XG4gICAgICAgIGNvbnN0IHsgc2lnbmF0dXJlUGFydHMgfSA9IGN0eC5leHRlbmRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgcGFyYW1zLnNpZ25hdHVyZUhpZ2ggPSBzaWduYXR1cmVQYXJ0cy5oaWdoO1xuICAgICAgICBwYXJhbXMuc2lnbmF0dXJlTG93ID0gc2lnbmF0dXJlUGFydHMubG93O1xuICAgICAgICBjb25zdCBzaWduZWRQYXlsb2FkID0gY3R4LnBhY2tJbnRvQ2VsbCh7IHN0cnVjdHVyZTogU0lHTkVEX1RSQU5TRkVSX1NUUlVDVFVSRSwgZGF0YTogcGFyYW1zIH0pO1xuICAgICAgICByZXR1cm4gY3R4LmNyZWF0ZVJhd0V4dGVybmFsTWVzc2FnZSh7XG4gICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGJvZHk6IHNpZ25lZFBheWxvYWQsXG4gICAgICAgICAgICBzdGF0ZUluaXQsXG4gICAgICAgICAgICBleHBpcmVBdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoU3RhdGUoY3R4KSB7XG4gICAgICAgIGxldCBzdGF0ZUluaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBwdWJsaWNLZXk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgY3R4LmdldEZ1bGxDb250cmFjdFN0YXRlKHRoaXMuYWRkcmVzcyk7XG4gICAgICAgIGlmIChzdGF0ZSA9PSBudWxsIHx8ICFzdGF0ZS5pc0RlcGxveWVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wdWJsaWNLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udHJhY3Qgbm90IGRlcGxveWVkIGFuZCBwdWJsaWMga2V5IHdhcyBub3Qgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZUluaXQgPSBtYWtlU3RhdGVJbml0KHRoaXMucHVibGljS2V5KTtcbiAgICAgICAgICAgIHB1YmxpY0tleSA9IHRoaXMucHVibGljS2V5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHVibGljS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjdHguZXh0cmFjdENvbnRyYWN0RGF0YShzdGF0ZS5ib2MpO1xuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGV4dHJhY3QgY29udHJhY3QgZGF0YScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHVibGljS2V5ID0gcGFyc2VJbml0RGF0YShjdHgsIGRhdGEpLnB1YmxpY0tleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHB1YmxpY0tleSA9IHRoaXMucHVibGljS2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnB1YmxpY0tleSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnB1YmxpY0tleSA9IHB1YmxpY0tleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHVibGljS2V5OiBwdWJsaWNLZXkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDY0LCAnMCcpLFxuICAgICAgICAgICAgc3RhdGVJbml0LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuSGlnaGxvYWRXYWxsZXRWMiA9IEhpZ2hsb2FkV2FsbGV0VjI7XG5jb25zdCBwYXJzZUluaXREYXRhID0gKGN0eCwgYm9jKSA9PiB7XG4gICAgY29uc3QgcGFyc2VkID0gY3R4LnVucGFja0Zyb21DZWxsKHsgc3RydWN0dXJlOiBEQVRBX1NUUlVDVFVSRSwgYm9jLCBhbGxvd1BhcnRpYWw6IHRydWUgfSk7XG4gICAgaWYgKHR5cGVvZiBwYXJzZWQgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJzZWRbJ3B1YmxpY0tleSddICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29udHJhY3QgZGF0YScpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwdWJsaWNLZXk6IG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KHBhcnNlZC5wdWJsaWNLZXkpLFxuICAgIH07XG59O1xuY29uc3QgbWFrZVN0YXRlSW5pdCA9IChwdWJsaWNLZXkpID0+IHtcbiAgICBjb25zdCBkYXRhID0gbmVrb3Rvbi5wYWNrSW50b0NlbGwoREFUQV9TVFJVQ1RVUkUsIHtcbiAgICAgICAgd2FsbGV0SWQ6IFdBTExFVF9JRCxcbiAgICAgICAgbGFzdENsZWFuZWQ6IDAsXG4gICAgICAgIHB1YmxpY0tleTogcHVibGljS2V5LnRvRml4ZWQoMCksXG4gICAgICAgIHF1ZXJpZXM6IGZhbHNlLFxuICAgIH0pO1xuICAgIHJldHVybiBuZWtvdG9uLm1lcmdlVHZjKEhJR0hMT0FEX1dBTExFVF9WMl9DT0RFLCBkYXRhKTtcbn07XG5jb25zdCBNRVNTQUdFU19TVFJVQ1RVUkUgPSBbXG4gICAge1xuICAgICAgICBuYW1lOiAnbWVzc2FnZXMnLFxuICAgICAgICB0eXBlOiAnbWFwKHVpbnQxNix0dXBsZSknLFxuICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICB7IG5hbWU6ICdmbGFncycsIHR5cGU6ICd1aW50OCcgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21lc3NhZ2UnLCB0eXBlOiAnY2VsbCcgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuXTtcbmNvbnN0IFVOU0lHTkVEX1RSQU5TRkVSX1NUUlVDVFVSRSA9IFtcbiAgICB7IG5hbWU6ICd3YWxsZXRJZCcsIHR5cGU6ICd1aW50MzInIH0sXG4gICAgeyBuYW1lOiAnZXhwaXJlQXQnLCB0eXBlOiAndWludDMyJyB9LFxuICAgIHsgbmFtZTogJ21lc3NhZ2VzSGFzaCcsIHR5cGU6ICd1aW50MzInIH0sXG4gICAgLi4uTUVTU0FHRVNfU1RSVUNUVVJFLFxuXTtcbmNvbnN0IFNJR05FRF9UUkFOU0ZFUl9TVFJVQ1RVUkUgPSBbXG4gICAgeyBuYW1lOiAnc2lnbmF0dXJlSGlnaCcsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgIHsgbmFtZTogJ3NpZ25hdHVyZUxvdycsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgIC4uLlVOU0lHTkVEX1RSQU5TRkVSX1NUUlVDVFVSRSxcbl07XG5jb25zdCBEQVRBX1NUUlVDVFVSRSA9IFtcbiAgICB7IG5hbWU6ICd3YWxsZXRJZCcsIHR5cGU6ICd1aW50MzInIH0sXG4gICAgeyBuYW1lOiAnbGFzdENsZWFuZWQnLCB0eXBlOiAndWludDY0JyB9LFxuICAgIHsgbmFtZTogJ3B1YmxpY0tleScsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgIHsgbmFtZTogJ3F1ZXJpZXMnLCB0eXBlOiAnYm9vbCcgfSxcbl07XG5jb25zdCBISUdITE9BRF9XQUxMRVRfVjJfQ09ERSA9ICd0ZTZjY2dFQkNRRUE1UUFCRlA4QTlLUVQ5THp5eUFzQkFnRWdCQUlCNnZLRENOY1lJTk1mMHovNEk2b2ZVeUM1OG1QdFJORFRIOU0vMC8vMEJORlRZSUJBOUE1dm9USHlZRkZ6dXZLaUIva0JWQkNIK1JEeW93TDBCTkg0QUgrT0ZpR0FFUFI0YjZVZ21BTFRCOVF3QWZzQWtUTGlBYlBtVzRNbG9jaEFOSUJBOUVPSzVqSElFc3NmRThzL3kvLzBBTW50VkFNQU5DQ0FRUFNXYjZVeVVSQ1VNRk1EdWQ0Z2t6TTJBWkl5TU9LekFnRklDQVVDQVNBSEJnQkJ2bCtYYWlhR21QbU9tZjZmK1krZ0pvcVJCQUlIb0hOOUNZeVMyL3lWM1I4VUFCZTluT2RxSm9hYStZNjRYL3dBQk5Bdyc7XG5jb25zdCBXQUxMRVRfSUQgPSAwO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///128\n")},61:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletV3Account = void 0;\nconst everscale_inpage_provider_1 = __webpack_require__(511);\nconst bignumber_js_1 = __importDefault(__webpack_require__(431));\nconst core_1 = __importDefault(__webpack_require__(521));\nconst { ensureNekotonLoaded, nekoton } = core_1.default;\n/**\n * @category AccountsStorage\n */\nclass WalletV3Account {\n    constructor(address) {\n        this.address = address;\n    }\n    static async computeAddress(args) {\n        // TODO: Somehow propagate init params\n        await ensureNekotonLoaded();\n        const publicKey = args.publicKey instanceof bignumber_js_1.default\n            ? args.publicKey\n            : new bignumber_js_1.default(`0x${args.publicKey}`);\n        const tvc = makeStateInit(publicKey);\n        const hash = nekoton.getBocHash(tvc);\n        return new everscale_inpage_provider_1.Address(`${args.workchain != null ? args.workchain : 0}:${hash}`);\n    }\n    static async fromPubkey(args) {\n        const publicKey = new bignumber_js_1.default(`0x${args.publicKey}`);\n        const address = await WalletV3Account.computeAddress({ publicKey, workchain: args.workchain });\n        const result = new WalletV3Account(address);\n        result.publicKey = publicKey;\n        return result;\n    }\n    async fetchPublicKey(ctx) {\n        let publicKey = this.publicKey;\n        if (publicKey == null) {\n            publicKey = this.publicKey = await ctx.fetchPublicKey(this.address)\n                .then(publicKey => new bignumber_js_1.default(`0x${publicKey}`));\n        }\n        return publicKey.toString(16).padStart(64, '0');\n    }\n    async prepareMessage(args, ctx) {\n        const { seqno, publicKey, stateInit } = await this.fetchState(ctx);\n        const signer = await ctx.getSigner(publicKey);\n        const expireAt = ctx.nowSec + args.timeout;\n        const attachedPayload = args.payload\n            ? ctx.encodeInternalInput(args.payload)\n            : undefined;\n        const internalMessage = ctx.encodeInternalMessage({\n            dst: args.recipient,\n            bounce: args.bounce,\n            stateInit: args.stateInit,\n            body: attachedPayload,\n            amount: args.amount,\n        });\n        const params = {\n            walletId: WALLET_ID,\n            expireAt,\n            seqno,\n            flags: 3,\n            message: internalMessage,\n        };\n        const unsignedPayload = ctx.packIntoCell({ structure: UNSIGNED_TRANSFER_STRUCTURE, data: params });\n        const hash = ctx.getBocHash(unsignedPayload);\n        const signature = await signer.sign(hash);\n        const { signatureParts } = ctx.extendSignature(signature);\n        params.signatureHigh = signatureParts.high;\n        params.signatureLow = signatureParts.low;\n        const signedPayload = ctx.packIntoCell({\n            structure: SIGNED_TRANSFER_STRUCTURE,\n            data: params,\n        });\n        return ctx.createRawExternalMessage({\n            address: this.address,\n            body: signedPayload,\n            stateInit,\n            expireAt,\n        });\n    }\n    async fetchState(ctx) {\n        let stateInit = undefined;\n        let result;\n        const state = await ctx.getFullContractState(this.address);\n        if (state == null || !state.isDeployed) {\n            if (this.publicKey == null) {\n                throw new Error('Contract not deployed and public key was not specified');\n            }\n            stateInit = makeStateInit(this.publicKey);\n            result = { seqno: 0, publicKey: this.publicKey };\n        }\n        else {\n            const data = ctx.extractContractData(state.boc);\n            if (data == null) {\n                throw new Error('Failed to extract contract data');\n            }\n            result = parseInitData(ctx, data);\n        }\n        if (this.publicKey == null) {\n            this.publicKey = result.publicKey;\n        }\n        else if (!this.publicKey.eq(result.publicKey)) {\n            throw new Error('Public key mismatch');\n        }\n        return {\n            seqno: result.seqno,\n            publicKey: result.publicKey.toString(16).padStart(64, '0'),\n            stateInit,\n        };\n    }\n}\nexports.WalletV3Account = WalletV3Account;\nconst parseInitData = (ctx, boc) => {\n    const parsed = ctx.unpackFromCell({\n        structure: DATA_STRUCTURE,\n        boc,\n        allowPartial: false,\n    });\n    if (typeof parsed !== 'object' || typeof parsed['seqno'] !== 'string' || typeof parsed['publicKey'] !== 'string') {\n        throw new Error('Invalid contract data ');\n    }\n    return {\n        seqno: parseInt(parsed.seqno),\n        publicKey: new bignumber_js_1.default(parsed.publicKey),\n    };\n};\nconst makeStateInit = (publicKey) => {\n    const data = nekoton.packIntoCell(DATA_STRUCTURE, {\n        seqno: 0,\n        walletId: WALLET_ID,\n        publicKey: publicKey.toFixed(0),\n    });\n    return nekoton.mergeTvc(WALLET_V3_CODE, data);\n};\nconst UNSIGNED_TRANSFER_STRUCTURE = [\n    { name: 'walletId', type: 'uint32' },\n    { name: 'expireAt', type: 'uint32' },\n    { name: 'seqno', type: 'uint32' },\n    { name: 'flags', type: 'uint8' },\n    { name: 'message', type: 'cell' },\n];\nconst SIGNED_TRANSFER_STRUCTURE = [\n    { name: 'signatureHigh', type: 'uint256' },\n    { name: 'signatureLow', type: 'uint256' },\n    ...UNSIGNED_TRANSFER_STRUCTURE,\n];\nconst DATA_STRUCTURE = [\n    { name: 'seqno', type: 'uint32' },\n    { name: 'walletId', type: 'uint32' },\n    { name: 'publicKey', type: 'uint256' },\n];\nconst WALLET_V3_CODE = 'te6ccgEBAQEAcQAA3v8AIN0gggFMl7ohggEznLqxn3Gw7UTQ0x/THzHXC//jBOCk8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVA==';\nconst WALLET_ID = 0x4BA92D8A;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2NsaWVudC9BY2NvdW50c1N0b3JhZ2UvV2FsbGV0VjMuanM/NTdmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2FsbGV0VjNBY2NvdW50ID0gdm9pZCAwO1xuY29uc3QgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xID0gcmVxdWlyZShcImV2ZXJzY2FsZS1pbnBhZ2UtcHJvdmlkZXJcIik7XG5jb25zdCBiaWdudW1iZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmlnbnVtYmVyLmpzXCIpKTtcbmNvbnN0IGNvcmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vY29yZVwiKSk7XG5jb25zdCB7IGVuc3VyZU5la290b25Mb2FkZWQsIG5la290b24gfSA9IGNvcmVfMS5kZWZhdWx0O1xuLyoqXG4gKiBAY2F0ZWdvcnkgQWNjb3VudHNTdG9yYWdlXG4gKi9cbmNsYXNzIFdhbGxldFYzQWNjb3VudCB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcykge1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY29tcHV0ZUFkZHJlc3MoYXJncykge1xuICAgICAgICAvLyBUT0RPOiBTb21laG93IHByb3BhZ2F0ZSBpbml0IHBhcmFtc1xuICAgICAgICBhd2FpdCBlbnN1cmVOZWtvdG9uTG9hZGVkKCk7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGFyZ3MucHVibGljS2V5IGluc3RhbmNlb2YgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdFxuICAgICAgICAgICAgPyBhcmdzLnB1YmxpY0tleVxuICAgICAgICAgICAgOiBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdChgMHgke2FyZ3MucHVibGljS2V5fWApO1xuICAgICAgICBjb25zdCB0dmMgPSBtYWtlU3RhdGVJbml0KHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBuZWtvdG9uLmdldEJvY0hhc2godHZjKTtcbiAgICAgICAgcmV0dXJuIG5ldyBldmVyc2NhbGVfaW5wYWdlX3Byb3ZpZGVyXzEuQWRkcmVzcyhgJHthcmdzLndvcmtjaGFpbiAhPSBudWxsID8gYXJncy53b3JrY2hhaW4gOiAwfToke2hhc2h9YCk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBmcm9tUHVia2V5KGFyZ3MpIHtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQoYDB4JHthcmdzLnB1YmxpY0tleX1gKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IFdhbGxldFYzQWNjb3VudC5jb21wdXRlQWRkcmVzcyh7IHB1YmxpY0tleSwgd29ya2NoYWluOiBhcmdzLndvcmtjaGFpbiB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFdhbGxldFYzQWNjb3VudChhZGRyZXNzKTtcbiAgICAgICAgcmVzdWx0LnB1YmxpY0tleSA9IHB1YmxpY0tleTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hQdWJsaWNLZXkoY3R4KSB7XG4gICAgICAgIGxldCBwdWJsaWNLZXkgPSB0aGlzLnB1YmxpY0tleTtcbiAgICAgICAgaWYgKHB1YmxpY0tleSA9PSBudWxsKSB7XG4gICAgICAgICAgICBwdWJsaWNLZXkgPSB0aGlzLnB1YmxpY0tleSA9IGF3YWl0IGN0eC5mZXRjaFB1YmxpY0tleSh0aGlzLmFkZHJlc3MpXG4gICAgICAgICAgICAgICAgLnRoZW4ocHVibGljS2V5ID0+IG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KGAweCR7cHVibGljS2V5fWApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVibGljS2V5LnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgJzAnKTtcbiAgICB9XG4gICAgYXN5bmMgcHJlcGFyZU1lc3NhZ2UoYXJncywgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgc2Vxbm8sIHB1YmxpY0tleSwgc3RhdGVJbml0IH0gPSBhd2FpdCB0aGlzLmZldGNoU3RhdGUoY3R4KTtcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgY3R4LmdldFNpZ25lcihwdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBleHBpcmVBdCA9IGN0eC5ub3dTZWMgKyBhcmdzLnRpbWVvdXQ7XG4gICAgICAgIGNvbnN0IGF0dGFjaGVkUGF5bG9hZCA9IGFyZ3MucGF5bG9hZFxuICAgICAgICAgICAgPyBjdHguZW5jb2RlSW50ZXJuYWxJbnB1dChhcmdzLnBheWxvYWQpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxNZXNzYWdlID0gY3R4LmVuY29kZUludGVybmFsTWVzc2FnZSh7XG4gICAgICAgICAgICBkc3Q6IGFyZ3MucmVjaXBpZW50LFxuICAgICAgICAgICAgYm91bmNlOiBhcmdzLmJvdW5jZSxcbiAgICAgICAgICAgIHN0YXRlSW5pdDogYXJncy5zdGF0ZUluaXQsXG4gICAgICAgICAgICBib2R5OiBhdHRhY2hlZFBheWxvYWQsXG4gICAgICAgICAgICBhbW91bnQ6IGFyZ3MuYW1vdW50LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgd2FsbGV0SWQ6IFdBTExFVF9JRCxcbiAgICAgICAgICAgIGV4cGlyZUF0LFxuICAgICAgICAgICAgc2Vxbm8sXG4gICAgICAgICAgICBmbGFnczogMyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGludGVybmFsTWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdW5zaWduZWRQYXlsb2FkID0gY3R4LnBhY2tJbnRvQ2VsbCh7IHN0cnVjdHVyZTogVU5TSUdORURfVFJBTlNGRVJfU1RSVUNUVVJFLCBkYXRhOiBwYXJhbXMgfSk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBjdHguZ2V0Qm9jSGFzaCh1bnNpZ25lZFBheWxvYWQpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzaWduZXIuc2lnbihoYXNoKTtcbiAgICAgICAgY29uc3QgeyBzaWduYXR1cmVQYXJ0cyB9ID0gY3R4LmV4dGVuZFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICBwYXJhbXMuc2lnbmF0dXJlSGlnaCA9IHNpZ25hdHVyZVBhcnRzLmhpZ2g7XG4gICAgICAgIHBhcmFtcy5zaWduYXR1cmVMb3cgPSBzaWduYXR1cmVQYXJ0cy5sb3c7XG4gICAgICAgIGNvbnN0IHNpZ25lZFBheWxvYWQgPSBjdHgucGFja0ludG9DZWxsKHtcbiAgICAgICAgICAgIHN0cnVjdHVyZTogU0lHTkVEX1RSQU5TRkVSX1NUUlVDVFVSRSxcbiAgICAgICAgICAgIGRhdGE6IHBhcmFtcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjdHguY3JlYXRlUmF3RXh0ZXJuYWxNZXNzYWdlKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgIGJvZHk6IHNpZ25lZFBheWxvYWQsXG4gICAgICAgICAgICBzdGF0ZUluaXQsXG4gICAgICAgICAgICBleHBpcmVBdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoU3RhdGUoY3R4KSB7XG4gICAgICAgIGxldCBzdGF0ZUluaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgY3R4LmdldEZ1bGxDb250cmFjdFN0YXRlKHRoaXMuYWRkcmVzcyk7XG4gICAgICAgIGlmIChzdGF0ZSA9PSBudWxsIHx8ICFzdGF0ZS5pc0RlcGxveWVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wdWJsaWNLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udHJhY3Qgbm90IGRlcGxveWVkIGFuZCBwdWJsaWMga2V5IHdhcyBub3Qgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZUluaXQgPSBtYWtlU3RhdGVJbml0KHRoaXMucHVibGljS2V5KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHsgc2Vxbm86IDAsIHB1YmxpY0tleTogdGhpcy5wdWJsaWNLZXkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjdHguZXh0cmFjdENvbnRyYWN0RGF0YShzdGF0ZS5ib2MpO1xuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGV4dHJhY3QgY29udHJhY3QgZGF0YScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VJbml0RGF0YShjdHgsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnB1YmxpY0tleSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnB1YmxpY0tleSA9IHJlc3VsdC5wdWJsaWNLZXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMucHVibGljS2V5LmVxKHJlc3VsdC5wdWJsaWNLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1B1YmxpYyBrZXkgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2Vxbm86IHJlc3VsdC5zZXFubyxcbiAgICAgICAgICAgIHB1YmxpY0tleTogcmVzdWx0LnB1YmxpY0tleS50b1N0cmluZygxNikucGFkU3RhcnQoNjQsICcwJyksXG4gICAgICAgICAgICBzdGF0ZUluaXQsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5XYWxsZXRWM0FjY291bnQgPSBXYWxsZXRWM0FjY291bnQ7XG5jb25zdCBwYXJzZUluaXREYXRhID0gKGN0eCwgYm9jKSA9PiB7XG4gICAgY29uc3QgcGFyc2VkID0gY3R4LnVucGFja0Zyb21DZWxsKHtcbiAgICAgICAgc3RydWN0dXJlOiBEQVRBX1NUUlVDVFVSRSxcbiAgICAgICAgYm9jLFxuICAgICAgICBhbGxvd1BhcnRpYWw6IGZhbHNlLFxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgcGFyc2VkICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFyc2VkWydzZXFubyddICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgcGFyc2VkWydwdWJsaWNLZXknXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbnRyYWN0IGRhdGEgJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNlcW5vOiBwYXJzZUludChwYXJzZWQuc2Vxbm8pLFxuICAgICAgICBwdWJsaWNLZXk6IG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KHBhcnNlZC5wdWJsaWNLZXkpLFxuICAgIH07XG59O1xuY29uc3QgbWFrZVN0YXRlSW5pdCA9IChwdWJsaWNLZXkpID0+IHtcbiAgICBjb25zdCBkYXRhID0gbmVrb3Rvbi5wYWNrSW50b0NlbGwoREFUQV9TVFJVQ1RVUkUsIHtcbiAgICAgICAgc2Vxbm86IDAsXG4gICAgICAgIHdhbGxldElkOiBXQUxMRVRfSUQsXG4gICAgICAgIHB1YmxpY0tleTogcHVibGljS2V5LnRvRml4ZWQoMCksXG4gICAgfSk7XG4gICAgcmV0dXJuIG5la290b24ubWVyZ2VUdmMoV0FMTEVUX1YzX0NPREUsIGRhdGEpO1xufTtcbmNvbnN0IFVOU0lHTkVEX1RSQU5TRkVSX1NUUlVDVFVSRSA9IFtcbiAgICB7IG5hbWU6ICd3YWxsZXRJZCcsIHR5cGU6ICd1aW50MzInIH0sXG4gICAgeyBuYW1lOiAnZXhwaXJlQXQnLCB0eXBlOiAndWludDMyJyB9LFxuICAgIHsgbmFtZTogJ3NlcW5vJywgdHlwZTogJ3VpbnQzMicgfSxcbiAgICB7IG5hbWU6ICdmbGFncycsIHR5cGU6ICd1aW50OCcgfSxcbiAgICB7IG5hbWU6ICdtZXNzYWdlJywgdHlwZTogJ2NlbGwnIH0sXG5dO1xuY29uc3QgU0lHTkVEX1RSQU5TRkVSX1NUUlVDVFVSRSA9IFtcbiAgICB7IG5hbWU6ICdzaWduYXR1cmVIaWdoJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgeyBuYW1lOiAnc2lnbmF0dXJlTG93JywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgLi4uVU5TSUdORURfVFJBTlNGRVJfU1RSVUNUVVJFLFxuXTtcbmNvbnN0IERBVEFfU1RSVUNUVVJFID0gW1xuICAgIHsgbmFtZTogJ3NlcW5vJywgdHlwZTogJ3VpbnQzMicgfSxcbiAgICB7IG5hbWU6ICd3YWxsZXRJZCcsIHR5cGU6ICd1aW50MzInIH0sXG4gICAgeyBuYW1lOiAncHVibGljS2V5JywgdHlwZTogJ3VpbnQyNTYnIH0sXG5dO1xuY29uc3QgV0FMTEVUX1YzX0NPREUgPSAndGU2Y2NnRUJBUUVBY1FBQTN2OEFJTjBnZ2dGTWw3b2hnZ0V6bkxxeG4zR3c3VVRRMHgvVEh6SFhDLy9qQk9DazhtQ0RDTmNZSU5NZjB4L1RIL2dqRTd2eVkrMUUwTk1mMHgvVC85RlJNcnJ5b1ZGRXV2S2lCUGtCVkJCVitSRHlvL2dBa3lEWFNwYlRCOVFDK3dEbzBRR2t5TXNmeXgvTC84bnRWQT09JztcbmNvbnN0IFdBTExFVF9JRCA9IDB4NEJBOTJEOEE7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///61\n")},487:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.SimpleAccountsStorage = exports.AccountsStorageContext = exports.HighloadWalletV2 = exports.WalletV3Account = exports.MsigAccount = exports.GenericAccount = exports.GiverAccount = void 0;\nconst everscale_inpage_provider_1 = __webpack_require__(511);\nvar Giver_1 = __webpack_require__(766);\nObject.defineProperty(exports, "GiverAccount", ({ enumerable: true, get: function () { return Giver_1.GiverAccount; } }));\nvar Generic_1 = __webpack_require__(758);\nObject.defineProperty(exports, "GenericAccount", ({ enumerable: true, get: function () { return Generic_1.GenericAccount; } }));\nObject.defineProperty(exports, "MsigAccount", ({ enumerable: true, get: function () { return Generic_1.MsigAccount; } }));\nvar WalletV3_1 = __webpack_require__(61);\nObject.defineProperty(exports, "WalletV3Account", ({ enumerable: true, get: function () { return WalletV3_1.WalletV3Account; } }));\nvar HighloadWalletV2_1 = __webpack_require__(128);\nObject.defineProperty(exports, "HighloadWalletV2", ({ enumerable: true, get: function () { return HighloadWalletV2_1.HighloadWalletV2; } }));\n/**\n * @category AccountsStorage\n */\nclass AccountsStorageContext {\n    constructor(clock, connectionController, nekoton, keystore) {\n        this.clock = clock;\n        this.connectionController = connectionController;\n        this.nekoton = nekoton;\n        this.keystore = keystore;\n    }\n    async getSigner(publicKey) {\n        if (this.keystore == null) {\n            throw new Error(\'Keystore not found\');\n        }\n        const signer = await this.keystore.getSigner(publicKey);\n        if (signer == null) {\n            throw new Error(\'Signer not found\');\n        }\n        return signer;\n    }\n    get nowMs() {\n        return this.clock.nowMs;\n    }\n    get nowSec() {\n        return ~~(this.clock.nowMs / 1000);\n    }\n    async fetchPublicKey(address) {\n        const state = await this.getFullContractState(address);\n        if (state == null || !state.isDeployed) {\n            throw new Error(\'Contract not deployed\');\n        }\n        return this.nekoton.extractPublicKey(state.boc);\n    }\n    async getFullContractState(address) {\n        return this.connectionController.use(async ({ data: { transport } }) => transport.getFullContractState(address.toString()));\n    }\n    extractContractData(boc) {\n        return this.nekoton.extractContractData(boc);\n    }\n    packIntoCell(args) {\n        return this.nekoton.packIntoCell(args.structure, args.data, args.abiVersion);\n    }\n    unpackFromCell(args) {\n        return this.nekoton.unpackFromCell(args.structure, args.boc, args.allowPartial, args.abiVersion);\n    }\n    getBocHash(boc) {\n        return this.nekoton.getBocHash(boc);\n    }\n    extendSignature(signature) {\n        return this.nekoton.extendSignature(signature);\n    }\n    encodeInternalInput(args) {\n        return this.nekoton.encodeInternalInput(args.abi, args.method, args.params);\n    }\n    encodeInternalMessage(args) {\n        return this.nekoton.encodeInternalMessage(args.src, args.dst, args.bounce, args.stateInit, args.body, args.amount);\n    }\n    async createExternalMessage(args) {\n        const unsignedMessage = this.nekoton.createExternalMessage(this.clock, args.address.toString(), args.abi, args.method, args.stateInit, args.params, args.signer.publicKey, args.timeout);\n        try {\n            const signature = await args.signer.sign(unsignedMessage.hash);\n            return unsignedMessage.sign(signature);\n        }\n        finally {\n            unsignedMessage.free();\n        }\n    }\n    createRawExternalMessage(args) {\n        return this.nekoton.createRawExternalMessage(args.address.toString(), args.stateInit, args.body, args.expireAt);\n    }\n}\nexports.AccountsStorageContext = AccountsStorageContext;\n/**\n * @category AccountsStorage\n */\nclass SimpleAccountsStorage {\n    /**\n     * Creates new simple accounts storage.\n     *\n     * If no `defaultAccount` provided, uses first provided entry\n     *\n     * @param args\n     */\n    constructor(args = {}) {\n        this.accounts = new Map();\n        if (args.entries != null) {\n            for (const account of args.entries) {\n                if (this._defaultAccount == null) {\n                    this._defaultAccount = account.address;\n                }\n                this.accounts.set(account.address.toString(), account);\n            }\n        }\n        if (args.defaultAccount != null) {\n            let defaultAccount;\n            if (args.defaultAccount instanceof everscale_inpage_provider_1.Address) {\n                defaultAccount = args.defaultAccount;\n            }\n            else {\n                defaultAccount = new everscale_inpage_provider_1.Address(args.defaultAccount);\n            }\n            if (!this.accounts.has(defaultAccount.toString())) {\n                throw new Error(\'Provided default account not found in storage\');\n            }\n            this._defaultAccount = defaultAccount;\n        }\n    }\n    get defaultAccount() {\n        return this._defaultAccount;\n    }\n    set defaultAccount(value) {\n        const address = value === null || value === void 0 ? void 0 : value.toString();\n        if (address != null && !this.accounts.has(address)) {\n            throw new Error(\'Account not found in storage\');\n        }\n        this._defaultAccount = (value == null || value instanceof everscale_inpage_provider_1.Address) ? value : new everscale_inpage_provider_1.Address(value);\n    }\n    async getAccount(address) {\n        return this.accounts.get(address.toString());\n    }\n    addAccount(account) {\n        const address = account.address;\n        this.accounts.set(address.toString(), account);\n        return address;\n    }\n    hasAccount(address) {\n        return this.accounts.has(address.toString());\n    }\n    removeAccount(address) {\n        this.accounts.delete(address.toString());\n    }\n}\nexports.SimpleAccountsStorage = SimpleAccountsStorage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvQWNjb3VudHNTdG9yYWdlL2luZGV4LmpzPzYyOGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpbXBsZUFjY291bnRzU3RvcmFnZSA9IGV4cG9ydHMuQWNjb3VudHNTdG9yYWdlQ29udGV4dCA9IGV4cG9ydHMuSGlnaGxvYWRXYWxsZXRWMiA9IGV4cG9ydHMuV2FsbGV0VjNBY2NvdW50ID0gZXhwb3J0cy5Nc2lnQWNjb3VudCA9IGV4cG9ydHMuR2VuZXJpY0FjY291bnQgPSBleHBvcnRzLkdpdmVyQWNjb3VudCA9IHZvaWQgMDtcbmNvbnN0IGV2ZXJzY2FsZV9pbnBhZ2VfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCJldmVyc2NhbGUtaW5wYWdlLXByb3ZpZGVyXCIpO1xudmFyIEdpdmVyXzEgPSByZXF1aXJlKFwiLi9HaXZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdpdmVyQWNjb3VudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gR2l2ZXJfMS5HaXZlckFjY291bnQ7IH0gfSk7XG52YXIgR2VuZXJpY18xID0gcmVxdWlyZShcIi4vR2VuZXJpY1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdlbmVyaWNBY2NvdW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBHZW5lcmljXzEuR2VuZXJpY0FjY291bnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNc2lnQWNjb3VudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gR2VuZXJpY18xLk1zaWdBY2NvdW50OyB9IH0pO1xudmFyIFdhbGxldFYzXzEgPSByZXF1aXJlKFwiLi9XYWxsZXRWM1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldhbGxldFYzQWNjb3VudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gV2FsbGV0VjNfMS5XYWxsZXRWM0FjY291bnQ7IH0gfSk7XG52YXIgSGlnaGxvYWRXYWxsZXRWMl8xID0gcmVxdWlyZShcIi4vSGlnaGxvYWRXYWxsZXRWMlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkhpZ2hsb2FkV2FsbGV0VjJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEhpZ2hsb2FkV2FsbGV0VjJfMS5IaWdobG9hZFdhbGxldFYyOyB9IH0pO1xuLyoqXG4gKiBAY2F0ZWdvcnkgQWNjb3VudHNTdG9yYWdlXG4gKi9cbmNsYXNzIEFjY291bnRzU3RvcmFnZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGNsb2NrLCBjb25uZWN0aW9uQ29udHJvbGxlciwgbmVrb3Rvbiwga2V5c3RvcmUpIHtcbiAgICAgICAgdGhpcy5jbG9jayA9IGNsb2NrO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Db250cm9sbGVyID0gY29ubmVjdGlvbkNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMubmVrb3RvbiA9IG5la290b247XG4gICAgICAgIHRoaXMua2V5c3RvcmUgPSBrZXlzdG9yZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2lnbmVyKHB1YmxpY0tleSkge1xuICAgICAgICBpZiAodGhpcy5rZXlzdG9yZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleXN0b3JlIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHRoaXMua2V5c3RvcmUuZ2V0U2lnbmVyKHB1YmxpY0tleSk7XG4gICAgICAgIGlmIChzaWduZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaWduZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ25lcjtcbiAgICB9XG4gICAgZ2V0IG5vd01zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9jay5ub3dNcztcbiAgICB9XG4gICAgZ2V0IG5vd1NlYygpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMuY2xvY2subm93TXMgLyAxMDAwKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hQdWJsaWNLZXkoYWRkcmVzcykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGF3YWl0IHRoaXMuZ2V0RnVsbENvbnRyYWN0U3RhdGUoYWRkcmVzcyk7XG4gICAgICAgIGlmIChzdGF0ZSA9PSBudWxsIHx8ICFzdGF0ZS5pc0RlcGxveWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyYWN0IG5vdCBkZXBsb3llZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5la290b24uZXh0cmFjdFB1YmxpY0tleShzdGF0ZS5ib2MpO1xuICAgIH1cbiAgICBhc3luYyBnZXRGdWxsQ29udHJhY3RTdGF0ZShhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Db250cm9sbGVyLnVzZShhc3luYyAoeyBkYXRhOiB7IHRyYW5zcG9ydCB9IH0pID0+IHRyYW5zcG9ydC5nZXRGdWxsQ29udHJhY3RTdGF0ZShhZGRyZXNzLnRvU3RyaW5nKCkpKTtcbiAgICB9XG4gICAgZXh0cmFjdENvbnRyYWN0RGF0YShib2MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVrb3Rvbi5leHRyYWN0Q29udHJhY3REYXRhKGJvYyk7XG4gICAgfVxuICAgIHBhY2tJbnRvQ2VsbChhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5la290b24ucGFja0ludG9DZWxsKGFyZ3Muc3RydWN0dXJlLCBhcmdzLmRhdGEsIGFyZ3MuYWJpVmVyc2lvbik7XG4gICAgfVxuICAgIHVucGFja0Zyb21DZWxsKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVrb3Rvbi51bnBhY2tGcm9tQ2VsbChhcmdzLnN0cnVjdHVyZSwgYXJncy5ib2MsIGFyZ3MuYWxsb3dQYXJ0aWFsLCBhcmdzLmFiaVZlcnNpb24pO1xuICAgIH1cbiAgICBnZXRCb2NIYXNoKGJvYykge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWtvdG9uLmdldEJvY0hhc2goYm9jKTtcbiAgICB9XG4gICAgZXh0ZW5kU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWtvdG9uLmV4dGVuZFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIH1cbiAgICBlbmNvZGVJbnRlcm5hbElucHV0KGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVrb3Rvbi5lbmNvZGVJbnRlcm5hbElucHV0KGFyZ3MuYWJpLCBhcmdzLm1ldGhvZCwgYXJncy5wYXJhbXMpO1xuICAgIH1cbiAgICBlbmNvZGVJbnRlcm5hbE1lc3NhZ2UoYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWtvdG9uLmVuY29kZUludGVybmFsTWVzc2FnZShhcmdzLnNyYywgYXJncy5kc3QsIGFyZ3MuYm91bmNlLCBhcmdzLnN0YXRlSW5pdCwgYXJncy5ib2R5LCBhcmdzLmFtb3VudCk7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUV4dGVybmFsTWVzc2FnZShhcmdzKSB7XG4gICAgICAgIGNvbnN0IHVuc2lnbmVkTWVzc2FnZSA9IHRoaXMubmVrb3Rvbi5jcmVhdGVFeHRlcm5hbE1lc3NhZ2UodGhpcy5jbG9jaywgYXJncy5hZGRyZXNzLnRvU3RyaW5nKCksIGFyZ3MuYWJpLCBhcmdzLm1ldGhvZCwgYXJncy5zdGF0ZUluaXQsIGFyZ3MucGFyYW1zLCBhcmdzLnNpZ25lci5wdWJsaWNLZXksIGFyZ3MudGltZW91dCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBhcmdzLnNpZ25lci5zaWduKHVuc2lnbmVkTWVzc2FnZS5oYXNoKTtcbiAgICAgICAgICAgIHJldHVybiB1bnNpZ25lZE1lc3NhZ2Uuc2lnbihzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdW5zaWduZWRNZXNzYWdlLmZyZWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVSYXdFeHRlcm5hbE1lc3NhZ2UoYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWtvdG9uLmNyZWF0ZVJhd0V4dGVybmFsTWVzc2FnZShhcmdzLmFkZHJlc3MudG9TdHJpbmcoKSwgYXJncy5zdGF0ZUluaXQsIGFyZ3MuYm9keSwgYXJncy5leHBpcmVBdCk7XG4gICAgfVxufVxuZXhwb3J0cy5BY2NvdW50c1N0b3JhZ2VDb250ZXh0ID0gQWNjb3VudHNTdG9yYWdlQ29udGV4dDtcbi8qKlxuICogQGNhdGVnb3J5IEFjY291bnRzU3RvcmFnZVxuICovXG5jbGFzcyBTaW1wbGVBY2NvdW50c1N0b3JhZ2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IHNpbXBsZSBhY2NvdW50cyBzdG9yYWdlLlxuICAgICAqXG4gICAgICogSWYgbm8gYGRlZmF1bHRBY2NvdW50YCBwcm92aWRlZCwgdXNlcyBmaXJzdCBwcm92aWRlZCBlbnRyeVxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhcmdzID0ge30pIHtcbiAgICAgICAgdGhpcy5hY2NvdW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKGFyZ3MuZW50cmllcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFjY291bnQgb2YgYXJncy5lbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RlZmF1bHRBY2NvdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdEFjY291bnQgPSBhY2NvdW50LmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYWNjb3VudHMuc2V0KGFjY291bnQuYWRkcmVzcy50b1N0cmluZygpLCBhY2NvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy5kZWZhdWx0QWNjb3VudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgZGVmYXVsdEFjY291bnQ7XG4gICAgICAgICAgICBpZiAoYXJncy5kZWZhdWx0QWNjb3VudCBpbnN0YW5jZW9mIGV2ZXJzY2FsZV9pbnBhZ2VfcHJvdmlkZXJfMS5BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEFjY291bnQgPSBhcmdzLmRlZmF1bHRBY2NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEFjY291bnQgPSBuZXcgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3MoYXJncy5kZWZhdWx0QWNjb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWNjb3VudHMuaGFzKGRlZmF1bHRBY2NvdW50LnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBkZWZhdWx0IGFjY291bnQgbm90IGZvdW5kIGluIHN0b3JhZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRBY2NvdW50ID0gZGVmYXVsdEFjY291bnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRlZmF1bHRBY2NvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdEFjY291bnQ7XG4gICAgfVxuICAgIHNldCBkZWZhdWx0QWNjb3VudCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChhZGRyZXNzICE9IG51bGwgJiYgIXRoaXMuYWNjb3VudHMuaGFzKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgbm90IGZvdW5kIGluIHN0b3JhZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZWZhdWx0QWNjb3VudCA9ICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlIGluc3RhbmNlb2YgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3MpID8gdmFsdWUgOiBuZXcgZXZlcnNjYWxlX2lucGFnZV9wcm92aWRlcl8xLkFkZHJlc3ModmFsdWUpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBY2NvdW50KGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjb3VudHMuZ2V0KGFkZHJlc3MudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGFkZEFjY291bnQoYWNjb3VudCkge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYWNjb3VudC5hZGRyZXNzO1xuICAgICAgICB0aGlzLmFjY291bnRzLnNldChhZGRyZXNzLnRvU3RyaW5nKCksIGFjY291bnQpO1xuICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICB9XG4gICAgaGFzQWNjb3VudChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY291bnRzLmhhcyhhZGRyZXNzLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICByZW1vdmVBY2NvdW50KGFkZHJlc3MpIHtcbiAgICAgICAgdGhpcy5hY2NvdW50cy5kZWxldGUoYWRkcmVzcy50b1N0cmluZygpKTtcbiAgICB9XG59XG5leHBvcnRzLlNpbXBsZUFjY291bnRzU3RvcmFnZSA9IFNpbXBsZUFjY291bnRzU3RvcmFnZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///487\n')},315:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GqlSocket = void 0;\nconst core_1 = __importDefault(__webpack_require__(521));\nconst { nekoton, fetch, fetchAgent, debugLog } = core_1.default;\nclass GqlSocket {\n    async connect(clock, params) {\n        class GqlSender {\n            constructor(params) {\n                this.nextLatencyDetectionTime = 0;\n                this.params = params;\n                this.latencyDetectionInterval = params.latencyDetectionInterval || 60000;\n                this.endpoints = params.endpoints.map(GqlSocket.expandAddress);\n                if (this.endpoints.length == 1) {\n                    this.currentEndpoint = this.endpoints[0];\n                    this.nextLatencyDetectionTime = Number.MAX_VALUE;\n                }\n            }\n            isLocal() {\n                return this.params.local;\n            }\n            send(data, handler, _longQuery) {\n                ;\n                (async () => {\n                    const now = Date.now();\n                    try {\n                        let endpoint;\n                        if (this.currentEndpoint != null && now < this.nextLatencyDetectionTime) {\n                            // Default route\n                            endpoint = this.currentEndpoint;\n                        }\n                        else if (this.resolutionPromise != null) {\n                            // Already resolving\n                            endpoint = await this.resolutionPromise;\n                            delete this.resolutionPromise;\n                        }\n                        else {\n                            delete this.currentEndpoint;\n                            // Start resolving (current endpoint is null, or it is time to refresh)\n                            this.resolutionPromise = this._selectQueryingEndpoint().then((endpoint) => {\n                                this.currentEndpoint = endpoint;\n                                this.nextLatencyDetectionTime = Date.now() + this.latencyDetectionInterval;\n                                return endpoint;\n                            });\n                            endpoint = await this.resolutionPromise;\n                            delete this.resolutionPromise;\n                        }\n                        const response = await fetch(endpoint.url, {\n                            method: 'post',\n                            headers: DEFAULT_HEADERS,\n                            body: data,\n                            agent: endpoint.agent,\n                        }).then((response) => response.text());\n                        handler.onReceive(response);\n                    }\n                    catch (e) {\n                        handler.onError(e);\n                    }\n                })();\n            }\n            async _selectQueryingEndpoint() {\n                const maxLatency = this.params.maxLatency || 60000;\n                const endpointCount = this.endpoints.length;\n                for (let retryCount = 0; retryCount < 5; ++retryCount) {\n                    let handlers;\n                    const promise = new Promise((resolve, reject) => {\n                        handlers = {\n                            resolve: (endpoint) => resolve(endpoint),\n                            reject: () => reject(undefined),\n                        };\n                    });\n                    let checkedEndpoints = 0;\n                    let lastLatency;\n                    for (const endpoint of this.endpoints) {\n                        GqlSocket.checkLatency(endpoint).then((latency) => {\n                            ++checkedEndpoints;\n                            if (latency !== undefined && latency <= maxLatency) {\n                                return handlers.resolve(endpoint);\n                            }\n                            if (lastLatency === undefined ||\n                                lastLatency.latency === undefined ||\n                                (latency !== undefined && latency < lastLatency.latency)) {\n                                lastLatency = { endpoint, latency };\n                            }\n                            if (checkedEndpoints >= endpointCount) {\n                                if ((lastLatency === null || lastLatency === void 0 ? void 0 : lastLatency.latency) !== undefined) {\n                                    handlers.resolve(lastLatency.endpoint);\n                                }\n                                else {\n                                    handlers.reject();\n                                }\n                            }\n                        });\n                    }\n                    try {\n                        return await promise;\n                    }\n                    catch (e) {\n                        let resolveDelay;\n                        const delayPromise = new Promise((resolve) => {\n                            resolveDelay = () => resolve();\n                        });\n                        setTimeout(() => resolveDelay(), Math.min(100 * retryCount, 5000));\n                        await delayPromise;\n                    }\n                }\n                throw new Error('Not available endpoint found');\n            }\n        }\n        return new nekoton.GqlConnection(clock, new GqlSender(params));\n    }\n    static async checkLatency(endpoint) {\n        const response = await fetch(`${endpoint.url}?query=%7Binfo%7Bversion%20time%20latency%7D%7D`, {\n            method: 'get',\n            agent: endpoint.agent,\n        })\n            .then((response) => response.json())\n            .catch((e) => {\n            debugLog(e);\n            return undefined;\n        });\n        if (typeof response !== 'object' || response == null) {\n            return;\n        }\n        const data = response['data'];\n        if (typeof data !== 'object' || data == null) {\n            return;\n        }\n        const info = data['info'];\n        if (typeof info !== 'object' || info == null) {\n            return;\n        }\n        const latency = info['latency'];\n        if (typeof latency !== 'number') {\n            return;\n        }\n        return latency;\n    }\n}\nexports.GqlSocket = GqlSocket;\nGqlSocket.expandAddress = (baseUrl) => {\n    const lastBackslashIndex = baseUrl.lastIndexOf('/');\n    baseUrl = lastBackslashIndex < 0 ? baseUrl : baseUrl.substring(0, lastBackslashIndex);\n    let url;\n    if (baseUrl.startsWith('http://') || baseUrl.startsWith('https://')) {\n        url = `${baseUrl}/graphql`;\n    }\n    else if (['localhost', '127.0.0.1'].indexOf(baseUrl) >= 0) {\n        url = `http://${baseUrl}/graphql`;\n    }\n    else {\n        url = `https://${baseUrl}/graphql`;\n    }\n    return {\n        url,\n        agent: fetchAgent(url),\n    };\n};\nconst DEFAULT_HEADERS = {\n    'Content-Type': 'application/json',\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvQ29ubmVjdGlvbkNvbnRyb2xsZXIvZ3FsLmpzPzE2MDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdxbFNvY2tldCA9IHZvaWQgMDtcbmNvbnN0IGNvcmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vY29yZVwiKSk7XG5jb25zdCB7IG5la290b24sIGZldGNoLCBmZXRjaEFnZW50LCBkZWJ1Z0xvZyB9ID0gY29yZV8xLmRlZmF1bHQ7XG5jbGFzcyBHcWxTb2NrZXQge1xuICAgIGFzeW5jIGNvbm5lY3QoY2xvY2ssIHBhcmFtcykge1xuICAgICAgICBjbGFzcyBHcWxTZW5kZXIge1xuICAgICAgICAgICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TGF0ZW5jeURldGVjdGlvblRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZW5jeURldGVjdGlvbkludGVydmFsID0gcGFyYW1zLmxhdGVuY3lEZXRlY3Rpb25JbnRlcnZhbCB8fCA2MDAwMDtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50cyA9IHBhcmFtcy5lbmRwb2ludHMubWFwKEdxbFNvY2tldC5leHBhbmRBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRwb2ludHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RW5kcG9pbnQgPSB0aGlzLmVuZHBvaW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0TGF0ZW5jeURldGVjdGlvblRpbWUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzTG9jYWwoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmxvY2FsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VuZChkYXRhLCBoYW5kbGVyLCBfbG9uZ1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RW5kcG9pbnQgIT0gbnVsbCAmJiBub3cgPCB0aGlzLm5leHRMYXRlbmN5RGV0ZWN0aW9uVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgcm91dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludCA9IHRoaXMuY3VycmVudEVuZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5yZXNvbHV0aW9uUHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSByZXNvbHZpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludCA9IGF3YWl0IHRoaXMucmVzb2x1dGlvblByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVzb2x1dGlvblByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jdXJyZW50RW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgcmVzb2x2aW5nIChjdXJyZW50IGVuZHBvaW50IGlzIG51bGwsIG9yIGl0IGlzIHRpbWUgdG8gcmVmcmVzaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdXRpb25Qcm9taXNlID0gdGhpcy5fc2VsZWN0UXVlcnlpbmdFbmRwb2ludCgpLnRoZW4oKGVuZHBvaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEVuZHBvaW50ID0gZW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dExhdGVuY3lEZXRlY3Rpb25UaW1lID0gRGF0ZS5ub3coKSArIHRoaXMubGF0ZW5jeURldGVjdGlvbkludGVydmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQgPSBhd2FpdCB0aGlzLnJlc29sdXRpb25Qcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlc29sdXRpb25Qcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChlbmRwb2ludC51cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdwb3N0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBERUZBVUxUX0hFQURFUlMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2VudDogZW5kcG9pbnQuYWdlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UudGV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIub25SZWNlaXZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5vbkVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzeW5jIF9zZWxlY3RRdWVyeWluZ0VuZHBvaW50KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heExhdGVuY3kgPSB0aGlzLnBhcmFtcy5tYXhMYXRlbmN5IHx8IDYwMDAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50Q291bnQgPSB0aGlzLmVuZHBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcmV0cnlDb3VudCA9IDA7IHJldHJ5Q291bnQgPCA1OyArK3JldHJ5Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhhbmRsZXJzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZTogKGVuZHBvaW50KSA9PiByZXNvbHZlKGVuZHBvaW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Q6ICgpID0+IHJlamVjdCh1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGVja2VkRW5kcG9pbnRzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RMYXRlbmN5O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVuZHBvaW50IG9mIHRoaXMuZW5kcG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBHcWxTb2NrZXQuY2hlY2tMYXRlbmN5KGVuZHBvaW50KS50aGVuKChsYXRlbmN5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytjaGVja2VkRW5kcG9pbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXRlbmN5ICE9PSB1bmRlZmluZWQgJiYgbGF0ZW5jeSA8PSBtYXhMYXRlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVycy5yZXNvbHZlKGVuZHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RMYXRlbmN5ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdExhdGVuY3kubGF0ZW5jeSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsYXRlbmN5ICE9PSB1bmRlZmluZWQgJiYgbGF0ZW5jeSA8IGxhc3RMYXRlbmN5LmxhdGVuY3kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RMYXRlbmN5ID0geyBlbmRwb2ludCwgbGF0ZW5jeSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZEVuZHBvaW50cyA+PSBlbmRwb2ludENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobGFzdExhdGVuY3kgPT09IG51bGwgfHwgbGFzdExhdGVuY3kgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RMYXRlbmN5LmxhdGVuY3kpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnJlc29sdmUobGFzdExhdGVuY3kuZW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXNvbHZlRGVsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxheVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVEZWxheSA9ICgpID0+IHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlRGVsYXkoKSwgTWF0aC5taW4oMTAwICogcmV0cnlDb3VudCwgNTAwMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGVsYXlQcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGF2YWlsYWJsZSBlbmRwb2ludCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgbmVrb3Rvbi5HcWxDb25uZWN0aW9uKGNsb2NrLCBuZXcgR3FsU2VuZGVyKHBhcmFtcykpO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY2hlY2tMYXRlbmN5KGVuZHBvaW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7ZW5kcG9pbnQudXJsfT9xdWVyeT0lN0JpbmZvJTdCdmVyc2lvbiUyMHRpbWUlMjBsYXRlbmN5JTdEJTdEYCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnZ2V0JyxcbiAgICAgICAgICAgIGFnZW50OiBlbmRwb2ludC5hZ2VudCxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBkZWJ1Z0xvZyhlKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlICE9PSAnb2JqZWN0JyB8fCByZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHwgZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5mbyA9IGRhdGFbJ2luZm8nXTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmZvICE9PSAnb2JqZWN0JyB8fCBpbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXRlbmN5ID0gaW5mb1snbGF0ZW5jeSddO1xuICAgICAgICBpZiAodHlwZW9mIGxhdGVuY3kgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhdGVuY3k7XG4gICAgfVxufVxuZXhwb3J0cy5HcWxTb2NrZXQgPSBHcWxTb2NrZXQ7XG5HcWxTb2NrZXQuZXhwYW5kQWRkcmVzcyA9IChiYXNlVXJsKSA9PiB7XG4gICAgY29uc3QgbGFzdEJhY2tzbGFzaEluZGV4ID0gYmFzZVVybC5sYXN0SW5kZXhPZignLycpO1xuICAgIGJhc2VVcmwgPSBsYXN0QmFja3NsYXNoSW5kZXggPCAwID8gYmFzZVVybCA6IGJhc2VVcmwuc3Vic3RyaW5nKDAsIGxhc3RCYWNrc2xhc2hJbmRleCk7XG4gICAgbGV0IHVybDtcbiAgICBpZiAoYmFzZVVybC5zdGFydHNXaXRoKCdodHRwOi8vJykgfHwgYmFzZVVybC5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgICAgIHVybCA9IGAke2Jhc2VVcmx9L2dyYXBocWxgO1xuICAgIH1cbiAgICBlbHNlIGlmIChbJ2xvY2FsaG9zdCcsICcxMjcuMC4wLjEnXS5pbmRleE9mKGJhc2VVcmwpID49IDApIHtcbiAgICAgICAgdXJsID0gYGh0dHA6Ly8ke2Jhc2VVcmx9L2dyYXBocWxgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXJsID0gYGh0dHBzOi8vJHtiYXNlVXJsfS9ncmFwaHFsYDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXJsLFxuICAgICAgICBhZ2VudDogZmV0Y2hBZ2VudCh1cmwpLFxuICAgIH07XG59O1xuY29uc3QgREVGQVVMVF9IRUFERVJTID0ge1xuICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///315\n")},863:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectionController = exports.createConnectionController = exports.ConnectionError = exports.checkConnection = exports.NETWORK_PRESETS = exports.DEFAULT_NETWORK_GROUP = void 0;\nconst await_semaphore_1 = __webpack_require__(68);\nconst core_1 = __importDefault(__webpack_require__(521));\nconst gql_1 = __webpack_require__(315);\nconst jrpc_1 = __webpack_require__(106);\nconst { nekoton, debugLog } = core_1.default;\nexports.DEFAULT_NETWORK_GROUP = 'mainnet';\n/**\n * @category Client\n */\nexports.NETWORK_PRESETS = {\n    mainnet: {\n        id: 1,\n        group: 'mainnet',\n        type: 'graphql',\n        data: {\n            endpoints: [\n                'eri01.main.everos.dev',\n                'gra01.main.everos.dev',\n                'gra02.main.everos.dev',\n                'lim01.main.everos.dev',\n                'rbx01.main.everos.dev',\n            ],\n            local: false,\n        },\n    },\n    mainnetJrpc: {\n        id: 1,\n        group: 'mainnet',\n        type: 'jrpc',\n        data: {\n            endpoint: 'https://jrpc.everwallet.net/rpc',\n        },\n    },\n    testnet: {\n        id: 2,\n        group: 'testnet',\n        type: 'graphql',\n        data: {\n            endpoints: ['eri01.net.everos.dev', 'rbx01.net.everos.dev', 'gra01.net.everos.dev'],\n            local: false,\n        },\n    },\n    fld: {\n        id: 10,\n        group: 'fld',\n        type: 'graphql',\n        data: {\n            endpoints: ['gql.custler.net'],\n            local: false,\n        },\n    },\n    local: {\n        id: 31337,\n        group: 'localnet',\n        type: 'graphql',\n        data: {\n            endpoints: ['127.0.0.1'],\n            local: true,\n        },\n    },\n};\nfunction loadPreset(params) {\n    if (typeof params === 'string') {\n        const targetPreset = exports.NETWORK_PRESETS[params];\n        if (targetPreset == null) {\n            throw new Error(`Target preset id not found: ${params}`);\n        }\n        return targetPreset;\n    }\n    else {\n        return params;\n    }\n}\n/**\n * Tries to connect with the specified params. Throws an exception in case of error\n *\n * @category Client\n * @throws ConnectionError\n */\nasync function checkConnection(params) {\n    const preset = loadPreset(params);\n    const clock = new nekoton.ClockWithOffset();\n    try {\n        const controller = new ConnectionController(clock);\n        await controller['_connect'](preset);\n        if (controller['_initializedTransport'] != null) {\n            cleanupInitializedTransport(controller['_initializedTransport']);\n        }\n    }\n    catch (e) {\n        throw new ConnectionError(preset, e.toString());\n    }\n    finally {\n        clock.free();\n    }\n}\nexports.checkConnection = checkConnection;\n/**\n * @category Client\n */\nclass ConnectionError extends Error {\n    constructor(params, message) {\n        super(message);\n        this.params = params;\n    }\n}\nexports.ConnectionError = ConnectionError;\nasync function createConnectionController(clock, params, retry = false) {\n    const preset = loadPreset(params);\n    // Try connect\n    while (true) {\n        try {\n            const controller = new ConnectionController(clock);\n            await controller.startSwitchingNetwork(preset).then((handle) => handle.switch());\n            debugLog(`Successfully connected to ${preset.group}`);\n            return controller;\n        }\n        catch (e) {\n            if (retry) {\n                console.error('Connection failed:', e);\n                await new Promise((resolve) => {\n                    setTimeout(() => resolve(), 5000);\n                });\n                debugLog('Restarting connection process');\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n}\nexports.createConnectionController = createConnectionController;\nclass ConnectionController {\n    constructor(clock) {\n        this._networkMutex = new await_semaphore_1.Mutex();\n        this._acquiredTransportCounter = 0;\n        this._clock = clock;\n    }\n    async acquire() {\n        requireInitializedTransport(this._initializedTransport);\n        await this._acquireTransport();\n        return {\n            transport: this._initializedTransport,\n            release: () => this._releaseTransport(),\n        };\n    }\n    async use(f) {\n        requireInitializedTransport(this._initializedTransport);\n        await this._acquireTransport();\n        return f(this._initializedTransport)\n            .finally(() => {\n            this._releaseTransport();\n        });\n    }\n    async startSwitchingNetwork(params) {\n        var _a;\n        class NetworkSwitchHandle {\n            constructor(controller, release, params) {\n                this._controller = controller;\n                this._release = release;\n                this._params = params;\n            }\n            async switch() {\n                await this._controller\n                    ._connect(this._params)\n                    .finally(() => this._release());\n            }\n        }\n        (_a = this._cancelTestTransport) === null || _a === void 0 ? void 0 : _a.call(this);\n        const release = await this._networkMutex.acquire();\n        return new NetworkSwitchHandle(this, release, params);\n    }\n    get initializedTransport() {\n        return this._initializedTransport;\n    }\n    async _connect(params) {\n        if (this._initializedTransport != null) {\n            cleanupInitializedTransport(this._initializedTransport);\n        }\n        this._initializedTransport = undefined;\n        let TestConnectionResult;\n        (function (TestConnectionResult) {\n            TestConnectionResult[TestConnectionResult[\"DONE\"] = 0] = \"DONE\";\n            TestConnectionResult[TestConnectionResult[\"CANCELLED\"] = 1] = \"CANCELLED\";\n        })(TestConnectionResult || (TestConnectionResult = {}));\n        const testTransport = async ({ data: { transport } }, local) => {\n            return new Promise((resolve, reject) => {\n                this._cancelTestTransport = () => resolve(TestConnectionResult.CANCELLED);\n                if (local) {\n                    transport\n                        .getAccountsByCodeHash('4e92716de61d456e58f16e4e867e3e93a7548321eace86301b51c8b80ca6239b', 1)\n                        .then(() => resolve(TestConnectionResult.DONE))\n                        .catch((e) => reject(e));\n                }\n                else {\n                    // Try to get any account state\n                    transport\n                        .getFullContractState('-1:0000000000000000000000000000000000000000000000000000000000000000')\n                        .then(() => resolve(TestConnectionResult.DONE))\n                        .catch((e) => reject(e));\n                }\n                setTimeout(() => reject(new Error('Connection timeout')), 10000);\n            }).finally(() => this._cancelTestTransport = undefined);\n        };\n        try {\n            const { local, transportData } = await (params.type === 'graphql'\n                ? async () => {\n                    const socket = new gql_1.GqlSocket();\n                    const connection = await socket.connect(this._clock, params.data);\n                    const transport = nekoton.Transport.fromGqlConnection(connection);\n                    const transportData = {\n                        id: params.id,\n                        group: params.group,\n                        type: 'graphql',\n                        data: {\n                            socket,\n                            connection,\n                            transport,\n                        },\n                    };\n                    return {\n                        local: params.data.local,\n                        transportData,\n                    };\n                }\n                : async () => {\n                    const socket = new jrpc_1.JrpcSocket();\n                    const connection = await socket.connect(this._clock, params.data);\n                    const transport = nekoton.Transport.fromJrpcConnection(connection);\n                    const transportData = {\n                        id: params.id,\n                        group: params.group,\n                        type: 'jrpc',\n                        data: {\n                            socket,\n                            connection,\n                            transport,\n                        },\n                    };\n                    return {\n                        local: false,\n                        transportData,\n                    };\n                })();\n            try {\n                if (await testTransport(transportData, local) == TestConnectionResult.CANCELLED) {\n                    cleanupInitializedTransport(transportData);\n                    return;\n                }\n            }\n            catch (e) {\n                // Free transport data in case of error\n                cleanupInitializedTransport(transportData);\n                throw e;\n            }\n            this._initializedTransport = transportData;\n        }\n        catch (e) {\n            throw new Error(`Failed to create connection: ${e.toString()}`);\n        }\n    }\n    async _acquireTransport() {\n        debugLog('_acquireTransport');\n        if (this._acquiredTransportCounter > 0) {\n            debugLog('_acquireTransport -> increase');\n            this._acquiredTransportCounter += 1;\n        }\n        else {\n            this._acquiredTransportCounter = 1;\n            if (this._release != null) {\n                console.warn('mutex is already acquired');\n            }\n            else {\n                debugLog('_acquireTransport -> await');\n                this._release = await this._networkMutex.acquire();\n                debugLog('_acquireTransport -> create');\n            }\n        }\n    }\n    _releaseTransport() {\n        var _a;\n        debugLog('_releaseTransport');\n        this._acquiredTransportCounter -= 1;\n        if (this._acquiredTransportCounter <= 0) {\n            debugLog('_releaseTransport -> release');\n            (_a = this._release) === null || _a === void 0 ? void 0 : _a.call(this);\n            this._release = undefined;\n        }\n    }\n}\nexports.ConnectionController = ConnectionController;\nfunction cleanupInitializedTransport(transport) {\n    transport.data.transport.free();\n    transport.data.connection.free();\n}\nfunction requireInitializedTransport(transport) {\n    if (transport == null) {\n        throw new Error('Connection is not initialized');\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODYzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvQ29ubmVjdGlvbkNvbnRyb2xsZXIvaW5kZXguanM/YjIxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29ubmVjdGlvbkNvbnRyb2xsZXIgPSBleHBvcnRzLmNyZWF0ZUNvbm5lY3Rpb25Db250cm9sbGVyID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBleHBvcnRzLmNoZWNrQ29ubmVjdGlvbiA9IGV4cG9ydHMuTkVUV09SS19QUkVTRVRTID0gZXhwb3J0cy5ERUZBVUxUX05FVFdPUktfR1JPVVAgPSB2b2lkIDA7XG5jb25zdCBhd2FpdF9zZW1hcGhvcmVfMSA9IHJlcXVpcmUoXCJAYnJveHVzL2F3YWl0LXNlbWFwaG9yZVwiKTtcbmNvbnN0IGNvcmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vY29yZVwiKSk7XG5jb25zdCBncWxfMSA9IHJlcXVpcmUoXCIuL2dxbFwiKTtcbmNvbnN0IGpycGNfMSA9IHJlcXVpcmUoXCIuL2pycGNcIik7XG5jb25zdCB7IG5la290b24sIGRlYnVnTG9nIH0gPSBjb3JlXzEuZGVmYXVsdDtcbmV4cG9ydHMuREVGQVVMVF9ORVRXT1JLX0dST1VQID0gJ21haW5uZXQnO1xuLyoqXG4gKiBAY2F0ZWdvcnkgQ2xpZW50XG4gKi9cbmV4cG9ydHMuTkVUV09SS19QUkVTRVRTID0ge1xuICAgIG1haW5uZXQ6IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIGdyb3VwOiAnbWFpbm5ldCcsXG4gICAgICAgIHR5cGU6ICdncmFwaHFsJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZW5kcG9pbnRzOiBbXG4gICAgICAgICAgICAgICAgJ2VyaTAxLm1haW4uZXZlcm9zLmRldicsXG4gICAgICAgICAgICAgICAgJ2dyYTAxLm1haW4uZXZlcm9zLmRldicsXG4gICAgICAgICAgICAgICAgJ2dyYTAyLm1haW4uZXZlcm9zLmRldicsXG4gICAgICAgICAgICAgICAgJ2xpbTAxLm1haW4uZXZlcm9zLmRldicsXG4gICAgICAgICAgICAgICAgJ3JieDAxLm1haW4uZXZlcm9zLmRldicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgbWFpbm5ldEpycGM6IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIGdyb3VwOiAnbWFpbm5ldCcsXG4gICAgICAgIHR5cGU6ICdqcnBjJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZW5kcG9pbnQ6ICdodHRwczovL2pycGMuZXZlcndhbGxldC5uZXQvcnBjJyxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHRlc3RuZXQ6IHtcbiAgICAgICAgaWQ6IDIsXG4gICAgICAgIGdyb3VwOiAndGVzdG5ldCcsXG4gICAgICAgIHR5cGU6ICdncmFwaHFsJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZW5kcG9pbnRzOiBbJ2VyaTAxLm5ldC5ldmVyb3MuZGV2JywgJ3JieDAxLm5ldC5ldmVyb3MuZGV2JywgJ2dyYTAxLm5ldC5ldmVyb3MuZGV2J10sXG4gICAgICAgICAgICBsb2NhbDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBmbGQ6IHtcbiAgICAgICAgaWQ6IDEwLFxuICAgICAgICBncm91cDogJ2ZsZCcsXG4gICAgICAgIHR5cGU6ICdncmFwaHFsJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZW5kcG9pbnRzOiBbJ2dxbC5jdXN0bGVyLm5ldCddLFxuICAgICAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgbG9jYWw6IHtcbiAgICAgICAgaWQ6IDMxMzM3LFxuICAgICAgICBncm91cDogJ2xvY2FsbmV0JyxcbiAgICAgICAgdHlwZTogJ2dyYXBocWwnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBlbmRwb2ludHM6IFsnMTI3LjAuMC4xJ10sXG4gICAgICAgICAgICBsb2NhbDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGxvYWRQcmVzZXQocGFyYW1zKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFByZXNldCA9IGV4cG9ydHMuTkVUV09SS19QUkVTRVRTW3BhcmFtc107XG4gICAgICAgIGlmICh0YXJnZXRQcmVzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYXJnZXQgcHJlc2V0IGlkIG5vdCBmb3VuZDogJHtwYXJhbXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldFByZXNldDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxufVxuLyoqXG4gKiBUcmllcyB0byBjb25uZWN0IHdpdGggdGhlIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBhbiBleGNlcHRpb24gaW4gY2FzZSBvZiBlcnJvclxuICpcbiAqIEBjYXRlZ29yeSBDbGllbnRcbiAqIEB0aHJvd3MgQ29ubmVjdGlvbkVycm9yXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrQ29ubmVjdGlvbihwYXJhbXMpIHtcbiAgICBjb25zdCBwcmVzZXQgPSBsb2FkUHJlc2V0KHBhcmFtcyk7XG4gICAgY29uc3QgY2xvY2sgPSBuZXcgbmVrb3Rvbi5DbG9ja1dpdGhPZmZzZXQoKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IENvbm5lY3Rpb25Db250cm9sbGVyKGNsb2NrKTtcbiAgICAgICAgYXdhaXQgY29udHJvbGxlclsnX2Nvbm5lY3QnXShwcmVzZXQpO1xuICAgICAgICBpZiAoY29udHJvbGxlclsnX2luaXRpYWxpemVkVHJhbnNwb3J0J10gIT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYW51cEluaXRpYWxpemVkVHJhbnNwb3J0KGNvbnRyb2xsZXJbJ19pbml0aWFsaXplZFRyYW5zcG9ydCddKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKHByZXNldCwgZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGNsb2NrLmZyZWUoKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrQ29ubmVjdGlvbiA9IGNoZWNrQ29ubmVjdGlvbjtcbi8qKlxuICogQGNhdGVnb3J5IENsaWVudFxuICovXG5jbGFzcyBDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB9XG59XG5leHBvcnRzLkNvbm5lY3Rpb25FcnJvciA9IENvbm5lY3Rpb25FcnJvcjtcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb25Db250cm9sbGVyKGNsb2NrLCBwYXJhbXMsIHJldHJ5ID0gZmFsc2UpIHtcbiAgICBjb25zdCBwcmVzZXQgPSBsb2FkUHJlc2V0KHBhcmFtcyk7XG4gICAgLy8gVHJ5IGNvbm5lY3RcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBDb25uZWN0aW9uQ29udHJvbGxlcihjbG9jayk7XG4gICAgICAgICAgICBhd2FpdCBjb250cm9sbGVyLnN0YXJ0U3dpdGNoaW5nTmV0d29yayhwcmVzZXQpLnRoZW4oKGhhbmRsZSkgPT4gaGFuZGxlLnN3aXRjaCgpKTtcbiAgICAgICAgICAgIGRlYnVnTG9nKGBTdWNjZXNzZnVsbHkgY29ubmVjdGVkIHRvICR7cHJlc2V0Lmdyb3VwfWApO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChyZXRyeSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nvbm5lY3Rpb24gZmFpbGVkOicsIGUpO1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSgpLCA1MDAwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWJ1Z0xvZygnUmVzdGFydGluZyBjb25uZWN0aW9uIHByb2Nlc3MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUNvbm5lY3Rpb25Db250cm9sbGVyID0gY3JlYXRlQ29ubmVjdGlvbkNvbnRyb2xsZXI7XG5jbGFzcyBDb25uZWN0aW9uQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoY2xvY2spIHtcbiAgICAgICAgdGhpcy5fbmV0d29ya011dGV4ID0gbmV3IGF3YWl0X3NlbWFwaG9yZV8xLk11dGV4KCk7XG4gICAgICAgIHRoaXMuX2FjcXVpcmVkVHJhbnNwb3J0Q291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX2Nsb2NrID0gY2xvY2s7XG4gICAgfVxuICAgIGFzeW5jIGFjcXVpcmUoKSB7XG4gICAgICAgIHJlcXVpcmVJbml0aWFsaXplZFRyYW5zcG9ydCh0aGlzLl9pbml0aWFsaXplZFRyYW5zcG9ydCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2FjcXVpcmVUcmFuc3BvcnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydDogdGhpcy5faW5pdGlhbGl6ZWRUcmFuc3BvcnQsXG4gICAgICAgICAgICByZWxlYXNlOiAoKSA9PiB0aGlzLl9yZWxlYXNlVHJhbnNwb3J0KCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHVzZShmKSB7XG4gICAgICAgIHJlcXVpcmVJbml0aWFsaXplZFRyYW5zcG9ydCh0aGlzLl9pbml0aWFsaXplZFRyYW5zcG9ydCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2FjcXVpcmVUcmFuc3BvcnQoKTtcbiAgICAgICAgcmV0dXJuIGYodGhpcy5faW5pdGlhbGl6ZWRUcmFuc3BvcnQpXG4gICAgICAgICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZWxlYXNlVHJhbnNwb3J0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzdGFydFN3aXRjaGluZ05ldHdvcmsocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY2xhc3MgTmV0d29ya1N3aXRjaEhhbmRsZSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcihjb250cm9sbGVyLCByZWxlYXNlLCBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWxlYXNlID0gcmVsZWFzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3luYyBzd2l0Y2goKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fY29udHJvbGxlclxuICAgICAgICAgICAgICAgICAgICAuX2Nvbm5lY3QodGhpcy5fcGFyYW1zKVxuICAgICAgICAgICAgICAgICAgICAuZmluYWxseSgoKSA9PiB0aGlzLl9yZWxlYXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuX2NhbmNlbFRlc3RUcmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgICAgICBjb25zdCByZWxlYXNlID0gYXdhaXQgdGhpcy5fbmV0d29ya011dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXR3b3JrU3dpdGNoSGFuZGxlKHRoaXMsIHJlbGVhc2UsIHBhcmFtcyk7XG4gICAgfVxuICAgIGdldCBpbml0aWFsaXplZFRyYW5zcG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXRpYWxpemVkVHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBfY29ubmVjdChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkVHJhbnNwb3J0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFudXBJbml0aWFsaXplZFRyYW5zcG9ydCh0aGlzLl9pbml0aWFsaXplZFRyYW5zcG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWRUcmFuc3BvcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBUZXN0Q29ubmVjdGlvblJlc3VsdDtcbiAgICAgICAgKGZ1bmN0aW9uIChUZXN0Q29ubmVjdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgVGVzdENvbm5lY3Rpb25SZXN1bHRbVGVzdENvbm5lY3Rpb25SZXN1bHRbXCJET05FXCJdID0gMF0gPSBcIkRPTkVcIjtcbiAgICAgICAgICAgIFRlc3RDb25uZWN0aW9uUmVzdWx0W1Rlc3RDb25uZWN0aW9uUmVzdWx0W1wiQ0FOQ0VMTEVEXCJdID0gMV0gPSBcIkNBTkNFTExFRFwiO1xuICAgICAgICB9KShUZXN0Q29ubmVjdGlvblJlc3VsdCB8fCAoVGVzdENvbm5lY3Rpb25SZXN1bHQgPSB7fSkpO1xuICAgICAgICBjb25zdCB0ZXN0VHJhbnNwb3J0ID0gYXN5bmMgKHsgZGF0YTogeyB0cmFuc3BvcnQgfSB9LCBsb2NhbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWxUZXN0VHJhbnNwb3J0ID0gKCkgPT4gcmVzb2x2ZShUZXN0Q29ubmVjdGlvblJlc3VsdC5DQU5DRUxMRUQpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRBY2NvdW50c0J5Q29kZUhhc2goJzRlOTI3MTZkZTYxZDQ1NmU1OGYxNmU0ZTg2N2UzZTkzYTc1NDgzMjFlYWNlODYzMDFiNTFjOGI4MGNhNjIzOWInLCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gcmVzb2x2ZShUZXN0Q29ubmVjdGlvblJlc3VsdC5ET05FKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4gcmVqZWN0KGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBnZXQgYW55IGFjY291bnQgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RnVsbENvbnRyYWN0U3RhdGUoJy0xOjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gcmVzb2x2ZShUZXN0Q29ubmVjdGlvblJlc3VsdC5ET05FKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4gcmVqZWN0KGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKCdDb25uZWN0aW9uIHRpbWVvdXQnKSksIDEwMDAwKTtcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoKCkgPT4gdGhpcy5fY2FuY2VsVGVzdFRyYW5zcG9ydCA9IHVuZGVmaW5lZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGxvY2FsLCB0cmFuc3BvcnREYXRhIH0gPSBhd2FpdCAocGFyYW1zLnR5cGUgPT09ICdncmFwaHFsJ1xuICAgICAgICAgICAgICAgID8gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb2NrZXQgPSBuZXcgZ3FsXzEuR3FsU29ja2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBzb2NrZXQuY29ubmVjdCh0aGlzLl9jbG9jaywgcGFyYW1zLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZWtvdG9uLlRyYW5zcG9ydC5mcm9tR3FsQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cDogcGFyYW1zLmdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2dyYXBocWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbDogcGFyYW1zLmRhdGEubG9jYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnREYXRhLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gbmV3IGpycGNfMS5KcnBjU29ja2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBzb2NrZXQuY29ubmVjdCh0aGlzLl9jbG9jaywgcGFyYW1zLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZWtvdG9uLlRyYW5zcG9ydC5mcm9tSnJwY0Nvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zcG9ydERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcGFyYW1zLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IHBhcmFtcy5ncm91cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdqcnBjJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoYXdhaXQgdGVzdFRyYW5zcG9ydCh0cmFuc3BvcnREYXRhLCBsb2NhbCkgPT0gVGVzdENvbm5lY3Rpb25SZXN1bHQuQ0FOQ0VMTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXBJbml0aWFsaXplZFRyYW5zcG9ydCh0cmFuc3BvcnREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gRnJlZSB0cmFuc3BvcnQgZGF0YSBpbiBjYXNlIG9mIGVycm9yXG4gICAgICAgICAgICAgICAgY2xlYW51cEluaXRpYWxpemVkVHJhbnNwb3J0KHRyYW5zcG9ydERhdGEpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZFRyYW5zcG9ydCA9IHRyYW5zcG9ydERhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBjb25uZWN0aW9uOiAke2UudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfYWNxdWlyZVRyYW5zcG9ydCgpIHtcbiAgICAgICAgZGVidWdMb2coJ19hY3F1aXJlVHJhbnNwb3J0Jyk7XG4gICAgICAgIGlmICh0aGlzLl9hY3F1aXJlZFRyYW5zcG9ydENvdW50ZXIgPiAwKSB7XG4gICAgICAgICAgICBkZWJ1Z0xvZygnX2FjcXVpcmVUcmFuc3BvcnQgLT4gaW5jcmVhc2UnKTtcbiAgICAgICAgICAgIHRoaXMuX2FjcXVpcmVkVHJhbnNwb3J0Q291bnRlciArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWNxdWlyZWRUcmFuc3BvcnRDb3VudGVyID0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWxlYXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ211dGV4IGlzIGFscmVhZHkgYWNxdWlyZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYnVnTG9nKCdfYWNxdWlyZVRyYW5zcG9ydCAtPiBhd2FpdCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbGVhc2UgPSBhd2FpdCB0aGlzLl9uZXR3b3JrTXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgICAgIGRlYnVnTG9nKCdfYWNxdWlyZVRyYW5zcG9ydCAtPiBjcmVhdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVsZWFzZVRyYW5zcG9ydCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBkZWJ1Z0xvZygnX3JlbGVhc2VUcmFuc3BvcnQnKTtcbiAgICAgICAgdGhpcy5fYWNxdWlyZWRUcmFuc3BvcnRDb3VudGVyIC09IDE7XG4gICAgICAgIGlmICh0aGlzLl9hY3F1aXJlZFRyYW5zcG9ydENvdW50ZXIgPD0gMCkge1xuICAgICAgICAgICAgZGVidWdMb2coJ19yZWxlYXNlVHJhbnNwb3J0IC0+IHJlbGVhc2UnKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuX3JlbGVhc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcmVsZWFzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29ubmVjdGlvbkNvbnRyb2xsZXIgPSBDb25uZWN0aW9uQ29udHJvbGxlcjtcbmZ1bmN0aW9uIGNsZWFudXBJbml0aWFsaXplZFRyYW5zcG9ydCh0cmFuc3BvcnQpIHtcbiAgICB0cmFuc3BvcnQuZGF0YS50cmFuc3BvcnQuZnJlZSgpO1xuICAgIHRyYW5zcG9ydC5kYXRhLmNvbm5lY3Rpb24uZnJlZSgpO1xufVxuZnVuY3Rpb24gcmVxdWlyZUluaXRpYWxpemVkVHJhbnNwb3J0KHRyYW5zcG9ydCkge1xuICAgIGlmICh0cmFuc3BvcnQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gaXMgbm90IGluaXRpYWxpemVkJyk7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///863\n")},106:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JrpcSocket = void 0;\nconst core_1 = __importDefault(__webpack_require__(521));\nconst { nekoton, fetch, fetchAgent } = core_1.default;\nclass JrpcSocket {\n    async connect(clock, params) {\n        class JrpcSender {\n            constructor(params) {\n                this.endpoint = params.endpoint;\n                this.endpointAgent = fetchAgent(this.endpoint);\n                this.alternativeEndpoint = params.alternativeEndpoint != null\n                    ? params.alternativeEndpoint\n                    : params.endpoint;\n                this.alternativeEndpointAgent = fetchAgent(this.alternativeEndpoint);\n            }\n            send(data, handler, requiresDb) {\n                ;\n                (async () => {\n                    try {\n                        const url = requiresDb ? this.endpoint : this.alternativeEndpoint;\n                        const agent = requiresDb ? this.endpointAgent : this.alternativeEndpointAgent;\n                        const response = await fetch(url, {\n                            method: 'post',\n                            headers: DEFAULT_HEADERS,\n                            body: data,\n                            agent,\n                        }).then((response) => response.text());\n                        handler.onReceive(response);\n                    }\n                    catch (e) {\n                        handler.onError(e);\n                    }\n                })();\n            }\n        }\n        return new nekoton.JrpcConnection(clock, new JrpcSender(params));\n    }\n}\nexports.JrpcSocket = JrpcSocket;\nconst DEFAULT_HEADERS = {\n    'Content-Type': 'application/json',\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvQ29ubmVjdGlvbkNvbnRyb2xsZXIvanJwYy5qcz9iNDY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5KcnBjU29ja2V0ID0gdm9pZCAwO1xuY29uc3QgY29yZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9jb3JlXCIpKTtcbmNvbnN0IHsgbmVrb3RvbiwgZmV0Y2gsIGZldGNoQWdlbnQgfSA9IGNvcmVfMS5kZWZhdWx0O1xuY2xhc3MgSnJwY1NvY2tldCB7XG4gICAgYXN5bmMgY29ubmVjdChjbG9jaywgcGFyYW1zKSB7XG4gICAgICAgIGNsYXNzIEpycGNTZW5kZXIge1xuICAgICAgICAgICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRwb2ludCA9IHBhcmFtcy5lbmRwb2ludDtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50QWdlbnQgPSBmZXRjaEFnZW50KHRoaXMuZW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRpdmVFbmRwb2ludCA9IHBhcmFtcy5hbHRlcm5hdGl2ZUVuZHBvaW50ICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJhbXMuYWx0ZXJuYXRpdmVFbmRwb2ludFxuICAgICAgICAgICAgICAgICAgICA6IHBhcmFtcy5lbmRwb2ludDtcbiAgICAgICAgICAgICAgICB0aGlzLmFsdGVybmF0aXZlRW5kcG9pbnRBZ2VudCA9IGZldGNoQWdlbnQodGhpcy5hbHRlcm5hdGl2ZUVuZHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbmQoZGF0YSwgaGFuZGxlciwgcmVxdWlyZXNEYikge1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gcmVxdWlyZXNEYiA/IHRoaXMuZW5kcG9pbnQgOiB0aGlzLmFsdGVybmF0aXZlRW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZ2VudCA9IHJlcXVpcmVzRGIgPyB0aGlzLmVuZHBvaW50QWdlbnQgOiB0aGlzLmFsdGVybmF0aXZlRW5kcG9pbnRBZ2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAncG9zdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogREVGQVVMVF9IRUFERVJTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UudGV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIub25SZWNlaXZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5vbkVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IG5la290b24uSnJwY0Nvbm5lY3Rpb24oY2xvY2ssIG5ldyBKcnBjU2VuZGVyKHBhcmFtcykpO1xuICAgIH1cbn1cbmV4cG9ydHMuSnJwY1NvY2tldCA9IEpycGNTb2NrZXQ7XG5jb25zdCBERUZBVUxUX0hFQURFUlMgPSB7XG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///106\n")},536:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SubscriptionController = void 0;\nconst await_semaphore_1 = __webpack_require__(68);\nconst utils_1 = __webpack_require__(344);\nconst subscription_1 = __webpack_require__(334);\nconst DEFAULT_POLLING_INTERVAL = 10000; // 10s\nclass SubscriptionController {\n    constructor(connectionController, notify) {\n        this._subscriptions = new Map();\n        this._subscriptionsMutex = new await_semaphore_1.Mutex();\n        this._sendMessageRequests = new Map();\n        this._subscriptionStates = new Map();\n        this._connectionController = connectionController;\n        this._notify = notify;\n    }\n    async sendMessageLocally(address, signedMessage) {\n        const subscriptionId = (0, utils_1.getUniqueId)();\n        try {\n            await this.subscribeToContract(address, { state: true }, subscriptionId);\n            const subscription = this._subscriptions.get(address);\n            if (subscription == null) {\n                throw new Error('Failed to subscribe to contract');\n            }\n            return await subscription.use((contract) => contract.sendMessageLocally(signedMessage));\n        }\n        finally {\n            this.unsubscribeFromContract(address, subscriptionId).catch(console.error);\n        }\n    }\n    sendMessage(address, signedMessage) {\n        let messageRequests = this._sendMessageRequests.get(address);\n        if (messageRequests == null) {\n            messageRequests = new Map();\n            this._sendMessageRequests.set(address, messageRequests);\n        }\n        const subscriptionId = (0, utils_1.getUniqueId)();\n        return new Promise((resolve, reject) => {\n            const id = signedMessage.hash;\n            messageRequests.set(id, { resolve, reject });\n            this.subscribeToContract(address, { state: true }, subscriptionId)\n                .then(async () => {\n                const subscription = this._subscriptions.get(address);\n                if (subscription == null) {\n                    throw new Error('Failed to subscribe to contract');\n                }\n                await subscription.prepareReliablePolling();\n                await subscription\n                    .use(async (contract) => {\n                    await contract.sendMessage(signedMessage);\n                    subscription.skipRefreshTimer();\n                });\n            })\n                .catch((e) => this._rejectMessageRequest(address, id, e))\n                .finally(() => {\n                this.unsubscribeFromContract(address, subscriptionId).catch(console.error);\n            });\n        });\n    }\n    async subscribeToContract(address, params, internalId) {\n        return this._subscriptionsMutex.use(async () => {\n            let mergeInputParams = (currentParams) => {\n                const newParams = { ...currentParams };\n                Object.keys(newParams).map((param) => {\n                    if (param !== 'state' && param !== 'transactions') {\n                        throw new Error(`Unknown subscription topic: ${param}`);\n                    }\n                    const value = params[param];\n                    if (typeof value === 'boolean') {\n                        newParams[param] = value;\n                    }\n                    else if (value == null) {\n                        return;\n                    }\n                    else {\n                        throw new Error(`Unknown subscription topic value ${param}: ${value}`);\n                    }\n                });\n                return newParams;\n            };\n            const subscriptionState = this._subscriptionStates.get(address) || makeDefaultSubscriptionState();\n            let changedParams;\n            if (internalId == null) {\n                // Client subscription without id\n                // Changed params are `SubscriptionState.client`\n                changedParams = mergeInputParams(subscriptionState.client);\n            }\n            else {\n                // Internal subscription with id\n                // Changed params are `SubscriptionState.internal[internalId]`\n                let exisingParams = subscriptionState.internal.get(internalId);\n                if (exisingParams != null) {\n                    // Updating existing internal params\n                    changedParams = mergeInputParams(exisingParams);\n                    // Remove entry if it is empty\n                    if (isEmptySubscription(changedParams)) {\n                        subscriptionState.internal.delete(internalId);\n                    }\n                }\n                else {\n                    // Merge input params with empty struct\n                    changedParams = mergeInputParams({ state: false, transactions: false });\n                }\n            }\n            // Merge changed params with the rest of internal params\n            let computedParams = { ...changedParams };\n            for (const params of subscriptionState.internal.values()) {\n                computedParams.state || (computedParams.state = params.state);\n                computedParams.transactions || (computedParams.transactions = params.transactions);\n            }\n            // Remove subscription if all params are empty\n            if (isEmptySubscription(computedParams)) {\n                this._subscriptionStates.delete(address);\n                await this._tryUnsubscribe(address);\n                return { ...computedParams };\n            }\n            // Create subscription if it doesn't exist\n            let existingSubscription = this._subscriptions.get(address);\n            const isNewSubscription = existingSubscription == null;\n            if (existingSubscription == null) {\n                existingSubscription = await this._createSubscription(address);\n            }\n            // Update subscription state\n            if (internalId == null) {\n                // Update client params\n                subscriptionState.client = changedParams;\n            }\n            else {\n                // Set new internal params\n                subscriptionState.internal.set(internalId, changedParams);\n            }\n            this._subscriptionStates.set(address, subscriptionState);\n            // Start subscription\n            if (isNewSubscription) {\n                await existingSubscription.start();\n            }\n            // Returns only changed params\n            return { ...changedParams };\n        });\n    }\n    async unsubscribeFromContract(address, internalId) {\n        await this.subscribeToContract(address, {\n            state: false,\n            transactions: false,\n        }, internalId);\n    }\n    async unsubscribeFromAllContracts(internalId) {\n        for (const address of this._subscriptions.keys()) {\n            await this.unsubscribeFromContract(address, internalId);\n        }\n    }\n    get subscriptionStates() {\n        const result = {};\n        for (const [key, value] of this._subscriptionStates.entries()) {\n            result[key] = { ...value.client };\n        }\n        return result;\n    }\n    async _createSubscription(address) {\n        class ContractHandler {\n            constructor(address, controller) {\n                this._enabled = false;\n                this._address = address;\n                this._controller = controller;\n            }\n            enabledNotifications() {\n                this._enabled = true;\n            }\n            onMessageExpired(pendingTransaction) {\n                if (this._enabled) {\n                    this._controller\n                        ._resolveMessageRequest(this._address, pendingTransaction.messageHash, undefined)\n                        .catch(console.error);\n                }\n            }\n            onMessageSent(pendingTransaction, transaction) {\n                if (this._enabled) {\n                    this._controller\n                        ._resolveMessageRequest(this._address, pendingTransaction.messageHash, transaction)\n                        .catch(console.error);\n                }\n            }\n            onStateChanged(newState) {\n                if (this._enabled) {\n                    this._controller._notifyStateChanged(this._address, newState);\n                }\n            }\n            onTransactionsFound(transactions, info) {\n                if (this._enabled) {\n                    this._controller._notifyTransactionsFound(this._address, transactions, info);\n                }\n            }\n        }\n        const handler = new ContractHandler(address, this);\n        const subscription = await subscription_1.ContractSubscription.subscribe(this._connectionController, address, handler);\n        subscription.setPollingInterval(DEFAULT_POLLING_INTERVAL);\n        handler.enabledNotifications();\n        this._subscriptions.set(address, subscription);\n        return subscription;\n    }\n    async _tryUnsubscribe(address) {\n        const subscriptionState = this._subscriptionStates.get(address);\n        const sendMessageRequests = this._sendMessageRequests.get(address);\n        if (subscriptionState == null && ((sendMessageRequests === null || sendMessageRequests === void 0 ? void 0 : sendMessageRequests.size) || 0) == 0) {\n            const subscription = this._subscriptions.get(address);\n            this._subscriptions.delete(address);\n            await (subscription === null || subscription === void 0 ? void 0 : subscription.stop());\n        }\n    }\n    async _rejectMessageRequest(address, id, error) {\n        this._deleteMessageRequestAndGetCallback(address, id).reject(error);\n        await this._subscriptionsMutex.use(async () => this._tryUnsubscribe(address));\n    }\n    async _resolveMessageRequest(address, id, transaction) {\n        this._deleteMessageRequestAndGetCallback(address, id).resolve(transaction);\n        await this._subscriptionsMutex.use(async () => this._tryUnsubscribe(address));\n    }\n    _notifyStateChanged(address, state) {\n        const subscriptionState = this._subscriptionStates.get(address);\n        if (subscriptionState === null || subscriptionState === void 0 ? void 0 : subscriptionState.client.state) {\n            this._notify('contractStateChanged', {\n                address,\n                state,\n            });\n        }\n    }\n    _notifyTransactionsFound(address, transactions, info) {\n        const subscriptionState = this._subscriptionStates.get(address);\n        if (subscriptionState === null || subscriptionState === void 0 ? void 0 : subscriptionState.client.transactions) {\n            this._notify('transactionsFound', {\n                address,\n                transactions,\n                info,\n            });\n        }\n    }\n    _deleteMessageRequestAndGetCallback(address, id) {\n        var _a;\n        const callbacks = (_a = this._sendMessageRequests.get(address)) === null || _a === void 0 ? void 0 : _a.get(id);\n        if (!callbacks) {\n            throw new Error(`SendMessage request with id '${id}' not found`);\n        }\n        this._deleteMessageRequest(address, id);\n        return callbacks;\n    }\n    _deleteMessageRequest(address, id) {\n        const accountMessageRequests = this._sendMessageRequests.get(address);\n        if (!accountMessageRequests) {\n            return;\n        }\n        accountMessageRequests.delete(id);\n        if (accountMessageRequests.size == 0) {\n            this._sendMessageRequests.delete(address);\n        }\n    }\n}\nexports.SubscriptionController = SubscriptionController;\nconst makeDefaultSubscriptionState = () => ({\n    internal: new Map(),\n    client: {\n        state: false,\n        transactions: false,\n    },\n});\nconst isEmptySubscription = (params) => !params.state && !params.transactions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvU3Vic2NyaXB0aW9uQ29udHJvbGxlci9pbmRleC5qcz8zMjU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdWJzY3JpcHRpb25Db250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgYXdhaXRfc2VtYXBob3JlXzEgPSByZXF1aXJlKFwiQGJyb3h1cy9hd2FpdC1zZW1hcGhvcmVcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3Qgc3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKFwiLi9zdWJzY3JpcHRpb25cIik7XG5jb25zdCBERUZBVUxUX1BPTExJTkdfSU5URVJWQUwgPSAxMDAwMDsgLy8gMTBzXG5jbGFzcyBTdWJzY3JpcHRpb25Db250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uQ29udHJvbGxlciwgbm90aWZ5KSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNNdXRleCA9IG5ldyBhd2FpdF9zZW1hcGhvcmVfMS5NdXRleCgpO1xuICAgICAgICB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Db250cm9sbGVyID0gY29ubmVjdGlvbkNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuX25vdGlmeSA9IG5vdGlmeTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZE1lc3NhZ2VMb2NhbGx5KGFkZHJlc3MsIHNpZ25lZE1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uSWQgPSAoMCwgdXRpbHNfMS5nZXRVbmlxdWVJZCkoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3Vic2NyaWJlVG9Db250cmFjdChhZGRyZXNzLCB7IHN0YXRlOiB0cnVlIH0sIHN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnMuZ2V0KGFkZHJlc3MpO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc3Vic2NyaWJlIHRvIGNvbnRyYWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgc3Vic2NyaXB0aW9uLnVzZSgoY29udHJhY3QpID0+IGNvbnRyYWN0LnNlbmRNZXNzYWdlTG9jYWxseShzaWduZWRNZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbUNvbnRyYWN0KGFkZHJlc3MsIHN1YnNjcmlwdGlvbklkKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kTWVzc2FnZShhZGRyZXNzLCBzaWduZWRNZXNzYWdlKSB7XG4gICAgICAgIGxldCBtZXNzYWdlUmVxdWVzdHMgPSB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzLmdldChhZGRyZXNzKTtcbiAgICAgICAgaWYgKG1lc3NhZ2VSZXF1ZXN0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlUmVxdWVzdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzLnNldChhZGRyZXNzLCBtZXNzYWdlUmVxdWVzdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbklkID0gKDAsIHV0aWxzXzEuZ2V0VW5pcXVlSWQpKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHNpZ25lZE1lc3NhZ2UuaGFzaDtcbiAgICAgICAgICAgIG1lc3NhZ2VSZXF1ZXN0cy5zZXQoaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NvbnRyYWN0KGFkZHJlc3MsIHsgc3RhdGU6IHRydWUgfSwgc3Vic2NyaXB0aW9uSWQpXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnMuZ2V0KGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzdWJzY3JpYmUgdG8gY29udHJhY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgc3Vic2NyaXB0aW9uLnByZXBhcmVSZWxpYWJsZVBvbGxpbmcoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgLnVzZShhc3luYyAoY29udHJhY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY29udHJhY3Quc2VuZE1lc3NhZ2Uoc2lnbmVkTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5za2lwUmVmcmVzaFRpbWVyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4gdGhpcy5fcmVqZWN0TWVzc2FnZVJlcXVlc3QoYWRkcmVzcywgaWQsIGUpKVxuICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbUNvbnRyYWN0KGFkZHJlc3MsIHN1YnNjcmlwdGlvbklkKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc3Vic2NyaWJlVG9Db250cmFjdChhZGRyZXNzLCBwYXJhbXMsIGludGVybmFsSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbnNNdXRleC51c2UoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IG1lcmdlSW5wdXRQYXJhbXMgPSAoY3VycmVudFBhcmFtcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHsgLi4uY3VycmVudFBhcmFtcyB9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG5ld1BhcmFtcykubWFwKChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0gIT09ICdzdGF0ZScgJiYgcGFyYW0gIT09ICd0cmFuc2FjdGlvbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3Vic2NyaXB0aW9uIHRvcGljOiAke3BhcmFtfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zW3BhcmFtXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJhbXNbcGFyYW1dID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN1YnNjcmlwdGlvbiB0b3BpYyB2YWx1ZSAke3BhcmFtfTogJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdQYXJhbXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU3RhdGUgPSB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZXMuZ2V0KGFkZHJlc3MpIHx8IG1ha2VEZWZhdWx0U3Vic2NyaXB0aW9uU3RhdGUoKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkUGFyYW1zO1xuICAgICAgICAgICAgaWYgKGludGVybmFsSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIENsaWVudCBzdWJzY3JpcHRpb24gd2l0aG91dCBpZFxuICAgICAgICAgICAgICAgIC8vIENoYW5nZWQgcGFyYW1zIGFyZSBgU3Vic2NyaXB0aW9uU3RhdGUuY2xpZW50YFxuICAgICAgICAgICAgICAgIGNoYW5nZWRQYXJhbXMgPSBtZXJnZUlucHV0UGFyYW1zKHN1YnNjcmlwdGlvblN0YXRlLmNsaWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbnRlcm5hbCBzdWJzY3JpcHRpb24gd2l0aCBpZFxuICAgICAgICAgICAgICAgIC8vIENoYW5nZWQgcGFyYW1zIGFyZSBgU3Vic2NyaXB0aW9uU3RhdGUuaW50ZXJuYWxbaW50ZXJuYWxJZF1gXG4gICAgICAgICAgICAgICAgbGV0IGV4aXNpbmdQYXJhbXMgPSBzdWJzY3JpcHRpb25TdGF0ZS5pbnRlcm5hbC5nZXQoaW50ZXJuYWxJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXNpbmdQYXJhbXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGluZyBleGlzdGluZyBpbnRlcm5hbCBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZFBhcmFtcyA9IG1lcmdlSW5wdXRQYXJhbXMoZXhpc2luZ1BhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBlbnRyeSBpZiBpdCBpcyBlbXB0eVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eVN1YnNjcmlwdGlvbihjaGFuZ2VkUGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uU3RhdGUuaW50ZXJuYWwuZGVsZXRlKGludGVybmFsSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBNZXJnZSBpbnB1dCBwYXJhbXMgd2l0aCBlbXB0eSBzdHJ1Y3RcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZFBhcmFtcyA9IG1lcmdlSW5wdXRQYXJhbXMoeyBzdGF0ZTogZmFsc2UsIHRyYW5zYWN0aW9uczogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWVyZ2UgY2hhbmdlZCBwYXJhbXMgd2l0aCB0aGUgcmVzdCBvZiBpbnRlcm5hbCBwYXJhbXNcbiAgICAgICAgICAgIGxldCBjb21wdXRlZFBhcmFtcyA9IHsgLi4uY2hhbmdlZFBhcmFtcyB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJhbXMgb2Ygc3Vic2NyaXB0aW9uU3RhdGUuaW50ZXJuYWwudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlZFBhcmFtcy5zdGF0ZSB8fCAoY29tcHV0ZWRQYXJhbXMuc3RhdGUgPSBwYXJhbXMuc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkUGFyYW1zLnRyYW5zYWN0aW9ucyB8fCAoY29tcHV0ZWRQYXJhbXMudHJhbnNhY3Rpb25zID0gcGFyYW1zLnRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaXB0aW9uIGlmIGFsbCBwYXJhbXMgYXJlIGVtcHR5XG4gICAgICAgICAgICBpZiAoaXNFbXB0eVN1YnNjcmlwdGlvbihjb21wdXRlZFBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZXMuZGVsZXRlKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3RyeVVuc3Vic2NyaWJlKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLmNvbXB1dGVkUGFyYW1zIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgc3Vic2NyaXB0aW9uIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgIGxldCBleGlzdGluZ1N1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnMuZ2V0KGFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgaXNOZXdTdWJzY3JpcHRpb24gPSBleGlzdGluZ1N1YnNjcmlwdGlvbiA9PSBudWxsO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nU3Vic2NyaXB0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1N1YnNjcmlwdGlvbiA9IGF3YWl0IHRoaXMuX2NyZWF0ZVN1YnNjcmlwdGlvbihhZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzdWJzY3JpcHRpb24gc3RhdGVcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbElkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY2xpZW50IHBhcmFtc1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvblN0YXRlLmNsaWVudCA9IGNoYW5nZWRQYXJhbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgbmV3IGludGVybmFsIHBhcmFtc1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvblN0YXRlLmludGVybmFsLnNldChpbnRlcm5hbElkLCBjaGFuZ2VkUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlcy5zZXQoYWRkcmVzcywgc3Vic2NyaXB0aW9uU3RhdGUpO1xuICAgICAgICAgICAgLy8gU3RhcnQgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICBpZiAoaXNOZXdTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBleGlzdGluZ1N1YnNjcmlwdGlvbi5zdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0dXJucyBvbmx5IGNoYW5nZWQgcGFyYW1zXG4gICAgICAgICAgICByZXR1cm4geyAuLi5jaGFuZ2VkUGFyYW1zIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB1bnN1YnNjcmliZUZyb21Db250cmFjdChhZGRyZXNzLCBpbnRlcm5hbElkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3Vic2NyaWJlVG9Db250cmFjdChhZGRyZXNzLCB7XG4gICAgICAgICAgICBzdGF0ZTogZmFsc2UsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbnM6IGZhbHNlLFxuICAgICAgICB9LCBpbnRlcm5hbElkKTtcbiAgICB9XG4gICAgYXN5bmMgdW5zdWJzY3JpYmVGcm9tQWxsQ29udHJhY3RzKGludGVybmFsSWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIHRoaXMuX3N1YnNjcmlwdGlvbnMua2V5cygpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnVuc3Vic2NyaWJlRnJvbUNvbnRyYWN0KGFkZHJlc3MsIGludGVybmFsSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzdWJzY3JpcHRpb25TdGF0ZXMoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHsgLi4udmFsdWUuY2xpZW50IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgX2NyZWF0ZVN1YnNjcmlwdGlvbihhZGRyZXNzKSB7XG4gICAgICAgIGNsYXNzIENvbnRyYWN0SGFuZGxlciB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5hYmxlZE5vdGlmaWNhdGlvbnMoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbk1lc3NhZ2VFeHBpcmVkKHBlbmRpbmdUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5fcmVzb2x2ZU1lc3NhZ2VSZXF1ZXN0KHRoaXMuX2FkZHJlc3MsIHBlbmRpbmdUcmFuc2FjdGlvbi5tZXNzYWdlSGFzaCwgdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uTWVzc2FnZVNlbnQocGVuZGluZ1RyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5fcmVzb2x2ZU1lc3NhZ2VSZXF1ZXN0KHRoaXMuX2FkZHJlc3MsIHBlbmRpbmdUcmFuc2FjdGlvbi5tZXNzYWdlSGFzaCwgdHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25TdGF0ZUNoYW5nZWQobmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250cm9sbGVyLl9ub3RpZnlTdGF0ZUNoYW5nZWQodGhpcy5fYWRkcmVzcywgbmV3U3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uVHJhbnNhY3Rpb25zRm91bmQodHJhbnNhY3Rpb25zLCBpbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udHJvbGxlci5fbm90aWZ5VHJhbnNhY3Rpb25zRm91bmQodGhpcy5fYWRkcmVzcywgdHJhbnNhY3Rpb25zLCBpbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlciA9IG5ldyBDb250cmFjdEhhbmRsZXIoYWRkcmVzcywgdGhpcyk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IHN1YnNjcmlwdGlvbl8xLkNvbnRyYWN0U3Vic2NyaXB0aW9uLnN1YnNjcmliZSh0aGlzLl9jb25uZWN0aW9uQ29udHJvbGxlciwgYWRkcmVzcywgaGFuZGxlcik7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5zZXRQb2xsaW5nSW50ZXJ2YWwoREVGQVVMVF9QT0xMSU5HX0lOVEVSVkFMKTtcbiAgICAgICAgaGFuZGxlci5lbmFibGVkTm90aWZpY2F0aW9ucygpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnNldChhZGRyZXNzLCBzdWJzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH1cbiAgICBhc3luYyBfdHJ5VW5zdWJzY3JpYmUoYWRkcmVzcykge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25TdGF0ZSA9IHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlcy5nZXQoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IHNlbmRNZXNzYWdlUmVxdWVzdHMgPSB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzLmdldChhZGRyZXNzKTtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvblN0YXRlID09IG51bGwgJiYgKChzZW5kTWVzc2FnZVJlcXVlc3RzID09PSBudWxsIHx8IHNlbmRNZXNzYWdlUmVxdWVzdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbmRNZXNzYWdlUmVxdWVzdHMuc2l6ZSkgfHwgMCkgPT0gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5fc3Vic2NyaXB0aW9ucy5nZXQoYWRkcmVzcyk7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmRlbGV0ZShhZGRyZXNzKTtcbiAgICAgICAgICAgIGF3YWl0IChzdWJzY3JpcHRpb24gPT09IG51bGwgfHwgc3Vic2NyaXB0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdWJzY3JpcHRpb24uc3RvcCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfcmVqZWN0TWVzc2FnZVJlcXVlc3QoYWRkcmVzcywgaWQsIGVycm9yKSB7XG4gICAgICAgIHRoaXMuX2RlbGV0ZU1lc3NhZ2VSZXF1ZXN0QW5kR2V0Q2FsbGJhY2soYWRkcmVzcywgaWQpLnJlamVjdChlcnJvcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3N1YnNjcmlwdGlvbnNNdXRleC51c2UoYXN5bmMgKCkgPT4gdGhpcy5fdHJ5VW5zdWJzY3JpYmUoYWRkcmVzcykpO1xuICAgIH1cbiAgICBhc3luYyBfcmVzb2x2ZU1lc3NhZ2VSZXF1ZXN0KGFkZHJlc3MsIGlkLCB0cmFuc2FjdGlvbikge1xuICAgICAgICB0aGlzLl9kZWxldGVNZXNzYWdlUmVxdWVzdEFuZEdldENhbGxiYWNrKGFkZHJlc3MsIGlkKS5yZXNvbHZlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3Vic2NyaXB0aW9uc011dGV4LnVzZShhc3luYyAoKSA9PiB0aGlzLl90cnlVbnN1YnNjcmliZShhZGRyZXNzKSk7XG4gICAgfVxuICAgIF9ub3RpZnlTdGF0ZUNoYW5nZWQoYWRkcmVzcywgc3RhdGUpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU3RhdGUgPSB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZXMuZ2V0KGFkZHJlc3MpO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uU3RhdGUgPT09IG51bGwgfHwgc3Vic2NyaXB0aW9uU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1YnNjcmlwdGlvblN0YXRlLmNsaWVudC5zdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fbm90aWZ5KCdjb250cmFjdFN0YXRlQ2hhbmdlZCcsIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX25vdGlmeVRyYW5zYWN0aW9uc0ZvdW5kKGFkZHJlc3MsIHRyYW5zYWN0aW9ucywgaW5mbykge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25TdGF0ZSA9IHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlcy5nZXQoYWRkcmVzcyk7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25TdGF0ZSA9PT0gbnVsbCB8fCBzdWJzY3JpcHRpb25TdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Vic2NyaXB0aW9uU3RhdGUuY2xpZW50LnRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fbm90aWZ5KCd0cmFuc2FjdGlvbnNGb3VuZCcsIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgICAgICAgICAgICBpbmZvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2RlbGV0ZU1lc3NhZ2VSZXF1ZXN0QW5kR2V0Q2FsbGJhY2soYWRkcmVzcywgaWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAoX2EgPSB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzLmdldChhZGRyZXNzKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChpZCk7XG4gICAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlbmRNZXNzYWdlIHJlcXVlc3Qgd2l0aCBpZCAnJHtpZH0nIG5vdCBmb3VuZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlbGV0ZU1lc3NhZ2VSZXF1ZXN0KGFkZHJlc3MsIGlkKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrcztcbiAgICB9XG4gICAgX2RlbGV0ZU1lc3NhZ2VSZXF1ZXN0KGFkZHJlc3MsIGlkKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnRNZXNzYWdlUmVxdWVzdHMgPSB0aGlzLl9zZW5kTWVzc2FnZVJlcXVlc3RzLmdldChhZGRyZXNzKTtcbiAgICAgICAgaWYgKCFhY2NvdW50TWVzc2FnZVJlcXVlc3RzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWNjb3VudE1lc3NhZ2VSZXF1ZXN0cy5kZWxldGUoaWQpO1xuICAgICAgICBpZiAoYWNjb3VudE1lc3NhZ2VSZXF1ZXN0cy5zaXplID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRNZXNzYWdlUmVxdWVzdHMuZGVsZXRlKGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TdWJzY3JpcHRpb25Db250cm9sbGVyID0gU3Vic2NyaXB0aW9uQ29udHJvbGxlcjtcbmNvbnN0IG1ha2VEZWZhdWx0U3Vic2NyaXB0aW9uU3RhdGUgPSAoKSA9PiAoe1xuICAgIGludGVybmFsOiBuZXcgTWFwKCksXG4gICAgY2xpZW50OiB7XG4gICAgICAgIHN0YXRlOiBmYWxzZSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBmYWxzZSxcbiAgICB9LFxufSk7XG5jb25zdCBpc0VtcHR5U3Vic2NyaXB0aW9uID0gKHBhcmFtcykgPT4gIXBhcmFtcy5zdGF0ZSAmJiAhcGFyYW1zLnRyYW5zYWN0aW9ucztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///536\n")},334:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContractSubscription = void 0;\nconst await_semaphore_1 = __webpack_require__(68);\nconst core_1 = __importDefault(__webpack_require__(521));\nconst { nekoton, debugLog } = core_1.default;\nclass ContractSubscription {\n    constructor(connection, release, address, contract) {\n        this._contractMutex = new await_semaphore_1.Mutex();\n        this._pollingInterval = BACKGROUND_POLLING_INTERVAL;\n        this._isRunning = false;\n        this._connection = connection;\n        this._address = address;\n        this._contract = contract;\n        this._releaseTransport = release;\n        this._currentPollingMethod = contract.pollingMethod;\n    }\n    static async subscribe(connectionController, address, handler) {\n        const { transport: { data: { connection, transport } }, release, } = await connectionController.acquire();\n        try {\n            const contract = await transport.subscribeToGenericContract(address, handler);\n            if (contract == null) {\n                throw new Error(`Failed to subscribe to contract: ${address}`);\n            }\n            return new ContractSubscription(connection, release, address, contract);\n        }\n        catch (e) {\n            release();\n            throw e;\n        }\n    }\n    setPollingInterval(interval) {\n        this._pollingInterval = interval;\n    }\n    async start() {\n        if (this._releaseTransport == null) {\n            throw new Error('Contract subscription must not be started after being closed');\n        }\n        if (this._loopPromise) {\n            debugLog('ContractSubscription -> awaiting loop promise');\n            await this._loopPromise;\n        }\n        debugLog('ContractSubscription -> loop started');\n        this._loopPromise = (async () => {\n            const isSimple = !(this._connection instanceof nekoton.GqlConnection);\n            this._isRunning = true;\n            let previousPollingMethod = this._currentPollingMethod;\n            while (this._isRunning) {\n                const pollingMethodChanged = previousPollingMethod != this._currentPollingMethod;\n                previousPollingMethod = this._currentPollingMethod;\n                if (isSimple || this._currentPollingMethod == 'manual') {\n                    this._currentBlockId = undefined;\n                    debugLog('ContractSubscription -> manual -> waiting begins');\n                    const pollingInterval = this._currentPollingMethod == 'manual'\n                        ? this._pollingInterval\n                        : INTENSIVE_POLLING_INTERVAL;\n                    await new Promise((resolve) => {\n                        const timerHandle = setTimeout(() => {\n                            this._refreshTimer = undefined;\n                            resolve();\n                        }, pollingInterval);\n                        this._refreshTimer = [timerHandle, resolve];\n                    });\n                    debugLog('ContractSubscription -> manual -> waiting ends');\n                    if (!this._isRunning) {\n                        break;\n                    }\n                    debugLog('ContractSubscription -> manual -> refreshing begins');\n                    try {\n                        this._currentPollingMethod = await this._contractMutex.use(async () => {\n                            await this._contract.refresh();\n                            return this._contract.pollingMethod;\n                        });\n                    }\n                    catch (e) {\n                        console.error(`Error during account refresh (${this._address})`, e);\n                    }\n                    debugLog('ContractSubscription -> manual -> refreshing ends');\n                }\n                else {\n                    // SAFETY: connection is always GqlConnection here due to `isSimple`\n                    const connection = this._connection;\n                    debugLog('ContractSubscription -> reliable start');\n                    if (pollingMethodChanged && this._suggestedBlockId != null) {\n                        this._currentBlockId = this._suggestedBlockId;\n                    }\n                    this._suggestedBlockId = undefined;\n                    let nextBlockId;\n                    if (this._currentBlockId == null) {\n                        console.warn('Starting reliable connection with unknown block');\n                        try {\n                            const latestBlock = await connection.getLatestBlock(this._address);\n                            this._currentBlockId = latestBlock.id;\n                            nextBlockId = this._currentBlockId;\n                        }\n                        catch (e) {\n                            console.error(`Failed to get latest block for ${this._address}`, e);\n                            continue;\n                        }\n                    }\n                    else {\n                        try {\n                            nextBlockId = await connection.waitForNextBlock(this._currentBlockId, this._address, NEXT_BLOCK_TIMEOUT);\n                        }\n                        catch (e) {\n                            console.error(`Failed to wait for next block for ${this._address}`);\n                            continue; // retry\n                        }\n                    }\n                    try {\n                        this._currentPollingMethod = await this._contractMutex.use(async () => {\n                            await this._contract.handleBlock(nextBlockId);\n                            return this._contract.pollingMethod;\n                        });\n                        this._currentBlockId = nextBlockId;\n                    }\n                    catch (e) {\n                        console.error(`Failed to handle block for ${this._address}`, e);\n                    }\n                }\n            }\n            debugLog('ContractSubscription -> loop finished');\n        })();\n    }\n    skipRefreshTimer() {\n        var _a, _b;\n        clearTimeout((_a = this._refreshTimer) === null || _a === void 0 ? void 0 : _a[0]);\n        (_b = this._refreshTimer) === null || _b === void 0 ? void 0 : _b[1]();\n        this._refreshTimer = undefined;\n    }\n    async pause() {\n        if (!this._isRunning) {\n            return;\n        }\n        this._isRunning = false;\n        this.skipRefreshTimer();\n        await this._loopPromise;\n        this._loopPromise = undefined;\n        this._currentPollingMethod = await this._contractMutex.use(async () => {\n            return this._contract.pollingMethod;\n        });\n        this._currentBlockId = undefined;\n        this._suggestedBlockId = undefined;\n    }\n    async stop() {\n        var _a;\n        await this.pause();\n        this._contract.free();\n        (_a = this._releaseTransport) === null || _a === void 0 ? void 0 : _a.call(this);\n        this._releaseTransport = undefined;\n    }\n    async prepareReliablePolling() {\n        try {\n            if (this._connection instanceof nekoton.GqlConnection) {\n                this._suggestedBlockId = (await this._connection.getLatestBlock(this._address)).id;\n            }\n        }\n        catch (e) {\n            throw new Error(`Failed to prepare reliable polling: ${e.toString()}`);\n        }\n    }\n    async use(f) {\n        const release = await this._contractMutex.acquire();\n        return f(this._contract)\n            .then((res) => {\n            release();\n            return res;\n        })\n            .catch((err) => {\n            release();\n            throw err;\n        });\n    }\n}\nexports.ContractSubscription = ContractSubscription;\nconst NEXT_BLOCK_TIMEOUT = 60; // 60s\nconst INTENSIVE_POLLING_INTERVAL = 2000; // 2s\nconst BACKGROUND_POLLING_INTERVAL = 60000;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvU3Vic2NyaXB0aW9uQ29udHJvbGxlci9zdWJzY3JpcHRpb24uanM/ZDc5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udHJhY3RTdWJzY3JpcHRpb24gPSB2b2lkIDA7XG5jb25zdCBhd2FpdF9zZW1hcGhvcmVfMSA9IHJlcXVpcmUoXCJAYnJveHVzL2F3YWl0LXNlbWFwaG9yZVwiKTtcbmNvbnN0IGNvcmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vY29yZVwiKSk7XG5jb25zdCB7IG5la290b24sIGRlYnVnTG9nIH0gPSBjb3JlXzEuZGVmYXVsdDtcbmNsYXNzIENvbnRyYWN0U3Vic2NyaXB0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCByZWxlYXNlLCBhZGRyZXNzLCBjb250cmFjdCkge1xuICAgICAgICB0aGlzLl9jb250cmFjdE11dGV4ID0gbmV3IGF3YWl0X3NlbWFwaG9yZV8xLk11dGV4KCk7XG4gICAgICAgIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCA9IEJBQ0tHUk9VTkRfUE9MTElOR19JTlRFUlZBTDtcbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICB0aGlzLl9hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5fY29udHJhY3QgPSBjb250cmFjdDtcbiAgICAgICAgdGhpcy5fcmVsZWFzZVRyYW5zcG9ydCA9IHJlbGVhc2U7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRQb2xsaW5nTWV0aG9kID0gY29udHJhY3QucG9sbGluZ01ldGhvZDtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIHN1YnNjcmliZShjb25uZWN0aW9uQ29udHJvbGxlciwgYWRkcmVzcywgaGFuZGxlcikge1xuICAgICAgICBjb25zdCB7IHRyYW5zcG9ydDogeyBkYXRhOiB7IGNvbm5lY3Rpb24sIHRyYW5zcG9ydCB9IH0sIHJlbGVhc2UsIH0gPSBhd2FpdCBjb25uZWN0aW9uQ29udHJvbGxlci5hY3F1aXJlKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IHRyYW5zcG9ydC5zdWJzY3JpYmVUb0dlbmVyaWNDb250cmFjdChhZGRyZXNzLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIGlmIChjb250cmFjdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3Vic2NyaWJlIHRvIGNvbnRyYWN0OiAke2FkZHJlc3N9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0U3Vic2NyaXB0aW9uKGNvbm5lY3Rpb24sIHJlbGVhc2UsIGFkZHJlc3MsIGNvbnRyYWN0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQb2xsaW5nSW50ZXJ2YWwoaW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5fcG9sbGluZ0ludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5fcmVsZWFzZVRyYW5zcG9ydCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyYWN0IHN1YnNjcmlwdGlvbiBtdXN0IG5vdCBiZSBzdGFydGVkIGFmdGVyIGJlaW5nIGNsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9sb29wUHJvbWlzZSkge1xuICAgICAgICAgICAgZGVidWdMb2coJ0NvbnRyYWN0U3Vic2NyaXB0aW9uIC0+IGF3YWl0aW5nIGxvb3AgcHJvbWlzZScpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbG9vcFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWdMb2coJ0NvbnRyYWN0U3Vic2NyaXB0aW9uIC0+IGxvb3Agc3RhcnRlZCcpO1xuICAgICAgICB0aGlzLl9sb29wUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1NpbXBsZSA9ICEodGhpcy5fY29ubmVjdGlvbiBpbnN0YW5jZW9mIG5la290b24uR3FsQ29ubmVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzUG9sbGluZ01ldGhvZCA9IHRoaXMuX2N1cnJlbnRQb2xsaW5nTWV0aG9kO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvbGxpbmdNZXRob2RDaGFuZ2VkID0gcHJldmlvdXNQb2xsaW5nTWV0aG9kICE9IHRoaXMuX2N1cnJlbnRQb2xsaW5nTWV0aG9kO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9sbGluZ01ldGhvZCA9IHRoaXMuX2N1cnJlbnRQb2xsaW5nTWV0aG9kO1xuICAgICAgICAgICAgICAgIGlmIChpc1NpbXBsZSB8fCB0aGlzLl9jdXJyZW50UG9sbGluZ01ldGhvZCA9PSAnbWFudWFsJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50QmxvY2tJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdMb2coJ0NvbnRyYWN0U3Vic2NyaXB0aW9uIC0+IG1hbnVhbCAtPiB3YWl0aW5nIGJlZ2lucycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2xsaW5nSW50ZXJ2YWwgPSB0aGlzLl9jdXJyZW50UG9sbGluZ01ldGhvZCA9PSAnbWFudWFsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9wb2xsaW5nSW50ZXJ2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogSU5URU5TSVZFX1BPTExJTkdfSU5URVJWQUw7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lckhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBwb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVmcmVzaFRpbWVyID0gW3RpbWVySGFuZGxlLCByZXNvbHZlXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nKCdDb250cmFjdFN1YnNjcmlwdGlvbiAtPiBtYW51YWwgLT4gd2FpdGluZyBlbmRzJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZygnQ29udHJhY3RTdWJzY3JpcHRpb24gLT4gbWFudWFsIC0+IHJlZnJlc2hpbmcgYmVnaW5zJyk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50UG9sbGluZ01ldGhvZCA9IGF3YWl0IHRoaXMuX2NvbnRyYWN0TXV0ZXgudXNlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9jb250cmFjdC5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyYWN0LnBvbGxpbmdNZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZHVyaW5nIGFjY291bnQgcmVmcmVzaCAoJHt0aGlzLl9hZGRyZXNzfSlgLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZygnQ29udHJhY3RTdWJzY3JpcHRpb24gLT4gbWFudWFsIC0+IHJlZnJlc2hpbmcgZW5kcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBjb25uZWN0aW9uIGlzIGFsd2F5cyBHcWxDb25uZWN0aW9uIGhlcmUgZHVlIHRvIGBpc1NpbXBsZWBcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nKCdDb250cmFjdFN1YnNjcmlwdGlvbiAtPiByZWxpYWJsZSBzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9sbGluZ01ldGhvZENoYW5nZWQgJiYgdGhpcy5fc3VnZ2VzdGVkQmxvY2tJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50QmxvY2tJZCA9IHRoaXMuX3N1Z2dlc3RlZEJsb2NrSWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3VnZ2VzdGVkQmxvY2tJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRCbG9ja0lkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEJsb2NrSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdTdGFydGluZyByZWxpYWJsZSBjb25uZWN0aW9uIHdpdGggdW5rbm93biBibG9jaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXRlc3RCbG9jayA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2sodGhpcy5fYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEJsb2NrSWQgPSBsYXRlc3RCbG9jay5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0QmxvY2tJZCA9IHRoaXMuX2N1cnJlbnRCbG9ja0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZ2V0IGxhdGVzdCBibG9jayBmb3IgJHt0aGlzLl9hZGRyZXNzfWAsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0QmxvY2tJZCA9IGF3YWl0IGNvbm5lY3Rpb24ud2FpdEZvck5leHRCbG9jayh0aGlzLl9jdXJyZW50QmxvY2tJZCwgdGhpcy5fYWRkcmVzcywgTkVYVF9CTE9DS19USU1FT1VUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHdhaXQgZm9yIG5leHQgYmxvY2sgZm9yICR7dGhpcy5fYWRkcmVzc31gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFBvbGxpbmdNZXRob2QgPSBhd2FpdCB0aGlzLl9jb250cmFjdE11dGV4LnVzZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fY29udHJhY3QuaGFuZGxlQmxvY2sobmV4dEJsb2NrSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250cmFjdC5wb2xsaW5nTWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50QmxvY2tJZCA9IG5leHRCbG9ja0lkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gaGFuZGxlIGJsb2NrIGZvciAke3RoaXMuX2FkZHJlc3N9YCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1Z0xvZygnQ29udHJhY3RTdWJzY3JpcHRpb24gLT4gbG9vcCBmaW5pc2hlZCcpO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBza2lwUmVmcmVzaFRpbWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjbGVhclRpbWVvdXQoKF9hID0gdGhpcy5fcmVmcmVzaFRpbWVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pO1xuICAgICAgICAoX2IgPSB0aGlzLl9yZWZyZXNoVGltZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsxXSgpO1xuICAgICAgICB0aGlzLl9yZWZyZXNoVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFzeW5jIHBhdXNlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzUnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNraXBSZWZyZXNoVGltZXIoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fbG9vcFByb21pc2U7XG4gICAgICAgIHRoaXMuX2xvb3BQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jdXJyZW50UG9sbGluZ01ldGhvZCA9IGF3YWl0IHRoaXMuX2NvbnRyYWN0TXV0ZXgudXNlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250cmFjdC5wb2xsaW5nTWV0aG9kO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY3VycmVudEJsb2NrSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3N1Z2dlc3RlZEJsb2NrSWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFzeW5jIHN0b3AoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYXdhaXQgdGhpcy5wYXVzZSgpO1xuICAgICAgICB0aGlzLl9jb250cmFjdC5mcmVlKCk7XG4gICAgICAgIChfYSA9IHRoaXMuX3JlbGVhc2VUcmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZWxlYXNlVHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyBwcmVwYXJlUmVsaWFibGVQb2xsaW5nKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb24gaW5zdGFuY2VvZiBuZWtvdG9uLkdxbENvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWdnZXN0ZWRCbG9ja0lkID0gKGF3YWl0IHRoaXMuX2Nvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2sodGhpcy5fYWRkcmVzcykpLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwcmVwYXJlIHJlbGlhYmxlIHBvbGxpbmc6ICR7ZS50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHVzZShmKSB7XG4gICAgICAgIGNvbnN0IHJlbGVhc2UgPSBhd2FpdCB0aGlzLl9jb250cmFjdE11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgcmV0dXJuIGYodGhpcy5fY29udHJhY3QpXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db250cmFjdFN1YnNjcmlwdGlvbiA9IENvbnRyYWN0U3Vic2NyaXB0aW9uO1xuY29uc3QgTkVYVF9CTE9DS19USU1FT1VUID0gNjA7IC8vIDYwc1xuY29uc3QgSU5URU5TSVZFX1BPTExJTkdfSU5URVJWQUwgPSAyMDAwOyAvLyAyc1xuY29uc3QgQkFDS0dST1VORF9QT0xMSU5HX0lOVEVSVkFMID0gNjAwMDA7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///334\n")},241:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Clock = void 0;\n/**\n * Wrapper around clocks which are used in `EverscaleStandaloneClient` instances\n *\n * @category Client\n */\nclass Clock {\n    constructor(offset) {\n        this.impls = [];\n        this.currentOffset = 0;\n        if (offset != null) {\n            this.currentOffset = offset;\n        }\n    }\n    /**\n     * Clock offset in milliseconds\n     */\n    get offset() {\n        return this.currentOffset;\n    }\n    /**\n     * Set clock offset in milliseconds\n     */\n    set offset(value) {\n        this.currentOffset = value;\n        for (const impl of this.impls) {\n            impl.updateOffset(this.currentOffset);\n        }\n    }\n    /**\n     * Returns current time in milliseconds\n     */\n    get time() {\n        return new Date().getTime() + this.offset;\n    }\n    /**\n     * Detaches all affected providers\n     *\n     * NOTE: affected providers offset remains the same\n     */\n    detach() {\n        this.impls = [];\n    }\n}\nexports.Clock = Clock;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvY2xvY2suanM/MzZhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xvY2sgPSB2b2lkIDA7XG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIGNsb2NrcyB3aGljaCBhcmUgdXNlZCBpbiBgRXZlcnNjYWxlU3RhbmRhbG9uZUNsaWVudGAgaW5zdGFuY2VzXG4gKlxuICogQGNhdGVnb3J5IENsaWVudFxuICovXG5jbGFzcyBDbG9jayB7XG4gICAgY29uc3RydWN0b3Iob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuaW1wbHMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKG9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvY2sgb2Zmc2V0IGluIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIGdldCBvZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBjbG9jayBvZmZzZXQgaW4gbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgc2V0IG9mZnNldCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRPZmZzZXQgPSB2YWx1ZTtcbiAgICAgICAgZm9yIChjb25zdCBpbXBsIG9mIHRoaXMuaW1wbHMpIHtcbiAgICAgICAgICAgIGltcGwudXBkYXRlT2Zmc2V0KHRoaXMuY3VycmVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJyZW50IHRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgZ2V0IHRpbWUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHRoaXMub2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRhY2hlcyBhbGwgYWZmZWN0ZWQgcHJvdmlkZXJzXG4gICAgICpcbiAgICAgKiBOT1RFOiBhZmZlY3RlZCBwcm92aWRlcnMgb2Zmc2V0IHJlbWFpbnMgdGhlIHNhbWVcbiAgICAgKi9cbiAgICBkZXRhY2goKSB7XG4gICAgICAgIHRoaXMuaW1wbHMgPSBbXTtcbiAgICB9XG59XG5leHBvcnRzLkNsb2NrID0gQ2xvY2s7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///241\n')},637:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EverscaleStandaloneClient = exports.SUPPORTED_PERMISSIONS = exports.VERSION = exports.DEFAULT_CLIENT_PROPERTIES = exports.Clock = exports.SimpleKeystore = exports.checkConnection = exports.ConnectionError = exports.NETWORK_PRESETS = void 0;\nconst fast_safe_stringify_1 = __importDefault(__webpack_require__(445));\nconst core_1 = __importDefault(__webpack_require__(521));\nconst utils_1 = __webpack_require__(344);\nconst ConnectionController_1 = __webpack_require__(863);\nconst SubscriptionController_1 = __webpack_require__(536);\nconst AccountsStorage_1 = __webpack_require__(487);\nvar ConnectionController_2 = __webpack_require__(863);\nObject.defineProperty(exports, \"NETWORK_PRESETS\", ({ enumerable: true, get: function () { return ConnectionController_2.NETWORK_PRESETS; } }));\nvar ConnectionController_3 = __webpack_require__(863);\nObject.defineProperty(exports, \"ConnectionError\", ({ enumerable: true, get: function () { return ConnectionController_3.ConnectionError; } }));\nObject.defineProperty(exports, \"checkConnection\", ({ enumerable: true, get: function () { return ConnectionController_3.checkConnection; } }));\n__exportStar(__webpack_require__(487), exports);\nvar keystore_1 = __webpack_require__(837);\nObject.defineProperty(exports, \"SimpleKeystore\", ({ enumerable: true, get: function () { return keystore_1.SimpleKeystore; } }));\nvar clock_1 = __webpack_require__(241);\nObject.defineProperty(exports, \"Clock\", ({ enumerable: true, get: function () { return clock_1.Clock; } }));\nconst { ensureNekotonLoaded, nekoton } = core_1.default;\nfunction validateMessageProperties(message) {\n    const m = message || {};\n    return {\n        retryCount: m.retryCount != null ? Math.max(1, ~~m.retryCount) : 5,\n        timeout: m.timeout != null ? Math.max(1, ~~m.timeout) : 60,\n        timeoutGrowFactor: m.timeoutGrowFactor || 1.2,\n        retryTransfers: true,\n    };\n}\n/**\n * @category Client\n */\nexports.DEFAULT_CLIENT_PROPERTIES = {\n    connection: ConnectionController_1.DEFAULT_NETWORK_GROUP,\n};\n/**\n * @category Client\n */\nexports.VERSION = '0.2.25';\n/**\n * @category Client\n */\nexports.SUPPORTED_PERMISSIONS = ['basic', 'accountInteraction'];\n/**\n * @category Client\n */\nclass EverscaleStandaloneClient extends utils_1.SafeEventEmitter {\n    constructor(ctx) {\n        super();\n        this._handlers = {\n            requestPermissions,\n            changeAccount,\n            disconnect,\n            subscribe,\n            unsubscribe,\n            unsubscribeAll,\n            getProviderState,\n            getFullContractState,\n            getAccountsByCodeHash,\n            getTransactions,\n            getTransaction,\n            findTransaction,\n            runLocal,\n            getExpectedAddress,\n            getBocHash,\n            packIntoCell,\n            unpackFromCell,\n            extractPublicKey,\n            codeToTvc,\n            mergeTvc,\n            splitTvc,\n            setCodeSalt,\n            getCodeSalt,\n            encodeInternalInput,\n            decodeInput,\n            decodeOutput,\n            decodeEvent,\n            decodeTransaction,\n            decodeTransactionEvents,\n            verifySignature,\n            sendUnsignedExternalMessage,\n            // addAsset, // not supported\n            signData,\n            signDataRaw,\n            // encryptData, // not supported\n            // decryptData, // not supported\n            // estimateFees, // not supported\n            sendMessage,\n            sendMessageDelayed,\n            sendExternalMessage,\n            sendExternalMessageDelayed,\n        };\n        this._context = ctx;\n    }\n    static async create(params) {\n        await ensureNekotonLoaded(params.initInput);\n        // NOTE: capture client inside notify using wrapper object\n        const notificationContext = {};\n        const notify = (method, params) => {\n            var _a;\n            (_a = notificationContext.client) === null || _a === void 0 ? void 0 : _a.emit(method, params);\n        };\n        const clock = new core_1.default.nekoton.ClockWithOffset();\n        if (params.clock != null) {\n            params.clock['impls'].push(clock);\n            clock.updateOffset(params.clock.offset);\n        }\n        try {\n            const connectionController = await (0, ConnectionController_1.createConnectionController)(clock, params.connection);\n            const subscriptionController = new SubscriptionController_1.SubscriptionController(connectionController, notify);\n            const client = new EverscaleStandaloneClient({\n                permissions: {},\n                connectionController,\n                subscriptionController,\n                properties: {\n                    message: validateMessageProperties(params.message),\n                },\n                keystore: params.keystore,\n                accountsStorage: params.accountsStorage,\n                clock,\n                notify,\n            });\n            // NOTE: WeakRef is not working here, so hope it will be garbage collected\n            notificationContext.client = client;\n            return client;\n        }\n        catch (e) {\n            if (params.clock != null) {\n                params.clock['impls'].pop();\n            }\n            clock.free();\n            throw e;\n        }\n    }\n    request(req) {\n        const handler = this._handlers[req.method];\n        if (handler == null) {\n            throw invalidRequest(req, `Method '${req.method}' is not supported by standalone provider`);\n        }\n        return handler(this._context, req);\n    }\n    addListener(eventName, listener) {\n        return super.addListener(eventName, listener);\n    }\n    removeListener(eventName, listener) {\n        return super.removeListener(eventName, listener);\n    }\n    on(eventName, listener) {\n        return super.on(eventName, listener);\n    }\n    once(eventName, listener) {\n        return super.once(eventName, listener);\n    }\n    prependListener(eventName, listener) {\n        return super.prependListener(eventName, listener);\n    }\n    prependOnceListener(eventName, listener) {\n        return super.prependOnceListener(eventName, listener);\n    }\n}\nexports.EverscaleStandaloneClient = EverscaleStandaloneClient;\nconst requestPermissions = async (ctx, req) => {\n    requireParams(req);\n    const { permissions } = req.params;\n    requireArray(req, req.params, 'permissions');\n    const newPermissions = { ...ctx.permissions };\n    for (const permission of permissions) {\n        if (permission === 'basic' || permission === 'tonClient') {\n            newPermissions.basic = true;\n        }\n        else if (permission === 'accountInteraction') {\n            if (newPermissions.accountInteraction != null) {\n                continue;\n            }\n            newPermissions.accountInteraction = await makeAccountInteractionPermission(req, ctx);\n        }\n        else {\n            throw invalidRequest(req, `Permission '${permission}' is not supported by standalone provider`);\n        }\n    }\n    ctx.permissions = newPermissions;\n    // NOTE: be sure to return object copy to prevent adding new permissions\n    const permissionsCopy = JSON.parse(JSON.stringify(newPermissions));\n    ctx.notify('permissionsChanged', {\n        permissions: permissionsCopy,\n    });\n    return permissionsCopy;\n};\nconst changeAccount = async (ctx, req) => {\n    requireAccountsStorage(req, ctx);\n    const newPermissions = { ...ctx.permissions };\n    newPermissions.accountInteraction = await makeAccountInteractionPermission(req, ctx);\n    ctx.permissions = newPermissions;\n    // NOTE: be sure to return object copy to prevent adding new permissions\n    const permissionsCopy = JSON.parse(JSON.stringify(newPermissions));\n    ctx.notify('permissionsChanged', {\n        permissions: permissionsCopy,\n    });\n    return permissionsCopy;\n};\nconst disconnect = async (ctx, _req) => {\n    ctx.permissions = {};\n    await ctx.subscriptionController.unsubscribeFromAllContracts();\n    ctx.notify('permissionsChanged', { permissions: {} });\n    return undefined;\n};\nconst subscribe = async (ctx, req) => {\n    requireParams(req);\n    const { address, subscriptions } = req.params;\n    requireString(req, req.params, 'address');\n    requireOptionalObject(req, req.params, 'subscriptions');\n    let repackedAddress;\n    try {\n        repackedAddress = nekoton.repackAddress(address);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    try {\n        return await ctx.subscriptionController.subscribeToContract(repackedAddress, subscriptions);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst unsubscribe = async (ctx, req) => {\n    requireParams(req);\n    const { address } = req.params;\n    requireString(req, req.params, 'address');\n    let repackedAddress;\n    try {\n        repackedAddress = nekoton.repackAddress(address);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    await ctx.subscriptionController.unsubscribeFromContract(repackedAddress);\n    return undefined;\n};\nconst unsubscribeAll = async (ctx, _req) => {\n    await ctx.subscriptionController.unsubscribeFromAllContracts();\n    return undefined;\n};\nconst getProviderState = async (ctx, req) => {\n    const transport = ctx.connectionController.initializedTransport;\n    if (transport == null) {\n        throw invalidRequest(req, 'Connection controller was not initialized');\n    }\n    const version = exports.VERSION;\n    return {\n        version,\n        numericVersion: (0, utils_1.convertVersionToInt32)(version),\n        networkId: transport.id,\n        selectedConnection: transport.group,\n        supportedPermissions: [...exports.SUPPORTED_PERMISSIONS],\n        permissions: JSON.parse(JSON.stringify(ctx.permissions)),\n        subscriptions: ctx.subscriptionController.subscriptionStates,\n    };\n};\nconst getFullContractState = async (ctx, req) => {\n    requireParams(req);\n    const { address } = req.params;\n    requireString(req, req.params, 'address');\n    const { connectionController } = ctx;\n    try {\n        return connectionController.use(async ({ data: { transport } }) => ({\n            state: await transport.getFullContractState(address),\n        }));\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getAccountsByCodeHash = async (ctx, req) => {\n    requireParams(req);\n    const { codeHash, limit, continuation } = req.params;\n    requireString(req, req.params, 'codeHash');\n    requireOptionalNumber(req, req.params, 'limit');\n    requireOptionalString(req, req.params, 'continuation');\n    const { connectionController } = ctx;\n    try {\n        return connectionController.use(({ data: { transport } }) => transport.getAccountsByCodeHash(codeHash, limit || 50, continuation));\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getTransactions = async (ctx, req) => {\n    requireParams(req);\n    const { address, continuation, limit } = req.params;\n    requireString(req, req.params, 'address');\n    requireOptional(req, req.params, 'continuation', requireTransactionId);\n    requireOptionalNumber(req, req.params, 'limit');\n    const { connectionController } = ctx;\n    try {\n        return connectionController.use(({ data: { transport } }) => transport.getTransactions(address, continuation === null || continuation === void 0 ? void 0 : continuation.lt, limit || 50));\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getTransaction = async (ctx, req) => {\n    requireParams(req);\n    const { hash } = req.params;\n    requireString(req, req.params, 'hash');\n    const { connectionController } = ctx;\n    try {\n        return {\n            transaction: await connectionController.use(({ data: { transport } }) => transport.getTransaction(hash)),\n        };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst findTransaction = async (ctx, req) => {\n    requireParams(req);\n    const { inMessageHash } = req.params;\n    requireOptional(req, req.params, 'inMessageHash', requireString);\n    const { connectionController } = ctx;\n    // TODO: add more filters\n    if (inMessageHash == null) {\n        return {\n            transaction: undefined,\n        };\n    }\n    try {\n        return {\n            transaction: await connectionController.use(({ data: { transport } }) => transport.getDstTransaction(inMessageHash)),\n        };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst runLocal = async (ctx, req) => {\n    requireParams(req);\n    const { address, cachedState, responsible, functionCall } = req.params;\n    requireString(req, req.params, 'address');\n    requireOptional(req, req.params, 'cachedState', requireContractState);\n    requireOptionalBoolean(req, req.params, 'responsible');\n    requireFunctionCall(req, req.params, 'functionCall');\n    const { clock, connectionController } = ctx;\n    let contractState = cachedState;\n    if (contractState == null) {\n        contractState = await connectionController.use(async ({ data: { transport } }) => transport.getFullContractState(address));\n    }\n    if (contractState == null) {\n        throw invalidRequest(req, 'Account not found');\n    }\n    if (!contractState.isDeployed || contractState.lastTransactionId == null) {\n        throw invalidRequest(req, 'Account is not deployed');\n    }\n    try {\n        const { output, code } = nekoton.runLocal(clock, contractState.boc, functionCall.abi, functionCall.method, functionCall.params, responsible || false);\n        return { output, code };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getExpectedAddress = async (_ctx, req) => {\n    requireParams(req);\n    const { tvc, abi, workchain, publicKey, initParams } = req.params;\n    requireString(req, req.params, 'tvc');\n    requireString(req, req.params, 'abi');\n    requireOptionalNumber(req, req.params, 'workchain');\n    requireOptionalString(req, req.params, 'publicKey');\n    try {\n        return nekoton.getExpectedAddress(tvc, abi, workchain || 0, publicKey, initParams);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getBocHash = async (_ctx, req) => {\n    requireParams(req);\n    const { boc } = req.params;\n    requireString(req, req.params, 'boc');\n    try {\n        return { hash: nekoton.getBocHash(boc) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst packIntoCell = async (_ctx, req) => {\n    requireParams(req);\n    const { structure, data, abiVersion } = req.params;\n    requireArray(req, req.params, 'structure');\n    requireOptional(req, req.params, 'abiVersion', requireString);\n    try {\n        return { boc: nekoton.packIntoCell(structure, data, abiVersion) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst unpackFromCell = async (_ctx, req) => {\n    requireParams(req);\n    const { structure, boc, allowPartial, abiVersion } = req.params;\n    requireArray(req, req.params, 'structure');\n    requireString(req, req.params, 'boc');\n    requireBoolean(req, req.params, 'allowPartial');\n    requireOptional(req, req.params, 'abiVersion', requireString);\n    try {\n        return { data: nekoton.unpackFromCell(structure, boc, allowPartial, abiVersion) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst extractPublicKey = async (_ctx, req) => {\n    requireParams(req);\n    const { boc } = req.params;\n    requireString(req, req.params, 'boc');\n    try {\n        return { publicKey: nekoton.extractPublicKey(boc) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst codeToTvc = async (_ctx, req) => {\n    requireParams(req);\n    const { code } = req.params;\n    requireString(req, req.params, 'code');\n    try {\n        return { tvc: nekoton.codeToTvc(code) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst mergeTvc = async (_ctx, req) => {\n    requireParams(req);\n    const { code, data } = req.params;\n    requireString(req, req.params, 'code');\n    requireString(req, req.params, 'data');\n    try {\n        return { tvc: nekoton.mergeTvc(code, data) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst splitTvc = async (_ctx, req) => {\n    requireParams(req);\n    const { tvc } = req.params;\n    requireString(req, req.params, 'tvc');\n    try {\n        return nekoton.splitTvc(tvc);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst setCodeSalt = async (_ctx, req) => {\n    requireParams(req);\n    const { code, salt } = req.params;\n    requireString(req, req.params, 'code');\n    requireString(req, req.params, 'salt');\n    try {\n        return { code: nekoton.setCodeSalt(code, salt) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getCodeSalt = async (_ctx, req) => {\n    requireParams(req);\n    const { code } = req.params;\n    requireString(req, req.params, 'code');\n    try {\n        return { salt: nekoton.getCodeSalt(code) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst encodeInternalInput = async (_ctx, req) => {\n    requireParams(req);\n    requireFunctionCall(req, req, 'params');\n    const { abi, method, params } = req.params;\n    try {\n        return { boc: nekoton.encodeInternalInput(abi, method, params) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeInput = async (_ctx, req) => {\n    requireParams(req);\n    const { body, abi, method, internal } = req.params;\n    requireString(req, req.params, 'body');\n    requireString(req, req.params, 'abi');\n    requireMethodOrArray(req, req.params, 'method');\n    requireBoolean(req, req.params, 'internal');\n    try {\n        return nekoton.decodeInput(body, abi, method, internal) || null;\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeOutput = async (_ctx, req) => {\n    requireParams(req);\n    const { body, abi, method } = req.params;\n    requireString(req, req.params, 'body');\n    requireString(req, req.params, 'abi');\n    requireMethodOrArray(req, req.params, 'method');\n    try {\n        return nekoton.decodeOutput(body, abi, method) || null;\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeEvent = async (_ctx, req) => {\n    requireParams(req);\n    const { body, abi, event } = req.params;\n    requireString(req, req.params, 'body');\n    requireString(req, req.params, 'abi');\n    requireMethodOrArray(req, req.params, 'event');\n    try {\n        return nekoton.decodeEvent(body, abi, event) || null;\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeTransaction = async (_ctx, req) => {\n    requireParams(req);\n    const { transaction, abi, method } = req.params;\n    requireString(req, req.params, 'abi');\n    requireMethodOrArray(req, req.params, 'method');\n    try {\n        return nekoton.decodeTransaction(transaction, abi, method) || null;\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeTransactionEvents = async (_ctx, req) => {\n    requireParams(req);\n    const { transaction, abi } = req.params;\n    requireString(req, req.params, 'abi');\n    try {\n        return { events: nekoton.decodeTransactionEvents(transaction, abi) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst verifySignature = async (_ctx, req) => {\n    requireParams(req);\n    const { publicKey, dataHash, signature } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'dataHash');\n    requireString(req, req.params, 'signature');\n    try {\n        return { isValid: nekoton.verifySignature(publicKey, dataHash, signature) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst sendUnsignedExternalMessage = async (ctx, req) => {\n    requireParams(req);\n    const { recipient, stateInit, payload, local } = req.params;\n    requireString(req, req.params, 'recipient');\n    requireOptionalString(req, req.params, 'stateInit');\n    requireOptionalRawFunctionCall(req, req.params, 'payload');\n    requireOptionalBoolean(req, req.params, 'local');\n    let repackedRecipient;\n    try {\n        repackedRecipient = nekoton.repackAddress(recipient);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    const { clock, subscriptionController, properties } = ctx;\n    const makeSignedMessage = (timeout) => {\n        try {\n            if (typeof payload === 'string' || payload == null) {\n                const expireAt = ~~(clock.nowMs / 1000) + timeout;\n                return nekoton.createRawExternalMessage(repackedRecipient, stateInit, payload, expireAt);\n            }\n            else {\n                return nekoton.createExternalMessageWithoutSignature(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, timeout);\n            }\n        }\n        catch (e) {\n            throw invalidRequest(req, e.toString());\n        }\n    };\n    const handleTransaction = (transaction) => {\n        let output;\n        try {\n            if (typeof payload === 'object' && typeof payload != null) {\n                const decoded = nekoton.decodeTransaction(transaction, payload.abi, payload.method);\n                output = decoded === null || decoded === void 0 ? void 0 : decoded.output;\n            }\n        }\n        catch (_) { /* do nothing */\n        }\n        return { transaction, output };\n    };\n    // Force local execution\n    if (local === true) {\n        const signedMessage = makeSignedMessage(60);\n        const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage);\n        return handleTransaction(transaction);\n    }\n    // Send and wait with several retries\n    let timeout = properties.message.timeout;\n    for (let retry = 0; retry < properties.message.retryCount; ++retry) {\n        const signedMessage = makeSignedMessage(timeout);\n        const transaction = await subscriptionController.sendMessage(repackedRecipient, signedMessage);\n        if (transaction == null) {\n            timeout *= properties.message.timeoutGrowFactor;\n            continue;\n        }\n        return handleTransaction(transaction);\n    }\n    // Execute locally\n    const errorMessage = 'Message expired';\n    const signedMessage = makeSignedMessage(60);\n    const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage)\n        .catch((e) => {\n        throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);\n    });\n    const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';\n    throw invalidRequest(req, `${errorMessage}${additionalText}`);\n};\nconst signData = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireParams(req);\n    const { publicKey, data } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'data');\n    const { keystore } = ctx;\n    const signer = await keystore.getSigner(publicKey);\n    if (signer == null) {\n        throw invalidRequest(req, 'Signer not found for public key');\n    }\n    try {\n        const dataHash = nekoton.getDataHash(data);\n        return {\n            dataHash,\n            ...(await signer.sign(dataHash).then(nekoton.extendSignature)),\n        };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst signDataRaw = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireParams(req);\n    const { publicKey, data } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'data');\n    const { keystore } = ctx;\n    const signer = await keystore.getSigner(publicKey);\n    if (signer == null) {\n        throw invalidRequest(req, 'Signer not found for public key');\n    }\n    try {\n        return await signer.sign(data).then(nekoton.extendSignature);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst sendMessage = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireAccountsStorage(req, ctx);\n    requireParams(req);\n    const { sender, recipient, amount, bounce, payload } = req.params;\n    requireString(req, req.params, 'sender');\n    requireString(req, req.params, 'recipient');\n    requireString(req, req.params, 'amount');\n    requireBoolean(req, req.params, 'bounce');\n    requireOptional(req, req.params, 'payload', requireFunctionCall);\n    const { clock, properties, subscriptionController, connectionController, keystore, accountsStorage } = ctx;\n    let repackedSender;\n    let repackedRecipient;\n    let account;\n    try {\n        repackedSender = nekoton.repackAddress(sender);\n        repackedRecipient = nekoton.repackAddress(recipient);\n        account = await accountsStorage.getAccount(repackedSender).then((account) => {\n            if (account != null) {\n                return account;\n            }\n            else {\n                throw new Error('Sender not found');\n            }\n        });\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    const makeSignedMessage = async (timeout) => {\n        try {\n            return account.prepareMessage({\n                recipient: repackedRecipient,\n                amount,\n                bounce,\n                payload,\n                stateInit: undefined,\n                timeout,\n            }, new AccountsStorage_1.AccountsStorageContext(clock, connectionController, nekoton, keystore));\n        }\n        catch (e) {\n            throw invalidRequest(req, e.toString());\n        }\n    };\n    // Send and wait with several retries\n    let timeout = properties.message.timeout;\n    // Set `retryCount` if not explicitly disabled\n    const retryCount = properties.message.retryTransfers !== false ? properties.message.retryCount : 1;\n    for (let retry = 0; retry < retryCount; ++retry) {\n        const signedMessage = await makeSignedMessage(timeout);\n        const transaction = await subscriptionController.sendMessage(repackedSender, signedMessage);\n        if (transaction == null) {\n            timeout *= properties.message.timeoutGrowFactor;\n            continue;\n        }\n        return { transaction };\n    }\n    // Execute locally\n    const errorMessage = 'Message expired';\n    const signedMessage = await makeSignedMessage(60);\n    const transaction = await subscriptionController.sendMessageLocally(repackedSender, signedMessage)\n        .catch((e) => {\n        throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);\n    });\n    const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';\n    throw invalidRequest(req, `${errorMessage}${additionalText}`);\n};\nconst sendMessageDelayed = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireAccountsStorage(req, ctx);\n    requireParams(req);\n    const { sender, recipient, amount, bounce, payload } = req.params;\n    requireString(req, req.params, 'sender');\n    requireString(req, req.params, 'recipient');\n    requireString(req, req.params, 'amount');\n    requireBoolean(req, req.params, 'bounce');\n    requireOptional(req, req.params, 'payload', requireFunctionCall);\n    const { clock, subscriptionController, connectionController, keystore, accountsStorage, notify } = ctx;\n    let repackedSender;\n    let repackedRecipient;\n    try {\n        repackedSender = nekoton.repackAddress(sender);\n        repackedRecipient = nekoton.repackAddress(recipient);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    let signedMessage;\n    try {\n        const account = await accountsStorage.getAccount(repackedSender);\n        if (account == null) {\n            throw new Error('Sender not found');\n        }\n        signedMessage = await account.prepareMessage({\n            recipient: repackedRecipient,\n            amount,\n            bounce,\n            payload,\n            stateInit: undefined,\n            timeout: 60, // TEMP\n        }, new AccountsStorage_1.AccountsStorageContext(clock, connectionController, nekoton, keystore));\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    subscriptionController.sendMessage(repackedSender, signedMessage)\n        .then(transaction => {\n        notify('messageStatusUpdated', {\n            address: repackedSender,\n            hash: signedMessage.hash,\n            transaction,\n        });\n    })\n        .catch(console.error);\n    return {\n        message: {\n            account: repackedSender,\n            hash: signedMessage.hash,\n            expireAt: signedMessage.expireAt,\n        },\n    };\n};\nconst sendExternalMessage = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireParams(req);\n    const { publicKey, recipient, stateInit, payload, local } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'recipient');\n    requireOptionalString(req, req.params, 'stateInit');\n    requireFunctionCall(req, req.params, 'payload');\n    requireOptionalBoolean(req, req.params, 'local');\n    let repackedRecipient;\n    try {\n        repackedRecipient = nekoton.repackAddress(recipient);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    const { clock, subscriptionController, keystore, properties } = ctx;\n    const signer = await keystore.getSigner(publicKey);\n    if (signer == null) {\n        throw invalidRequest(req, 'Signer not found for public key');\n    }\n    const makeSignedMessage = async (timeout) => {\n        let unsignedMessage;\n        try {\n            unsignedMessage = nekoton.createExternalMessage(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, publicKey, timeout);\n        }\n        catch (e) {\n            throw invalidRequest(req, e.toString());\n        }\n        try {\n            const signature = await signer.sign(unsignedMessage.hash);\n            return unsignedMessage.sign(signature);\n        }\n        catch (e) {\n            throw invalidRequest(req, e.toString());\n        }\n        finally {\n            unsignedMessage.free();\n        }\n    };\n    const handleTransaction = (transaction) => {\n        let output;\n        try {\n            const decoded = nekoton.decodeTransaction(transaction, payload.abi, payload.method);\n            output = decoded === null || decoded === void 0 ? void 0 : decoded.output;\n        }\n        catch (_) { /* do nothing */\n        }\n        return { transaction, output };\n    };\n    // Force local execution\n    if (local === true) {\n        const signedMessage = await makeSignedMessage(60);\n        const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage);\n        return handleTransaction(transaction);\n    }\n    // Send and wait with several retries\n    let timeout = properties.message.timeout;\n    for (let retry = 0; retry < properties.message.retryCount; ++retry) {\n        const signedMessage = await makeSignedMessage(timeout);\n        const transaction = await subscriptionController.sendMessage(repackedRecipient, signedMessage);\n        if (transaction == null) {\n            timeout *= properties.message.timeoutGrowFactor;\n            continue;\n        }\n        return handleTransaction(transaction);\n    }\n    // Execute locally\n    const errorMessage = 'Message expired';\n    const signedMessage = await makeSignedMessage(60);\n    const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage)\n        .catch((e) => {\n        throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);\n    });\n    const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';\n    throw invalidRequest(req, `${errorMessage}${additionalText}`);\n};\nconst sendExternalMessageDelayed = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireParams(req);\n    const { publicKey, recipient, stateInit, payload } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'recipient');\n    requireOptionalString(req, req.params, 'stateInit');\n    requireFunctionCall(req, req.params, 'payload');\n    let repackedRecipient;\n    try {\n        repackedRecipient = nekoton.repackAddress(recipient);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    const { clock, subscriptionController, keystore, properties, notify } = ctx;\n    const signer = await keystore.getSigner(publicKey);\n    if (signer == null) {\n        throw invalidRequest(req, 'Signer not found for public key');\n    }\n    let unsignedMessage;\n    try {\n        unsignedMessage = nekoton.createExternalMessage(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, publicKey, properties.message.timeout);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    let signedMessage;\n    try {\n        const signature = await signer.sign(unsignedMessage.hash);\n        signedMessage = unsignedMessage.sign(signature);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    finally {\n        unsignedMessage.free();\n    }\n    subscriptionController.sendMessage(repackedRecipient, signedMessage)\n        .then(transaction => {\n        notify('messageStatusUpdated', {\n            address: repackedRecipient,\n            hash: signedMessage.hash,\n            transaction,\n        });\n    })\n        .catch(console.error);\n    return {\n        message: {\n            account: repackedRecipient,\n            hash: signedMessage.hash,\n            expireAt: signedMessage.expireAt,\n        },\n    };\n};\nfunction requireKeystore(req, context) {\n    if (context.keystore == null) {\n        throw invalidRequest(req, 'Keystore not found');\n    }\n}\nfunction requireAccountsStorage(req, context) {\n    if (context.accountsStorage == null) {\n        throw invalidRequest(req, 'AccountsStorage not found');\n    }\n}\nfunction requireParams(req) {\n    if (req.params == null || typeof req.params !== 'object') {\n        throw invalidRequest(req, 'required params object');\n    }\n}\nfunction requireObject(req, object, key) {\n    const property = object[key];\n    if (typeof property !== 'object') {\n        throw invalidRequest(req, `'${String(key)}' must be an object`);\n    }\n}\nfunction requireOptionalObject(req, object, key) {\n    const property = object[key];\n    if (property != null && typeof property !== 'object') {\n        throw invalidRequest(req, `'${String(key)}' must be an object if specified`);\n    }\n}\nfunction requireBoolean(req, object, key) {\n    const property = object[key];\n    if (typeof property !== 'boolean') {\n        throw invalidRequest(req, `'${String(key)}' must be a boolean`);\n    }\n}\nfunction requireOptionalBoolean(req, object, key) {\n    const property = object[key];\n    if (property != null && typeof property !== 'boolean') {\n        throw invalidRequest(req, `'${String(key)}' must be a boolean if specified`);\n    }\n}\nfunction requireString(req, object, key) {\n    const property = object[key];\n    if (typeof property !== 'string' || property.length === 0) {\n        throw invalidRequest(req, `'${String(key)}' must be non-empty string`);\n    }\n}\nfunction requireOptionalString(req, object, key) {\n    const property = object[key];\n    if (property != null && (typeof property !== 'string' || property.length === 0)) {\n        throw invalidRequest(req, `'${String(key)}' must be a non-empty string if provided`);\n    }\n}\nfunction requireOptionalNumber(req, object, key) {\n    const property = object[key];\n    if (property != null && typeof property !== 'number') {\n        throw invalidRequest(req, `'${String(key)}' must be a number if provider`);\n    }\n}\nfunction requireArray(req, object, key) {\n    const property = object[key];\n    if (!Array.isArray(property)) {\n        throw invalidRequest(req, `'${String(key)}' must be an array`);\n    }\n}\nfunction requireOptional(req, object, key, predicate) {\n    const property = object[key];\n    if (property != null) {\n        predicate(req, object, key);\n    }\n}\nfunction requireTransactionId(req, object, key) {\n    requireObject(req, object, key);\n    const property = object[key];\n    requireString(req, property, 'lt');\n    requireString(req, property, 'hash');\n}\nfunction requireLastTransactionId(req, object, key) {\n    requireObject(req, object, key);\n    const property = object[key];\n    requireBoolean(req, property, 'isExact');\n    requireString(req, property, 'lt');\n    requireOptionalString(req, property, 'hash');\n}\nfunction requireContractState(req, object, key) {\n    requireObject(req, object, key);\n    const property = object[key];\n    requireString(req, property, 'balance');\n    requireOptional(req, property, 'lastTransactionId', requireLastTransactionId);\n    requireBoolean(req, property, 'isDeployed');\n}\nfunction requireFunctionCall(req, object, key) {\n    requireObject(req, object, key);\n    const property = object[key];\n    requireString(req, property, 'abi');\n    requireString(req, property, 'method');\n    requireObject(req, property, 'params');\n}\nfunction requireOptionalRawFunctionCall(req, object, key) {\n    const property = object[key];\n    if (typeof property === 'string' || property == null) {\n        return;\n    }\n    else if (typeof property === 'object') {\n        requireString(req, property, 'abi');\n        requireString(req, property, 'method');\n        requireObject(req, property, 'params');\n    }\n    else {\n        throw invalidRequest(req, `'${String(key)}' must be a function all or optional string`);\n    }\n}\nfunction requireMethodOrArray(req, object, key) {\n    const property = object[key];\n    if (property != null && typeof property !== 'string' && !Array.isArray(property)) {\n        throw invalidRequest(req, `'${String(key)}' must be a method name or an array of possible names`);\n    }\n}\nasync function makeAccountInteractionPermission(req, ctx) {\n    requireAccountsStorage(req, ctx);\n    const defaultAccount = ctx.accountsStorage.defaultAccount;\n    if (defaultAccount == null) {\n        throw invalidRequest(req, 'Default account not set in accounts storage');\n    }\n    const account = await ctx.accountsStorage.getAccount(defaultAccount);\n    if (account == null) {\n        throw invalidRequest(req, 'Default account not found');\n    }\n    const publicKey = await account.fetchPublicKey(new AccountsStorage_1.AccountsStorageContext(ctx.clock, ctx.connectionController, nekoton));\n    return {\n        address: account.address.toString(),\n        publicKey,\n        contractType: 'unknown',\n    };\n}\nconst invalidRequest = (req, message, data) => new NekotonRpcError(2, `${req.method}: ${message}`, data);\nclass NekotonRpcError extends Error {\n    constructor(code, message, data) {\n        if (!Number.isInteger(code)) {\n            throw new Error('\"code\" must be an integer');\n        }\n        if (!message || typeof message !== 'string') {\n            throw new Error('\"message\" must be a nonempty string');\n        }\n        super(message);\n        this.code = code;\n        this.data = data;\n    }\n    serialize() {\n        const serialized = {\n            code: this.code,\n            message: this.message,\n        };\n        if (this.data !== undefined) {\n            serialized.data = this.data;\n        }\n        if (this.stack) {\n            serialized.stack = this.stack;\n        }\n        return serialized;\n    }\n    toString() {\n        return (0, fast_safe_stringify_1.default)(this.serialize(), stringifyReplacer, 2);\n    }\n}\nconst stringifyReplacer = (_, value) => {\n    if (value === '[Circular]') {\n        return undefined;\n    }\n    return value;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjM3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvaW5kZXguanM/ZTEwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FdmVyc2NhbGVTdGFuZGFsb25lQ2xpZW50ID0gZXhwb3J0cy5TVVBQT1JURURfUEVSTUlTU0lPTlMgPSBleHBvcnRzLlZFUlNJT04gPSBleHBvcnRzLkRFRkFVTFRfQ0xJRU5UX1BST1BFUlRJRVMgPSBleHBvcnRzLkNsb2NrID0gZXhwb3J0cy5TaW1wbGVLZXlzdG9yZSA9IGV4cG9ydHMuY2hlY2tDb25uZWN0aW9uID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBleHBvcnRzLk5FVFdPUktfUFJFU0VUUyA9IHZvaWQgMDtcbmNvbnN0IGZhc3Rfc2FmZV9zdHJpbmdpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZmFzdC1zYWZlLXN0cmluZ2lmeVwiKSk7XG5jb25zdCBjb3JlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2NvcmVcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgQ29ubmVjdGlvbkNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL0Nvbm5lY3Rpb25Db250cm9sbGVyXCIpO1xuY29uc3QgU3Vic2NyaXB0aW9uQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4vU3Vic2NyaXB0aW9uQ29udHJvbGxlclwiKTtcbmNvbnN0IEFjY291bnRzU3RvcmFnZV8xID0gcmVxdWlyZShcIi4vQWNjb3VudHNTdG9yYWdlXCIpO1xudmFyIENvbm5lY3Rpb25Db250cm9sbGVyXzIgPSByZXF1aXJlKFwiLi9Db25uZWN0aW9uQ29udHJvbGxlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5FVFdPUktfUFJFU0VUU1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ29ubmVjdGlvbkNvbnRyb2xsZXJfMi5ORVRXT1JLX1BSRVNFVFM7IH0gfSk7XG52YXIgQ29ubmVjdGlvbkNvbnRyb2xsZXJfMyA9IHJlcXVpcmUoXCIuL0Nvbm5lY3Rpb25Db250cm9sbGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvbkVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDb25uZWN0aW9uQ29udHJvbGxlcl8zLkNvbm5lY3Rpb25FcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNoZWNrQ29ubmVjdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ29ubmVjdGlvbkNvbnRyb2xsZXJfMy5jaGVja0Nvbm5lY3Rpb247IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQWNjb3VudHNTdG9yYWdlXCIpLCBleHBvcnRzKTtcbnZhciBrZXlzdG9yZV8xID0gcmVxdWlyZShcIi4va2V5c3RvcmVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaW1wbGVLZXlzdG9yZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ga2V5c3RvcmVfMS5TaW1wbGVLZXlzdG9yZTsgfSB9KTtcbnZhciBjbG9ja18xID0gcmVxdWlyZShcIi4vY2xvY2tcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbG9ja1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xvY2tfMS5DbG9jazsgfSB9KTtcbmNvbnN0IHsgZW5zdXJlTmVrb3RvbkxvYWRlZCwgbmVrb3RvbiB9ID0gY29yZV8xLmRlZmF1bHQ7XG5mdW5jdGlvbiB2YWxpZGF0ZU1lc3NhZ2VQcm9wZXJ0aWVzKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBtID0gbWVzc2FnZSB8fCB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXRyeUNvdW50OiBtLnJldHJ5Q291bnQgIT0gbnVsbCA/IE1hdGgubWF4KDEsIH5+bS5yZXRyeUNvdW50KSA6IDUsXG4gICAgICAgIHRpbWVvdXQ6IG0udGltZW91dCAhPSBudWxsID8gTWF0aC5tYXgoMSwgfn5tLnRpbWVvdXQpIDogNjAsXG4gICAgICAgIHRpbWVvdXRHcm93RmFjdG9yOiBtLnRpbWVvdXRHcm93RmFjdG9yIHx8IDEuMixcbiAgICAgICAgcmV0cnlUcmFuc2ZlcnM6IHRydWUsXG4gICAgfTtcbn1cbi8qKlxuICogQGNhdGVnb3J5IENsaWVudFxuICovXG5leHBvcnRzLkRFRkFVTFRfQ0xJRU5UX1BST1BFUlRJRVMgPSB7XG4gICAgY29ubmVjdGlvbjogQ29ubmVjdGlvbkNvbnRyb2xsZXJfMS5ERUZBVUxUX05FVFdPUktfR1JPVVAsXG59O1xuLyoqXG4gKiBAY2F0ZWdvcnkgQ2xpZW50XG4gKi9cbmV4cG9ydHMuVkVSU0lPTiA9ICcwLjIuMjUnO1xuLyoqXG4gKiBAY2F0ZWdvcnkgQ2xpZW50XG4gKi9cbmV4cG9ydHMuU1VQUE9SVEVEX1BFUk1JU1NJT05TID0gWydiYXNpYycsICdhY2NvdW50SW50ZXJhY3Rpb24nXTtcbi8qKlxuICogQGNhdGVnb3J5IENsaWVudFxuICovXG5jbGFzcyBFdmVyc2NhbGVTdGFuZGFsb25lQ2xpZW50IGV4dGVuZHMgdXRpbHNfMS5TYWZlRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7XG4gICAgICAgICAgICByZXF1ZXN0UGVybWlzc2lvbnMsXG4gICAgICAgICAgICBjaGFuZ2VBY2NvdW50LFxuICAgICAgICAgICAgZGlzY29ubmVjdCxcbiAgICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlLFxuICAgICAgICAgICAgdW5zdWJzY3JpYmVBbGwsXG4gICAgICAgICAgICBnZXRQcm92aWRlclN0YXRlLFxuICAgICAgICAgICAgZ2V0RnVsbENvbnRyYWN0U3RhdGUsXG4gICAgICAgICAgICBnZXRBY2NvdW50c0J5Q29kZUhhc2gsXG4gICAgICAgICAgICBnZXRUcmFuc2FjdGlvbnMsXG4gICAgICAgICAgICBnZXRUcmFuc2FjdGlvbixcbiAgICAgICAgICAgIGZpbmRUcmFuc2FjdGlvbixcbiAgICAgICAgICAgIHJ1bkxvY2FsLFxuICAgICAgICAgICAgZ2V0RXhwZWN0ZWRBZGRyZXNzLFxuICAgICAgICAgICAgZ2V0Qm9jSGFzaCxcbiAgICAgICAgICAgIHBhY2tJbnRvQ2VsbCxcbiAgICAgICAgICAgIHVucGFja0Zyb21DZWxsLFxuICAgICAgICAgICAgZXh0cmFjdFB1YmxpY0tleSxcbiAgICAgICAgICAgIGNvZGVUb1R2YyxcbiAgICAgICAgICAgIG1lcmdlVHZjLFxuICAgICAgICAgICAgc3BsaXRUdmMsXG4gICAgICAgICAgICBzZXRDb2RlU2FsdCxcbiAgICAgICAgICAgIGdldENvZGVTYWx0LFxuICAgICAgICAgICAgZW5jb2RlSW50ZXJuYWxJbnB1dCxcbiAgICAgICAgICAgIGRlY29kZUlucHV0LFxuICAgICAgICAgICAgZGVjb2RlT3V0cHV0LFxuICAgICAgICAgICAgZGVjb2RlRXZlbnQsXG4gICAgICAgICAgICBkZWNvZGVUcmFuc2FjdGlvbixcbiAgICAgICAgICAgIGRlY29kZVRyYW5zYWN0aW9uRXZlbnRzLFxuICAgICAgICAgICAgdmVyaWZ5U2lnbmF0dXJlLFxuICAgICAgICAgICAgc2VuZFVuc2lnbmVkRXh0ZXJuYWxNZXNzYWdlLFxuICAgICAgICAgICAgLy8gYWRkQXNzZXQsIC8vIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIHNpZ25EYXRhLFxuICAgICAgICAgICAgc2lnbkRhdGFSYXcsXG4gICAgICAgICAgICAvLyBlbmNyeXB0RGF0YSwgLy8gbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgLy8gZGVjcnlwdERhdGEsIC8vIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIC8vIGVzdGltYXRlRmVlcywgLy8gbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgc2VuZE1lc3NhZ2UsXG4gICAgICAgICAgICBzZW5kTWVzc2FnZURlbGF5ZWQsXG4gICAgICAgICAgICBzZW5kRXh0ZXJuYWxNZXNzYWdlLFxuICAgICAgICAgICAgc2VuZEV4dGVybmFsTWVzc2FnZURlbGF5ZWQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjdHg7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIGF3YWl0IGVuc3VyZU5la290b25Mb2FkZWQocGFyYW1zLmluaXRJbnB1dCk7XG4gICAgICAgIC8vIE5PVEU6IGNhcHR1cmUgY2xpZW50IGluc2lkZSBub3RpZnkgdXNpbmcgd3JhcHBlciBvYmplY3RcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uQ29udGV4dCA9IHt9O1xuICAgICAgICBjb25zdCBub3RpZnkgPSAobWV0aG9kLCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IG5vdGlmaWNhdGlvbkNvbnRleHQuY2xpZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW1pdChtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsb2NrID0gbmV3IGNvcmVfMS5kZWZhdWx0Lm5la290b24uQ2xvY2tXaXRoT2Zmc2V0KCk7XG4gICAgICAgIGlmIChwYXJhbXMuY2xvY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyYW1zLmNsb2NrWydpbXBscyddLnB1c2goY2xvY2spO1xuICAgICAgICAgICAgY2xvY2sudXBkYXRlT2Zmc2V0KHBhcmFtcy5jbG9jay5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uQ29udHJvbGxlciA9IGF3YWl0ICgwLCBDb25uZWN0aW9uQ29udHJvbGxlcl8xLmNyZWF0ZUNvbm5lY3Rpb25Db250cm9sbGVyKShjbG9jaywgcGFyYW1zLmNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uQ29udHJvbGxlciA9IG5ldyBTdWJzY3JpcHRpb25Db250cm9sbGVyXzEuU3Vic2NyaXB0aW9uQ29udHJvbGxlcihjb25uZWN0aW9uQ29udHJvbGxlciwgbm90aWZ5KTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBFdmVyc2NhbGVTdGFuZGFsb25lQ2xpZW50KHtcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczoge30sXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbkNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZhbGlkYXRlTWVzc2FnZVByb3BlcnRpZXMocGFyYW1zLm1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAga2V5c3RvcmU6IHBhcmFtcy5rZXlzdG9yZSxcbiAgICAgICAgICAgICAgICBhY2NvdW50c1N0b3JhZ2U6IHBhcmFtcy5hY2NvdW50c1N0b3JhZ2UsXG4gICAgICAgICAgICAgICAgY2xvY2ssXG4gICAgICAgICAgICAgICAgbm90aWZ5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBOT1RFOiBXZWFrUmVmIGlzIG5vdCB3b3JraW5nIGhlcmUsIHNvIGhvcGUgaXQgd2lsbCBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICAgICAgICAgICAgbm90aWZpY2F0aW9uQ29udGV4dC5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmNsb2NrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuY2xvY2tbJ2ltcGxzJ10ucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbG9jay5mcmVlKCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3QocmVxKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9oYW5kbGVyc1tyZXEubWV0aG9kXTtcbiAgICAgICAgaWYgKGhhbmRsZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgTWV0aG9kICcke3JlcS5tZXRob2R9JyBpcyBub3Qgc3VwcG9ydGVkIGJ5IHN0YW5kYWxvbmUgcHJvdmlkZXJgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlcih0aGlzLl9jb250ZXh0LCByZXEpO1xuICAgIH1cbiAgICBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLm9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHByZXBlbmRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHByZXBlbmRPbmNlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIucHJlcGVuZE9uY2VMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG59XG5leHBvcnRzLkV2ZXJzY2FsZVN0YW5kYWxvbmVDbGllbnQgPSBFdmVyc2NhbGVTdGFuZGFsb25lQ2xpZW50O1xuY29uc3QgcmVxdWVzdFBlcm1pc3Npb25zID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgcGVybWlzc2lvbnMgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZUFycmF5KHJlcSwgcmVxLnBhcmFtcywgJ3Blcm1pc3Npb25zJyk7XG4gICAgY29uc3QgbmV3UGVybWlzc2lvbnMgPSB7IC4uLmN0eC5wZXJtaXNzaW9ucyB9O1xuICAgIGZvciAoY29uc3QgcGVybWlzc2lvbiBvZiBwZXJtaXNzaW9ucykge1xuICAgICAgICBpZiAocGVybWlzc2lvbiA9PT0gJ2Jhc2ljJyB8fCBwZXJtaXNzaW9uID09PSAndG9uQ2xpZW50Jykge1xuICAgICAgICAgICAgbmV3UGVybWlzc2lvbnMuYmFzaWMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBlcm1pc3Npb24gPT09ICdhY2NvdW50SW50ZXJhY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAobmV3UGVybWlzc2lvbnMuYWNjb3VudEludGVyYWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1Blcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbiA9IGF3YWl0IG1ha2VBY2NvdW50SW50ZXJhY3Rpb25QZXJtaXNzaW9uKHJlcSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYFBlcm1pc3Npb24gJyR7cGVybWlzc2lvbn0nIGlzIG5vdCBzdXBwb3J0ZWQgYnkgc3RhbmRhbG9uZSBwcm92aWRlcmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGN0eC5wZXJtaXNzaW9ucyA9IG5ld1Blcm1pc3Npb25zO1xuICAgIC8vIE5PVEU6IGJlIHN1cmUgdG8gcmV0dXJuIG9iamVjdCBjb3B5IHRvIHByZXZlbnQgYWRkaW5nIG5ldyBwZXJtaXNzaW9uc1xuICAgIGNvbnN0IHBlcm1pc3Npb25zQ29weSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobmV3UGVybWlzc2lvbnMpKTtcbiAgICBjdHgubm90aWZ5KCdwZXJtaXNzaW9uc0NoYW5nZWQnLCB7XG4gICAgICAgIHBlcm1pc3Npb25zOiBwZXJtaXNzaW9uc0NvcHksXG4gICAgfSk7XG4gICAgcmV0dXJuIHBlcm1pc3Npb25zQ29weTtcbn07XG5jb25zdCBjaGFuZ2VBY2NvdW50ID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZUFjY291bnRzU3RvcmFnZShyZXEsIGN0eCk7XG4gICAgY29uc3QgbmV3UGVybWlzc2lvbnMgPSB7IC4uLmN0eC5wZXJtaXNzaW9ucyB9O1xuICAgIG5ld1Blcm1pc3Npb25zLmFjY291bnRJbnRlcmFjdGlvbiA9IGF3YWl0IG1ha2VBY2NvdW50SW50ZXJhY3Rpb25QZXJtaXNzaW9uKHJlcSwgY3R4KTtcbiAgICBjdHgucGVybWlzc2lvbnMgPSBuZXdQZXJtaXNzaW9ucztcbiAgICAvLyBOT1RFOiBiZSBzdXJlIHRvIHJldHVybiBvYmplY3QgY29weSB0byBwcmV2ZW50IGFkZGluZyBuZXcgcGVybWlzc2lvbnNcbiAgICBjb25zdCBwZXJtaXNzaW9uc0NvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG5ld1Blcm1pc3Npb25zKSk7XG4gICAgY3R4Lm5vdGlmeSgncGVybWlzc2lvbnNDaGFuZ2VkJywge1xuICAgICAgICBwZXJtaXNzaW9uczogcGVybWlzc2lvbnNDb3B5LFxuICAgIH0pO1xuICAgIHJldHVybiBwZXJtaXNzaW9uc0NvcHk7XG59O1xuY29uc3QgZGlzY29ubmVjdCA9IGFzeW5jIChjdHgsIF9yZXEpID0+IHtcbiAgICBjdHgucGVybWlzc2lvbnMgPSB7fTtcbiAgICBhd2FpdCBjdHguc3Vic2NyaXB0aW9uQ29udHJvbGxlci51bnN1YnNjcmliZUZyb21BbGxDb250cmFjdHMoKTtcbiAgICBjdHgubm90aWZ5KCdwZXJtaXNzaW9uc0NoYW5nZWQnLCB7IHBlcm1pc3Npb25zOiB7fSB9KTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmNvbnN0IHN1YnNjcmliZSA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IGFkZHJlc3MsIHN1YnNjcmlwdGlvbnMgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdhZGRyZXNzJyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsT2JqZWN0KHJlcSwgcmVxLnBhcmFtcywgJ3N1YnNjcmlwdGlvbnMnKTtcbiAgICBsZXQgcmVwYWNrZWRBZGRyZXNzO1xuICAgIHRyeSB7XG4gICAgICAgIHJlcGFja2VkQWRkcmVzcyA9IG5la290b24ucmVwYWNrQWRkcmVzcyhhZGRyZXNzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgY3R4LnN1YnNjcmlwdGlvbkNvbnRyb2xsZXIuc3Vic2NyaWJlVG9Db250cmFjdChyZXBhY2tlZEFkZHJlc3MsIHN1YnNjcmlwdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IHVuc3Vic2NyaWJlID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgYWRkcmVzcyB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2FkZHJlc3MnKTtcbiAgICBsZXQgcmVwYWNrZWRBZGRyZXNzO1xuICAgIHRyeSB7XG4gICAgICAgIHJlcGFja2VkQWRkcmVzcyA9IG5la290b24ucmVwYWNrQWRkcmVzcyhhZGRyZXNzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBhd2FpdCBjdHguc3Vic2NyaXB0aW9uQ29udHJvbGxlci51bnN1YnNjcmliZUZyb21Db250cmFjdChyZXBhY2tlZEFkZHJlc3MpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuY29uc3QgdW5zdWJzY3JpYmVBbGwgPSBhc3luYyAoY3R4LCBfcmVxKSA9PiB7XG4gICAgYXdhaXQgY3R4LnN1YnNjcmlwdGlvbkNvbnRyb2xsZXIudW5zdWJzY3JpYmVGcm9tQWxsQ29udHJhY3RzKCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5jb25zdCBnZXRQcm92aWRlclN0YXRlID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgY29uc3QgdHJhbnNwb3J0ID0gY3R4LmNvbm5lY3Rpb25Db250cm9sbGVyLmluaXRpYWxpemVkVHJhbnNwb3J0O1xuICAgIGlmICh0cmFuc3BvcnQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsICdDb25uZWN0aW9uIGNvbnRyb2xsZXIgd2FzIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH1cbiAgICBjb25zdCB2ZXJzaW9uID0gZXhwb3J0cy5WRVJTSU9OO1xuICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIG51bWVyaWNWZXJzaW9uOiAoMCwgdXRpbHNfMS5jb252ZXJ0VmVyc2lvblRvSW50MzIpKHZlcnNpb24pLFxuICAgICAgICBuZXR3b3JrSWQ6IHRyYW5zcG9ydC5pZCxcbiAgICAgICAgc2VsZWN0ZWRDb25uZWN0aW9uOiB0cmFuc3BvcnQuZ3JvdXAsXG4gICAgICAgIHN1cHBvcnRlZFBlcm1pc3Npb25zOiBbLi4uZXhwb3J0cy5TVVBQT1JURURfUEVSTUlTU0lPTlNdLFxuICAgICAgICBwZXJtaXNzaW9uczogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjdHgucGVybWlzc2lvbnMpKSxcbiAgICAgICAgc3Vic2NyaXB0aW9uczogY3R4LnN1YnNjcmlwdGlvbkNvbnRyb2xsZXIuc3Vic2NyaXB0aW9uU3RhdGVzLFxuICAgIH07XG59O1xuY29uc3QgZ2V0RnVsbENvbnRyYWN0U3RhdGUgPSBhc3luYyAoY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBhZGRyZXNzIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYWRkcmVzcycpO1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbkNvbnRyb2xsZXIgfSA9IGN0eDtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbkNvbnRyb2xsZXIudXNlKGFzeW5jICh7IGRhdGE6IHsgdHJhbnNwb3J0IH0gfSkgPT4gKHtcbiAgICAgICAgICAgIHN0YXRlOiBhd2FpdCB0cmFuc3BvcnQuZ2V0RnVsbENvbnRyYWN0U3RhdGUoYWRkcmVzcyksXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBnZXRBY2NvdW50c0J5Q29kZUhhc2ggPSBhc3luYyAoY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBjb2RlSGFzaCwgbGltaXQsIGNvbnRpbnVhdGlvbiB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2NvZGVIYXNoJyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsTnVtYmVyKHJlcSwgcmVxLnBhcmFtcywgJ2xpbWl0Jyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2NvbnRpbnVhdGlvbicpO1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbkNvbnRyb2xsZXIgfSA9IGN0eDtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbkNvbnRyb2xsZXIudXNlKCh7IGRhdGE6IHsgdHJhbnNwb3J0IH0gfSkgPT4gdHJhbnNwb3J0LmdldEFjY291bnRzQnlDb2RlSGFzaChjb2RlSGFzaCwgbGltaXQgfHwgNTAsIGNvbnRpbnVhdGlvbikpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGdldFRyYW5zYWN0aW9ucyA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGNvbnRpbnVhdGlvbiwgbGltaXQgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdhZGRyZXNzJyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsKHJlcSwgcmVxLnBhcmFtcywgJ2NvbnRpbnVhdGlvbicsIHJlcXVpcmVUcmFuc2FjdGlvbklkKTtcbiAgICByZXF1aXJlT3B0aW9uYWxOdW1iZXIocmVxLCByZXEucGFyYW1zLCAnbGltaXQnKTtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25Db250cm9sbGVyIH0gPSBjdHg7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25Db250cm9sbGVyLnVzZSgoeyBkYXRhOiB7IHRyYW5zcG9ydCB9IH0pID0+IHRyYW5zcG9ydC5nZXRUcmFuc2FjdGlvbnMoYWRkcmVzcywgY29udGludWF0aW9uID09PSBudWxsIHx8IGNvbnRpbnVhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGludWF0aW9uLmx0LCBsaW1pdCB8fCA1MCkpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGdldFRyYW5zYWN0aW9uID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgaGFzaCB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2hhc2gnKTtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25Db250cm9sbGVyIH0gPSBjdHg7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBhd2FpdCBjb25uZWN0aW9uQ29udHJvbGxlci51c2UoKHsgZGF0YTogeyB0cmFuc3BvcnQgfSB9KSA9PiB0cmFuc3BvcnQuZ2V0VHJhbnNhY3Rpb24oaGFzaCkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGZpbmRUcmFuc2FjdGlvbiA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IGluTWVzc2FnZUhhc2ggfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZU9wdGlvbmFsKHJlcSwgcmVxLnBhcmFtcywgJ2luTWVzc2FnZUhhc2gnLCByZXF1aXJlU3RyaW5nKTtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25Db250cm9sbGVyIH0gPSBjdHg7XG4gICAgLy8gVE9ETzogYWRkIG1vcmUgZmlsdGVyc1xuICAgIGlmIChpbk1lc3NhZ2VIYXNoID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogYXdhaXQgY29ubmVjdGlvbkNvbnRyb2xsZXIudXNlKCh7IGRhdGE6IHsgdHJhbnNwb3J0IH0gfSkgPT4gdHJhbnNwb3J0LmdldERzdFRyYW5zYWN0aW9uKGluTWVzc2FnZUhhc2gpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBydW5Mb2NhbCA9IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGNhY2hlZFN0YXRlLCByZXNwb25zaWJsZSwgZnVuY3Rpb25DYWxsIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYWRkcmVzcycpO1xuICAgIHJlcXVpcmVPcHRpb25hbChyZXEsIHJlcS5wYXJhbXMsICdjYWNoZWRTdGF0ZScsIHJlcXVpcmVDb250cmFjdFN0YXRlKTtcbiAgICByZXF1aXJlT3B0aW9uYWxCb29sZWFuKHJlcSwgcmVxLnBhcmFtcywgJ3Jlc3BvbnNpYmxlJyk7XG4gICAgcmVxdWlyZUZ1bmN0aW9uQ2FsbChyZXEsIHJlcS5wYXJhbXMsICdmdW5jdGlvbkNhbGwnKTtcbiAgICBjb25zdCB7IGNsb2NrLCBjb25uZWN0aW9uQ29udHJvbGxlciB9ID0gY3R4O1xuICAgIGxldCBjb250cmFjdFN0YXRlID0gY2FjaGVkU3RhdGU7XG4gICAgaWYgKGNvbnRyYWN0U3RhdGUgPT0gbnVsbCkge1xuICAgICAgICBjb250cmFjdFN0YXRlID0gYXdhaXQgY29ubmVjdGlvbkNvbnRyb2xsZXIudXNlKGFzeW5jICh7IGRhdGE6IHsgdHJhbnNwb3J0IH0gfSkgPT4gdHJhbnNwb3J0LmdldEZ1bGxDb250cmFjdFN0YXRlKGFkZHJlc3MpKTtcbiAgICB9XG4gICAgaWYgKGNvbnRyYWN0U3RhdGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsICdBY2NvdW50IG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbnRyYWN0U3RhdGUuaXNEZXBsb3llZCB8fCBjb250cmFjdFN0YXRlLmxhc3RUcmFuc2FjdGlvbklkID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCAnQWNjb3VudCBpcyBub3QgZGVwbG95ZWQnKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBvdXRwdXQsIGNvZGUgfSA9IG5la290b24ucnVuTG9jYWwoY2xvY2ssIGNvbnRyYWN0U3RhdGUuYm9jLCBmdW5jdGlvbkNhbGwuYWJpLCBmdW5jdGlvbkNhbGwubWV0aG9kLCBmdW5jdGlvbkNhbGwucGFyYW1zLCByZXNwb25zaWJsZSB8fCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB7IG91dHB1dCwgY29kZSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGdldEV4cGVjdGVkQWRkcmVzcyA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyB0dmMsIGFiaSwgd29ya2NoYWluLCBwdWJsaWNLZXksIGluaXRQYXJhbXMgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICd0dmMnKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2FiaScpO1xuICAgIHJlcXVpcmVPcHRpb25hbE51bWJlcihyZXEsIHJlcS5wYXJhbXMsICd3b3JrY2hhaW4nKTtcbiAgICByZXF1aXJlT3B0aW9uYWxTdHJpbmcocmVxLCByZXEucGFyYW1zLCAncHVibGljS2V5Jyk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5la290b24uZ2V0RXhwZWN0ZWRBZGRyZXNzKHR2YywgYWJpLCB3b3JrY2hhaW4gfHwgMCwgcHVibGljS2V5LCBpbml0UGFyYW1zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBnZXRCb2NIYXNoID0gYXN5bmMgKF9jdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IGJvYyB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2JvYycpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IGhhc2g6IG5la290b24uZ2V0Qm9jSGFzaChib2MpIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3QgcGFja0ludG9DZWxsID0gYXN5bmMgKF9jdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IHN0cnVjdHVyZSwgZGF0YSwgYWJpVmVyc2lvbiB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlQXJyYXkocmVxLCByZXEucGFyYW1zLCAnc3RydWN0dXJlJyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsKHJlcSwgcmVxLnBhcmFtcywgJ2FiaVZlcnNpb24nLCByZXF1aXJlU3RyaW5nKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyBib2M6IG5la290b24ucGFja0ludG9DZWxsKHN0cnVjdHVyZSwgZGF0YSwgYWJpVmVyc2lvbikgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCB1bnBhY2tGcm9tQ2VsbCA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBzdHJ1Y3R1cmUsIGJvYywgYWxsb3dQYXJ0aWFsLCBhYmlWZXJzaW9uIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVBcnJheShyZXEsIHJlcS5wYXJhbXMsICdzdHJ1Y3R1cmUnKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2JvYycpO1xuICAgIHJlcXVpcmVCb29sZWFuKHJlcSwgcmVxLnBhcmFtcywgJ2FsbG93UGFydGlhbCcpO1xuICAgIHJlcXVpcmVPcHRpb25hbChyZXEsIHJlcS5wYXJhbXMsICdhYmlWZXJzaW9uJywgcmVxdWlyZVN0cmluZyk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbmVrb3Rvbi51bnBhY2tGcm9tQ2VsbChzdHJ1Y3R1cmUsIGJvYywgYWxsb3dQYXJ0aWFsLCBhYmlWZXJzaW9uKSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGV4dHJhY3RQdWJsaWNLZXkgPSBhc3luYyAoX2N0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgYm9jIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYm9jJyk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgcHVibGljS2V5OiBuZWtvdG9uLmV4dHJhY3RQdWJsaWNLZXkoYm9jKSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGNvZGVUb1R2YyA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBjb2RlIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnY29kZScpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IHR2YzogbmVrb3Rvbi5jb2RlVG9UdmMoY29kZSkgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBtZXJnZVR2YyA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBjb2RlLCBkYXRhIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnY29kZScpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnZGF0YScpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IHR2YzogbmVrb3Rvbi5tZXJnZVR2Yyhjb2RlLCBkYXRhKSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IHNwbGl0VHZjID0gYXN5bmMgKF9jdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IHR2YyB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3R2YycpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZWtvdG9uLnNwbGl0VHZjKHR2Yyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3Qgc2V0Q29kZVNhbHQgPSBhc3luYyAoX2N0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgY29kZSwgc2FsdCB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2NvZGUnKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3NhbHQnKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyBjb2RlOiBuZWtvdG9uLnNldENvZGVTYWx0KGNvZGUsIHNhbHQpIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3QgZ2V0Q29kZVNhbHQgPSBhc3luYyAoX2N0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZVBhcmFtcyhyZXEpO1xuICAgIGNvbnN0IHsgY29kZSB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2NvZGUnKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyBzYWx0OiBuZWtvdG9uLmdldENvZGVTYWx0KGNvZGUpIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3QgZW5jb2RlSW50ZXJuYWxJbnB1dCA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgcmVxdWlyZUZ1bmN0aW9uQ2FsbChyZXEsIHJlcSwgJ3BhcmFtcycpO1xuICAgIGNvbnN0IHsgYWJpLCBtZXRob2QsIHBhcmFtcyB9ID0gcmVxLnBhcmFtcztcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyBib2M6IG5la290b24uZW5jb2RlSW50ZXJuYWxJbnB1dChhYmksIG1ldGhvZCwgcGFyYW1zKSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGRlY29kZUlucHV0ID0gYXN5bmMgKF9jdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IGJvZHksIGFiaSwgbWV0aG9kLCBpbnRlcm5hbCB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2JvZHknKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2FiaScpO1xuICAgIHJlcXVpcmVNZXRob2RPckFycmF5KHJlcSwgcmVxLnBhcmFtcywgJ21ldGhvZCcpO1xuICAgIHJlcXVpcmVCb29sZWFuKHJlcSwgcmVxLnBhcmFtcywgJ2ludGVybmFsJyk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5la290b24uZGVjb2RlSW5wdXQoYm9keSwgYWJpLCBtZXRob2QsIGludGVybmFsKSB8fCBudWxsO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGRlY29kZU91dHB1dCA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBib2R5LCBhYmksIG1ldGhvZCB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2JvZHknKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2FiaScpO1xuICAgIHJlcXVpcmVNZXRob2RPckFycmF5KHJlcSwgcmVxLnBhcmFtcywgJ21ldGhvZCcpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZWtvdG9uLmRlY29kZU91dHB1dChib2R5LCBhYmksIG1ldGhvZCkgfHwgbnVsbDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBkZWNvZGVFdmVudCA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBib2R5LCBhYmksIGV2ZW50IH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYm9keScpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYWJpJyk7XG4gICAgcmVxdWlyZU1ldGhvZE9yQXJyYXkocmVxLCByZXEucGFyYW1zLCAnZXZlbnQnKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmVrb3Rvbi5kZWNvZGVFdmVudChib2R5LCBhYmksIGV2ZW50KSB8fCBudWxsO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGRlY29kZVRyYW5zYWN0aW9uID0gYXN5bmMgKF9jdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9uLCBhYmksIG1ldGhvZCB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2FiaScpO1xuICAgIHJlcXVpcmVNZXRob2RPckFycmF5KHJlcSwgcmVxLnBhcmFtcywgJ21ldGhvZCcpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZWtvdG9uLmRlY29kZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBhYmksIG1ldGhvZCkgfHwgbnVsbDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBkZWNvZGVUcmFuc2FjdGlvbkV2ZW50cyA9IGFzeW5jIChfY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbiwgYWJpIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYWJpJyk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgZXZlbnRzOiBuZWtvdG9uLmRlY29kZVRyYW5zYWN0aW9uRXZlbnRzKHRyYW5zYWN0aW9uLCBhYmkpIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG59O1xuY29uc3QgdmVyaWZ5U2lnbmF0dXJlID0gYXN5bmMgKF9jdHgsIHJlcSkgPT4ge1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IHB1YmxpY0tleSwgZGF0YUhhc2gsIHNpZ25hdHVyZSB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3B1YmxpY0tleScpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnZGF0YUhhc2gnKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3NpZ25hdHVyZScpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IG5la290b24udmVyaWZ5U2lnbmF0dXJlKHB1YmxpY0tleSwgZGF0YUhhc2gsIHNpZ25hdHVyZSkgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBzZW5kVW5zaWduZWRFeHRlcm5hbE1lc3NhZ2UgPSBhc3luYyAoY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyByZWNpcGllbnQsIHN0YXRlSW5pdCwgcGF5bG9hZCwgbG9jYWwgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdyZWNpcGllbnQnKTtcbiAgICByZXF1aXJlT3B0aW9uYWxTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnc3RhdGVJbml0Jyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsUmF3RnVuY3Rpb25DYWxsKHJlcSwgcmVxLnBhcmFtcywgJ3BheWxvYWQnKTtcbiAgICByZXF1aXJlT3B0aW9uYWxCb29sZWFuKHJlcSwgcmVxLnBhcmFtcywgJ2xvY2FsJyk7XG4gICAgbGV0IHJlcGFja2VkUmVjaXBpZW50O1xuICAgIHRyeSB7XG4gICAgICAgIHJlcGFja2VkUmVjaXBpZW50ID0gbmVrb3Rvbi5yZXBhY2tBZGRyZXNzKHJlY2lwaWVudCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgY29uc3QgeyBjbG9jaywgc3Vic2NyaXB0aW9uQ29udHJvbGxlciwgcHJvcGVydGllcyB9ID0gY3R4O1xuICAgIGNvbnN0IG1ha2VTaWduZWRNZXNzYWdlID0gKHRpbWVvdXQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycgfHwgcGF5bG9hZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwaXJlQXQgPSB+fihjbG9jay5ub3dNcyAvIDEwMDApICsgdGltZW91dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmVrb3Rvbi5jcmVhdGVSYXdFeHRlcm5hbE1lc3NhZ2UocmVwYWNrZWRSZWNpcGllbnQsIHN0YXRlSW5pdCwgcGF5bG9hZCwgZXhwaXJlQXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5la290b24uY3JlYXRlRXh0ZXJuYWxNZXNzYWdlV2l0aG91dFNpZ25hdHVyZShjbG9jaywgcmVwYWNrZWRSZWNpcGllbnQsIHBheWxvYWQuYWJpLCBwYXlsb2FkLm1ldGhvZCwgc3RhdGVJbml0LCBwYXlsb2FkLnBhcmFtcywgdGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlVHJhbnNhY3Rpb24gPSAodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgICAgbGV0IG91dHB1dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBheWxvYWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY29kZWQgPSBuZWtvdG9uLmRlY29kZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBwYXlsb2FkLmFiaSwgcGF5bG9hZC5tZXRob2QpO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IGRlY29kZWQgPT09IG51bGwgfHwgZGVjb2RlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVjb2RlZC5vdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHsgLyogZG8gbm90aGluZyAqL1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRyYW5zYWN0aW9uLCBvdXRwdXQgfTtcbiAgICB9O1xuICAgIC8vIEZvcmNlIGxvY2FsIGV4ZWN1dGlvblxuICAgIGlmIChsb2NhbCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBzaWduZWRNZXNzYWdlID0gbWFrZVNpZ25lZE1lc3NhZ2UoNjApO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHN1YnNjcmlwdGlvbkNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VMb2NhbGx5KHJlcGFja2VkUmVjaXBpZW50LCBzaWduZWRNZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgLy8gU2VuZCBhbmQgd2FpdCB3aXRoIHNldmVyYWwgcmV0cmllc1xuICAgIGxldCB0aW1lb3V0ID0gcHJvcGVydGllcy5tZXNzYWdlLnRpbWVvdXQ7XG4gICAgZm9yIChsZXQgcmV0cnkgPSAwOyByZXRyeSA8IHByb3BlcnRpZXMubWVzc2FnZS5yZXRyeUNvdW50OyArK3JldHJ5KSB7XG4gICAgICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2UgPSBtYWtlU2lnbmVkTWVzc2FnZSh0aW1lb3V0KTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCBzdWJzY3JpcHRpb25Db250cm9sbGVyLnNlbmRNZXNzYWdlKHJlcGFja2VkUmVjaXBpZW50LCBzaWduZWRNZXNzYWdlKTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgKj0gcHJvcGVydGllcy5tZXNzYWdlLnRpbWVvdXRHcm93RmFjdG9yO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgLy8gRXhlY3V0ZSBsb2NhbGx5XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ01lc3NhZ2UgZXhwaXJlZCc7XG4gICAgY29uc3Qgc2lnbmVkTWVzc2FnZSA9IG1ha2VTaWduZWRNZXNzYWdlKDYwKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHN1YnNjcmlwdGlvbkNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VMb2NhbGx5KHJlcGFja2VkUmVjaXBpZW50LCBzaWduZWRNZXNzYWdlKVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgJHtlcnJvck1lc3NhZ2V9LiAke2UudG9TdHJpbmcoKX1gKTtcbiAgICB9KTtcbiAgICBjb25zdCBhZGRpdGlvbmFsVGV4dCA9IHRyYW5zYWN0aW9uLmV4aXRDb2RlICE9IG51bGwgPyBgLiBQb3NzaWJsZSBleGl0IGNvZGU6ICR7dHJhbnNhY3Rpb24uZXhpdENvZGV9YCA6ICcnO1xuICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYCR7ZXJyb3JNZXNzYWdlfSR7YWRkaXRpb25hbFRleHR9YCk7XG59O1xuY29uc3Qgc2lnbkRhdGEgPSBhc3luYyAoY3R4LCByZXEpID0+IHtcbiAgICByZXF1aXJlS2V5c3RvcmUocmVxLCBjdHgpO1xuICAgIHJlcXVpcmVQYXJhbXMocmVxKTtcbiAgICBjb25zdCB7IHB1YmxpY0tleSwgZGF0YSB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3B1YmxpY0tleScpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnZGF0YScpO1xuICAgIGNvbnN0IHsga2V5c3RvcmUgfSA9IGN0eDtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBrZXlzdG9yZS5nZXRTaWduZXIocHVibGljS2V5KTtcbiAgICBpZiAoc2lnbmVyID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCAnU2lnbmVyIG5vdCBmb3VuZCBmb3IgcHVibGljIGtleScpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhSGFzaCA9IG5la290b24uZ2V0RGF0YUhhc2goZGF0YSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhSGFzaCxcbiAgICAgICAgICAgIC4uLihhd2FpdCBzaWduZXIuc2lnbihkYXRhSGFzaCkudGhlbihuZWtvdG9uLmV4dGVuZFNpZ25hdHVyZSkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IHNpZ25EYXRhUmF3ID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZUtleXN0b3JlKHJlcSwgY3R4KTtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBwdWJsaWNLZXksIGRhdGEgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdwdWJsaWNLZXknKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ2RhdGEnKTtcbiAgICBjb25zdCB7IGtleXN0b3JlIH0gPSBjdHg7XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQga2V5c3RvcmUuZ2V0U2lnbmVyKHB1YmxpY0tleSk7XG4gICAgaWYgKHNpZ25lciA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgJ1NpZ25lciBub3QgZm91bmQgZm9yIHB1YmxpYyBrZXknKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNpZ25lci5zaWduKGRhdGEpLnRoZW4obmVrb3Rvbi5leHRlbmRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IHNlbmRNZXNzYWdlID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZUtleXN0b3JlKHJlcSwgY3R4KTtcbiAgICByZXF1aXJlQWNjb3VudHNTdG9yYWdlKHJlcSwgY3R4KTtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBzZW5kZXIsIHJlY2lwaWVudCwgYW1vdW50LCBib3VuY2UsIHBheWxvYWQgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdzZW5kZXInKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3JlY2lwaWVudCcpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYW1vdW50Jyk7XG4gICAgcmVxdWlyZUJvb2xlYW4ocmVxLCByZXEucGFyYW1zLCAnYm91bmNlJyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsKHJlcSwgcmVxLnBhcmFtcywgJ3BheWxvYWQnLCByZXF1aXJlRnVuY3Rpb25DYWxsKTtcbiAgICBjb25zdCB7IGNsb2NrLCBwcm9wZXJ0aWVzLCBzdWJzY3JpcHRpb25Db250cm9sbGVyLCBjb25uZWN0aW9uQ29udHJvbGxlciwga2V5c3RvcmUsIGFjY291bnRzU3RvcmFnZSB9ID0gY3R4O1xuICAgIGxldCByZXBhY2tlZFNlbmRlcjtcbiAgICBsZXQgcmVwYWNrZWRSZWNpcGllbnQ7XG4gICAgbGV0IGFjY291bnQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVwYWNrZWRTZW5kZXIgPSBuZWtvdG9uLnJlcGFja0FkZHJlc3Moc2VuZGVyKTtcbiAgICAgICAgcmVwYWNrZWRSZWNpcGllbnQgPSBuZWtvdG9uLnJlcGFja0FkZHJlc3MocmVjaXBpZW50KTtcbiAgICAgICAgYWNjb3VudCA9IGF3YWl0IGFjY291bnRzU3RvcmFnZS5nZXRBY2NvdW50KHJlcGFja2VkU2VuZGVyKS50aGVuKChhY2NvdW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoYWNjb3VudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgY29uc3QgbWFrZVNpZ25lZE1lc3NhZ2UgPSBhc3luYyAodGltZW91dCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY291bnQucHJlcGFyZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHJlY2lwaWVudDogcmVwYWNrZWRSZWNpcGllbnQsXG4gICAgICAgICAgICAgICAgYW1vdW50LFxuICAgICAgICAgICAgICAgIGJvdW5jZSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgIHN0YXRlSW5pdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICB9LCBuZXcgQWNjb3VudHNTdG9yYWdlXzEuQWNjb3VudHNTdG9yYWdlQ29udGV4dChjbG9jaywgY29ubmVjdGlvbkNvbnRyb2xsZXIsIG5la290b24sIGtleXN0b3JlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gU2VuZCBhbmQgd2FpdCB3aXRoIHNldmVyYWwgcmV0cmllc1xuICAgIGxldCB0aW1lb3V0ID0gcHJvcGVydGllcy5tZXNzYWdlLnRpbWVvdXQ7XG4gICAgLy8gU2V0IGByZXRyeUNvdW50YCBpZiBub3QgZXhwbGljaXRseSBkaXNhYmxlZFxuICAgIGNvbnN0IHJldHJ5Q291bnQgPSBwcm9wZXJ0aWVzLm1lc3NhZ2UucmV0cnlUcmFuc2ZlcnMgIT09IGZhbHNlID8gcHJvcGVydGllcy5tZXNzYWdlLnJldHJ5Q291bnQgOiAxO1xuICAgIGZvciAobGV0IHJldHJ5ID0gMDsgcmV0cnkgPCByZXRyeUNvdW50OyArK3JldHJ5KSB7XG4gICAgICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2UgPSBhd2FpdCBtYWtlU2lnbmVkTWVzc2FnZSh0aW1lb3V0KTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCBzdWJzY3JpcHRpb25Db250cm9sbGVyLnNlbmRNZXNzYWdlKHJlcGFja2VkU2VuZGVyLCBzaWduZWRNZXNzYWdlKTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgKj0gcHJvcGVydGllcy5tZXNzYWdlLnRpbWVvdXRHcm93RmFjdG9yO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHJhbnNhY3Rpb24gfTtcbiAgICB9XG4gICAgLy8gRXhlY3V0ZSBsb2NhbGx5XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ01lc3NhZ2UgZXhwaXJlZCc7XG4gICAgY29uc3Qgc2lnbmVkTWVzc2FnZSA9IGF3YWl0IG1ha2VTaWduZWRNZXNzYWdlKDYwKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHN1YnNjcmlwdGlvbkNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VMb2NhbGx5KHJlcGFja2VkU2VuZGVyLCBzaWduZWRNZXNzYWdlKVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgJHtlcnJvck1lc3NhZ2V9LiAke2UudG9TdHJpbmcoKX1gKTtcbiAgICB9KTtcbiAgICBjb25zdCBhZGRpdGlvbmFsVGV4dCA9IHRyYW5zYWN0aW9uLmV4aXRDb2RlICE9IG51bGwgPyBgLiBQb3NzaWJsZSBleGl0IGNvZGU6ICR7dHJhbnNhY3Rpb24uZXhpdENvZGV9YCA6ICcnO1xuICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYCR7ZXJyb3JNZXNzYWdlfSR7YWRkaXRpb25hbFRleHR9YCk7XG59O1xuY29uc3Qgc2VuZE1lc3NhZ2VEZWxheWVkID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZUtleXN0b3JlKHJlcSwgY3R4KTtcbiAgICByZXF1aXJlQWNjb3VudHNTdG9yYWdlKHJlcSwgY3R4KTtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBzZW5kZXIsIHJlY2lwaWVudCwgYW1vdW50LCBib3VuY2UsIHBheWxvYWQgfSA9IHJlcS5wYXJhbXM7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdzZW5kZXInKTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3JlY2lwaWVudCcpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnYW1vdW50Jyk7XG4gICAgcmVxdWlyZUJvb2xlYW4ocmVxLCByZXEucGFyYW1zLCAnYm91bmNlJyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsKHJlcSwgcmVxLnBhcmFtcywgJ3BheWxvYWQnLCByZXF1aXJlRnVuY3Rpb25DYWxsKTtcbiAgICBjb25zdCB7IGNsb2NrLCBzdWJzY3JpcHRpb25Db250cm9sbGVyLCBjb25uZWN0aW9uQ29udHJvbGxlciwga2V5c3RvcmUsIGFjY291bnRzU3RvcmFnZSwgbm90aWZ5IH0gPSBjdHg7XG4gICAgbGV0IHJlcGFja2VkU2VuZGVyO1xuICAgIGxldCByZXBhY2tlZFJlY2lwaWVudDtcbiAgICB0cnkge1xuICAgICAgICByZXBhY2tlZFNlbmRlciA9IG5la290b24ucmVwYWNrQWRkcmVzcyhzZW5kZXIpO1xuICAgICAgICByZXBhY2tlZFJlY2lwaWVudCA9IG5la290b24ucmVwYWNrQWRkcmVzcyhyZWNpcGllbnQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGxldCBzaWduZWRNZXNzYWdlO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCBhY2NvdW50c1N0b3JhZ2UuZ2V0QWNjb3VudChyZXBhY2tlZFNlbmRlcik7XG4gICAgICAgIGlmIChhY2NvdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25lZE1lc3NhZ2UgPSBhd2FpdCBhY2NvdW50LnByZXBhcmVNZXNzYWdlKHtcbiAgICAgICAgICAgIHJlY2lwaWVudDogcmVwYWNrZWRSZWNpcGllbnQsXG4gICAgICAgICAgICBhbW91bnQsXG4gICAgICAgICAgICBib3VuY2UsXG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgc3RhdGVJbml0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aW1lb3V0OiA2MCwgLy8gVEVNUFxuICAgICAgICB9LCBuZXcgQWNjb3VudHNTdG9yYWdlXzEuQWNjb3VudHNTdG9yYWdlQ29udGV4dChjbG9jaywgY29ubmVjdGlvbkNvbnRyb2xsZXIsIG5la290b24sIGtleXN0b3JlKSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgc3Vic2NyaXB0aW9uQ29udHJvbGxlci5zZW5kTWVzc2FnZShyZXBhY2tlZFNlbmRlciwgc2lnbmVkTWVzc2FnZSlcbiAgICAgICAgLnRoZW4odHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBub3RpZnkoJ21lc3NhZ2VTdGF0dXNVcGRhdGVkJywge1xuICAgICAgICAgICAgYWRkcmVzczogcmVwYWNrZWRTZW5kZXIsXG4gICAgICAgICAgICBoYXNoOiBzaWduZWRNZXNzYWdlLmhhc2gsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgIGFjY291bnQ6IHJlcGFja2VkU2VuZGVyLFxuICAgICAgICAgICAgaGFzaDogc2lnbmVkTWVzc2FnZS5oYXNoLFxuICAgICAgICAgICAgZXhwaXJlQXQ6IHNpZ25lZE1lc3NhZ2UuZXhwaXJlQXQsXG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5jb25zdCBzZW5kRXh0ZXJuYWxNZXNzYWdlID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZUtleXN0b3JlKHJlcSwgY3R4KTtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBwdWJsaWNLZXksIHJlY2lwaWVudCwgc3RhdGVJbml0LCBwYXlsb2FkLCBsb2NhbCB9ID0gcmVxLnBhcmFtcztcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3B1YmxpY0tleScpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAncmVjaXBpZW50Jyk7XG4gICAgcmVxdWlyZU9wdGlvbmFsU3RyaW5nKHJlcSwgcmVxLnBhcmFtcywgJ3N0YXRlSW5pdCcpO1xuICAgIHJlcXVpcmVGdW5jdGlvbkNhbGwocmVxLCByZXEucGFyYW1zLCAncGF5bG9hZCcpO1xuICAgIHJlcXVpcmVPcHRpb25hbEJvb2xlYW4ocmVxLCByZXEucGFyYW1zLCAnbG9jYWwnKTtcbiAgICBsZXQgcmVwYWNrZWRSZWNpcGllbnQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVwYWNrZWRSZWNpcGllbnQgPSBuZWtvdG9uLnJlcGFja0FkZHJlc3MocmVjaXBpZW50KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBjb25zdCB7IGNsb2NrLCBzdWJzY3JpcHRpb25Db250cm9sbGVyLCBrZXlzdG9yZSwgcHJvcGVydGllcyB9ID0gY3R4O1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IGtleXN0b3JlLmdldFNpZ25lcihwdWJsaWNLZXkpO1xuICAgIGlmIChzaWduZXIgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsICdTaWduZXIgbm90IGZvdW5kIGZvciBwdWJsaWMga2V5Jyk7XG4gICAgfVxuICAgIGNvbnN0IG1ha2VTaWduZWRNZXNzYWdlID0gYXN5bmMgKHRpbWVvdXQpID0+IHtcbiAgICAgICAgbGV0IHVuc2lnbmVkTWVzc2FnZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVuc2lnbmVkTWVzc2FnZSA9IG5la290b24uY3JlYXRlRXh0ZXJuYWxNZXNzYWdlKGNsb2NrLCByZXBhY2tlZFJlY2lwaWVudCwgcGF5bG9hZC5hYmksIHBheWxvYWQubWV0aG9kLCBzdGF0ZUluaXQsIHBheWxvYWQucGFyYW1zLCBwdWJsaWNLZXksIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25lci5zaWduKHVuc2lnbmVkTWVzc2FnZS5oYXNoKTtcbiAgICAgICAgICAgIHJldHVybiB1bnNpZ25lZE1lc3NhZ2Uuc2lnbihzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB1bnNpZ25lZE1lc3NhZ2UuZnJlZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVUcmFuc2FjdGlvbiA9ICh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlZCA9IG5la290b24uZGVjb2RlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHBheWxvYWQuYWJpLCBwYXlsb2FkLm1ldGhvZCk7XG4gICAgICAgICAgICBvdXRwdXQgPSBkZWNvZGVkID09PSBudWxsIHx8IGRlY29kZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlY29kZWQub3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7IC8qIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0cmFuc2FjdGlvbiwgb3V0cHV0IH07XG4gICAgfTtcbiAgICAvLyBGb3JjZSBsb2NhbCBleGVjdXRpb25cbiAgICBpZiAobG9jYWwgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3Qgc2lnbmVkTWVzc2FnZSA9IGF3YWl0IG1ha2VTaWduZWRNZXNzYWdlKDYwKTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCBzdWJzY3JpcHRpb25Db250cm9sbGVyLnNlbmRNZXNzYWdlTG9jYWxseShyZXBhY2tlZFJlY2lwaWVudCwgc2lnbmVkTWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIC8vIFNlbmQgYW5kIHdhaXQgd2l0aCBzZXZlcmFsIHJldHJpZXNcbiAgICBsZXQgdGltZW91dCA9IHByb3BlcnRpZXMubWVzc2FnZS50aW1lb3V0O1xuICAgIGZvciAobGV0IHJldHJ5ID0gMDsgcmV0cnkgPCBwcm9wZXJ0aWVzLm1lc3NhZ2UucmV0cnlDb3VudDsgKytyZXRyeSkge1xuICAgICAgICBjb25zdCBzaWduZWRNZXNzYWdlID0gYXdhaXQgbWFrZVNpZ25lZE1lc3NhZ2UodGltZW91dCk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgc3Vic2NyaXB0aW9uQ29udHJvbGxlci5zZW5kTWVzc2FnZShyZXBhY2tlZFJlY2lwaWVudCwgc2lnbmVkTWVzc2FnZSk7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aW1lb3V0ICo9IHByb3BlcnRpZXMubWVzc2FnZS50aW1lb3V0R3Jvd0ZhY3RvcjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIC8vIEV4ZWN1dGUgbG9jYWxseVxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICdNZXNzYWdlIGV4cGlyZWQnO1xuICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2UgPSBhd2FpdCBtYWtlU2lnbmVkTWVzc2FnZSg2MCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCBzdWJzY3JpcHRpb25Db250cm9sbGVyLnNlbmRNZXNzYWdlTG9jYWxseShyZXBhY2tlZFJlY2lwaWVudCwgc2lnbmVkTWVzc2FnZSlcbiAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYCR7ZXJyb3JNZXNzYWdlfS4gJHtlLnRvU3RyaW5nKCl9YCk7XG4gICAgfSk7XG4gICAgY29uc3QgYWRkaXRpb25hbFRleHQgPSB0cmFuc2FjdGlvbi5leGl0Q29kZSAhPSBudWxsID8gYC4gUG9zc2libGUgZXhpdCBjb2RlOiAke3RyYW5zYWN0aW9uLmV4aXRDb2RlfWAgOiAnJztcbiAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGAke2Vycm9yTWVzc2FnZX0ke2FkZGl0aW9uYWxUZXh0fWApO1xufTtcbmNvbnN0IHNlbmRFeHRlcm5hbE1lc3NhZ2VEZWxheWVkID0gYXN5bmMgKGN0eCwgcmVxKSA9PiB7XG4gICAgcmVxdWlyZUtleXN0b3JlKHJlcSwgY3R4KTtcbiAgICByZXF1aXJlUGFyYW1zKHJlcSk7XG4gICAgY29uc3QgeyBwdWJsaWNLZXksIHJlY2lwaWVudCwgc3RhdGVJbml0LCBwYXlsb2FkIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCByZXEucGFyYW1zLCAncHVibGljS2V5Jyk7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHJlcS5wYXJhbXMsICdyZWNpcGllbnQnKTtcbiAgICByZXF1aXJlT3B0aW9uYWxTdHJpbmcocmVxLCByZXEucGFyYW1zLCAnc3RhdGVJbml0Jyk7XG4gICAgcmVxdWlyZUZ1bmN0aW9uQ2FsbChyZXEsIHJlcS5wYXJhbXMsICdwYXlsb2FkJyk7XG4gICAgbGV0IHJlcGFja2VkUmVjaXBpZW50O1xuICAgIHRyeSB7XG4gICAgICAgIHJlcGFja2VkUmVjaXBpZW50ID0gbmVrb3Rvbi5yZXBhY2tBZGRyZXNzKHJlY2lwaWVudCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgY29uc3QgeyBjbG9jaywgc3Vic2NyaXB0aW9uQ29udHJvbGxlciwga2V5c3RvcmUsIHByb3BlcnRpZXMsIG5vdGlmeSB9ID0gY3R4O1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IGtleXN0b3JlLmdldFNpZ25lcihwdWJsaWNLZXkpO1xuICAgIGlmIChzaWduZXIgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsICdTaWduZXIgbm90IGZvdW5kIGZvciBwdWJsaWMga2V5Jyk7XG4gICAgfVxuICAgIGxldCB1bnNpZ25lZE1lc3NhZ2U7XG4gICAgdHJ5IHtcbiAgICAgICAgdW5zaWduZWRNZXNzYWdlID0gbmVrb3Rvbi5jcmVhdGVFeHRlcm5hbE1lc3NhZ2UoY2xvY2ssIHJlcGFja2VkUmVjaXBpZW50LCBwYXlsb2FkLmFiaSwgcGF5bG9hZC5tZXRob2QsIHN0YXRlSW5pdCwgcGF5bG9hZC5wYXJhbXMsIHB1YmxpY0tleSwgcHJvcGVydGllcy5tZXNzYWdlLnRpbWVvdXQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGxldCBzaWduZWRNZXNzYWdlO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25lci5zaWduKHVuc2lnbmVkTWVzc2FnZS5oYXNoKTtcbiAgICAgICAgc2lnbmVkTWVzc2FnZSA9IHVuc2lnbmVkTWVzc2FnZS5zaWduKHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHVuc2lnbmVkTWVzc2FnZS5mcmVlKCk7XG4gICAgfVxuICAgIHN1YnNjcmlwdGlvbkNvbnRyb2xsZXIuc2VuZE1lc3NhZ2UocmVwYWNrZWRSZWNpcGllbnQsIHNpZ25lZE1lc3NhZ2UpXG4gICAgICAgIC50aGVuKHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgbm90aWZ5KCdtZXNzYWdlU3RhdHVzVXBkYXRlZCcsIHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHJlcGFja2VkUmVjaXBpZW50LFxuICAgICAgICAgICAgaGFzaDogc2lnbmVkTWVzc2FnZS5oYXNoLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgICAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICBhY2NvdW50OiByZXBhY2tlZFJlY2lwaWVudCxcbiAgICAgICAgICAgIGhhc2g6IHNpZ25lZE1lc3NhZ2UuaGFzaCxcbiAgICAgICAgICAgIGV4cGlyZUF0OiBzaWduZWRNZXNzYWdlLmV4cGlyZUF0LFxuICAgICAgICB9LFxuICAgIH07XG59O1xuZnVuY3Rpb24gcmVxdWlyZUtleXN0b3JlKHJlcSwgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LmtleXN0b3JlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCAnS2V5c3RvcmUgbm90IGZvdW5kJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZUFjY291bnRzU3RvcmFnZShyZXEsIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5hY2NvdW50c1N0b3JhZ2UgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsICdBY2NvdW50c1N0b3JhZ2Ugbm90IGZvdW5kJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZVBhcmFtcyhyZXEpIHtcbiAgICBpZiAocmVxLnBhcmFtcyA9PSBudWxsIHx8IHR5cGVvZiByZXEucGFyYW1zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsICdyZXF1aXJlZCBwYXJhbXMgb2JqZWN0Jyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZU9iamVjdChyZXEsIG9iamVjdCwga2V5KSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBvYmplY3Rba2V5XTtcbiAgICBpZiAodHlwZW9mIHByb3BlcnR5ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGAnJHtTdHJpbmcoa2V5KX0nIG11c3QgYmUgYW4gb2JqZWN0YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZU9wdGlvbmFsT2JqZWN0KHJlcSwgb2JqZWN0LCBrZXkpIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IG9iamVjdFtrZXldO1xuICAgIGlmIChwcm9wZXJ0eSAhPSBudWxsICYmIHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgJyR7U3RyaW5nKGtleSl9JyBtdXN0IGJlIGFuIG9iamVjdCBpZiBzcGVjaWZpZWRgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1aXJlQm9vbGVhbihyZXEsIG9iamVjdCwga2V5KSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBvYmplY3Rba2V5XTtcbiAgICBpZiAodHlwZW9mIHByb3BlcnR5ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgJyR7U3RyaW5nKGtleSl9JyBtdXN0IGJlIGEgYm9vbGVhbmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcXVpcmVPcHRpb25hbEJvb2xlYW4ocmVxLCBvYmplY3QsIGtleSkge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgaWYgKHByb3BlcnR5ICE9IG51bGwgJiYgdHlwZW9mIHByb3BlcnR5ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZFJlcXVlc3QocmVxLCBgJyR7U3RyaW5nKGtleSl9JyBtdXN0IGJlIGEgYm9vbGVhbiBpZiBzcGVjaWZpZWRgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1aXJlU3RyaW5nKHJlcSwgb2JqZWN0LCBrZXkpIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IG9iamVjdFtrZXldO1xuICAgIGlmICh0eXBlb2YgcHJvcGVydHkgIT09ICdzdHJpbmcnIHx8IHByb3BlcnR5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGAnJHtTdHJpbmcoa2V5KX0nIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ2ApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcXVpcmVPcHRpb25hbFN0cmluZyhyZXEsIG9iamVjdCwga2V5KSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBvYmplY3Rba2V5XTtcbiAgICBpZiAocHJvcGVydHkgIT0gbnVsbCAmJiAodHlwZW9mIHByb3BlcnR5ICE9PSAnc3RyaW5nJyB8fCBwcm9wZXJ0eS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYCcke1N0cmluZyhrZXkpfScgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgaWYgcHJvdmlkZWRgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1aXJlT3B0aW9uYWxOdW1iZXIocmVxLCBvYmplY3QsIGtleSkge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgaWYgKHByb3BlcnR5ICE9IG51bGwgJiYgdHlwZW9mIHByb3BlcnR5ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGAnJHtTdHJpbmcoa2V5KX0nIG11c3QgYmUgYSBudW1iZXIgaWYgcHJvdmlkZXJgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1aXJlQXJyYXkocmVxLCBvYmplY3QsIGtleSkge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BlcnR5KSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGAnJHtTdHJpbmcoa2V5KX0nIG11c3QgYmUgYW4gYXJyYXlgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1aXJlT3B0aW9uYWwocmVxLCBvYmplY3QsIGtleSwgcHJlZGljYXRlKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBvYmplY3Rba2V5XTtcbiAgICBpZiAocHJvcGVydHkgIT0gbnVsbCkge1xuICAgICAgICBwcmVkaWNhdGUocmVxLCBvYmplY3QsIGtleSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZVRyYW5zYWN0aW9uSWQocmVxLCBvYmplY3QsIGtleSkge1xuICAgIHJlcXVpcmVPYmplY3QocmVxLCBvYmplY3QsIGtleSk7XG4gICAgY29uc3QgcHJvcGVydHkgPSBvYmplY3Rba2V5XTtcbiAgICByZXF1aXJlU3RyaW5nKHJlcSwgcHJvcGVydHksICdsdCcpO1xuICAgIHJlcXVpcmVTdHJpbmcocmVxLCBwcm9wZXJ0eSwgJ2hhc2gnKTtcbn1cbmZ1bmN0aW9uIHJlcXVpcmVMYXN0VHJhbnNhY3Rpb25JZChyZXEsIG9iamVjdCwga2V5KSB7XG4gICAgcmVxdWlyZU9iamVjdChyZXEsIG9iamVjdCwga2V5KTtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IG9iamVjdFtrZXldO1xuICAgIHJlcXVpcmVCb29sZWFuKHJlcSwgcHJvcGVydHksICdpc0V4YWN0Jyk7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHByb3BlcnR5LCAnbHQnKTtcbiAgICByZXF1aXJlT3B0aW9uYWxTdHJpbmcocmVxLCBwcm9wZXJ0eSwgJ2hhc2gnKTtcbn1cbmZ1bmN0aW9uIHJlcXVpcmVDb250cmFjdFN0YXRlKHJlcSwgb2JqZWN0LCBrZXkpIHtcbiAgICByZXF1aXJlT2JqZWN0KHJlcSwgb2JqZWN0LCBrZXkpO1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHByb3BlcnR5LCAnYmFsYW5jZScpO1xuICAgIHJlcXVpcmVPcHRpb25hbChyZXEsIHByb3BlcnR5LCAnbGFzdFRyYW5zYWN0aW9uSWQnLCByZXF1aXJlTGFzdFRyYW5zYWN0aW9uSWQpO1xuICAgIHJlcXVpcmVCb29sZWFuKHJlcSwgcHJvcGVydHksICdpc0RlcGxveWVkJyk7XG59XG5mdW5jdGlvbiByZXF1aXJlRnVuY3Rpb25DYWxsKHJlcSwgb2JqZWN0LCBrZXkpIHtcbiAgICByZXF1aXJlT2JqZWN0KHJlcSwgb2JqZWN0LCBrZXkpO1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHByb3BlcnR5LCAnYWJpJyk7XG4gICAgcmVxdWlyZVN0cmluZyhyZXEsIHByb3BlcnR5LCAnbWV0aG9kJyk7XG4gICAgcmVxdWlyZU9iamVjdChyZXEsIHByb3BlcnR5LCAncGFyYW1zJyk7XG59XG5mdW5jdGlvbiByZXF1aXJlT3B0aW9uYWxSYXdGdW5jdGlvbkNhbGwocmVxLCBvYmplY3QsIGtleSkge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0W2tleV07XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycgfHwgcHJvcGVydHkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmVxdWlyZVN0cmluZyhyZXEsIHByb3BlcnR5LCAnYWJpJyk7XG4gICAgICAgIHJlcXVpcmVTdHJpbmcocmVxLCBwcm9wZXJ0eSwgJ21ldGhvZCcpO1xuICAgICAgICByZXF1aXJlT2JqZWN0KHJlcSwgcHJvcGVydHksICdwYXJhbXMnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgYCcke1N0cmluZyhrZXkpfScgbXVzdCBiZSBhIGZ1bmN0aW9uIGFsbCBvciBvcHRpb25hbCBzdHJpbmdgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1aXJlTWV0aG9kT3JBcnJheShyZXEsIG9iamVjdCwga2V5KSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBvYmplY3Rba2V5XTtcbiAgICBpZiAocHJvcGVydHkgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcGVydHkgIT09ICdzdHJpbmcnICYmICFBcnJheS5pc0FycmF5KHByb3BlcnR5KSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsIGAnJHtTdHJpbmcoa2V5KX0nIG11c3QgYmUgYSBtZXRob2QgbmFtZSBvciBhbiBhcnJheSBvZiBwb3NzaWJsZSBuYW1lc2ApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIG1ha2VBY2NvdW50SW50ZXJhY3Rpb25QZXJtaXNzaW9uKHJlcSwgY3R4KSB7XG4gICAgcmVxdWlyZUFjY291bnRzU3RvcmFnZShyZXEsIGN0eCk7XG4gICAgY29uc3QgZGVmYXVsdEFjY291bnQgPSBjdHguYWNjb3VudHNTdG9yYWdlLmRlZmF1bHRBY2NvdW50O1xuICAgIGlmIChkZWZhdWx0QWNjb3VudCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IGludmFsaWRSZXF1ZXN0KHJlcSwgJ0RlZmF1bHQgYWNjb3VudCBub3Qgc2V0IGluIGFjY291bnRzIHN0b3JhZ2UnKTtcbiAgICB9XG4gICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IGN0eC5hY2NvdW50c1N0b3JhZ2UuZ2V0QWNjb3VudChkZWZhdWx0QWNjb3VudCk7XG4gICAgaWYgKGFjY291bnQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkUmVxdWVzdChyZXEsICdEZWZhdWx0IGFjY291bnQgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IGFjY291bnQuZmV0Y2hQdWJsaWNLZXkobmV3IEFjY291bnRzU3RvcmFnZV8xLkFjY291bnRzU3RvcmFnZUNvbnRleHQoY3R4LmNsb2NrLCBjdHguY29ubmVjdGlvbkNvbnRyb2xsZXIsIG5la290b24pKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBhY2NvdW50LmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgcHVibGljS2V5LFxuICAgICAgICBjb250cmFjdFR5cGU6ICd1bmtub3duJyxcbiAgICB9O1xufVxuY29uc3QgaW52YWxpZFJlcXVlc3QgPSAocmVxLCBtZXNzYWdlLCBkYXRhKSA9PiBuZXcgTmVrb3RvblJwY0Vycm9yKDIsIGAke3JlcS5tZXRob2R9OiAke21lc3NhZ2V9YCwgZGF0YSk7XG5jbGFzcyBOZWtvdG9uUnBjRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9uZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgICAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhY2spIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQuc3RhY2sgPSB0aGlzLnN0YWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICgwLCBmYXN0X3NhZmVfc3RyaW5naWZ5XzEuZGVmYXVsdCkodGhpcy5zZXJpYWxpemUoKSwgc3RyaW5naWZ5UmVwbGFjZXIsIDIpO1xuICAgIH1cbn1cbmNvbnN0IHN0cmluZ2lmeVJlcGxhY2VyID0gKF8sIHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSAnW0NpcmN1bGFyXScpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///637\n")},837:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.SimpleKeystore = void 0;\nconst core_1 = __importDefault(__webpack_require__(521));\nconst { nekoton } = core_1.default;\n/**\n * @category Keystore\n */\nclass SimpleKeystore {\n    constructor(entries = {}) {\n        this.signers = new Map();\n        this.signersByPublicKey = new Map();\n        for (const [id, signer] of Object.entries(entries)) {\n            this.addKeyPair(id, signer);\n        }\n    }\n    static generateKeyPair() {\n        return nekoton.ed25519_generateKeyPair();\n    }\n    addKeyPair(idOrKeypair, rest) {\n        let id;\n        let keyPair;\n        if (typeof idOrKeypair == \'string\') {\n            id = idOrKeypair;\n            keyPair = rest;\n        }\n        else {\n            id = idOrKeypair.publicKey;\n            keyPair = idOrKeypair;\n        }\n        const signer = new SimpleSigner(keyPair);\n        this.signers.set(id, signer);\n        this.signersByPublicKey.set(keyPair.publicKey, signer);\n    }\n    removeKeyPair(id) {\n        const signer = this.signers.get(id);\n        if (signer != null) {\n            this.signers.delete(id);\n            this.signersByPublicKey.delete(signer.publicKey);\n        }\n    }\n    /**\n     * Generate and add a new key\n     *\n     * @returns keyId of the new signer\n     */\n    async withNewKey(f, options = {}) {\n        const newKey = SimpleKeystore.generateKeyPair();\n        const keyId = options.keyId != null ? options.keyId : newKey.publicKey;\n        const keepOnError = options.keepOnError || false;\n        this.addKeyPair(keyId, newKey);\n        return f(keyId)\n            .then(retain => {\n            if (retain === false) {\n                this.removeKeyPair(keyId);\n            }\n            return keyId;\n        })\n            .catch((e) => {\n            if (!keepOnError) {\n                this.removeKeyPair(keyId);\n            }\n            throw e;\n        });\n    }\n    async getSigner(id) {\n        return this.signers.get(id) || this.signersByPublicKey.get(id);\n    }\n}\nexports.SimpleKeystore = SimpleKeystore;\nclass SimpleSigner {\n    constructor(keyPair) {\n        this.keyPair = keyPair;\n        this.publicKey = this.keyPair.publicKey;\n    }\n    async sign(rawData) {\n        return nekoton.ed25519_sign(this.keyPair.secretKey, rawData);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODM3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQva2V5c3RvcmUuanM/NzQzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2ltcGxlS2V5c3RvcmUgPSB2b2lkIDA7XG5jb25zdCBjb3JlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2NvcmVcIikpO1xuY29uc3QgeyBuZWtvdG9uIH0gPSBjb3JlXzEuZGVmYXVsdDtcbi8qKlxuICogQGNhdGVnb3J5IEtleXN0b3JlXG4gKi9cbmNsYXNzIFNpbXBsZUtleXN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihlbnRyaWVzID0ge30pIHtcbiAgICAgICAgdGhpcy5zaWduZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNpZ25lcnNCeVB1YmxpY0tleSA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBbaWQsIHNpZ25lcl0gb2YgT2JqZWN0LmVudHJpZXMoZW50cmllcykpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkS2V5UGFpcihpZCwgc2lnbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2VuZXJhdGVLZXlQYWlyKCkge1xuICAgICAgICByZXR1cm4gbmVrb3Rvbi5lZDI1NTE5X2dlbmVyYXRlS2V5UGFpcigpO1xuICAgIH1cbiAgICBhZGRLZXlQYWlyKGlkT3JLZXlwYWlyLCByZXN0KSB7XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgbGV0IGtleVBhaXI7XG4gICAgICAgIGlmICh0eXBlb2YgaWRPcktleXBhaXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlkID0gaWRPcktleXBhaXI7XG4gICAgICAgICAgICBrZXlQYWlyID0gcmVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gaWRPcktleXBhaXIucHVibGljS2V5O1xuICAgICAgICAgICAga2V5UGFpciA9IGlkT3JLZXlwYWlyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25lciA9IG5ldyBTaW1wbGVTaWduZXIoa2V5UGFpcik7XG4gICAgICAgIHRoaXMuc2lnbmVycy5zZXQoaWQsIHNpZ25lcik7XG4gICAgICAgIHRoaXMuc2lnbmVyc0J5UHVibGljS2V5LnNldChrZXlQYWlyLnB1YmxpY0tleSwgc2lnbmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlS2V5UGFpcihpZCkge1xuICAgICAgICBjb25zdCBzaWduZXIgPSB0aGlzLnNpZ25lcnMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKHNpZ25lciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNpZ25lcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIHRoaXMuc2lnbmVyc0J5UHVibGljS2V5LmRlbGV0ZShzaWduZXIucHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbmQgYWRkIGEgbmV3IGtleVxuICAgICAqXG4gICAgICogQHJldHVybnMga2V5SWQgb2YgdGhlIG5ldyBzaWduZXJcbiAgICAgKi9cbiAgICBhc3luYyB3aXRoTmV3S2V5KGYsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBuZXdLZXkgPSBTaW1wbGVLZXlzdG9yZS5nZW5lcmF0ZUtleVBhaXIoKTtcbiAgICAgICAgY29uc3Qga2V5SWQgPSBvcHRpb25zLmtleUlkICE9IG51bGwgPyBvcHRpb25zLmtleUlkIDogbmV3S2V5LnB1YmxpY0tleTtcbiAgICAgICAgY29uc3Qga2VlcE9uRXJyb3IgPSBvcHRpb25zLmtlZXBPbkVycm9yIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmFkZEtleVBhaXIoa2V5SWQsIG5ld0tleSk7XG4gICAgICAgIHJldHVybiBmKGtleUlkKVxuICAgICAgICAgICAgLnRoZW4ocmV0YWluID0+IHtcbiAgICAgICAgICAgIGlmIChyZXRhaW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVLZXlQYWlyKGtleUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXlJZDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFrZWVwT25FcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlS2V5UGFpcihrZXlJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2lnbmVyKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25lcnMuZ2V0KGlkKSB8fCB0aGlzLnNpZ25lcnNCeVB1YmxpY0tleS5nZXQoaWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2ltcGxlS2V5c3RvcmUgPSBTaW1wbGVLZXlzdG9yZTtcbmNsYXNzIFNpbXBsZVNpZ25lciB7XG4gICAgY29uc3RydWN0b3Ioa2V5UGFpcikge1xuICAgICAgICB0aGlzLmtleVBhaXIgPSBrZXlQYWlyO1xuICAgICAgICB0aGlzLnB1YmxpY0tleSA9IHRoaXMua2V5UGFpci5wdWJsaWNLZXk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ24ocmF3RGF0YSkge1xuICAgICAgICByZXR1cm4gbmVrb3Rvbi5lZDI1NTE5X3NpZ24odGhpcy5rZXlQYWlyLnNlY3JldEtleSwgcmF3RGF0YSk7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///837\n')},344:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getUniqueId = exports.convertVersionToInt32 = exports.SafeEventEmitter = void 0;\nconst events_1 = __webpack_require__(187);\nfunction safeApply(handler, context, args) {\n    try {\n        Reflect.apply(handler, context, args);\n    }\n    catch (err) {\n        // Throw error after timeout so as not to interrupt the stack\n        setTimeout(() => {\n            throw err;\n        });\n    }\n}\nfunction arrayClone(arr) {\n    const n = arr.length;\n    const copy = new Array(n);\n    for (let i = 0; i < n; i += 1) {\n        copy[i] = arr[i];\n    }\n    return copy;\n}\nclass SafeEventEmitter extends events_1.EventEmitter {\n    emit(type, ...args) {\n        let doError = type === 'error';\n        const events = this._events;\n        if (events !== undefined) {\n            doError = doError && events.error === undefined;\n        }\n        else if (!doError) {\n            return false;\n        }\n        if (doError) {\n            let er;\n            if (args.length > 0) {\n                ;\n                [er] = args;\n            }\n            if (er instanceof Error) {\n                throw er;\n            }\n            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);\n            err.context = er;\n            throw err;\n        }\n        const handler = events[type];\n        if (handler === undefined) {\n            return false;\n        }\n        if (typeof handler === 'function') {\n            safeApply(handler, this, args);\n        }\n        else {\n            const len = handler.length;\n            const listeners = arrayClone(handler);\n            for (let i = 0; i < len; i += 1) {\n                safeApply(listeners[i], this, args);\n            }\n        }\n        return true;\n    }\n}\nexports.SafeEventEmitter = SafeEventEmitter;\n/**\n * @category Utils\n */\nconst convertVersionToInt32 = (version) => {\n    const parts = version.split('.');\n    if (parts.length !== 3) {\n        throw new Error('Received invalid version string');\n    }\n    parts.forEach((part) => {\n        if (~~part > 999) {\n            throw new Error(`Version string invalid, ${part} is too large`);\n        }\n    });\n    let multiplier = 1000000;\n    let numericVersion = 0;\n    for (let i = 0; i < 3; i++) {\n        numericVersion += ~~parts[i] * multiplier;\n        multiplier /= 1000;\n    }\n    return numericVersion;\n};\nexports.convertVersionToInt32 = convertVersionToInt32;\nconst MAX = 4294967295;\nlet idCounter = Math.floor(Math.random() * MAX);\nfunction getUniqueId() {\n    idCounter = (idCounter + 1) % MAX;\n    return idCounter;\n}\nexports.getUniqueId = getUniqueId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jbGllbnQvdXRpbHMuanM/ZWYyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0VW5pcXVlSWQgPSBleHBvcnRzLmNvbnZlcnRWZXJzaW9uVG9JbnQzMiA9IGV4cG9ydHMuU2FmZUV2ZW50RW1pdHRlciA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmZ1bmN0aW9uIHNhZmVBcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgUmVmbGVjdC5hcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBUaHJvdyBlcnJvciBhZnRlciB0aW1lb3V0IHNvIGFzIG5vdCB0byBpbnRlcnJ1cHQgdGhlIHN0YWNrXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcnJheUNsb25lKGFycikge1xuICAgIGNvbnN0IG4gPSBhcnIubGVuZ3RoO1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpICs9IDEpIHtcbiAgICAgICAgY29weVtpXSA9IGFycltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5jbGFzcyBTYWZlRXZlbnRFbWl0dGVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBlbWl0KHR5cGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGRvRXJyb3IgPSB0eXBlID09PSAnZXJyb3InO1xuICAgICAgICBjb25zdCBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICAgIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZG9FcnJvciA9IGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRvRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9FcnJvcikge1xuICAgICAgICAgICAgbGV0IGVyO1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBbZXJdID0gYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYFVuaGFuZGxlZCBlcnJvci4ke2VyID8gYCAoJHtlci5tZXNzYWdlfSlgIDogJyd9YCk7XG4gICAgICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG4gICAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNhZmVBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBzYWZlQXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLlNhZmVFdmVudEVtaXR0ZXIgPSBTYWZlRXZlbnRFbWl0dGVyO1xuLyoqXG4gKiBAY2F0ZWdvcnkgVXRpbHNcbiAqL1xuY29uc3QgY29udmVydFZlcnNpb25Ub0ludDMyID0gKHZlcnNpb24pID0+IHtcbiAgICBjb25zdCBwYXJ0cyA9IHZlcnNpb24uc3BsaXQoJy4nKTtcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVjZWl2ZWQgaW52YWxpZCB2ZXJzaW9uIHN0cmluZycpO1xuICAgIH1cbiAgICBwYXJ0cy5mb3JFYWNoKChwYXJ0KSA9PiB7XG4gICAgICAgIGlmICh+fnBhcnQgPiA5OTkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmVyc2lvbiBzdHJpbmcgaW52YWxpZCwgJHtwYXJ0fSBpcyB0b28gbGFyZ2VgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBtdWx0aXBsaWVyID0gMTAwMDAwMDtcbiAgICBsZXQgbnVtZXJpY1ZlcnNpb24gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIG51bWVyaWNWZXJzaW9uICs9IH5+cGFydHNbaV0gKiBtdWx0aXBsaWVyO1xuICAgICAgICBtdWx0aXBsaWVyIC89IDEwMDA7XG4gICAgfVxuICAgIHJldHVybiBudW1lcmljVmVyc2lvbjtcbn07XG5leHBvcnRzLmNvbnZlcnRWZXJzaW9uVG9JbnQzMiA9IGNvbnZlcnRWZXJzaW9uVG9JbnQzMjtcbmNvbnN0IE1BWCA9IDQyOTQ5NjcyOTU7XG5sZXQgaWRDb3VudGVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTUFYKTtcbmZ1bmN0aW9uIGdldFVuaXF1ZUlkKCkge1xuICAgIGlkQ291bnRlciA9IChpZENvdW50ZXIgKyAxKSAlIE1BWDtcbiAgICByZXR1cm4gaWRDb3VudGVyO1xufVxuZXhwb3J0cy5nZXRVbmlxdWVJZCA9IGdldFVuaXF1ZUlkO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///344\n")},521:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst core = {\n    ensureNekotonLoaded: undefined,\n    nekoton: undefined,\n    fetch: undefined,\n    fetchAgent: () => undefined,\n    debugLog: undefined,\n};\nexports.default = core;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZXJzY2FsZS1zdGFuZGFsb25lLWNsaWVudC9jb3JlLmpzP2M5ODQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb3JlID0ge1xuICAgIGVuc3VyZU5la290b25Mb2FkZWQ6IHVuZGVmaW5lZCxcbiAgICBuZWtvdG9uOiB1bmRlZmluZWQsXG4gICAgZmV0Y2g6IHVuZGVmaW5lZCxcbiAgICBmZXRjaEFnZW50OiAoKSA9PiB1bmRlZmluZWQsXG4gICAgZGVidWdMb2c6IHVuZGVmaW5lZCxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBjb3JlO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///521\n')},91:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst nekoton_wasm_1 = __importStar(__webpack_require__(559)), nt = nekoton_wasm_1;\nconst core_1 = __importDefault(__webpack_require__(521));\nlet clientInitializationStarted = false;\nlet notifyClientInitialized;\nconst initializationPromise = new Promise((resolve, reject) => {\n    notifyClientInitialized = { resolve, reject };\n});\ncore_1.default.ensureNekotonLoaded = (initInput) => {\n    if (!clientInitializationStarted) {\n        clientInitializationStarted = true;\n        (0, nekoton_wasm_1.default)(initInput).then(notifyClientInitialized.resolve).catch(notifyClientInitialized.reject);\n    }\n    return initializationPromise;\n};\ncore_1.default.nekoton = nt;\ncore_1.default.fetch = fetch;\ncore_1.default.debugLog = console.debug;\n__exportStar(__webpack_require__(637), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXgtYmF0dGxlLWdhbWUvLi9ub2RlX21vZHVsZXMvZXZlcnNjYWxlLXN0YW5kYWxvbmUtY2xpZW50L2luZGV4LmpzPzBlNzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBuZWtvdG9uX3dhc21fMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibmVrb3Rvbi13YXNtXCIpKSwgbnQgPSBuZWtvdG9uX3dhc21fMTtcbmNvbnN0IGNvcmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb3JlXCIpKTtcbmxldCBjbGllbnRJbml0aWFsaXphdGlvblN0YXJ0ZWQgPSBmYWxzZTtcbmxldCBub3RpZnlDbGllbnRJbml0aWFsaXplZDtcbmNvbnN0IGluaXRpYWxpemF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBub3RpZnlDbGllbnRJbml0aWFsaXplZCA9IHsgcmVzb2x2ZSwgcmVqZWN0IH07XG59KTtcbmNvcmVfMS5kZWZhdWx0LmVuc3VyZU5la290b25Mb2FkZWQgPSAoaW5pdElucHV0KSA9PiB7XG4gICAgaWYgKCFjbGllbnRJbml0aWFsaXphdGlvblN0YXJ0ZWQpIHtcbiAgICAgICAgY2xpZW50SW5pdGlhbGl6YXRpb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgKDAsIG5la290b25fd2FzbV8xLmRlZmF1bHQpKGluaXRJbnB1dCkudGhlbihub3RpZnlDbGllbnRJbml0aWFsaXplZC5yZXNvbHZlKS5jYXRjaChub3RpZnlDbGllbnRJbml0aWFsaXplZC5yZWplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25Qcm9taXNlO1xufTtcbmNvcmVfMS5kZWZhdWx0Lm5la290b24gPSBudDtcbmNvcmVfMS5kZWZhdWx0LmZldGNoID0gZmV0Y2g7XG5jb3JlXzEuZGVmYXVsdC5kZWJ1Z0xvZyA9IGNvbnNvbGUuZGVidWc7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2xpZW50XCIpLCBleHBvcnRzKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///91\n')},445:module=>{eval("module.exports = stringify\nstringify.default = stringify\nstringify.stable = deterministicStringify\nstringify.stableStringify = deterministicStringify\n\nvar LIMIT_REPLACE_NODE = '[...]'\nvar CIRCULAR_REPLACE_NODE = '[Circular]'\n\nvar arr = []\nvar replacerStack = []\n\nfunction defaultOptions () {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER\n  }\n}\n\n// Regular stringify\nfunction stringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  decirc(obj, '', 0, [], undefined, 0, options)\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer)\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction setReplace (replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, { value: replace })\n      arr.push([parent, k, val, propertyDescriptor])\n    } else {\n      replacerStack.push([val, k, replace])\n    }\n  } else {\n    parent[k] = replace\n    arr.push([parent, k, val])\n  }\n}\n\nfunction decirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      var keys = Object.keys(val)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        decirc(val[key], key, i, stack, val, depth, options)\n      }\n    }\n    stack.pop()\n  }\n}\n\n// Stable-stringify\nfunction compareFunction (a, b) {\n  if (a < b) {\n    return -1\n  }\n  if (a > b) {\n    return 1\n  }\n  return 0\n}\n\nfunction deterministicStringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer)\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n    try {\n      if (typeof val.toJSON === 'function') {\n        return\n      }\n    } catch (_) {\n      return\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {}\n      var keys = Object.keys(val).sort(compareFunction)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        deterministicDecirc(val[key], key, i, stack, val, depth, options)\n        tmp[key] = val[key]\n      }\n      if (typeof parent !== 'undefined') {\n        arr.push([parent, k, val])\n        parent[k] = tmp\n      } else {\n        return tmp\n      }\n    }\n    stack.pop()\n  }\n}\n\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues (replacer) {\n  replacer =\n    typeof replacer !== 'undefined'\n      ? replacer\n      : function (k, v) {\n        return v\n      }\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i]\n        if (part[1] === key && part[0] === val) {\n          val = part[2]\n          replacerStack.splice(i, 1)\n          break\n        }\n      }\n    }\n    return replacer.call(this, key, val)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL2Zhc3Qtc2FmZS1zdHJpbmdpZnkvaW5kZXguanM/ZTVlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHN0cmluZ2lmeVxuc3RyaW5naWZ5LmRlZmF1bHQgPSBzdHJpbmdpZnlcbnN0cmluZ2lmeS5zdGFibGUgPSBkZXRlcm1pbmlzdGljU3RyaW5naWZ5XG5zdHJpbmdpZnkuc3RhYmxlU3RyaW5naWZ5ID0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeVxuXG52YXIgTElNSVRfUkVQTEFDRV9OT0RFID0gJ1suLi5dJ1xudmFyIENJUkNVTEFSX1JFUExBQ0VfTk9ERSA9ICdbQ2lyY3VsYXJdJ1xuXG52YXIgYXJyID0gW11cbnZhciByZXBsYWNlclN0YWNrID0gW11cblxuZnVuY3Rpb24gZGVmYXVsdE9wdGlvbnMgKCkge1xuICByZXR1cm4ge1xuICAgIGRlcHRoTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgIGVkZ2VzTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gIH1cbn1cblxuLy8gUmVndWxhciBzdHJpbmdpZnlcbmZ1bmN0aW9uIHN0cmluZ2lmeSAob2JqLCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKVxuICB9XG5cbiAgZGVjaXJjKG9iaiwgJycsIDAsIFtdLCB1bmRlZmluZWQsIDAsIG9wdGlvbnMpXG4gIHZhciByZXNcbiAgdHJ5IHtcbiAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlcilcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlR2V0dGVyVmFsdWVzKHJlcGxhY2VyKSwgc3BhY2VyKVxuICAgIH1cbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSgnW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXScpXG4gIH0gZmluYWxseSB7XG4gICAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpXG4gICAgICBpZiAocGFydC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnRbMF0sIHBhcnRbMV0sIHBhcnRbM10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHNldFJlcGxhY2UgKHJlcGxhY2UsIHZhbCwgaywgcGFyZW50KSB7XG4gIHZhciBwcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgaylcbiAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyZW50LCBrLCB7IHZhbHVlOiByZXBsYWNlIH0pXG4gICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWwsIHByb3BlcnR5RGVzY3JpcHRvcl0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGxhY2VyU3RhY2sucHVzaChbdmFsLCBrLCByZXBsYWNlXSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50W2tdID0gcmVwbGFjZVxuICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVjaXJjICh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgZGVwdGggKz0gMVxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RhY2tbaV0gPT09IHZhbCkge1xuICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBkZXB0aCA+IG9wdGlvbnMuZGVwdGhMaW1pdFxuICAgICkge1xuICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMuZWRnZXNMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGVkZ2VJbmRleCArIDEgPiBvcHRpb25zLmVkZ2VzTGltaXRcbiAgICApIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHN0YWNrLnB1c2godmFsKVxuICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVjaXJjKHZhbFtpXSwgaSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgICAgZGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKVxuICB9XG59XG5cbi8vIFN0YWJsZS1zdHJpbmdpZnlcbmZ1bmN0aW9uIGNvbXBhcmVGdW5jdGlvbiAoYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMVxuICB9XG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNTdHJpbmdpZnkgKG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKClcbiAgfVxuXG4gIHZhciB0bXAgPSBkZXRlcm1pbmlzdGljRGVjaXJjKG9iaiwgJycsIDAsIFtdLCB1bmRlZmluZWQsIDAsIG9wdGlvbnMpIHx8IG9ialxuICB2YXIgcmVzXG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VyLCBzcGFjZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KHRtcCwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcilcbiAgICB9XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJ1t1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV0nKVxuICB9IGZpbmFsbHkge1xuICAgIC8vIEVuc3VyZSB0aGF0IHdlIHJlc3RvcmUgdGhlIG9iamVjdCBhcyBpdCB3YXMuXG4gICAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpXG4gICAgICBpZiAocGFydC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnRbMF0sIHBhcnRbMV0sIHBhcnRbM10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNEZWNpcmMgKHZhbCwgaywgZWRnZUluZGV4LCBzdGFjaywgcGFyZW50LCBkZXB0aCwgb3B0aW9ucykge1xuICBkZXB0aCArPSAxXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgIHNldFJlcGxhY2UoQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHZhbC50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGRlcHRoID4gb3B0aW9ucy5kZXB0aExpbWl0XG4gICAgKSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgZWRnZUluZGV4ICsgMSA+IG9wdGlvbnMuZWRnZXNMaW1pdFxuICAgICkge1xuICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc3RhY2sucHVzaCh2YWwpXG4gICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtpXSwgaSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBvYmplY3QgaW4gdGhlIHJlcXVpcmVkIHdheVxuICAgICAgdmFyIHRtcCA9IHt9XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCkuc29ydChjb21wYXJlRnVuY3Rpb24pXG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxuICAgICAgICB0bXBba2V5XSA9IHZhbFtrZXldXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhcmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSlcbiAgICAgICAgcGFyZW50W2tdID0gdG1wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG1wXG4gICAgICB9XG4gICAgfVxuICAgIHN0YWNrLnBvcCgpXG4gIH1cbn1cblxuLy8gd3JhcHMgcmVwbGFjZXIgZnVuY3Rpb24gdG8gaGFuZGxlIHZhbHVlcyB3ZSBjb3VsZG4ndCByZXBsYWNlXG4vLyBhbmQgbWFyayB0aGVtIGFzIHJlcGxhY2VkIHZhbHVlXG5mdW5jdGlvbiByZXBsYWNlR2V0dGVyVmFsdWVzIChyZXBsYWNlcikge1xuICByZXBsYWNlciA9XG4gICAgdHlwZW9mIHJlcGxhY2VyICE9PSAndW5kZWZpbmVkJ1xuICAgICAgPyByZXBsYWNlclxuICAgICAgOiBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICByZXR1cm4gdlxuICAgICAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBsYWNlclN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcmVwbGFjZXJTdGFja1tpXVxuICAgICAgICBpZiAocGFydFsxXSA9PT0ga2V5ICYmIHBhcnRbMF0gPT09IHZhbCkge1xuICAgICAgICAgIHZhbCA9IHBhcnRbMl1cbiAgICAgICAgICByZXBsYWNlclN0YWNrLnNwbGljZShpLCAxKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWwpXG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///445\n")},559:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "checkAddress": () => (/* binding */ checkAddress),\n/* harmony export */   "repackAddress": () => (/* binding */ repackAddress),\n/* harmony export */   "runLocal": () => (/* binding */ runLocal),\n/* harmony export */   "makeFullAccountBoc": () => (/* binding */ makeFullAccountBoc),\n/* harmony export */   "parseFullAccountBoc": () => (/* binding */ parseFullAccountBoc),\n/* harmony export */   "executeLocal": () => (/* binding */ executeLocal),\n/* harmony export */   "getExpectedAddress": () => (/* binding */ getExpectedAddress),\n/* harmony export */   "getBocHash": () => (/* binding */ getBocHash),\n/* harmony export */   "packIntoCell": () => (/* binding */ packIntoCell),\n/* harmony export */   "unpackFromCell": () => (/* binding */ unpackFromCell),\n/* harmony export */   "extractContractData": () => (/* binding */ extractContractData),\n/* harmony export */   "extractPublicKey": () => (/* binding */ extractPublicKey),\n/* harmony export */   "codeToTvc": () => (/* binding */ codeToTvc),\n/* harmony export */   "mergeTvc": () => (/* binding */ mergeTvc),\n/* harmony export */   "splitTvc": () => (/* binding */ splitTvc),\n/* harmony export */   "setCodeSalt": () => (/* binding */ setCodeSalt),\n/* harmony export */   "getCodeSalt": () => (/* binding */ getCodeSalt),\n/* harmony export */   "encodeInternalInput": () => (/* binding */ encodeInternalInput),\n/* harmony export */   "encodeInternalMessage": () => (/* binding */ encodeInternalMessage),\n/* harmony export */   "decodeInput": () => (/* binding */ decodeInput),\n/* harmony export */   "decodeEvent": () => (/* binding */ decodeEvent),\n/* harmony export */   "decodeOutput": () => (/* binding */ decodeOutput),\n/* harmony export */   "decodeTransaction": () => (/* binding */ decodeTransaction),\n/* harmony export */   "decodeTransactionEvents": () => (/* binding */ decodeTransactionEvents),\n/* harmony export */   "getDataHash": () => (/* binding */ getDataHash),\n/* harmony export */   "ed25519_generateKeyPair": () => (/* binding */ ed25519_generateKeyPair),\n/* harmony export */   "ed25519_sign": () => (/* binding */ ed25519_sign),\n/* harmony export */   "extendSignature": () => (/* binding */ extendSignature),\n/* harmony export */   "verifySignature": () => (/* binding */ verifySignature),\n/* harmony export */   "createRawExternalMessage": () => (/* binding */ createRawExternalMessage),\n/* harmony export */   "createExternalMessageWithoutSignature": () => (/* binding */ createExternalMessageWithoutSignature),\n/* harmony export */   "createExternalMessage": () => (/* binding */ createExternalMessage),\n/* harmony export */   "ClockWithOffset": () => (/* binding */ ClockWithOffset),\n/* harmony export */   "GenericContract": () => (/* binding */ GenericContract),\n/* harmony export */   "GqlConnection": () => (/* binding */ GqlConnection),\n/* harmony export */   "GqlQuery": () => (/* binding */ GqlQuery),\n/* harmony export */   "JrpcConnection": () => (/* binding */ JrpcConnection),\n/* harmony export */   "JrpcQuery": () => (/* binding */ JrpcQuery),\n/* harmony export */   "Transport": () => (/* binding */ Transport),\n/* harmony export */   "UnsignedMessage": () => (/* binding */ UnsignedMessage),\n/* harmony export */   "initSync": () => (/* binding */ initSync),\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n\nlet wasm;\n\nconst cachedTextDecoder = new TextDecoder(\'utf-8\', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = new Uint8Array();\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedFloat64Memory0 = new Float64Array();\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nlet cachedInt32Memory0 = new Int32Array();\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = new TextEncoder(\'utf-8\');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === \'function\'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == \'number\' || type == \'boolean\' || val == null) {\n        return  `${val}`;\n    }\n    if (type == \'string\') {\n        return `"${val}"`;\n    }\n    if (type == \'symbol\') {\n        const description = val.description;\n        if (description == null) {\n            return \'Symbol\';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == \'function\') {\n        const name = val.name;\n        if (typeof name == \'string\' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return \'Function\';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = \'[\';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += \', \' + debugString(val[i]);\n        }\n        debug += \']\';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard \'[object ClassName]\'\n        return toString.call(val);\n    }\n    if (className == \'Object\') {\n        // we\'re a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return \'Object(\' + JSON.stringify(val) + \')\';\n        } catch (_) {\n            return \'Object\';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won\'t\n        // be deallocated while we\'re invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);\n\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_32(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hcb77729c6af9d376(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n/**\n* @param {string} address\n* @returns {boolean}\n*/\nfunction checkAddress(address) {\n    const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.checkAddress(ptr0, len0);\n    return ret !== 0;\n}\n\n/**\n* @param {string} address\n* @returns {string}\n*/\nfunction repackAddress(address) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.repackAddress(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {ClockWithOffset} clock\n* @param {string} account_stuff_boc\n* @param {string} contract_abi\n* @param {string} method\n* @param {TokensObject} input\n* @param {boolean} responsible\n* @returns {ExecutionOutput}\n*/\nfunction runLocal(clock, account_stuff_boc, contract_abi, method, input, responsible) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(clock, ClockWithOffset);\n        const ptr0 = passStringToWasm0(account_stuff_boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(method, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        wasm.runLocal(retptr, clock.ptr, ptr0, len0, ptr1, len1, ptr2, len2, addHeapObject(input), responsible);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} account_stuff_boc\n* @returns {string}\n*/\nfunction makeFullAccountBoc(account_stuff_boc) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(account_stuff_boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.makeFullAccountBoc(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {string} account\n* @returns {FullContractState | undefined}\n*/\nfunction parseFullAccountBoc(account) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(account, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.parseFullAccountBoc(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} config\n* @param {string} account\n* @param {string} message\n* @param {number} utime\n* @param {boolean} disable_signature_check\n* @returns {TransactionExecutorOutput}\n*/\nfunction executeLocal(config, account, message, utime, disable_signature_check) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(config, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(account, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        wasm.executeLocal(retptr, ptr0, len0, ptr1, len1, ptr2, len2, utime, disable_signature_check);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} tvc\n* @param {string} contract_abi\n* @param {number} workchain_id\n* @param {string | undefined} public_key\n* @param {TokensObject} init_data\n* @returns {ExpectedAddress}\n*/\nfunction getExpectedAddress(tvc, contract_abi, workchain_id, public_key, init_data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(tvc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(public_key) ? 0 : passStringToWasm0(public_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        wasm.getExpectedAddress(retptr, ptr0, len0, ptr1, len1, workchain_id, ptr2, len2, addHeapObject(init_data));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} boc\n* @returns {string}\n*/\nfunction getBocHash(boc) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.getBocHash(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {Array<AbiParam>} params\n* @param {TokensObject} tokens\n* @param {string | undefined} abi_version\n* @returns {string}\n*/\nfunction packIntoCell(params, tokens, abi_version) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = isLikeNone(abi_version) ? 0 : passStringToWasm0(abi_version, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.packIntoCell(retptr, addHeapObject(params), addHeapObject(tokens), ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {Array<AbiParam>} params\n* @param {string} boc\n* @param {boolean} allow_partial\n* @param {string | undefined} abi_version\n* @returns {TokensObject}\n*/\nfunction unpackFromCell(params, boc, allow_partial, abi_version) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(abi_version) ? 0 : passStringToWasm0(abi_version, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        wasm.unpackFromCell(retptr, addHeapObject(params), ptr0, len0, allow_partial, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} boc\n* @returns {string | undefined}\n*/\nfunction extractContractData(boc) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.extractContractData(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        let v1;\n        if (r0 !== 0) {\n            v1 = getStringFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n        }\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} boc\n* @returns {string}\n*/\nfunction extractPublicKey(boc) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(boc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.extractPublicKey(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {string} code\n* @returns {string}\n*/\nfunction codeToTvc(code) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.codeToTvc(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @param {string} code\n* @param {string} data\n* @returns {string}\n*/\nfunction mergeTvc(code, data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.mergeTvc(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr2 = r0;\n        var len2 = r1;\n        if (r3) {\n            ptr2 = 0; len2 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr2, len2);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr2, len2);\n    }\n}\n\n/**\n* @param {string} tvc\n* @returns {StateInit}\n*/\nfunction splitTvc(tvc) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(tvc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.splitTvc(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} code\n* @param {string} salt\n* @returns {string}\n*/\nfunction setCodeSalt(code, salt) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(salt, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.setCodeSalt(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr2 = r0;\n        var len2 = r1;\n        if (r3) {\n            ptr2 = 0; len2 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr2, len2);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr2, len2);\n    }\n}\n\n/**\n* @param {string} code\n* @returns {string | undefined}\n*/\nfunction getCodeSalt(code) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.getCodeSalt(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        let v1;\n        if (r0 !== 0) {\n            v1 = getStringFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n        }\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} contract_abi\n* @param {string} method\n* @param {TokensObject} input\n* @returns {string}\n*/\nfunction encodeInternalInput(contract_abi, method, input) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(method, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.encodeInternalInput(retptr, ptr0, len0, ptr1, len1, addHeapObject(input));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr2 = r0;\n        var len2 = r1;\n        if (r3) {\n            ptr2 = 0; len2 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr2, len2);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr2, len2);\n    }\n}\n\n/**\n* @param {string | undefined} src\n* @param {string} dst\n* @param {boolean} bounce\n* @param {string | undefined} state_init\n* @param {string | undefined} body\n* @param {string} amount\n* @returns {string}\n*/\nfunction encodeInternalMessage(src, dst, bounce, state_init, body, amount) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = isLikeNone(src) ? 0 : passStringToWasm0(src, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(dst, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(state_init) ? 0 : passStringToWasm0(state_init, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        var ptr3 = isLikeNone(body) ? 0 : passStringToWasm0(body, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len3 = WASM_VECTOR_LEN;\n        const ptr4 = passStringToWasm0(amount, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len4 = WASM_VECTOR_LEN;\n        wasm.encodeInternalMessage(retptr, ptr0, len0, ptr1, len1, bounce, ptr2, len2, ptr3, len3, ptr4, len4);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr5 = r0;\n        var len5 = r1;\n        if (r3) {\n            ptr5 = 0; len5 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr5, len5);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr5, len5);\n    }\n}\n\n/**\n* @param {string} message_body\n* @param {string} contract_abi\n* @param {MethodName} method\n* @param {boolean} internal\n* @returns {DecodedInput | undefined}\n*/\nfunction decodeInput(message_body, contract_abi, method, internal) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(message_body, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.decodeInput(retptr, ptr0, len0, ptr1, len1, addHeapObject(method), internal);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} message_body\n* @param {string} contract_abi\n* @param {MethodName} event\n* @returns {DecodedEvent | undefined}\n*/\nfunction decodeEvent(message_body, contract_abi, event) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(message_body, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.decodeEvent(retptr, ptr0, len0, ptr1, len1, addHeapObject(event));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} message_body\n* @param {string} contract_abi\n* @param {MethodName} method\n* @returns {DecodedOutput | undefined}\n*/\nfunction decodeOutput(message_body, contract_abi, method) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(message_body, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.decodeOutput(retptr, ptr0, len0, ptr1, len1, addHeapObject(method));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {Transaction} transaction\n* @param {string} contract_abi\n* @param {MethodName} method\n* @returns {DecodedTransaction | undefined}\n*/\nfunction decodeTransaction(transaction, contract_abi, method) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.decodeTransaction(retptr, addHeapObject(transaction), ptr0, len0, addHeapObject(method));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {Transaction} transaction\n* @param {string} contract_abi\n* @returns {DecodedTransactionEvents}\n*/\nfunction decodeTransactionEvents(transaction, contract_abi) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.decodeTransactionEvents(retptr, addHeapObject(transaction), ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} data\n* @returns {string}\n*/\nfunction getDataHash(data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.getDataHash(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr1 = r0;\n        var len1 = r1;\n        if (r3) {\n            ptr1 = 0; len1 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr1, len1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr1, len1);\n    }\n}\n\n/**\n* @returns {Ed25519KeyPair}\n*/\nfunction ed25519_generateKeyPair() {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.ed25519_generateKeyPair(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} secret_key\n* @param {string} data\n* @returns {string}\n*/\nfunction ed25519_sign(secret_key, data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(secret_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.ed25519_sign(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr2 = r0;\n        var len2 = r1;\n        if (r3) {\n            ptr2 = 0; len2 = 0;\n            throw takeObject(r2);\n        }\n        return getStringFromWasm0(ptr2, len2);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(ptr2, len2);\n    }\n}\n\n/**\n* @param {string} signature\n* @returns {ExtendedSignature}\n*/\nfunction extendSignature(signature) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(signature, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.extendSignature(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} public_key\n* @param {string} data\n* @param {string} signature\n* @returns {boolean}\n*/\nfunction verifySignature(public_key, data, signature) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(public_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(signature, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        wasm.verifySignature(retptr, ptr0, len0, ptr1, len1, ptr2, len2);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return r0 !== 0;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} dst\n* @param {string | undefined} state_init\n* @param {string | undefined} body\n* @param {number} expire_at\n* @returns {SignedMessage}\n*/\nfunction createRawExternalMessage(dst, state_init, body, expire_at) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(dst, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(state_init) ? 0 : passStringToWasm0(state_init, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(body) ? 0 : passStringToWasm0(body, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        wasm.createRawExternalMessage(retptr, ptr0, len0, ptr1, len1, ptr2, len2, expire_at);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {ClockWithOffset} clock\n* @param {string} dst\n* @param {string} contract_abi\n* @param {string} method\n* @param {string | undefined} state_init\n* @param {TokensObject} input\n* @param {number} timeout\n* @returns {SignedMessage}\n*/\nfunction createExternalMessageWithoutSignature(clock, dst, contract_abi, method, state_init, input, timeout) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(clock, ClockWithOffset);\n        const ptr0 = passStringToWasm0(dst, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(method, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        var ptr3 = isLikeNone(state_init) ? 0 : passStringToWasm0(state_init, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len3 = WASM_VECTOR_LEN;\n        wasm.createExternalMessageWithoutSignature(retptr, clock.ptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, addHeapObject(input), timeout);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {ClockWithOffset} clock\n* @param {string} dst\n* @param {string} contract_abi\n* @param {string} method\n* @param {string | undefined} state_init\n* @param {TokensObject} input\n* @param {string} public_key\n* @param {number} timeout\n* @returns {UnsignedMessage}\n*/\nfunction createExternalMessage(clock, dst, contract_abi, method, state_init, input, public_key, timeout) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(clock, ClockWithOffset);\n        const ptr0 = passStringToWasm0(dst, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(contract_abi, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(method, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        var ptr3 = isLikeNone(state_init) ? 0 : passStringToWasm0(state_init, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len3 = WASM_VECTOR_LEN;\n        const ptr4 = passStringToWasm0(public_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len4 = WASM_VECTOR_LEN;\n        wasm.createExternalMessage(retptr, clock.ptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, addHeapObject(input), ptr4, len4, timeout);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return UnsignedMessage.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\nfunction __wbg_adapter_163(arg0, arg1, arg2, arg3) {\n    wasm.wasm_bindgen__convert__closures__invoke2_mut__hecba896d1563d223(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\n/**\n*/\nclass ClockWithOffset {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ClockWithOffset.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_clockwithoffset_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.clockwithoffset_new();\n        return ClockWithOffset.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    get nowMs() {\n        const ret = wasm.clockwithoffset_nowMs(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} offset_ms\n    */\n    updateOffset(offset_ms) {\n        wasm.clockwithoffset_updateOffset(this.ptr, offset_ms);\n    }\n    /**\n    * @returns {number}\n    */\n    offsetMs() {\n        const ret = wasm.clockwithoffset_offsetMs(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nclass GenericContract {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenericContract.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genericcontract_free(ptr);\n    }\n    /**\n    * @returns {string}\n    */\n    get address() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genericcontract_address(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {SignedMessage} message\n    * @returns {Promise<Transaction>}\n    */\n    sendMessageLocally(message) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genericcontract_sendMessageLocally(retptr, this.ptr, addHeapObject(message));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {SignedMessage} message\n    * @returns {Promise<PendingTransaction>}\n    */\n    sendMessage(message) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genericcontract_sendMessage(retptr, this.ptr, addHeapObject(message));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Promise<void>}\n    */\n    refresh() {\n        const ret = wasm.genericcontract_refresh(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} block_id\n    * @returns {Promise<void>}\n    */\n    handleBlock(block_id) {\n        const ptr0 = passStringToWasm0(block_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.genericcontract_handleBlock(this.ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} lt\n    * @returns {Promise<void>}\n    */\n    preloadTransactions(lt) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(lt, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.genericcontract_preloadTransactions(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {PollingMethod}\n    */\n    get pollingMethod() {\n        const ret = wasm.genericcontract_pollingMethod(this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n*/\nclass GqlConnection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GqlConnection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_gqlconnection_free(ptr);\n    }\n    /**\n    * @param {ClockWithOffset} clock\n    * @param {IGqlSender} sender\n    */\n    constructor(clock, sender) {\n        _assertClass(clock, ClockWithOffset);\n        const ret = wasm.gqlconnection_new(clock.ptr, addHeapObject(sender));\n        return GqlConnection.__wrap(ret);\n    }\n    /**\n    * @param {string} address\n    * @returns {Promise<LatestBlock>}\n    */\n    getLatestBlock(address) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.gqlconnection_getLatestBlock(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} current_block_id\n    * @param {string} address\n    * @param {number} timeout\n    * @returns {Promise<string>}\n    */\n    waitForNextBlock(current_block_id, address, timeout) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(current_block_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.gqlconnection_waitForNextBlock(retptr, this.ptr, ptr0, len0, ptr1, len1, timeout);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass GqlQuery {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GqlQuery.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_gqlquery_free(ptr);\n    }\n    /**\n    * @param {string} data\n    */\n    onReceive(data) {\n        const ptr = this.__destroy_into_raw();\n        const ptr0 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.gqlquery_onReceive(ptr, ptr0, len0);\n    }\n    /**\n    * @param {any} arg0\n    */\n    onError(arg0) {\n        const ptr = this.__destroy_into_raw();\n        wasm.gqlquery_onError(ptr, addHeapObject(arg0));\n    }\n    /**\n    */\n    onTimeout() {\n        const ptr = this.__destroy_into_raw();\n        wasm.gqlquery_onTimeout(ptr);\n    }\n}\n/**\n*/\nclass JrpcConnection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(JrpcConnection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jrpcconnection_free(ptr);\n    }\n    /**\n    * @param {ClockWithOffset} clock\n    * @param {any} sender\n    */\n    constructor(clock, sender) {\n        _assertClass(clock, ClockWithOffset);\n        const ret = wasm.jrpcconnection_new(clock.ptr, addHeapObject(sender));\n        return JrpcConnection.__wrap(ret);\n    }\n}\n/**\n*/\nclass JrpcQuery {\n\n    static __wrap(ptr) {\n        const obj = Object.create(JrpcQuery.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jrpcquery_free(ptr);\n    }\n    /**\n    * @param {string} data\n    */\n    onReceive(data) {\n        const ptr = this.__destroy_into_raw();\n        const ptr0 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.jrpcquery_onReceive(ptr, ptr0, len0);\n    }\n    /**\n    * @param {any} arg0\n    */\n    onError(arg0) {\n        const ptr = this.__destroy_into_raw();\n        wasm.jrpcquery_onError(ptr, addHeapObject(arg0));\n    }\n    /**\n    */\n    onTimeout() {\n        const ptr = this.__destroy_into_raw();\n        wasm.jrpcquery_onTimeout(ptr);\n    }\n}\n/**\n*/\nclass Transport {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Transport.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transport_free(ptr);\n    }\n    /**\n    * @param {GqlConnection} gql\n    * @returns {Transport}\n    */\n    static fromGqlConnection(gql) {\n        _assertClass(gql, GqlConnection);\n        const ret = wasm.transport_fromGqlConnection(gql.ptr);\n        return Transport.__wrap(ret);\n    }\n    /**\n    * @param {JrpcConnection} jrpc\n    * @returns {Transport}\n    */\n    static fromJrpcConnection(jrpc) {\n        _assertClass(jrpc, JrpcConnection);\n        const ret = wasm.transport_fromJrpcConnection(jrpc.ptr);\n        return Transport.__wrap(ret);\n    }\n    /**\n    * @param {string} address\n    * @param {any} handler\n    * @returns {Promise<GenericContract>}\n    */\n    subscribeToGenericContract(address, handler) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transport_subscribeToGenericContract(retptr, this.ptr, ptr0, len0, addHeapObject(handler));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} address\n    * @returns {Promise<FullContractState | undefined>}\n    */\n    getFullContractState(address) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transport_getFullContractState(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} code_hash\n    * @param {number} limit\n    * @param {string | undefined} continuation\n    * @returns {Promise<AccountsList>}\n    */\n    getAccountsByCodeHash(code_hash, limit, continuation) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(code_hash, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            var ptr1 = isLikeNone(continuation) ? 0 : passStringToWasm0(continuation, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.transport_getAccountsByCodeHash(retptr, this.ptr, ptr0, len0, limit, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} address\n    * @param {string | undefined} continuation\n    * @param {number} limit\n    * @returns {Promise<TransactionsList>}\n    */\n    getTransactions(address, continuation, limit) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            var ptr1 = isLikeNone(continuation) ? 0 : passStringToWasm0(continuation, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.transport_getTransactions(retptr, this.ptr, ptr0, len0, ptr1, len1, limit);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} hash\n    * @returns {Promise<Transaction | undefined>}\n    */\n    getTransaction(hash) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hash, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transport_getTransaction(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} message_hash\n    * @returns {Promise<Transaction | undefined>}\n    */\n    getDstTransaction(message_hash) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(message_hash, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transport_getDstTransaction(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass UnsignedMessage {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnsignedMessage.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unsignedmessage_free(ptr);\n    }\n    /**\n    * @param {ClockWithOffset} clock\n    */\n    refreshTimeout(clock) {\n        _assertClass(clock, ClockWithOffset);\n        wasm.unsignedmessage_refreshTimeout(this.ptr, clock.ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    expireAt() {\n        const ret = wasm.unsignedmessage_expireAt(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {string}\n    */\n    get hash() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unsignedmessage_hash(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} signature\n    * @returns {SignedMessage}\n    */\n    sign(signature) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(signature, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.unsignedmessage_sign(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {SignedMessage}\n    */\n    signFake() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unsignedmessage_signFake(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nasync function load(module, imports) {\n    if (typeof Response === \'function\' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === \'function\') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get(\'Content-Type\') != \'application/wasm\') {\n                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction getImports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_length_6e3bbe7c8bd4dbd8 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === \'number\' ? obj : undefined;\n        getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n    };\n    imports.wbg.__wbindgen_is_null = function(arg0) {\n        const ret = getObject(arg0) === null;\n        return ret;\n    };\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === \'string\' ? obj : undefined;\n        var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === \'object\' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === \'string\';\n        return ret;\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_now_58886682b7e790d7 = function() {\n        const ret = Date.now();\n        return ret;\n    };\n    imports.wbg.__wbg_new_8d2af00bc1e329ee = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_0b9bfdd97583284e = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_send_55c5735308610fc0 = function(arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).send(getStringFromWasm0(arg1, arg2), GqlQuery.__wrap(arg3), arg4 !== 0);\n    };\n    imports.wbg.__wbg_send_c4fe5ef5f4851b5a = function(arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).send(getStringFromWasm0(arg1, arg2), JrpcQuery.__wrap(arg3), arg4 !== 0);\n    };\n    imports.wbg.__wbg_new_1d9a920c6bfc44a8 = function() {\n        const ret = new Array();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_push_740e4b286702d964 = function(arg0, arg1) {\n        const ret = getObject(arg0).push(getObject(arg1));\n        return ret;\n    };\n    imports.wbg.__wbg_genericcontract_new = function(arg0) {\n        const ret = GenericContract.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_onMessageSent_fc2ded3b8153507a = function(arg0, arg1, arg2) {\n        getObject(arg0).onMessageSent(takeObject(arg1), takeObject(arg2));\n    };\n    imports.wbg.__wbg_onMessageExpired_fbdb4b1a8bb0e7c5 = function(arg0, arg1) {\n        getObject(arg0).onMessageExpired(takeObject(arg1));\n    };\n    imports.wbg.__wbg_onStateChanged_e696a7b987dba9ea = function(arg0, arg1) {\n        getObject(arg0).onStateChanged(takeObject(arg1));\n    };\n    imports.wbg.__wbg_onTransactionsFound_33b7b56c770e2e88 = function(arg0, arg1, arg2) {\n        getObject(arg0).onTransactionsFound(takeObject(arg1), takeObject(arg2));\n    };\n    imports.wbg.__wbg_keys_0702294afaeb6044 = function(arg0) {\n        const ret = Object.keys(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_57245cc7d7c7619d = function(arg0, arg1) {\n        const ret = getObject(arg0)[arg1 >>> 0];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = getObject(arg0);\n        const ret = typeof(v) === \'boolean\' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbg_isLocal_0cc0f6258c8cf6ca = function(arg0) {\n        const ret = getObject(arg0).isLocal();\n        return ret;\n    };\n    imports.wbg.__wbg_new_9962f939219f1820 = function(arg0, arg1) {\n        try {\n            var state0 = {a: arg0, b: arg1};\n            var cb0 = (arg0, arg1) => {\n                const a = state0.a;\n                state0.a = 0;\n                try {\n                    return __wbg_adapter_163(a, state0.b, arg0, arg1);\n                } finally {\n                    state0.a = a;\n                }\n            };\n            const ret = new Promise(cb0);\n            return addHeapObject(ret);\n        } finally {\n            state0.a = state0.b = 0;\n        }\n    };\n    imports.wbg.__wbg_static_accessor_NODE_MODULE_cf6401cc1091279e = function() {\n        const ret = module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_process_0cc2ada8524d6f83 = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_versions_c11acceab27a6c87 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_node_7ff1ce49caf23815 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_a746e79b322b9336 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_crypto_2036bed7c44c25e7 = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_msCrypto_a21fc88caf1ecdc8 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_f5933855e4f48a19 = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_765201544a2b6869 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_self_6d479506f72c6a71 = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_window_f2557cc78490aceb = function() { return handleError(function () {\n        const ret = window.window;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_7f206bda628d5286 = function() { return handleError(function () {\n        const ret = globalThis.globalThis;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_global_ba75c50d1cf384f4 = function() { return handleError(function () {\n        const ret = __webpack_require__.g.global;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_newnoargs_b5b063fc6c2f0376 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_call_97ae9d8645dc388b = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_isArray_27c46c67f498e15d = function(arg0) {\n        const ret = Array.isArray(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_call_168da88779e35f61 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_set_bf3f89b92d5a34bf = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_randomFillSync_065afffde01daa66 = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_subarray_58ad4efbb5bcb886 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getRandomValues_b99eec4244a475bb = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_length_9e1ae1900cb0fbd5 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_buffer_3f3d764d4747d564 = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_8c3f0052272a457a = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_83db9690f9353e79 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(getObject(arg1));\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbg_then_11f7a54d67b4bfad = function(arg0, arg1) {\n        const ret = getObject(arg0).then(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cb_drop = function(arg0) {\n        const obj = takeObject(arg0).original;\n        if (obj.cnt-- == 1) {\n            obj.a = 0;\n            return true;\n        }\n        const ret = false;\n        return ret;\n    };\n    imports.wbg.__wbg_resolve_99fe17964f31ffc0 = function(arg0) {\n        const ret = Promise.resolve(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6437 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 925, __wbg_adapter_32);\n        return addHeapObject(ret);\n    };\n\n    return imports;\n}\n\nfunction initMemory(imports, maybe_memory) {\n\n}\n\nfunction finalizeInit(instance, module) {\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n    cachedFloat64Memory0 = new Float64Array();\n    cachedInt32Memory0 = new Int32Array();\n    cachedUint8Memory0 = new Uint8Array();\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    const imports = getImports();\n\n    initMemory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return finalizeInit(instance, module);\n}\n\nasync function init(input) {\n    if (typeof input === \'undefined\') {\n        input = new URL(/* asset import */ __webpack_require__(444), __webpack_require__.b);\n    }\n    const imports = getImports();\n\n    if (typeof input === \'string\' || (typeof Request === \'function\' && input instanceof Request) || (typeof URL === \'function\' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    initMemory(imports);\n\n    const { instance, module } = await load(await input, imports);\n\n    return finalizeInit(instance, module);\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (init);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTU5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4LWJhdHRsZS1nYW1lLy4vbm9kZV9tb2R1bGVzL25la290b24td2FzbS9uZWtvdG9uX3dhc20uanM/ZDUyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmxldCB3YXNtO1xuXG5jb25zdCBjYWNoZWRUZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGlnbm9yZUJPTTogdHJ1ZSwgZmF0YWw6IHRydWUgfSk7XG5cbmNhY2hlZFRleHREZWNvZGVyLmRlY29kZSgpO1xuXG5sZXQgY2FjaGVkVWludDhNZW1vcnkwID0gbmV3IFVpbnQ4QXJyYXkoKTtcblxuZnVuY3Rpb24gZ2V0VWludDhNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWRVaW50OE1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRVaW50OE1lbW9yeTAgPSBuZXcgVWludDhBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkVWludDhNZW1vcnkwO1xufVxuXG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyLCBsZW4pIHtcbiAgICByZXR1cm4gY2FjaGVkVGV4dERlY29kZXIuZGVjb2RlKGdldFVpbnQ4TWVtb3J5MCgpLnN1YmFycmF5KHB0ciwgcHRyICsgbGVuKSk7XG59XG5cbmNvbnN0IGhlYXAgPSBuZXcgQXJyYXkoMzIpLmZpbGwodW5kZWZpbmVkKTtcblxuaGVhcC5wdXNoKHVuZGVmaW5lZCwgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xuXG5sZXQgaGVhcF9uZXh0ID0gaGVhcC5sZW5ndGg7XG5cbmZ1bmN0aW9uIGFkZEhlYXBPYmplY3Qob2JqKSB7XG4gICAgaWYgKGhlYXBfbmV4dCA9PT0gaGVhcC5sZW5ndGgpIGhlYXAucHVzaChoZWFwLmxlbmd0aCArIDEpO1xuICAgIGNvbnN0IGlkeCA9IGhlYXBfbmV4dDtcbiAgICBoZWFwX25leHQgPSBoZWFwW2lkeF07XG5cbiAgICBoZWFwW2lkeF0gPSBvYmo7XG4gICAgcmV0dXJuIGlkeDtcbn1cblxuZnVuY3Rpb24gZ2V0T2JqZWN0KGlkeCkgeyByZXR1cm4gaGVhcFtpZHhdOyB9XG5cbmZ1bmN0aW9uIGlzTGlrZU5vbmUoeCkge1xuICAgIHJldHVybiB4ID09PSB1bmRlZmluZWQgfHwgeCA9PT0gbnVsbDtcbn1cblxubGV0IGNhY2hlZEZsb2F0NjRNZW1vcnkwID0gbmV3IEZsb2F0NjRBcnJheSgpO1xuXG5mdW5jdGlvbiBnZXRGbG9hdDY0TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkRmxvYXQ2NE1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRGbG9hdDY0TWVtb3J5MCA9IG5ldyBGbG9hdDY0QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZEZsb2F0NjRNZW1vcnkwO1xufVxuXG5sZXQgY2FjaGVkSW50MzJNZW1vcnkwID0gbmV3IEludDMyQXJyYXkoKTtcblxuZnVuY3Rpb24gZ2V0SW50MzJNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWRJbnQzMk1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRJbnQzMk1lbW9yeTAgPSBuZXcgSW50MzJBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkSW50MzJNZW1vcnkwO1xufVxuXG5sZXQgV0FTTV9WRUNUT1JfTEVOID0gMDtcblxuY29uc3QgY2FjaGVkVGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoJ3V0Zi04Jyk7XG5cbmNvbnN0IGVuY29kZVN0cmluZyA9ICh0eXBlb2YgY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlSW50byA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZnVuY3Rpb24gKGFyZywgdmlldykge1xuICAgIHJldHVybiBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGVJbnRvKGFyZywgdmlldyk7XG59XG4gICAgOiBmdW5jdGlvbiAoYXJnLCB2aWV3KSB7XG4gICAgY29uc3QgYnVmID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlKGFyZyk7XG4gICAgdmlldy5zZXQoYnVmKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWFkOiBhcmcubGVuZ3RoLFxuICAgICAgICB3cml0dGVuOiBidWYubGVuZ3RoXG4gICAgfTtcbn0pO1xuXG5mdW5jdGlvbiBwYXNzU3RyaW5nVG9XYXNtMChhcmcsIG1hbGxvYywgcmVhbGxvYykge1xuXG4gICAgaWYgKHJlYWxsb2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBidWYgPSBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGUoYXJnKTtcbiAgICAgICAgY29uc3QgcHRyID0gbWFsbG9jKGJ1Zi5sZW5ndGgpO1xuICAgICAgICBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIsIHB0ciArIGJ1Zi5sZW5ndGgpLnNldChidWYpO1xuICAgICAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBidWYubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGxldCBsZW4gPSBhcmcubGVuZ3RoO1xuICAgIGxldCBwdHIgPSBtYWxsb2MobGVuKTtcblxuICAgIGNvbnN0IG1lbSA9IGdldFVpbnQ4TWVtb3J5MCgpO1xuXG4gICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICBmb3IgKDsgb2Zmc2V0IDwgbGVuOyBvZmZzZXQrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gYXJnLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgaWYgKGNvZGUgPiAweDdGKSBicmVhaztcbiAgICAgICAgbWVtW3B0ciArIG9mZnNldF0gPSBjb2RlO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXQgIT09IGxlbikge1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBwdHIgPSByZWFsbG9jKHB0ciwgbGVuLCBsZW4gPSBvZmZzZXQgKyBhcmcubGVuZ3RoICogMyk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIgKyBvZmZzZXQsIHB0ciArIGxlbik7XG4gICAgICAgIGNvbnN0IHJldCA9IGVuY29kZVN0cmluZyhhcmcsIHZpZXcpO1xuXG4gICAgICAgIG9mZnNldCArPSByZXQud3JpdHRlbjtcbiAgICB9XG5cbiAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHB0cjtcbn1cblxuZnVuY3Rpb24gZHJvcE9iamVjdChpZHgpIHtcbiAgICBpZiAoaWR4IDwgMzYpIHJldHVybjtcbiAgICBoZWFwW2lkeF0gPSBoZWFwX25leHQ7XG4gICAgaGVhcF9uZXh0ID0gaWR4O1xufVxuXG5mdW5jdGlvbiB0YWtlT2JqZWN0KGlkeCkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChpZHgpO1xuICAgIGRyb3BPYmplY3QoaWR4KTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkZWJ1Z1N0cmluZyh2YWwpIHtcbiAgICAvLyBwcmltaXRpdmUgdHlwZXNcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbDtcbiAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdib29sZWFuJyB8fCB2YWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIGAke3ZhbH1gO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYFwiJHt2YWx9XCJgO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSAnc3ltYm9sJykge1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbC5kZXNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnU3ltYm9sJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgU3ltYm9sKCR7ZGVzY3JpcHRpb259KWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBuYW1lID0gdmFsLm5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyAmJiBuYW1lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBgRnVuY3Rpb24oJHtuYW1lfSlgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdGdW5jdGlvbic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb2JqZWN0c1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdmFsLmxlbmd0aDtcbiAgICAgICAgbGV0IGRlYnVnID0gJ1snO1xuICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGVidWcgKz0gZGVidWdTdHJpbmcodmFsWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRlYnVnICs9ICcsICcgKyBkZWJ1Z1N0cmluZyh2YWxbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnICs9ICddJztcbiAgICAgICAgcmV0dXJuIGRlYnVnO1xuICAgIH1cbiAgICAvLyBUZXN0IGZvciBidWlsdC1pblxuICAgIGNvbnN0IGJ1aWx0SW5NYXRjaGVzID0gL1xcW29iamVjdCAoW15cXF1dKylcXF0vLmV4ZWModG9TdHJpbmcuY2FsbCh2YWwpKTtcbiAgICBsZXQgY2xhc3NOYW1lO1xuICAgIGlmIChidWlsdEluTWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IGJ1aWx0SW5NYXRjaGVzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZhaWxlZCB0byBtYXRjaCB0aGUgc3RhbmRhcmQgJ1tvYmplY3QgQ2xhc3NOYW1lXSdcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKTtcbiAgICB9XG4gICAgaWYgKGNsYXNzTmFtZSA9PSAnT2JqZWN0Jykge1xuICAgICAgICAvLyB3ZSdyZSBhIHVzZXIgZGVmaW5lZCBjbGFzcyBvciBPYmplY3RcbiAgICAgICAgLy8gSlNPTi5zdHJpbmdpZnkgYXZvaWRzIHByb2JsZW1zIHdpdGggY3ljbGVzLCBhbmQgaXMgZ2VuZXJhbGx5IG11Y2hcbiAgICAgICAgLy8gZWFzaWVyIHRoYW4gbG9vcGluZyB0aHJvdWdoIG93blByb3BlcnRpZXMgb2YgYHZhbGAuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gJ09iamVjdCgnICsgSlNPTi5zdHJpbmdpZnkodmFsKSArICcpJztcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuICdPYmplY3QnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVycm9yc1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gYCR7dmFsLm5hbWV9OiAke3ZhbC5tZXNzYWdlfVxcbiR7dmFsLnN0YWNrfWA7XG4gICAgfVxuICAgIC8vIFRPRE8gd2UgY291bGQgdGVzdCBmb3IgbW9yZSB0aGluZ3MgaGVyZSwgbGlrZSBgU2V0YHMgYW5kIGBNYXBgcy5cbiAgICByZXR1cm4gY2xhc3NOYW1lO1xufVxuXG5mdW5jdGlvbiBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCBkdG9yLCBmKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB7IGE6IGFyZzAsIGI6IGFyZzEsIGNudDogMSwgZHRvciB9O1xuICAgIGNvbnN0IHJlYWwgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAvLyBGaXJzdCB1cCB3aXRoIGEgY2xvc3VyZSB3ZSBpbmNyZW1lbnQgdGhlIGludGVybmFsIHJlZmVyZW5jZVxuICAgICAgICAvLyBjb3VudC4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIFJ1c3QgY2xvc3VyZSBlbnZpcm9ubWVudCB3b24ndFxuICAgICAgICAvLyBiZSBkZWFsbG9jYXRlZCB3aGlsZSB3ZSdyZSBpbnZva2luZyBpdC5cbiAgICAgICAgc3RhdGUuY250Kys7XG4gICAgICAgIGNvbnN0IGEgPSBzdGF0ZS5hO1xuICAgICAgICBzdGF0ZS5hID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmKGEsIHN0YXRlLmIsIC4uLmFyZ3MpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKC0tc3RhdGUuY250ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yLmdldChzdGF0ZS5kdG9yKShhLCBzdGF0ZS5iKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmVhbC5vcmlnaW5hbCA9IHN0YXRlO1xuXG4gICAgcmV0dXJuIHJlYWw7XG59XG5mdW5jdGlvbiBfX3diZ19hZGFwdGVyXzMyKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICB3YXNtLl9keW5fY29yZV9fb3BzX19mdW5jdGlvbl9fRm5NdXRfX0FfX19fT3V0cHV0X19fUl9hc193YXNtX2JpbmRnZW5fX2Nsb3N1cmVfX1dhc21DbG9zdXJlX19fZGVzY3JpYmVfX2ludm9rZV9faGNiNzc3MjljNmFmOWQzNzYoYXJnMCwgYXJnMSwgYWRkSGVhcE9iamVjdChhcmcyKSk7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRDbGFzcyhpbnN0YW5jZSwga2xhc3MpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIGtsYXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIGluc3RhbmNlIG9mICR7a2xhc3MubmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlLnB0cjtcbn1cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYWRkcmVzcywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgY29uc3QgcmV0ID0gd2FzbS5jaGVja0FkZHJlc3MocHRyMCwgbGVuMCk7XG4gICAgcmV0dXJuIHJldCAhPT0gMDtcbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzXG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGFja0FkZHJlc3MoYWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYWRkcmVzcywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLnJlcGFja0FkZHJlc3MocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICB2YXIgcHRyMSA9IHIwO1xuICAgICAgICB2YXIgbGVuMSA9IHIxO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHB0cjEgPSAwOyBsZW4xID0gMDtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMSwgbGVuMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocHRyMSwgbGVuMSk7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtDbG9ja1dpdGhPZmZzZXR9IGNsb2NrXG4qIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50X3N0dWZmX2JvY1xuKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RfYWJpXG4qIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiogQHBhcmFtIHtUb2tlbnNPYmplY3R9IGlucHV0XG4qIEBwYXJhbSB7Ym9vbGVhbn0gcmVzcG9uc2libGVcbiogQHJldHVybnMge0V4ZWN1dGlvbk91dHB1dH1cbiovXG5leHBvcnQgZnVuY3Rpb24gcnVuTG9jYWwoY2xvY2ssIGFjY291bnRfc3R1ZmZfYm9jLCBjb250cmFjdF9hYmksIG1ldGhvZCwgaW5wdXQsIHJlc3BvbnNpYmxlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjbG9jaywgQ2xvY2tXaXRoT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFjY291bnRfc3R1ZmZfYm9jLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChjb250cmFjdF9hYmksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMiA9IHBhc3NTdHJpbmdUb1dhc20wKG1ldGhvZCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLnJ1bkxvY2FsKHJldHB0ciwgY2xvY2sucHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBwdHIyLCBsZW4yLCBhZGRIZWFwT2JqZWN0KGlucHV0KSwgcmVzcG9uc2libGUpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50X3N0dWZmX2JvY1xuKiBAcmV0dXJucyB7c3RyaW5nfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRnVsbEFjY291bnRCb2MoYWNjb3VudF9zdHVmZl9ib2MpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFjY291bnRfc3R1ZmZfYm9jLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20ubWFrZUZ1bGxBY2NvdW50Qm9jKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgdmFyIHB0cjEgPSByMDtcbiAgICAgICAgdmFyIGxlbjEgPSByMTtcbiAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICBwdHIxID0gMDsgbGVuMSA9IDA7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjEsIGxlbjEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHB0cjEsIGxlbjEpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50XG4qIEByZXR1cm5zIHtGdWxsQ29udHJhY3RTdGF0ZSB8IHVuZGVmaW5lZH1cbiovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGdWxsQWNjb3VudEJvYyhhY2NvdW50KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhY2NvdW50LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20ucGFyc2VGdWxsQWNjb3VudEJvYyhyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBjb25maWdcbiogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRcbiogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiogQHBhcmFtIHtudW1iZXJ9IHV0aW1lXG4qIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZV9zaWduYXR1cmVfY2hlY2tcbiogQHJldHVybnMge1RyYW5zYWN0aW9uRXhlY3V0b3JPdXRwdXR9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVMb2NhbChjb25maWcsIGFjY291bnQsIG1lc3NhZ2UsIHV0aW1lLCBkaXNhYmxlX3NpZ25hdHVyZV9jaGVjaykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY29uZmlnLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChhY2NvdW50LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjIgPSBwYXNzU3RyaW5nVG9XYXNtMChtZXNzYWdlLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjIgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uZXhlY3V0ZUxvY2FsKHJldHB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgcHRyMiwgbGVuMiwgdXRpbWUsIGRpc2FibGVfc2lnbmF0dXJlX2NoZWNrKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gdHZjXG4qIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdF9hYmlcbiogQHBhcmFtIHtudW1iZXJ9IHdvcmtjaGFpbl9pZFxuKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gcHVibGljX2tleVxuKiBAcGFyYW0ge1Rva2Vuc09iamVjdH0gaW5pdF9kYXRhXG4qIEByZXR1cm5zIHtFeHBlY3RlZEFkZHJlc3N9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEV4cGVjdGVkQWRkcmVzcyh0dmMsIGNvbnRyYWN0X2FiaSwgd29ya2NoYWluX2lkLCBwdWJsaWNfa2V5LCBpbml0X2RhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHR2Yywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAoY29udHJhY3RfYWJpLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIyID0gaXNMaWtlTm9uZShwdWJsaWNfa2V5KSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChwdWJsaWNfa2V5LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmdldEV4cGVjdGVkQWRkcmVzcyhyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIHdvcmtjaGFpbl9pZCwgcHRyMiwgbGVuMiwgYWRkSGVhcE9iamVjdChpbml0X2RhdGEpKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gYm9jXG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJvY0hhc2goYm9jKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChib2MsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5nZXRCb2NIYXNoKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgdmFyIHB0cjEgPSByMDtcbiAgICAgICAgdmFyIGxlbjEgPSByMTtcbiAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICBwdHIxID0gMDsgbGVuMSA9IDA7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjEsIGxlbjEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHB0cjEsIGxlbjEpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7QXJyYXk8QWJpUGFyYW0+fSBwYXJhbXNcbiogQHBhcmFtIHtUb2tlbnNPYmplY3R9IHRva2Vuc1xuKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gYWJpX3ZlcnNpb25cbiogQHJldHVybnMge3N0cmluZ31cbiovXG5leHBvcnQgZnVuY3Rpb24gcGFja0ludG9DZWxsKHBhcmFtcywgdG9rZW5zLCBhYmlfdmVyc2lvbikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoYWJpX3ZlcnNpb24pID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKGFiaV92ZXJzaW9uLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLnBhY2tJbnRvQ2VsbChyZXRwdHIsIGFkZEhlYXBPYmplY3QocGFyYW1zKSwgYWRkSGVhcE9iamVjdCh0b2tlbnMpLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICB2YXIgcHRyMSA9IHIwO1xuICAgICAgICB2YXIgbGVuMSA9IHIxO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHB0cjEgPSAwOyBsZW4xID0gMDtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMSwgbGVuMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocHRyMSwgbGVuMSk7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtBcnJheTxBYmlQYXJhbT59IHBhcmFtc1xuKiBAcGFyYW0ge3N0cmluZ30gYm9jXG4qIEBwYXJhbSB7Ym9vbGVhbn0gYWxsb3dfcGFydGlhbFxuKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gYWJpX3ZlcnNpb25cbiogQHJldHVybnMge1Rva2Vuc09iamVjdH1cbiovXG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrRnJvbUNlbGwocGFyYW1zLCBib2MsIGFsbG93X3BhcnRpYWwsIGFiaV92ZXJzaW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChib2MsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgdmFyIHB0cjEgPSBpc0xpa2VOb25lKGFiaV92ZXJzaW9uKSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChhYmlfdmVyc2lvbiwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS51bnBhY2tGcm9tQ2VsbChyZXRwdHIsIGFkZEhlYXBPYmplY3QocGFyYW1zKSwgcHRyMCwgbGVuMCwgYWxsb3dfcGFydGlhbCwgcHRyMSwgbGVuMSk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IGJvY1xuKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0Q29udHJhY3REYXRhKGJvYykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYm9jLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uZXh0cmFjdENvbnRyYWN0RGF0YShyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICB2YXIgcjMgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgM107XG4gICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHYxO1xuICAgICAgICBpZiAocjAgIT09IDApIHtcbiAgICAgICAgICAgIHYxID0gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHIwLCByMSAqIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2MTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBib2NcbiogQHJldHVybnMge3N0cmluZ31cbiovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFB1YmxpY0tleShib2MpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGJvYywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmV4dHJhY3RQdWJsaWNLZXkocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICB2YXIgcHRyMSA9IHIwO1xuICAgICAgICB2YXIgbGVuMSA9IHIxO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHB0cjEgPSAwOyBsZW4xID0gMDtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMSwgbGVuMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocHRyMSwgbGVuMSk7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiogQHJldHVybnMge3N0cmluZ31cbiovXG5leHBvcnQgZnVuY3Rpb24gY29kZVRvVHZjKGNvZGUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGNvZGUsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5jb2RlVG9UdmMocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICB2YXIgcHRyMSA9IHIwO1xuICAgICAgICB2YXIgbGVuMSA9IHIxO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHB0cjEgPSAwOyBsZW4xID0gMDtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMSwgbGVuMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocHRyMSwgbGVuMSk7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiogQHJldHVybnMge3N0cmluZ31cbiovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VUdmMoY29kZSwgZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY29kZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAoZGF0YSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLm1lcmdlVHZjKHJldHB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgdmFyIHB0cjIgPSByMDtcbiAgICAgICAgdmFyIGxlbjIgPSByMTtcbiAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICBwdHIyID0gMDsgbGVuMiA9IDA7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjIsIGxlbjIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHB0cjIsIGxlbjIpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSB0dmNcbiogQHJldHVybnMge1N0YXRlSW5pdH1cbiovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRUdmModHZjKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMCh0dmMsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5zcGxpdFR2YyhyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4qIEBwYXJhbSB7c3RyaW5nfSBzYWx0XG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHNldENvZGVTYWx0KGNvZGUsIHNhbHQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGNvZGUsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHNhbHQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5zZXRDb2RlU2FsdChyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICB2YXIgcjMgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgM107XG4gICAgICAgIHZhciBwdHIyID0gcjA7XG4gICAgICAgIHZhciBsZW4yID0gcjE7XG4gICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgcHRyMiA9IDA7IGxlbjIgPSAwO1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIyLCBsZW4yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShwdHIyLCBsZW4yKTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2RlU2FsdChjb2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChjb2RlLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uZ2V0Q29kZVNhbHQocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICAgICAgICB2MSA9IGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyMCwgcjEgKiAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjE7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RfYWJpXG4qIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiogQHBhcmFtIHtUb2tlbnNPYmplY3R9IGlucHV0XG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUludGVybmFsSW5wdXQoY29udHJhY3RfYWJpLCBtZXRob2QsIGlucHV0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChjb250cmFjdF9hYmksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKG1ldGhvZCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmVuY29kZUludGVybmFsSW5wdXQocmV0cHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBhZGRIZWFwT2JqZWN0KGlucHV0KSk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgdmFyIHB0cjIgPSByMDtcbiAgICAgICAgdmFyIGxlbjIgPSByMTtcbiAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICBwdHIyID0gMDsgbGVuMiA9IDA7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjIsIGxlbjIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHB0cjIsIGxlbjIpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBzcmNcbiogQHBhcmFtIHtzdHJpbmd9IGRzdFxuKiBAcGFyYW0ge2Jvb2xlYW59IGJvdW5jZVxuKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gc3RhdGVfaW5pdFxuKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gYm9keVxuKiBAcGFyYW0ge3N0cmluZ30gYW1vdW50XG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUludGVybmFsTWVzc2FnZShzcmMsIGRzdCwgYm91bmNlLCBzdGF0ZV9pbml0LCBib2R5LCBhbW91bnQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKHNyYykgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoc3JjLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAoZHN0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIyID0gaXNMaWtlTm9uZShzdGF0ZV9pbml0KSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChzdGF0ZV9pbml0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMyA9IGlzTGlrZU5vbmUoYm9keSkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoYm9keSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMyA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyNCA9IHBhc3NTdHJpbmdUb1dhc20wKGFtb3VudCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW40ID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmVuY29kZUludGVybmFsTWVzc2FnZShyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIGJvdW5jZSwgcHRyMiwgbGVuMiwgcHRyMywgbGVuMywgcHRyNCwgbGVuNCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgdmFyIHB0cjUgPSByMDtcbiAgICAgICAgdmFyIGxlbjUgPSByMTtcbiAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICBwdHI1ID0gMDsgbGVuNSA9IDA7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjUsIGxlbjUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHB0cjUsIGxlbjUpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlX2JvZHlcbiogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0X2FiaVxuKiBAcGFyYW0ge01ldGhvZE5hbWV9IG1ldGhvZFxuKiBAcGFyYW0ge2Jvb2xlYW59IGludGVybmFsXG4qIEByZXR1cm5zIHtEZWNvZGVkSW5wdXQgfCB1bmRlZmluZWR9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUlucHV0KG1lc3NhZ2VfYm9keSwgY29udHJhY3RfYWJpLCBtZXRob2QsIGludGVybmFsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChtZXNzYWdlX2JvZHksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKGNvbnRyYWN0X2FiaSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmRlY29kZUlucHV0KHJldHB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgYWRkSGVhcE9iamVjdChtZXRob2QpLCBpbnRlcm5hbCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VfYm9keVxuKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RfYWJpXG4qIEBwYXJhbSB7TWV0aG9kTmFtZX0gZXZlbnRcbiogQHJldHVybnMge0RlY29kZWRFdmVudCB8IHVuZGVmaW5lZH1cbiovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRXZlbnQobWVzc2FnZV9ib2R5LCBjb250cmFjdF9hYmksIGV2ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChtZXNzYWdlX2JvZHksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKGNvbnRyYWN0X2FiaSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmRlY29kZUV2ZW50KHJldHB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgYWRkSGVhcE9iamVjdChldmVudCkpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlX2JvZHlcbiogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0X2FiaVxuKiBAcGFyYW0ge01ldGhvZE5hbWV9IG1ldGhvZFxuKiBAcmV0dXJucyB7RGVjb2RlZE91dHB1dCB8IHVuZGVmaW5lZH1cbiovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlT3V0cHV0KG1lc3NhZ2VfYm9keSwgY29udHJhY3RfYWJpLCBtZXRob2QpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKG1lc3NhZ2VfYm9keSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAoY29udHJhY3RfYWJpLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uZGVjb2RlT3V0cHV0KHJldHB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgYWRkSGVhcE9iamVjdChtZXRob2QpKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RfYWJpXG4qIEBwYXJhbSB7TWV0aG9kTmFtZX0gbWV0aG9kXG4qIEByZXR1cm5zIHtEZWNvZGVkVHJhbnNhY3Rpb24gfCB1bmRlZmluZWR9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb250cmFjdF9hYmksIG1ldGhvZCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY29udHJhY3RfYWJpLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uZGVjb2RlVHJhbnNhY3Rpb24ocmV0cHRyLCBhZGRIZWFwT2JqZWN0KHRyYW5zYWN0aW9uKSwgcHRyMCwgbGVuMCwgYWRkSGVhcE9iamVjdChtZXRob2QpKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RfYWJpXG4qIEByZXR1cm5zIHtEZWNvZGVkVHJhbnNhY3Rpb25FdmVudHN9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVRyYW5zYWN0aW9uRXZlbnRzKHRyYW5zYWN0aW9uLCBjb250cmFjdF9hYmkpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGNvbnRyYWN0X2FiaSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmRlY29kZVRyYW5zYWN0aW9uRXZlbnRzKHJldHB0ciwgYWRkSGVhcE9iamVjdCh0cmFuc2FjdGlvbiksIHB0cjAsIGxlbjApO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGFIYXNoKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGRhdGEsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5nZXREYXRhSGFzaChyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICB2YXIgcjMgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgM107XG4gICAgICAgIHZhciBwdHIxID0gcjA7XG4gICAgICAgIHZhciBsZW4xID0gcjE7XG4gICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgcHRyMSA9IDA7IGxlbjEgPSAwO1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIxLCBsZW4xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShwdHIxLCBsZW4xKTtcbiAgICB9XG59XG5cbi8qKlxuKiBAcmV0dXJucyB7RWQyNTUxOUtleVBhaXJ9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGVkMjU1MTlfZ2VuZXJhdGVLZXlQYWlyKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICB3YXNtLmVkMjU1MTlfZ2VuZXJhdGVLZXlQYWlyKHJldHB0cik7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IHNlY3JldF9rZXlcbiogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiogQHJldHVybnMge3N0cmluZ31cbiovXG5leHBvcnQgZnVuY3Rpb24gZWQyNTUxOV9zaWduKHNlY3JldF9rZXksIGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHNlY3JldF9rZXksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKGRhdGEsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5lZDI1NTE5X3NpZ24ocmV0cHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICB2YXIgcHRyMiA9IHIwO1xuICAgICAgICB2YXIgbGVuMiA9IHIxO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHB0cjIgPSAwOyBsZW4yID0gMDtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMiwgbGVuMik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocHRyMiwgbGVuMik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZVxuKiBAcmV0dXJucyB7RXh0ZW5kZWRTaWduYXR1cmV9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHNpZ25hdHVyZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmV4dGVuZFNpZ25hdHVyZShyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNfa2V5XG4qIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4qIEBwYXJhbSB7c3RyaW5nfSBzaWduYXR1cmVcbiogQHJldHVybnMge2Jvb2xlYW59XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZShwdWJsaWNfa2V5LCBkYXRhLCBzaWduYXR1cmUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHB1YmxpY19rZXksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKGRhdGEsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMiA9IHBhc3NTdHJpbmdUb1dhc20wKHNpZ25hdHVyZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLnZlcmlmeVNpZ25hdHVyZShyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIHB0cjIsIGxlbjIpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByMCAhPT0gMDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBkc3RcbiogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHN0YXRlX2luaXRcbiogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGJvZHlcbiogQHBhcmFtIHtudW1iZXJ9IGV4cGlyZV9hdFxuKiBAcmV0dXJucyB7U2lnbmVkTWVzc2FnZX1cbiovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmF3RXh0ZXJuYWxNZXNzYWdlKGRzdCwgc3RhdGVfaW5pdCwgYm9keSwgZXhwaXJlX2F0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChkc3QsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgdmFyIHB0cjEgPSBpc0xpa2VOb25lKHN0YXRlX2luaXQpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHN0YXRlX2luaXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIyID0gaXNMaWtlTm9uZShib2R5KSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChib2R5LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmNyZWF0ZVJhd0V4dGVybmFsTWVzc2FnZShyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIHB0cjIsIGxlbjIsIGV4cGlyZV9hdCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtDbG9ja1dpdGhPZmZzZXR9IGNsb2NrXG4qIEBwYXJhbSB7c3RyaW5nfSBkc3RcbiogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0X2FiaVxuKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4qIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBzdGF0ZV9pbml0XG4qIEBwYXJhbSB7VG9rZW5zT2JqZWN0fSBpbnB1dFxuKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuKiBAcmV0dXJucyB7U2lnbmVkTWVzc2FnZX1cbiovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXh0ZXJuYWxNZXNzYWdlV2l0aG91dFNpZ25hdHVyZShjbG9jaywgZHN0LCBjb250cmFjdF9hYmksIG1ldGhvZCwgc3RhdGVfaW5pdCwgaW5wdXQsIHRpbWVvdXQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGNsb2NrLCBDbG9ja1dpdGhPZmZzZXQpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoZHN0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChjb250cmFjdF9hYmksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMiA9IHBhc3NTdHJpbmdUb1dhc20wKG1ldGhvZCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMyA9IGlzTGlrZU5vbmUoc3RhdGVfaW5pdCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoc3RhdGVfaW5pdCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMyA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5jcmVhdGVFeHRlcm5hbE1lc3NhZ2VXaXRob3V0U2lnbmF0dXJlKHJldHB0ciwgY2xvY2sucHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBwdHIyLCBsZW4yLCBwdHIzLCBsZW4zLCBhZGRIZWFwT2JqZWN0KGlucHV0KSwgdGltZW91dCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogQHBhcmFtIHtDbG9ja1dpdGhPZmZzZXR9IGNsb2NrXG4qIEBwYXJhbSB7c3RyaW5nfSBkc3RcbiogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0X2FiaVxuKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4qIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBzdGF0ZV9pbml0XG4qIEBwYXJhbSB7VG9rZW5zT2JqZWN0fSBpbnB1dFxuKiBAcGFyYW0ge3N0cmluZ30gcHVibGljX2tleVxuKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuKiBAcmV0dXJucyB7VW5zaWduZWRNZXNzYWdlfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFeHRlcm5hbE1lc3NhZ2UoY2xvY2ssIGRzdCwgY29udHJhY3RfYWJpLCBtZXRob2QsIHN0YXRlX2luaXQsIGlucHV0LCBwdWJsaWNfa2V5LCB0aW1lb3V0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjbG9jaywgQ2xvY2tXaXRoT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGRzdCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAoY29udHJhY3RfYWJpLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjIgPSBwYXNzU3RyaW5nVG9XYXNtMChtZXRob2QsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMiA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgdmFyIHB0cjMgPSBpc0xpa2VOb25lKHN0YXRlX2luaXQpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHN0YXRlX2luaXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjMgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjQgPSBwYXNzU3RyaW5nVG9XYXNtMChwdWJsaWNfa2V5LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjQgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uY3JlYXRlRXh0ZXJuYWxNZXNzYWdlKHJldHB0ciwgY2xvY2sucHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBwdHIyLCBsZW4yLCBwdHIzLCBsZW4zLCBhZGRIZWFwT2JqZWN0KGlucHV0KSwgcHRyNCwgbGVuNCwgdGltZW91dCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVuc2lnbmVkTWVzc2FnZS5fX3dyYXAocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihmLCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhuX3N0b3JlKGFkZEhlYXBPYmplY3QoZSkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXlVOEZyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHJldHVybiBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIgLyAxLCBwdHIgLyAxICsgbGVuKTtcbn1cbmZ1bmN0aW9uIF9fd2JnX2FkYXB0ZXJfMTYzKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICB3YXNtLndhc21fYmluZGdlbl9fY29udmVydF9fY2xvc3VyZXNfX2ludm9rZTJfbXV0X19oZWNiYTg5NmQxNTYzZDIyMyhhcmcwLCBhcmcxLCBhZGRIZWFwT2JqZWN0KGFyZzIpLCBhZGRIZWFwT2JqZWN0KGFyZzMpKTtcbn1cblxuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIENsb2NrV2l0aE9mZnNldCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKENsb2NrV2l0aE9mZnNldC5wcm90b3R5cGUpO1xuICAgICAgICBvYmoucHRyID0gcHRyO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLnB0cjtcbiAgICAgICAgdGhpcy5wdHIgPSAwO1xuXG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19jbG9ja3dpdGhvZmZzZXRfZnJlZShwdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmNsb2Nrd2l0aG9mZnNldF9uZXcoKTtcbiAgICAgICAgcmV0dXJuIENsb2NrV2l0aE9mZnNldC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgZ2V0IG5vd01zKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmNsb2Nrd2l0aG9mZnNldF9ub3dNcyh0aGlzLnB0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldF9tc1xuICAgICovXG4gICAgdXBkYXRlT2Zmc2V0KG9mZnNldF9tcykge1xuICAgICAgICB3YXNtLmNsb2Nrd2l0aG9mZnNldF91cGRhdGVPZmZzZXQodGhpcy5wdHIsIG9mZnNldF9tcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIG9mZnNldE1zKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmNsb2Nrd2l0aG9mZnNldF9vZmZzZXRNcyh0aGlzLnB0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIEdlbmVyaWNDb250cmFjdCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEdlbmVyaWNDb250cmFjdC5wcm90b3R5cGUpO1xuICAgICAgICBvYmoucHRyID0gcHRyO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLnB0cjtcbiAgICAgICAgdGhpcy5wdHIgPSAwO1xuXG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19nZW5lcmljY29udHJhY3RfZnJlZShwdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgKi9cbiAgICBnZXQgYWRkcmVzcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5nZW5lcmljY29udHJhY3RfYWRkcmVzcyhyZXRwdHIsIHRoaXMucHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyMCwgcjEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtTaWduZWRNZXNzYWdlfSBtZXNzYWdlXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvbj59XG4gICAgKi9cbiAgICBzZW5kTWVzc2FnZUxvY2FsbHkobWVzc2FnZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmdlbmVyaWNjb250cmFjdF9zZW5kTWVzc2FnZUxvY2FsbHkocmV0cHRyLCB0aGlzLnB0ciwgYWRkSGVhcE9iamVjdChtZXNzYWdlKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1NpZ25lZE1lc3NhZ2V9IG1lc3NhZ2VcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPFBlbmRpbmdUcmFuc2FjdGlvbj59XG4gICAgKi9cbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uZ2VuZXJpY2NvbnRyYWN0X3NlbmRNZXNzYWdlKHJldHB0ciwgdGhpcy5wdHIsIGFkZEhlYXBPYmplY3QobWVzc2FnZSkpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgKi9cbiAgICByZWZyZXNoKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmdlbmVyaWNjb250cmFjdF9yZWZyZXNoKHRoaXMucHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gYmxvY2tfaWRcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICovXG4gICAgaGFuZGxlQmxvY2soYmxvY2tfaWQpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGJsb2NrX2lkLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZ2VuZXJpY2NvbnRyYWN0X2hhbmRsZUJsb2NrKHRoaXMucHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gbHRcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICovXG4gICAgcHJlbG9hZFRyYW5zYWN0aW9ucyhsdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAobHQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmdlbmVyaWNjb250cmFjdF9wcmVsb2FkVHJhbnNhY3Rpb25zKHJldHB0ciwgdGhpcy5wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1BvbGxpbmdNZXRob2R9XG4gICAgKi9cbiAgICBnZXQgcG9sbGluZ01ldGhvZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5nZW5lcmljY29udHJhY3RfcG9sbGluZ01ldGhvZCh0aGlzLnB0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxufVxuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIEdxbENvbm5lY3Rpb24ge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShHcWxDb25uZWN0aW9uLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5wdHIgPSBwdHI7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMucHRyO1xuICAgICAgICB0aGlzLnB0ciA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2dxbGNvbm5lY3Rpb25fZnJlZShwdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7Q2xvY2tXaXRoT2Zmc2V0fSBjbG9ja1xuICAgICogQHBhcmFtIHtJR3FsU2VuZGVyfSBzZW5kZXJcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsb2NrLCBzZW5kZXIpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGNsb2NrLCBDbG9ja1dpdGhPZmZzZXQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmdxbGNvbm5lY3Rpb25fbmV3KGNsb2NrLnB0ciwgYWRkSGVhcE9iamVjdChzZW5kZXIpKTtcbiAgICAgICAgcmV0dXJuIEdxbENvbm5lY3Rpb24uX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPExhdGVzdEJsb2NrPn1cbiAgICAqL1xuICAgIGdldExhdGVzdEJsb2NrKGFkZHJlc3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFkZHJlc3MsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmdxbGNvbm5lY3Rpb25fZ2V0TGF0ZXN0QmxvY2socmV0cHRyLCB0aGlzLnB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudF9ibG9ja19pZFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxuICAgICovXG4gICAgd2FpdEZvck5leHRCbG9jayhjdXJyZW50X2Jsb2NrX2lkLCBhZGRyZXNzLCB0aW1lb3V0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChjdXJyZW50X2Jsb2NrX2lkLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKGFkZHJlc3MsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmdxbGNvbm5lY3Rpb25fd2FpdEZvck5leHRCbG9jayhyZXRwdHIsIHRoaXMucHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBHcWxRdWVyeSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEdxbFF1ZXJ5LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5wdHIgPSBwdHI7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMucHRyO1xuICAgICAgICB0aGlzLnB0ciA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2dxbHF1ZXJ5X2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICAgICovXG4gICAgb25SZWNlaXZlKGRhdGEpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGRhdGEsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5ncWxxdWVyeV9vblJlY2VpdmUocHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge2FueX0gYXJnMFxuICAgICovXG4gICAgb25FcnJvcihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uZ3FscXVlcnlfb25FcnJvcihwdHIsIGFkZEhlYXBPYmplY3QoYXJnMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAqL1xuICAgIG9uVGltZW91dCgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5ncWxxdWVyeV9vblRpbWVvdXQocHRyKTtcbiAgICB9XG59XG4vKipcbiovXG5leHBvcnQgY2xhc3MgSnJwY0Nvbm5lY3Rpb24ge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShKcnBjQ29ubmVjdGlvbi5wcm90b3R5cGUpO1xuICAgICAgICBvYmoucHRyID0gcHRyO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLnB0cjtcbiAgICAgICAgdGhpcy5wdHIgPSAwO1xuXG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19qcnBjY29ubmVjdGlvbl9mcmVlKHB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtDbG9ja1dpdGhPZmZzZXR9IGNsb2NrXG4gICAgKiBAcGFyYW0ge2FueX0gc2VuZGVyXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbG9jaywgc2VuZGVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjbG9jaywgQ2xvY2tXaXRoT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5qcnBjY29ubmVjdGlvbl9uZXcoY2xvY2sucHRyLCBhZGRIZWFwT2JqZWN0KHNlbmRlcikpO1xuICAgICAgICByZXR1cm4gSnJwY0Nvbm5lY3Rpb24uX193cmFwKHJldCk7XG4gICAgfVxufVxuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIEpycGNRdWVyeSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEpycGNRdWVyeS5wcm90b3R5cGUpO1xuICAgICAgICBvYmoucHRyID0gcHRyO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLnB0cjtcbiAgICAgICAgdGhpcy5wdHIgPSAwO1xuXG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19qcnBjcXVlcnlfZnJlZShwdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4gICAgKi9cbiAgICBvblJlY2VpdmUoZGF0YSkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoZGF0YSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmpycGNxdWVyeV9vblJlY2VpdmUocHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge2FueX0gYXJnMFxuICAgICovXG4gICAgb25FcnJvcihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uanJwY3F1ZXJ5X29uRXJyb3IocHRyLCBhZGRIZWFwT2JqZWN0KGFyZzApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKi9cbiAgICBvblRpbWVvdXQoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uanJwY3F1ZXJ5X29uVGltZW91dChwdHIpO1xuICAgIH1cbn1cbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBUcmFuc3BvcnQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc3BvcnQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLnB0ciA9IHB0cjtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5wdHI7XG4gICAgICAgIHRoaXMucHRyID0gMDtcblxuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhbnNwb3J0X2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0dxbENvbm5lY3Rpb259IGdxbFxuICAgICogQHJldHVybnMge1RyYW5zcG9ydH1cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tR3FsQ29ubmVjdGlvbihncWwpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGdxbCwgR3FsQ29ubmVjdGlvbik7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNwb3J0X2Zyb21HcWxDb25uZWN0aW9uKGdxbC5wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNwb3J0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7SnJwY0Nvbm5lY3Rpb259IGpycGNcbiAgICAqIEByZXR1cm5zIHtUcmFuc3BvcnR9XG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpycGNDb25uZWN0aW9uKGpycGMpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGpycGMsIEpycGNDb25uZWN0aW9uKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc3BvcnRfZnJvbUpycGNDb25uZWN0aW9uKGpycGMucHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zcG9ydC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICAgICogQHBhcmFtIHthbnl9IGhhbmRsZXJcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdlbmVyaWNDb250cmFjdD59XG4gICAgKi9cbiAgICBzdWJzY3JpYmVUb0dlbmVyaWNDb250cmFjdChhZGRyZXNzLCBoYW5kbGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhZGRyZXNzLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS50cmFuc3BvcnRfc3Vic2NyaWJlVG9HZW5lcmljQ29udHJhY3QocmV0cHRyLCB0aGlzLnB0ciwgcHRyMCwgbGVuMCwgYWRkSGVhcE9iamVjdChoYW5kbGVyKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICAgICogQHJldHVybnMge1Byb21pc2U8RnVsbENvbnRyYWN0U3RhdGUgfCB1bmRlZmluZWQ+fVxuICAgICovXG4gICAgZ2V0RnVsbENvbnRyYWN0U3RhdGUoYWRkcmVzcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYWRkcmVzcywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20udHJhbnNwb3J0X2dldEZ1bGxDb250cmFjdFN0YXRlKHJldHB0ciwgdGhpcy5wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVfaGFzaFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0XG4gICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gY29udGludWF0aW9uXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBY2NvdW50c0xpc3Q+fVxuICAgICovXG4gICAgZ2V0QWNjb3VudHNCeUNvZGVIYXNoKGNvZGVfaGFzaCwgbGltaXQsIGNvbnRpbnVhdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY29kZV9oYXNoLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgdmFyIHB0cjEgPSBpc0xpa2VOb25lKGNvbnRpbnVhdGlvbikgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoY29udGludWF0aW9uLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICB2YXIgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20udHJhbnNwb3J0X2dldEFjY291bnRzQnlDb2RlSGFzaChyZXRwdHIsIHRoaXMucHRyLCBwdHIwLCBsZW4wLCBsaW1pdCwgcHRyMSwgbGVuMSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGNvbnRpbnVhdGlvblxuICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0XG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvbnNMaXN0Pn1cbiAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9ucyhhZGRyZXNzLCBjb250aW51YXRpb24sIGxpbWl0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhZGRyZXNzLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgdmFyIHB0cjEgPSBpc0xpa2VOb25lKGNvbnRpbnVhdGlvbikgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoY29udGludWF0aW9uLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICB2YXIgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20udHJhbnNwb3J0X2dldFRyYW5zYWN0aW9ucyhyZXRwdHIsIHRoaXMucHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBsaW1pdCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gaGFzaFxuICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb24gfCB1bmRlZmluZWQ+fVxuICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb24oaGFzaCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoaGFzaCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20udHJhbnNwb3J0X2dldFRyYW5zYWN0aW9uKHJldHB0ciwgdGhpcy5wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VfaGFzaFxuICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb24gfCB1bmRlZmluZWQ+fVxuICAgICovXG4gICAgZ2V0RHN0VHJhbnNhY3Rpb24obWVzc2FnZV9oYXNoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChtZXNzYWdlX2hhc2gsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnRyYW5zcG9ydF9nZXREc3RUcmFuc2FjdGlvbihyZXRwdHIsIHRoaXMucHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBVbnNpZ25lZE1lc3NhZ2Uge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShVbnNpZ25lZE1lc3NhZ2UucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLnB0ciA9IHB0cjtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5wdHI7XG4gICAgICAgIHRoaXMucHRyID0gMDtcblxuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdW5zaWduZWRtZXNzYWdlX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0Nsb2NrV2l0aE9mZnNldH0gY2xvY2tcbiAgICAqL1xuICAgIHJlZnJlc2hUaW1lb3V0KGNsb2NrKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjbG9jaywgQ2xvY2tXaXRoT2Zmc2V0KTtcbiAgICAgICAgd2FzbS51bnNpZ25lZG1lc3NhZ2VfcmVmcmVzaFRpbWVvdXQodGhpcy5wdHIsIGNsb2NrLnB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGV4cGlyZUF0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnVuc2lnbmVkbWVzc2FnZV9leHBpcmVBdCh0aGlzLnB0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAqL1xuICAgIGdldCBoYXNoKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnVuc2lnbmVkbWVzc2FnZV9oYXNoKHJldHB0ciwgdGhpcy5wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHIwLCByMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlXG4gICAgKiBAcmV0dXJucyB7U2lnbmVkTWVzc2FnZX1cbiAgICAqL1xuICAgIHNpZ24oc2lnbmF0dXJlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChzaWduYXR1cmUsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnVuc2lnbmVkbWVzc2FnZV9zaWduKHJldHB0ciwgdGhpcy5wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1NpZ25lZE1lc3NhZ2V9XG4gICAgKi9cbiAgICBzaWduRmFrZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS51bnNpZ25lZG1lc3NhZ2Vfc2lnbkZha2UocmV0cHRyLCB0aGlzLnB0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWQobW9kdWxlLCBpbXBvcnRzKSB7XG4gICAgaWYgKHR5cGVvZiBSZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJyAmJiBtb2R1bGUgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhtb2R1bGUsIGltcG9ydHMpO1xuXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgIT0gJ2FwcGxpY2F0aW9uL3dhc20nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcImBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ2AgZmFpbGVkIGJlY2F1c2UgeW91ciBzZXJ2ZXIgZG9lcyBub3Qgc2VydmUgd2FzbSB3aXRoIGBhcHBsaWNhdGlvbi93YXNtYCBNSU1FIHR5cGUuIEZhbGxpbmcgYmFjayB0byBgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVgIHdoaWNoIGlzIHNsb3dlci4gT3JpZ2luYWwgZXJyb3I6XFxuXCIsIGUpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBieXRlcyA9IGF3YWl0IG1vZHVsZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYnl0ZXMsIGltcG9ydHMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShtb2R1bGUsIGltcG9ydHMpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lkluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpbnN0YW5jZSwgbW9kdWxlIH07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0SW1wb3J0cygpIHtcbiAgICBjb25zdCBpbXBvcnRzID0ge307XG4gICAgaW1wb3J0cy53YmcgPSB7fTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX3N0cmluZ19uZXcgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2xlbmd0aF82ZTNiYmU3YzhiZDRkYmQ4ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc191bmRlZmluZWQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9udW1iZXJfZ2V0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCBvYmogPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZihvYmopID09PSAnbnVtYmVyJyA/IG9iaiA6IHVuZGVmaW5lZDtcbiAgICAgICAgZ2V0RmxvYXQ2NE1lbW9yeTAoKVthcmcwIC8gOCArIDFdID0gaXNMaWtlTm9uZShyZXQpID8gMCA6IHJldDtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAwXSA9ICFpc0xpa2VOb25lKHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2lzX251bGwgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKSA9PT0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fc3RyaW5nX2dldCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2Yob2JqKSA9PT0gJ3N0cmluZycgPyBvYmogOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShyZXQpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAxXSA9IGxlbjA7XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMF0gPSBwdHIwO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc19vYmplY3QgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGdldE9iamVjdChhcmcwKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKHZhbCkgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5faXNfc3RyaW5nID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YoZ2V0T2JqZWN0KGFyZzApKSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX29iamVjdF9kcm9wX3JlZiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgdGFrZU9iamVjdChhcmcwKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fbnVtYmVyX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gYXJnMDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vd181ODg4NjY4MmI3ZTc5MGQ3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfOGQyYWYwMGJjMWUzMjllZSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEVycm9yKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfMGI5YmZkZDk3NTgzMjg0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgT2JqZWN0KCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZW5kXzU1YzU3MzUzMDg2MTBmYzAgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5zZW5kKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSwgR3FsUXVlcnkuX193cmFwKGFyZzMpLCBhcmc0ICE9PSAwKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NlbmRfYzRmZTVlZjVmNDg1MWI1YSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnNlbmQoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpLCBKcnBjUXVlcnkuX193cmFwKGFyZzMpLCBhcmc0ICE9PSAwKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld18xZDlhOTIwYzZiZmM0NGE4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBBcnJheSgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcHVzaF83NDBlNGIyODY3MDJkOTY0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkucHVzaChnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2VuZXJpY2NvbnRyYWN0X25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gR2VuZXJpY0NvbnRyYWN0Ll9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX29uTWVzc2FnZVNlbnRfZmMyZGVkM2I4MTUzNTA3YSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9uTWVzc2FnZVNlbnQodGFrZU9iamVjdChhcmcxKSwgdGFrZU9iamVjdChhcmcyKSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19vbk1lc3NhZ2VFeHBpcmVkX2ZiZGI0YjFhOGJiMGU3YzUgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbk1lc3NhZ2VFeHBpcmVkKHRha2VPYmplY3QoYXJnMSkpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfb25TdGF0ZUNoYW5nZWRfZTY5NmE3Yjk4N2RiYTllYSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm9uU3RhdGVDaGFuZ2VkKHRha2VPYmplY3QoYXJnMSkpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfb25UcmFuc2FjdGlvbnNGb3VuZF8zM2I3YjU2Yzc3MGUyZTg4ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub25UcmFuc2FjdGlvbnNGb3VuZCh0YWtlT2JqZWN0KGFyZzEpLCB0YWtlT2JqZWN0KGFyZzIpKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2tleXNfMDcwMjI5NGFmYWViNjA0NCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gT2JqZWN0LmtleXMoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldF81NzI0NWNjN2Q3Yzc2MTlkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMClbYXJnMSA+Pj4gMF07XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Jvb2xlYW5fZ2V0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCB2ID0gZ2V0T2JqZWN0KGFyZzApO1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YodikgPT09ICdib29sZWFuJyA/ICh2ID8gMSA6IDApIDogMjtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2lzTG9jYWxfMGNjMGY2MjU4YzhjZjZjYSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmlzTG9jYWwoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld185OTYyZjkzOTIxOWYxODIwID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHN0YXRlMCA9IHthOiBhcmcwLCBiOiBhcmcxfTtcbiAgICAgICAgICAgIHZhciBjYjAgPSAoYXJnMCwgYXJnMSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBzdGF0ZTAuYTtcbiAgICAgICAgICAgICAgICBzdGF0ZTAuYSA9IDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fd2JnX2FkYXB0ZXJfMTYzKGEsIHN0YXRlMC5iLCBhcmcwLCBhcmcxKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTAuYSA9IGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKGNiMCk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc3RhdGUwLmEgPSBzdGF0ZTAuYiA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9OT0RFX01PRFVMRV9jZjY0MDFjYzEwOTEyNzllID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG1vZHVsZTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fb2JqZWN0X2Nsb25lX3JlZiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcHJvY2Vzc18wY2MyYWRhODUyNGQ2ZjgzID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkucHJvY2VzcztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3ZlcnNpb25zX2MxMWFjY2VhYjI3YTZjODcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS52ZXJzaW9ucztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vZGVfN2ZmMWNlNDljYWYyMzgxNSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm5vZGU7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZXF1aXJlX2E3NDZlNzliMzIyYjkzMzYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5yZXF1aXJlKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NyeXB0b18yMDM2YmVkN2M0NGMyNWU3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuY3J5cHRvO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbXNDcnlwdG9fYTIxZmM4OGNhZjFlY2RjOCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm1zQ3J5cHRvO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3d2l0aGxlbmd0aF9mNTkzMzg1NWU0ZjQ4YTE5ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShhcmcwID4+PiAwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldF83NjUyMDE1NDRhMmI2ODY5ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBSZWZsZWN0LmdldChnZXRPYmplY3QoYXJnMCksIGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NlbGZfNmQ0Nzk1MDZmNzJjNmE3MSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXQgPSBzZWxmLnNlbGY7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3dpbmRvd19mMjU1N2NjNzg0OTBhY2ViID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdpbmRvdy53aW5kb3c7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dsb2JhbFRoaXNfN2YyMDZiZGE2MjhkNTI4NiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXQgPSBnbG9iYWxUaGlzLmdsb2JhbFRoaXM7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dsb2JhbF9iYTc1YzUwZDFjZjM4NGY0ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdsb2JhbC5nbG9iYWw7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld25vYXJnc19iNWIwNjNmYzZjMmYwMzc2ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgRnVuY3Rpb24oZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NhbGxfOTdhZTlkODY0NWRjMzg4YiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNhbGwoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaXNBcnJheV8yN2M0NmM2N2Y0OThlMTVkID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBBcnJheS5pc0FycmF5KGdldE9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jYWxsXzE2OGRhODg3NzllMzVmNjEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5jYWxsKGdldE9iamVjdChhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X2JmM2Y4OWI5MmQ1YTM0YmYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFJlZmxlY3Quc2V0KGdldE9iamVjdChhcmcwKSwgZ2V0T2JqZWN0KGFyZzEpLCBnZXRPYmplY3QoYXJnMikpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yYW5kb21GaWxsU3luY18wNjVhZmZmZGUwMWRhYTY2ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkucmFuZG9tRmlsbFN5bmMoZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcxLCBhcmcyKSk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N1YmFycmF5XzU4YWQ0ZWZiYjViY2I4ODYgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5zdWJhcnJheShhcmcxID4+PiAwLCBhcmcyID4+PiAwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFJhbmRvbVZhbHVlc19iOTllZWM0MjQ0YTQ3NWJiID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuZ2V0UmFuZG9tVmFsdWVzKGdldE9iamVjdChhcmcxKSk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2xlbmd0aF85ZTFhZTE5MDBjYjBmYmQ1ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9tZW1vcnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5tZW1vcnk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19idWZmZXJfM2YzZDc2NGQ0NzQ3ZDU2NCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld184YzNmMDA1MjI3MmE0NTdhID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0XzgzZGI5NjkwZjkzNTNlNzkgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5zZXQoZ2V0T2JqZWN0KGFyZzEpLCBhcmcyID4+PiAwKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fZGVidWdfc3RyaW5nID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBkZWJ1Z1N0cmluZyhnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gcHRyMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fdGhyb3cgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdGhlbl8xMWY3YTU0ZDY3YjRiZmFkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudGhlbihnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jYl9kcm9wID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCBvYmogPSB0YWtlT2JqZWN0KGFyZzApLm9yaWdpbmFsO1xuICAgICAgICBpZiAob2JqLmNudC0tID09IDEpIHtcbiAgICAgICAgICAgIG9iai5hID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVzb2x2ZV85OWZlMTc5NjRmMzFmZmMwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBQcm9taXNlLnJlc29sdmUoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2xvc3VyZV93cmFwcGVyNjQzNyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbWFrZU11dENsb3N1cmUoYXJnMCwgYXJnMSwgOTI1LCBfX3diZ19hZGFwdGVyXzMyKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGltcG9ydHM7XG59XG5cbmZ1bmN0aW9uIGluaXRNZW1vcnkoaW1wb3J0cywgbWF5YmVfbWVtb3J5KSB7XG5cbn1cblxuZnVuY3Rpb24gZmluYWxpemVJbml0KGluc3RhbmNlLCBtb2R1bGUpIHtcbiAgICB3YXNtID0gaW5zdGFuY2UuZXhwb3J0cztcbiAgICBpbml0Ll9fd2JpbmRnZW5fd2FzbV9tb2R1bGUgPSBtb2R1bGU7XG4gICAgY2FjaGVkRmxvYXQ2NE1lbW9yeTAgPSBuZXcgRmxvYXQ2NEFycmF5KCk7XG4gICAgY2FjaGVkSW50MzJNZW1vcnkwID0gbmV3IEludDMyQXJyYXkoKTtcbiAgICBjYWNoZWRVaW50OE1lbW9yeTAgPSBuZXcgVWludDhBcnJheSgpO1xuXG5cbiAgICByZXR1cm4gd2FzbTtcbn1cblxuZnVuY3Rpb24gaW5pdFN5bmMobW9kdWxlKSB7XG4gICAgY29uc3QgaW1wb3J0cyA9IGdldEltcG9ydHMoKTtcblxuICAgIGluaXRNZW1vcnkoaW1wb3J0cyk7XG5cbiAgICBpZiAoIShtb2R1bGUgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5Nb2R1bGUpKSB7XG4gICAgICAgIG1vZHVsZSA9IG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobW9kdWxlKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShtb2R1bGUsIGltcG9ydHMpO1xuXG4gICAgcmV0dXJuIGZpbmFsaXplSW5pdChpbnN0YW5jZSwgbW9kdWxlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5pdChpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlucHV0ID0gbmV3IFVSTCgnbmVrb3Rvbl93YXNtX2JnLndhc20nLCBpbXBvcnQubWV0YS51cmwpO1xuICAgIH1cbiAgICBjb25zdCBpbXBvcnRzID0gZ2V0SW1wb3J0cygpO1xuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgKHR5cGVvZiBSZXF1ZXN0ID09PSAnZnVuY3Rpb24nICYmIGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkgfHwgKHR5cGVvZiBVUkwgPT09ICdmdW5jdGlvbicgJiYgaW5wdXQgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIGlucHV0ID0gZmV0Y2goaW5wdXQpO1xuICAgIH1cblxuICAgIGluaXRNZW1vcnkoaW1wb3J0cyk7XG5cbiAgICBjb25zdCB7IGluc3RhbmNlLCBtb2R1bGUgfSA9IGF3YWl0IGxvYWQoYXdhaXQgaW5wdXQsIGltcG9ydHMpO1xuXG4gICAgcmV0dXJuIGZpbmFsaXplSW5pdChpbnN0YW5jZSwgbW9kdWxlKTtcbn1cblxuZXhwb3J0IHsgaW5pdFN5bmMgfVxuZXhwb3J0IGRlZmF1bHQgaW5pdDtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///559\n')},444:(g,I,n)=>{"use strict";g.exports=n.p+"3610d36b17fcc23a1d17.wasm"}},__webpack_module_cache__={};function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var n=__webpack_module_cache__[g]={id:g,loaded:!1,exports:{}};return __webpack_modules__[g].call(n.exports,n,n.exports,__webpack_require__),n.loaded=!0,n.exports}__webpack_require__.m=__webpack_modules__,__webpack_require__.d=(g,I)=>{for(var n in I)__webpack_require__.o(I,n)&&!__webpack_require__.o(g,n)&&Object.defineProperty(g,n,{enumerable:!0,get:I[n]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(g){if("object"==typeof window)return window}}(),__webpack_require__.hmd=g=>((g=Object.create(g)).children||(g.children=[]),Object.defineProperty(g,"exports",{enumerable:!0,set:()=>{throw new Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: "+g.id)}}),g),__webpack_require__.o=(g,I)=>Object.prototype.hasOwnProperty.call(g,I),__webpack_require__.r=g=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},(()=>{var g;__webpack_require__.g.importScripts&&(g=__webpack_require__.g.location+"");var I=__webpack_require__.g.document;if(!g&&I&&(I.currentScript&&(g=I.currentScript.src),!g)){var n=I.getElementsByTagName("script");n.length&&(g=n[n.length-1].src)}if(!g)throw new Error("Automatic publicPath is not supported in this browser");g=g.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=g})(),__webpack_require__.b=document.baseURI||self.location.href;var __webpack_exports__=__webpack_require__(612)})();